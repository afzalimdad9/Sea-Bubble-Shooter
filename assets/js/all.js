function getBg(t) {
    var e = -1
      , e = "tutorial" === t ? 1 : Math.floor((t - 1) / LEVEL_NUM_OF_EVERY_MAP) + 1;
    return 5 < e || 1 > e ? "assets/res/PlayScene1.jpg" : "assets/res/PlayScene" + e + ".jpg"
}
function isLocalStorageNameSupported() {
    var t = window.famobi.localStorage;
    try {
        return t.setItem("test", "1"),
        t.removeItem("test"),
        !0
    } catch (e) {
        return !1
    }
}
var cc = cc || {};
cc._tmp = cc._tmp || {},
cc._LogInfos = {};
var _p = window
  , _p = Object.prototype
  , _p = null;
if (cc.ORIENTATION_PORTRAIT = 0,
cc.ORIENTATION_PORTRAIT_UPSIDE_DOWN = 1,
cc.ORIENTATION_LANDSCAPE_LEFT = 2,
cc.ORIENTATION_LANDSCAPE_RIGHT = 3,
cc._drawingUtil = null,
cc._renderContext = null,
cc._supportRender = !1,
cc._canvas = null,
cc.container = null,
cc._gameDiv = null,
cc.newElement = function(t) {
    return document.createElement(t)
}
,
cc.each = function(t, e, i) {
    if (t)
        if (t instanceof Array)
            for (var n = 0, r = t.length; n < r && !1 !== e.call(i, t[n], n); n++)
                ;
        else
            for (n in t)
                if (!1 === e.call(i, t[n], n))
                    break
}
,
cc.extend = function(t) {
    var e = 2 <= arguments.length ? Array.prototype.slice.call(arguments, 1) : [];
    return cc.each(e, function(e) {
        for (var i in e)
            e.hasOwnProperty(i) && (t[i] = e[i])
    }),
    t
}
,
cc.isFunction = function(t) {
    return "function" == typeof t
}
,
cc.isNumber = function(t) {
    return "number" == typeof t || "[object Number]" === Object.prototype.toString.call(t)
}
,
cc.isString = function(t) {
    return "string" == typeof t || "[object String]" === Object.prototype.toString.call(t)
}
,
cc.isArray = function(t) {
    return Array.isArray(t) || "object" == typeof t && "[object Array]" === Object.prototype.toString.call(t)
}
,
cc.isUndefined = function(t) {
    return "undefined" == typeof t
}
,
cc.isObject = function(t) {
    return "object" == typeof t && "[object Object]" === Object.prototype.toString.call(t)
}
,
cc.isCrossOrigin = function(t) {
    if (!t)
        return cc.log("invalid URL"),
        !1;
    var e = t.indexOf("://");
    return -1 !== e && (e = t.indexOf("/", e + 3),
    (-1 === e ? t : t.substring(0, e)) !== location.origin)
}
,
cc.AsyncPool = function(t, e, i, n, r) {
    var c = this;
    c._srcObj = t,
    c._limit = e,
    c._pool = [],
    c._iterator = i,
    c._iteratorTarget = r,
    c._onEnd = n,
    c._onEndTarget = r,
    c._results = t instanceof Array ? [] : {},
    cc.each(t, function(t, e) {
        c._pool.push({
            index: e,
            value: t
        })
    }),
    c.size = c._pool.length,
    c.finishedSize = 0,
    c._workingSize = 0,
    c._limit = c._limit || c.size,
    c.onIterator = function(t, e) {
        c._iterator = t,
        c._iteratorTarget = e
    }
    ,
    c.onEnd = function(t, e) {
        c._onEnd = t,
        c._onEndTarget = e
    }
    ,
    c._handleItem = function() {
        var t = this;
        if (!(0 === t._pool.length || t._workingSize >= t._limit)) {
            var e = t._pool.shift()
              , i = e.value
              , n = e.index;
            t._workingSize++,
            t._iterator.call(t._iteratorTarget, i, n, function(e) {
                t.finishedSize++,
                t._workingSize--;
                var i = Array.prototype.slice.call(arguments, 1);
                t._results[this.index] = i[0],
                t.finishedSize === t.size ? t._onEnd && t._onEnd.call(t._onEndTarget, null, t._results) : t._handleItem()
            }
            .bind(e), t)
        }
    }
    ,
    c.flow = function() {
        if (0 === this._pool.length)
            this._onEnd && this._onEnd.call(this._onEndTarget, null, []);
        else
            for (var t = 0; t < this._limit; t++)
                this._handleItem()
    }
}
,
cc.async = {
    series: function(t, e, i) {
        return t = new cc.AsyncPool(t,1,function(t, e, n) {
            t.call(i, n)
        }
        ,e,i),
        t.flow(),
        t
    },
    parallel: function(t, e, i) {
        return t = new cc.AsyncPool(t,0,function(t, e, n) {
            t.call(i, n)
        }
        ,e,i),
        t.flow(),
        t
    },
    waterfall: function(t, e, i) {
        var n = []
          , r = [null]
          , c = new cc.AsyncPool(t,1,function(e, c, s) {
            n.push(function(e) {
                n = Array.prototype.slice.call(arguments, 1),
                t.length - 1 === c && (r = r.concat(n)),
                s.apply(null, arguments)
            }),
            e.apply(i, n)
        }
        ,function(t) {
            if (e) {
                if (t)
                    return e.call(i, t);
                e.apply(i, r)
            }
        }
        );
        return c.flow(),
        c
    },
    map: function(t, e, i, n) {
        var r = e;
        return "object" == typeof e && (i = e.cb,
        n = e.iteratorTarget,
        r = e.iterator),
        t = new cc.AsyncPool(t,0,r,i,n),
        t.flow(),
        t
    },
    mapLimit: function(t, e, i, n, r) {
        return t = new cc.AsyncPool(t,e,i,n,r),
        t.flow(),
        t
    }
},
cc.path = {
    normalizeRE: /[^\.\/]+\/\.\.\//,
    join: function() {
        for (var t = arguments.length, e = "", i = 0; i < t; i++)
            e = (e + ("" === e ? "" : "/") + arguments[i]).replace(/(\/|\\\\)$/, "");
        return e
    },
    extname: function(t) {
        return (t = /(\.[^\.\/\?\\]*)(\?.*)?$/.exec(t)) ? t[1] : null
    },
    mainFileName: function(t) {
        if (t) {
            var e = t.lastIndexOf(".");
            if (-1 !== e)
                return t.substring(0, e)
        }
        return t
    },
    basename: function(t, e) {
        var i = t.indexOf("?");
        return 0 < i && (t = t.substring(0, i)),
        (i = /(\/|\\\\)([^(\/|\\\\)]+)$/g.exec(t.replace(/(\/|\\\\)$/, ""))) ? (i = i[2],
        e && t.substring(t.length - e.length).toLowerCase() === e.toLowerCase() ? i.substring(0, i.length - e.length) : i) : null
    },
    dirname: function(t) {
        return t.replace(/((.*)(\/|\\|\\\\))?(.*?\..*$)?/, "$2")
    },
    changeExtname: function(t, e) {
        e = e || "";
        var i = t.indexOf("?")
          , n = "";
        return 0 < i && (n = t.substring(i),
        t = t.substring(0, i)),
        i = t.lastIndexOf("."),
        0 > i ? t + e + n : t.substring(0, i) + e + n
    },
    changeBasename: function(t, e, i) {
        if (0 === e.indexOf("."))
            return this.changeExtname(t, e);
        var n = t.indexOf("?")
          , r = "";
        return i = i ? this.extname(t) : "",
        0 < n && (r = t.substring(n),
        t = t.substring(0, n)),
        n = t.lastIndexOf("/"),
        t.substring(0, 0 >= n ? 0 : n + 1) + e + i + r
    },
    _normalize: function(t) {
        var e = t = String(t);
        do
            e = t,
            t = t.replace(this.normalizeRE, "");
        while (e.length !== t.length);
        return t
    }
},
cc.loader = function() {
    var t = {}
      , e = {}
      , i = {}
      , n = {}
      , r = RegExp("^(?:(?:https?|ftp)://)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))|(?:localhost))(?::\\d{2,5})?(?:/\\S*)?$", "i");
    return {
        resPath: "",
        audioPath: "",
        cache: {},
        getXMLHttpRequest: function() {
            return window.XMLHttpRequest ? new window.XMLHttpRequest : new ActiveXObject("MSXML2.XMLHTTP")
        },
        _getArgs4Js: function(t) {
            var e = t[0]
              , i = t[1]
              , n = t[2]
              , r = ["", null, null];
            if (1 === t.length)
                r[1] = e instanceof Array ? e : [e];
            else if (2 === t.length)
                "function" == typeof i ? (r[1] = e instanceof Array ? e : [e],
                r[2] = i) : (r[0] = e || "",
                r[1] = i instanceof Array ? i : [i]);
            else {
                if (3 !== t.length)
                    throw Error("arguments error to load js!");
                r[0] = e || "",
                r[1] = i instanceof Array ? i : [i],
                r[2] = n
            }
            return r
        },
        loadJs: function(e, i, n) {
            var r = this
              , c = r._getArgs4Js(arguments)
              , s = c[0]
              , o = c[1]
              , c = c[2];
            -1 < navigator.userAgent.indexOf("Trident/5") ? r._loadJs4Dependency(s, o, 0, c) : cc.async.map(o, function(e, i, n) {
                return e = cc.path.join(s, e),
                t[e] ? n(null) : void r._createScript(e, !1, n)
            }, c)
        },
        loadJsWithImg: function(t, e, i) {
            var n = this._loadJsImg()
              , r = this._getArgs4Js(arguments);
            this.loadJs(r[0], r[1], function(t) {
                if (t)
                    throw Error(t);
                n.parentNode.removeChild(n),
                r[2] && r[2]()
            })
        },
        _createScript: function(e, i, n) {
            var r = document
              , c = document.createElement("script");
            c.async = i,
            t[e] = !0,
            cc.game.config.noCache && "string" == typeof e ? this._noCacheRex.test(e) ? c.src = e + "&_t=" + (new Date - 0) : c.src = e + "?_t=" + (new Date - 0) : c.src = e,
            c.addEventListener("load", function() {
                c.parentNode.removeChild(c),
                this.removeEventListener("load", arguments.callee, !1),
                n()
            }, !1),
            c.addEventListener("error", function() {
                c.parentNode.removeChild(c),
                n("Load " + e + " failed!")
            }, !1),
            r.body.appendChild(c)
        },
        _loadJs4Dependency: function(t, e, i, n) {
            if (i >= e.length)
                n && n();
            else {
                var r = this;
                r._createScript(cc.path.join(t, e[i]), !1, function(c) {
                    return c ? n(c) : void r._loadJs4Dependency(t, e, i + 1, n)
                })
            }
        },
        _loadJsImg: function() {
            var t = document
              , e = t.getElementById("cocos2d_loadJsImg");
            if (!e) {
                e = document.createElement("img"),
                cc._loadingImage && (e.src = cc._loadingImage),
                t = t.getElementById(cc.game.config.id),
                t.style.backgroundColor = "transparent",
                t.parentNode.appendChild(e);
                var i = getComputedStyle ? getComputedStyle(t) : t.currentStyle;
                i || (i = {
                    width: t.width,
                    height: t.height
                }),
                e.style.left = t.offsetLeft + (parseFloat(i.width) - e.width) / 2 + "px",
                e.style.top = t.offsetTop + (parseFloat(i.height) - e.height) / 2 + "px",
                e.style.position = "absolute"
            }
            return e
        },
        loadTxt: function(t, e) {
            if (cc._isNodeJs)
                require("fs").readFile(t, function(t, i) {
                    t ? e(t) : e(null, i.toString())
                });
            else {
                var i = this.getXMLHttpRequest()
                  , n = "load " + t + " failed!";
                i.open("GET", t, !0),
                /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? (i.setRequestHeader("Accept-Charset", "utf-8"),
                i.onreadystatechange = function() {
                    4 === i.readyState && (200 === i.status ? e(null, i.responseText) : e({
                        status: i.status,
                        errorMessage: n
                    }, null))
                }
                ) : (i.overrideMimeType && i.overrideMimeType("text/plain; charset=utf-8"),
                i.onload = function() {
                    4 === i.readyState && (200 === i.status ? e(null, i.responseText) : e({
                        status: i.status,
                        errorMessage: n
                    }, null))
                }
                ,
                i.onerror = function() {
                    e({
                        status: i.status,
                        errorMessage: n
                    }, null)
                }
                ),
                i.send(null)
            }
        },
        _loadTxtSync: function(t) {
            if (cc._isNodeJs)
                return require("fs").readFileSync(t).toString();
            var e = this.getXMLHttpRequest();
            return e.open("GET", t, !1),
            /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? e.setRequestHeader("Accept-Charset", "utf-8") : e.overrideMimeType && e.overrideMimeType("text/plain; charset=utf-8"),
            e.send(null),
            4 === !e.readyState || 200 !== e.status ? null : e.responseText
        },
        loadCsb: function(t, e) {
            var i = new XMLHttpRequest
              , n = "load " + t + " failed!";
            i.open("GET", t, !0),
            i.responseType = "arraybuffer",
            i.onload = function() {
                var t = i.response;
                t && (window.msg = t),
                4 === i.readyState && (200 === i.status ? e(null, i.response) : e({
                    status: i.status,
                    errorMessage: n
                }, null))
            }
            ,
            i.onerror = function() {
                e({
                    status: i.status,
                    errorMessage: n
                }, null)
            }
            ,
            i.send(null)
        },
        loadJson: function(t, e) {
            this.loadTxt(t, function(i, n) {
                if (i)
                    e(i);
                else {
                    try {
                        var r = JSON.parse(n)
                    } catch (c) {
                        throw Error("parse json [" + t + "] failed : " + c)
                    }
                    e(null, r)
                }
            })
        },
        _checkIsImageURL: function(t) {
            return null != /(\.png)|(\.jpg)|(\.bmp)|(\.jpeg)|(\.gif)/.exec(t)
        },
        loadImg: function(t, e, i) {
            var n = {
                isCrossOrigin: !0
            };
            void 0 !== i ? n.isCrossOrigin = null === e.isCrossOrigin ? n.isCrossOrigin : e.isCrossOrigin : void 0 !== e && (i = e);
            var r = this.getRes(t);
            if (r)
                return i && i(null, r),
                r;
            r = new Image,
            n.isCrossOrigin && "file://" !== location.origin && (r.crossOrigin = "Anonymous");
            var c = function() {
                this.removeEventListener("load", c, !1),
                this.removeEventListener("error", o, !1),
                cc.loader.cache[t] = r,
                i && i(null, r)
            }
              , s = this
              , o = function() {
                this.removeEventListener("error", o, !1),
                r.crossOrigin && "anonymous" === r.crossOrigin.toLowerCase() ? (n.isCrossOrigin = !1,
                s.release(t),
                cc.loader.loadImg(t, n, i)) : "function" == typeof i && i("load image failed")
            };
            return r.addEventListener("load", c),
            r.addEventListener("error", o),
            r.src = t,
            r
        },
        _loadResIterator: function(t, i, n) {
            var c = this
              , s = null
              , o = t.type;
            return o ? (o = "." + o.toLowerCase(),
            s = t.src ? t.src : t.name + o) : (s = t,
            o = cc.path.extname(s)),
            (i = c.getRes(s)) ? n(null, i) : (i = null,
            o && (i = e[o.toLowerCase()]),
            i ? (o = s,
            r.test(s) || (o = i.getBasePath ? i.getBasePath() : c.resPath,
            o = c.getUrl(o, s)),
            cc.game.config.noCache && "string" == typeof o && (o = c._noCacheRex.test(o) ? o + ("&_t=" + (new Date - 0)) : o + ("?_t=" + (new Date - 0))),
            void i.load(o, s, t, function(t, e) {
                t ? (cc.log(t),
                c.cache[s] = null,
                delete c.cache[s],
                n({
                    status: 520,
                    errorMessage: t
                }, null)) : (c.cache[s] = e,
                n(null, e))
            })) : (cc.error("loader for [" + o + "] not exists!"),
            n()))
        },
        _noCacheRex: /\?/,
        getUrl: function(t, n) {
            var r = cc.path;
            if (void 0 !== t && void 0 === n) {
                n = t;
                var c = r.extname(n)
                  , c = c ? c.toLowerCase() : "";
                t = (c = e[c]) && c.getBasePath ? c.getBasePath() : this.resPath
            }
            if (n = cc.path.join(t || "", n),
            n.match(/[\/(\\\\)]lang[\/(\\\\)]/i)) {
                if (i[n])
                    return i[n];
                r = r.extname(n) || "",
                n = i[n] = n.substring(0, n.length - r.length) + "_" + cc.sys.language + r
            }
            return n
        },
        load: function(t, e, i) {
            var n = this
              , r = arguments.length;
            if (0 === r)
                throw Error("arguments error!");
            return 3 === r ? "function" == typeof e && (e = "function" == typeof i ? {
                trigger: e,
                cb: i
            } : {
                cb: e,
                cbTarget: i
            }) : 2 === r ? "function" == typeof e && (e = {
                cb: e
            }) : 1 === r && (e = {}),
            t instanceof Array || (t = [t]),
            r = new cc.AsyncPool(t,0,function(t, i, r, c) {
                n._loadResIterator(t, i, function(t) {
                    var i = Array.prototype.slice.call(arguments, 1);
                    e.trigger && e.trigger.call(e.triggerTarget, i[0], c.size, c.finishedSize),
                    r(t, i[0])
                })
            }
            ,e.cb,e.cbTarget),
            r.flow(),
            r
        },
        _handleAliases: function(t, e) {
            var i, r = [];
            for (i in t) {
                var c = t[i];
                n[i] = c,
                r.push(c)
            }
            this.load(r, e)
        },
        loadAliases: function(t, e) {
            var i = this
              , n = i.getRes(t);
            n ? i._handleAliases(n.filenames, e) : i.load(t, function(t, n) {
                i._handleAliases(n[0].filenames, e)
            })
        },
        register: function(t, i) {
            if (t && i) {
                if ("string" == typeof t)
                    return e[t.trim().toLowerCase()] = i;
                for (var n = 0, r = t.length; n < r; n++)
                    e["." + t[n].trim().toLowerCase()] = i
            }
        },
        getRes: function(t) {
            return this.cache[t] || this.cache[n[t]]
        },
        _getAliase: function(t) {
            return n[t]
        },
        release: function(t) {
            var e = this.cache;
            delete e[t],
            delete e[n[t]],
            delete n[t]
        },
        releaseAll: function() {
            var t, e = this.cache;
            for (t in e)
                delete e[t];
            for (t in n)
                delete n[t]
        }
    }
}(),
cc.formatStr = function() {
    var t = arguments
      , e = t.length;
    if (1 > e)
        return "";
    var i = t[0]
      , n = !0;
    "object" == typeof i && (n = !1);
    for (var r = 1; r < e; ++r) {
        var c = t[r];
        if (n)
            for (; ; ) {
                var s = null;
                if ("number" == typeof c && (s = i.match(/(%d)|(%s)/))) {
                    i = i.replace(/(%d)|(%s)/, c);
                    break
                }
                i = (s = i.match(/%s/)) ? i.replace(/%s/, c) : i + ("    " + c);
                break
            }
        else
            i += "    " + c
    }
    return i
}
,
function() {
    function t(t) {
        var e = cc.game.CONFIG_KEY
          , i = parseInt(t[e.renderMode]) || 0
          , n = [cc.sys.OS_ANDROID]
          , r = [];
        (isNaN(i) || 2 < i || 0 > i) && (t[e.renderMode] = 0),
        cc._renderType = cc.game.RENDER_TYPE_CANVAS,
        cc._supportRender = !0,
        (2 === i || 0 === i && -1 === n.indexOf(cc.sys.os) && -1 === r.indexOf(cc.sys.browserType)) && (cc.sys.capabilities.opengl ? (cc._renderType = cc.game.RENDER_TYPE_WEBGL,
        cc._supportRender = !0) : cc._supportRender = !1),
        (1 === i || 0 === i && !cc._supportRender) && (cc.sys.capabilities.canvas ? (cc._renderType = cc.game.RENDER_TYPE_CANVAS,
        cc._supportRender = !0) : cc._supportRender = !1)
    }
    function e(t, i, n) {
        if (o[i])
            return null;
        n = n || "";
        var r = []
          , c = t[i];
        if (!c)
            throw Error("can not find module [" + i + "]");
        i = cc.path;
        for (var s = 0, a = c.length; s < a; s++) {
            var h = c[s];
            if (!o[h]) {
                var l = i.extname(h);
                l ? ".js" === l.toLowerCase() && r.push(i.join(n, h)) : (l = e(t, h, n)) && (r = r.concat(l)),
                o[h] = 1
            }
        }
        return r
    }
    function i(t) {
        cc._initDebugSetting && cc._initDebugSetting(t[cc.game.CONFIG_KEY.debugMode]),
        cc._engineLoaded = !0,
        cc.log(cc.ENGINE_VERSION),
        h && h()
    }
    function n(t) {
        var n = t[cc.game.CONFIG_KEY.engineDir]
          , r = cc.loader;
        if (cc.Class)
            i(t);
        else {
            var c = cc.path.join(n, "moduleConfig.json");
            r.loadJson(c, function(r, c) {
                if (r)
                    throw Error(r);
                var s = t.modules || []
                  , o = c.module
                  , a = [];
                cc.sys.capabilities.opengl && 0 > s.indexOf("base4webgl") ? s.splice(0, 0, "base4webgl") : 0 > s.indexOf("core") && s.splice(0, 0, "core");
                for (var h = 0, l = s.length; h < l; h++) {
                    var u = e(o, s[h], n);
                    u && (a = a.concat(u))
                }
                cc.loader.loadJsWithImg(a, function(e) {
                    if (e)
                        throw e;
                    i(t)
                })
            })
        }
    }
    function r() {
        this.removeEventListener("load", r, !1),
        n(cc.game.config)
    }
    var c = document.createElement("canvas")
      , s = document.createElement("canvas");
    cc.create3DContext = function(t, e) {
        for (var i = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"], n = null, r = 0; r < i.length; ++r) {
            try {
                n = t.getContext(i[r], e)
            } catch (c) {}
            if (n)
                break
        }
        return n
    }
    ,
    function() {
        cc.sys = {};
        var t = cc.sys;
        t.LANGUAGE_ENGLISH = "en",
        t.LANGUAGE_CHINESE = "zh",
        t.LANGUAGE_FRENCH = "fr",
        t.LANGUAGE_ITALIAN = "it",
        t.LANGUAGE_GERMAN = "de",
        t.LANGUAGE_SPANISH = "es",
        t.LANGUAGE_DUTCH = "du",
        t.LANGUAGE_RUSSIAN = "ru",
        t.LANGUAGE_KOREAN = "ko",
        t.LANGUAGE_JAPANESE = "ja",
        t.LANGUAGE_HUNGARIAN = "hu",
        t.LANGUAGE_PORTUGUESE = "pt",
        t.LANGUAGE_ARABIC = "ar",
        t.LANGUAGE_NORWEGIAN = "no",
        t.LANGUAGE_POLISH = "pl",
        t.LANGUAGE_UNKNOWN = "unkonwn",
        t.OS_IOS = "iOS",
        t.OS_ANDROID = "Android",
        t.OS_WINDOWS = "Windows",
        t.OS_MARMALADE = "Marmalade",
        t.OS_LINUX = "Linux",
        t.OS_BADA = "Bada",
        t.OS_BLACKBERRY = "Blackberry",
        t.OS_OSX = "OS X",
        t.OS_WP8 = "WP8",
        t.OS_WINRT = "WINRT",
        t.OS_UNKNOWN = "Unknown",
        t.UNKNOWN = -1,
        t.WIN32 = 0,
        t.LINUX = 1,
        t.MACOS = 2,
        t.ANDROID = 3,
        t.IPHONE = 4,
        t.IPAD = 5,
        t.BLACKBERRY = 6,
        t.NACL = 7,
        t.EMSCRIPTEN = 8,
        t.TIZEN = 9,
        t.WINRT = 10,
        t.WP8 = 11,
        t.MOBILE_BROWSER = 100,
        t.DESKTOP_BROWSER = 101,
        t.BROWSER_TYPE_WECHAT = "wechat",
        t.BROWSER_TYPE_ANDROID = "androidbrowser",
        t.BROWSER_TYPE_IE = "ie",
        t.BROWSER_TYPE_QQ = "qqbrowser",
        t.BROWSER_TYPE_MOBILE_QQ = "mqqbrowser",
        t.BROWSER_TYPE_UC = "ucbrowser",
        t.BROWSER_TYPE_360 = "360browser",
        t.BROWSER_TYPE_BAIDU_APP = "baiduboxapp",
        t.BROWSER_TYPE_BAIDU = "baidubrowser",
        t.BROWSER_TYPE_MAXTHON = "maxthon",
        t.BROWSER_TYPE_OPERA = "opera",
        t.BROWSER_TYPE_OUPENG = "oupeng",
        t.BROWSER_TYPE_MIUI = "miuibrowser",
        t.BROWSER_TYPE_FIREFOX = "firefox",
        t.BROWSER_TYPE_SAFARI = "safari",
        t.BROWSER_TYPE_CHROME = "chrome",
        t.BROWSER_TYPE_LIEBAO = "liebao",
        t.BROWSER_TYPE_QZONE = "qzone",
        t.BROWSER_TYPE_SOUGOU = "sogou",
        t.BROWSER_TYPE_UNKNOWN = "unknown",
        t.isNative = !1;
        var e = window
          , i = e.navigator
          , n = document
          , r = n.documentElement
          , o = i.userAgent.toLowerCase();
        t.isMobile = -1 !== o.indexOf("mobile") || -1 !== o.indexOf("android"),
        t.platform = t.isMobile ? t.MOBILE_BROWSER : t.DESKTOP_BROWSER;
        var a = i.language
          , a = (a = a ? a : i.browserLanguage) ? a.split("-")[0] : t.LANGUAGE_ENGLISH;
        t.language = a;
        var h = a = !1
          , l = ""
          , u = 0
          , d = /android (\d+(?:\.\d+)+)/i.exec(o) || /android (\d+(?:\.\d+)+)/i.exec(i.platform);
        d && (a = !0,
        l = d[1] || "",
        u = parseInt(l) || 0),
        (d = /(iPad|iPhone|iPod).*OS ((\d+_?){2,3})/i.exec(o)) && (h = !0,
        l = d[2] || "",
        u = parseInt(l) || 0),
        d = t.OS_UNKNOWN,
        -1 !== i.appVersion.indexOf("Win") ? d = t.OS_WINDOWS : h ? d = t.OS_IOS : -1 !== i.appVersion.indexOf("Mac") ? d = t.OS_OSX : -1 !== i.appVersion.indexOf("X11") && -1 === i.appVersion.indexOf("Linux") ? d = t.OS_UNIX : a ? d = t.OS_ANDROID : -1 !== i.appVersion.indexOf("Linux") && (d = t.OS_LINUX),
        t.os = d,
        t.osVersion = l,
        t.osMainVersion = u,
        t.browserType = t.BROWSER_TYPE_UNKNOWN,
        function() {
            var e = /qqbrowser|chrome|safari|firefox|opr|oupeng|opera/i
              , i = /sogou|qzone|liebao|micromessenger|ucbrowser|360 aphone|360browser|baiduboxapp|baidubrowser|maxthon|mxbrowser|trident|miuibrowser/i.exec(o);
            i || (i = e.exec(o)),
            e = i ? i[0] : t.BROWSER_TYPE_UNKNOWN,
            "micromessenger" === e ? e = t.BROWSER_TYPE_WECHAT : "safari" === e && o.match(/android.*applewebkit/) ? e = t.BROWSER_TYPE_ANDROID : "trident" === e ? e = t.BROWSER_TYPE_IE : "360 aphone" === e ? e = t.BROWSER_TYPE_360 : "mxbrowser" === e ? e = t.BROWSER_TYPE_MAXTHON : "opr" === e && (e = t.BROWSER_TYPE_OPERA),
            t.browserType = e
        }(),
        t.browserVersion = "",
        function() {
            var e = /(msie |rv:|firefox|chrome|ucbrowser|qq|oupeng|opera|opr|safari|miui)(mobile)?(browser)?\/?([\d.]+)/i
              , i = o.match(/(micromessenger|mx|maxthon|baidu|sogou)(mobile)?(browser)?\/?([\d.]+)/i);
            i || (i = o.match(e)),
            t.browserVersion = i ? i[4] : ""
        }(),
        a = window.devicePixelRatio || 1,
        t.windowPixelResolution = {
            width: a * (window.innerWidth || document.documentElement.clientWidth),
            height: a * (window.innerHeight || document.documentElement.clientHeight)
        },
        t._checkWebGLRenderMode = function() {
            if (cc._renderType !== cc.game.RENDER_TYPE_WEBGL)
                throw Error("This feature supports WebGL render mode only.")
        }
        ,
        t._supportCanvasNewBlendModes = function() {
            c.width = 1,
            c.height = 1;
            var t = c.getContext("2d");
            t.fillStyle = "#000",
            t.fillRect(0, 0, 1, 1),
            t.globalCompositeOperation = "multiply",
            s.width = 1,
            s.height = 1;
            var e = s.getContext("2d");
            return e.fillStyle = "#fff",
            e.fillRect(0, 0, 1, 1),
            t.drawImage(s, 0, 0, 1, 1),
            0 === t.getImageData(0, 0, 1, 1).data[0]
        }(),
        cc.sys.isMobile && (a = document.createElement("style"),
        a.type = "text/css",
        document.body.appendChild(a),
        a.textContent = "body,canvas,div{ -moz-user-select: none;-webkit-user-select: none;-ms-user-select: none;-khtml-user-select: none;-webkit-tap-highlight-color:rgba(0,0,0,0);}");
        try {
            var _ = t.localStorage = window.famobi.localStorage;
            _.setItem("storage", ""),
            _.removeItem("storage"),
            _ = null
        } catch (p) {
            _ = function() {
                cc.warn("Warning: localStorage isn't enabled. Please confirm browser cookie or privacy option")
            }
            ,
            t.localStorage = {
                getItem: _,
                setItem: _,
                removeItem: _,
                clear: _
            }
        }
        if (_ = !!c.getContext("2d"),
        a = !1,
        h = document.createElement("CANVAS"),
        e.WebGLRenderingContext)
            try {
                cc.create3DContext(h, {
                    stencil: !0,
                    preserveDrawingBuffer: !0
                }) && (a = !0)
            } catch (f) {}
        _ = t.capabilities = {
            canvas: _,
            opengl: a
        },
        (void 0 !== r.ontouchstart || void 0 !== n.ontouchstart || i.msPointerEnabled) && (_.touches = !0),
        void 0 !== r.onmouseup && (_.mouse = !0),
        void 0 !== r.onkeyup && (_.keyboard = !0),
        (e.DeviceMotionEvent || e.DeviceOrientationEvent) && (_.accelerometer = !0),
        t.garbageCollect = function() {}
        ,
        t.dumpRoot = function() {}
        ,
        t.restartVM = function() {}
        ,
        t.cleanScript = function(t) {}
        ,
        t.isObjectValid = function(t) {
            return !!t
        }
        ,
        t.dump = function() {
            var t;
            t = "" + ("isMobile : " + this.isMobile + "\r\n"),
            t += "language : " + this.language + "\r\n",
            t += "browserType : " + this.browserType + "\r\n",
            t += "capabilities : " + JSON.stringify(this.capabilities) + "\r\n",
            t += "os : " + this.os + "\r\n",
            t += "platform : " + this.platform + "\r\n",
            cc.log(t)
        }
        ,
        t.openURL = function(t) {
            window.open(t)
        }
    }(),
    delete c,
    delete s,
    cc.log = cc.warn = cc.error = cc.assert = function() {}
    ;
    var o = {}
      , a = !1
      , h = null;
    cc._engineLoaded = !1,
    cc.initEngine = function(e, i) {
        if (a) {
            var c = h;
            h = function() {
                c && c(),
                i && i()
            }
        } else
            h = i,
            !cc.game.config && e ? cc.game.config = e : cc.game.config || cc.game._loadConfig(),
            e = cc.game.config,
            t(e),
            document.body ? n(e) : cc._addEventListener(window, "load", r, !1),
            a = !0
    }
}(),
cc.game = {
    DEBUG_MODE_NONE: 0,
    DEBUG_MODE_INFO: 1,
    DEBUG_MODE_WARN: 2,
    DEBUG_MODE_ERROR: 3,
    DEBUG_MODE_INFO_FOR_WEB_PAGE: 4,
    DEBUG_MODE_WARN_FOR_WEB_PAGE: 5,
    DEBUG_MODE_ERROR_FOR_WEB_PAGE: 6,
    EVENT_HIDE: "game_on_hide",
    EVENT_SHOW: "game_on_show",
    EVENT_RESIZE: "game_on_resize",
    EVENT_RENDERER_INITED: "renderer_inited",
    RENDER_TYPE_CANVAS: 0,
    RENDER_TYPE_WEBGL: 1,
    RENDER_TYPE_OPENGL: 2,
    _eventHide: null,
    _eventShow: null,
    CONFIG_KEY: {
        width: "width",
        height: "height",
        engineDir: "engineDir",
        modules: "modules",
        debugMode: "debugMode",
        showFPS: "showFPS",
        frameRate: "frameRate",
        id: "id",
        renderMode: "renderMode",
        jsList: "jsList"
    },
    _paused: !0,
    _prepareCalled: !1,
    _prepared: !1,
    _rendererInitialized: !1,
    _renderContext: null,
    _intervalId: null,
    _lastTime: null,
    _frameTime: null,
    frame: null,
    container: null,
    canvas: null,
    config: null,
    onStart: null,
    onStop: null,
    setFrameRate: function(t) {
        this.config[this.CONFIG_KEY.frameRate] = t,
        this._intervalId && window.cancelAnimationFrame(this._intervalId),
        this._paused = !0,
        this._setAnimFrame(),
        this._runMainLoop()
    },
    step: function() {
        cc.director.mainLoop()
    },
    pause: function() {
        this._paused || (this._paused = !0,
        cc.audioEngine && cc.audioEngine._pausePlaying(),
        this._intervalId && window.cancelAnimationFrame(this._intervalId),
        this._intervalId = 0)
    },
    resume: function() {
        this._paused && (this._paused = !1,
        cc.audioEngine && cc.audioEngine._resumePlaying(),
        this._runMainLoop())
    },
    isPaused: function() {
        return this._paused
    },
    restart: function() {
        cc.director.popToSceneStackLevel(0),
        cc.audioEngine && cc.audioEngine.end(),
        cc.game.onStart()
    },
    prepare: function(t) {
        var e = this
          , i = e.config
          , n = e.CONFIG_KEY;
        this._loadConfig(),
        this._prepared ? t && t() : this._prepareCalled || (cc._engineLoaded ? (this._prepareCalled = !0,
        this._initRenderer(i[n.width], i[n.height]),
        cc.view = cc.EGLView._getInstance(),
        cc.director = cc.Director._getInstance(),
        cc.director.setOpenGLView && cc.director.setOpenGLView(cc.view),
        cc.winSize = cc.director.getWinSize(),
        this._initEvents(),
        this._setAnimFrame(),
        this._runMainLoop(),
        (i = i[n.jsList]) ? cc.loader.loadJsWithImg(i, function(i) {
            if (i)
                throw Error(i);
            e._prepared = !0,
            t && t()
        }) : t && t()) : cc.initEngine(this.config, function() {
            e.prepare(t)
        }))
    },
    run: function(t, e) {
        "function" == typeof t ? cc.game.onStart = t : (t && ("string" == typeof t ? (cc.game.config || this._loadConfig(),
        cc.game.config[cc.game.CONFIG_KEY.id] = t) : cc.game.config = t),
        "function" == typeof e && (cc.game.onStart = e)),
        this.prepare(cc.game.onStart && cc.game.onStart.bind(cc.game))
    },
    _setAnimFrame: function() {
        this._lastTime = new Date,
        this._frameTime = 1e3 / cc.game.config[cc.game.CONFIG_KEY.frameRate],
        cc.sys.os === cc.sys.OS_IOS && cc.sys.browserType === cc.sys.BROWSER_TYPE_WECHAT || 60 !== cc.game.config[cc.game.CONFIG_KEY.frameRate] ? (window.requestAnimFrame = this._stTime,
        window.cancelAnimationFrame = this._ctTime) : (window.requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || this._stTime,
        window.cancelAnimationFrame = window.cancelAnimationFrame || window.cancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.oCancelAnimationFrame || this._ctTime)
    },
    _stTime: function(t) {
        var e = (new Date).getTime()
          , i = Math.max(0, cc.game._frameTime - (e - cc.game._lastTime))
          , n = window.setTimeout(function() {
            t()
        }, i);
        return cc.game._lastTime = e + i,
        n
    },
    _ctTime: function(t) {
        window.clearTimeout(t)
    },
    _runMainLoop: function() {
        var t, e = this, i = cc.director;
        i.setDisplayStats(e.config[e.CONFIG_KEY.showFPS]),
        t = function() {
            e._paused || (i.mainLoop(),
            e._intervalId && window.cancelAnimationFrame(e._intervalId),
            e._intervalId = window.requestAnimFrame(t))
        }
        ,
        window.requestAnimFrame(t),
        e._paused = !1
    },
    _loadConfig: function() {
        if (this.config)
            this._initConfig(this.config);
        else if (document.ccConfig)
            this._initConfig(document.ccConfig);
        else
            try {
                for (var t = document.getElementsByTagName("script"), e = 0; e < t.length; e++) {
                    var i = t[e].getAttribute("cocos");
                    if ("" === i || i)
                        break
                }
                var n, r, c;
                e < t.length && ((n = t[e].src) && (c = /(.*)\//.exec(n)[0],
                cc.loader.resPath = c,
                n = cc.path.join(c, "project.json")),
                r = cc.loader._loadTxtSync(n)),
                r || (r = cc.loader._loadTxtSync("project.json"));
                var s = JSON.parse(r);
                this._initConfig(s || {})
            } catch (o) {
                cc.log("Failed to read or parse project.json"),
                this._initConfig({})
            }
    },
    _initConfig: function(t) {
        var e = this.CONFIG_KEY
          , i = t[e.modules];
        t[e.showFPS] = "undefined" == typeof t[e.showFPS] || t[e.showFPS],
        t[e.engineDir] = t[e.engineDir] || "frameworks/cocos2d-html5",
        null == t[e.debugMode] && (t[e.debugMode] = 0),
        t[e.frameRate] = t[e.frameRate] || 60,
        null == t[e.renderMode] && (t[e.renderMode] = 0),
        null == t[e.registerSystemEvent] && (t[e.registerSystemEvent] = !0),
        i && 0 > i.indexOf("core") && i.splice(0, 0, "core"),
        i && (t[e.modules] = i),
        this.config = t
    },
    _initRenderer: function(t, e) {
        if (!this._rendererInitialized) {
            if (!cc._supportRender)
                throw Error("The renderer doesn't support the renderMode " + this.config[this.CONFIG_KEY.renderMode]);
            var i, n = this.config[cc.game.CONFIG_KEY.id], r = window, c = cc.$(n) || cc.$("#" + n);
            "CANVAS" === c.tagName ? (t = t || c.width,
            e = e || c.height,
            this.canvas = cc._canvas = n = c,
            this.container = cc.container = i = document.createElement("DIV"),
            n.parentNode && n.parentNode.insertBefore(i, n)) : ("DIV" !== c.tagName && cc.log("Warning: target element is not a DIV or CANVAS"),
            t = t || c.clientWidth,
            e = e || c.clientHeight,
            this.canvas = cc._canvas = n = document.createElement("CANVAS"),
            this.container = cc.container = i = document.createElement("DIV"),
            c.appendChild(i)),
            i.setAttribute("id", "Cocos2dGameContainer"),
            i.appendChild(n),
            this.frame = i.parentNode === document.body ? document.documentElement : i.parentNode,
            n.addClass("gameCanvas"),
            n.setAttribute("width", t || 480),
            n.setAttribute("height", e || 320),
            n.setAttribute("tabindex", 99),
            n.style.outline = "none",
            c = i.style,
            c.width = (t || 480) + "px",
            c.height = (e || 320) + "px",
            c.margin = "0 auto",
            c.position = "relative",
            c.overflow = "hidden",
            i.top = "100%",
            cc._renderType === cc.game.RENDER_TYPE_WEBGL && (this._renderContext = cc._renderContext = cc.webglContext = cc.create3DContext(n, {
                stencil: !0,
                preserveDrawingBuffer: !0,
                antialias: !cc.sys.isMobile,
                alpha: !0
            })),
            this._renderContext ? (cc.renderer = cc.rendererWebGL,
            r.gl = this._renderContext,
            cc.shaderCache._init(),
            cc._drawingUtil = new cc.DrawingPrimitiveWebGL(this._renderContext),
            cc.textureCache._initializingRenderer()) : (cc.renderer = cc.rendererCanvas,
            this._renderContext = cc._renderContext = new cc.CanvasContextWrapper(n.getContext("2d")),
            cc._drawingUtil = cc.DrawingPrimitiveCanvas ? new cc.DrawingPrimitiveCanvas(this._renderContext) : null),
            cc._gameDiv = i,
            cc.game.canvas.oncontextmenu = function() {
                if (!cc._isContextMenuEnable)
                    return !1
            }
            ,
            this.dispatchEvent(this.EVENT_RENDERER_INITED, !0),
            this._rendererInitialized = !0
        }
    },
    _initEvents: function() {
        var t, e, i = window;
        this._eventHide = this._eventHide || new cc.EventCustom(this.EVENT_HIDE),
        this._eventHide.setUserData(this),
        this._eventShow = this._eventShow || new cc.EventCustom(this.EVENT_SHOW),
        this._eventShow.setUserData(this),
        this.config[this.CONFIG_KEY.registerSystemEvent] && cc.inputManager.registerSystemEvent(this.canvas),
        cc.isUndefined(document.hidden) ? cc.isUndefined(document.mozHidden) ? cc.isUndefined(document.msHidden) ? cc.isUndefined(document.webkitHidden) || (t = "webkitHidden",
        e = "webkitvisibilitychange") : (t = "msHidden",
        e = "msvisibilitychange") : (t = "mozHidden",
        e = "mozvisibilitychange") : (t = "hidden",
        e = "visibilitychange");
        var n = function() {
            cc.eventManager && cc.game._eventHide && cc.eventManager.dispatchEvent(cc.game._eventHide)
        }
          , r = function() {
            cc.eventManager && cc.game._eventShow && cc.eventManager.dispatchEvent(cc.game._eventShow)
        };
        t ? document.addEventListener(e, function() {
            document[t] ? n() : r()
        }, !1) : (i.addEventListener("blur", n, !1),
        i.addEventListener("focus", r, !1)),
        -1 < navigator.userAgent.indexOf("MicroMessenger") && (i.onfocus = function() {
            r()
        }
        ),
        "onpageshow"in window && "onpagehide"in window && (i.addEventListener("pagehide", n, !1),
        i.addEventListener("pageshow", r, !1)),
        cc.eventManager.addCustomListener(cc.game.EVENT_HIDE, function() {
            cc.game.pause()
        }),
        cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function() {
            cc.game.resume()
        })
    }
},
Function.prototype.bind = Function.prototype.bind || function(t) {
    if (!cc.isFunction(this))
        throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
    var e = Array.prototype.slice.call(arguments, 1)
      , i = this
      , n = function() {}
      , r = function() {
        return i.apply(this instanceof n && t ? this : t, e.concat(Array.prototype.slice.call(arguments)))
    };
    return n.prototype = this.prototype,
    r.prototype = new n,
    r
}
,
cc._urlRegExp = RegExp("^(?:(?:https?|ftp)://)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))|(?:localhost))(?::\\d{2,5})?(?:/\\S*)?$", "i"),
cc.EventHelper = function() {}
,
cc.EventHelper.prototype = {
    constructor: cc.EventHelper,
    apply: function(t) {
        t.addEventListener = cc.EventHelper.prototype.addEventListener,
        t.hasEventListener = cc.EventHelper.prototype.hasEventListener,
        t.removeEventListener = cc.EventHelper.prototype.removeEventListener,
        t.dispatchEvent = cc.EventHelper.prototype.dispatchEvent
    },
    addEventListener: function(t, e, i) {
        if ("load" === t && this._textureLoaded)
            setTimeout(function() {
                e.call(i)
            }, 0);
        else {
            void 0 === this._listeners && (this._listeners = {});
            var n = this._listeners;
            void 0 === n[t] && (n[t] = []),
            this.hasEventListener(t, e, i) || n[t].push({
                callback: e,
                eventTarget: i
            })
        }
    },
    hasEventListener: function(t, e, i) {
        if (void 0 === this._listeners)
            return !1;
        var n = this._listeners;
        if (void 0 !== n[t]) {
            t = 0;
            for (var r = n.length; t < r; t++) {
                var c = n[t];
                if (c.callback === e && c.eventTarget === i)
                    return !0
            }
        }
        return !1
    },
    removeEventListener: function(t, e) {
        if (void 0 !== this._listeners) {
            var i = this._listeners[t];
            if (void 0 !== i)
                for (var n = 0; n < i.length; )
                    i[n].eventTarget === e ? i.splice(n, 1) : n++
        }
    },
    dispatchEvent: function(t, e) {
        if (void 0 !== this._listeners) {
            null == e && (e = !0);
            var i = this._listeners[t];
            if (void 0 !== i) {
                for (var n = [], r = i.length, c = 0; c < r; c++)
                    n[c] = i[c];
                for (c = 0; c < r; c++)
                    n[c].callback.call(n[c].eventTarget, this);
                e && (i.length = 0)
            }
        }
    }
},
cc.EventHelper.prototype.apply(cc.game),
cc._LogInfos = {
    ActionManager_addAction: "cc.ActionManager.addAction(): action must be non-null",
    ActionManager_removeAction: "cocos2d: removeAction: Target not found",
    ActionManager_removeActionByTag: "cc.ActionManager.removeActionByTag(): an invalid tag",
    ActionManager_removeActionByTag_2: "cc.ActionManager.removeActionByTag(): target must be non-null",
    ActionManager_getActionByTag: "cc.ActionManager.getActionByTag(): an invalid tag",
    ActionManager_getActionByTag_2: "cocos2d : getActionByTag(tag = %s): Action not found",
    configuration_dumpInfo: "cocos2d: **** WARNING **** CC_ENABLE_PROFILERS is defined. Disable it when you finish profiling (from ccConfig.js)",
    configuration_loadConfigFile: "Expected 'data' dict, but not found. Config file: %s",
    configuration_loadConfigFile_2: "Please load the resource first : %s",
    Director_resume: "cocos2d: Director: Error in gettimeofday",
    Director_setProjection: "cocos2d: Director: unrecognized projection",
    Director_popToSceneStackLevel: "cocos2d: Director: unrecognized projection",
    Director_popToSceneStackLevel_2: "cocos2d: Director: Error in gettimeofday",
    Director_popScene: "running scene should not null",
    Director_pushScene: "the scene should not null",
    arrayVerifyType: "element type is wrong!",
    Scheduler_scheduleCallbackForTarget: "CCSheduler#scheduleCallback. Callback already scheduled. Updating interval from:%s to %s",
    Scheduler_scheduleCallbackForTarget_2: "cc.scheduler.scheduleCallbackForTarget(): callback_fn should be non-null.",
    Scheduler_scheduleCallbackForTarget_3: "cc.scheduler.scheduleCallbackForTarget(): target should be non-null.",
    Scheduler_pauseTarget: "cc.Scheduler.pauseTarget():target should be non-null",
    Scheduler_resumeTarget: "cc.Scheduler.resumeTarget():target should be non-null",
    Scheduler_isTargetPaused: "cc.Scheduler.isTargetPaused():target should be non-null",
    Node_getZOrder: "getZOrder is deprecated. Please use getLocalZOrder instead.",
    Node_setZOrder: "setZOrder is deprecated. Please use setLocalZOrder instead.",
    Node_getRotation: "RotationX != RotationY. Don't know which one to return",
    Node_getScale: "ScaleX != ScaleY. Don't know which one to return",
    Node_addChild: "An Node can't be added as a child of itself.",
    Node_addChild_2: "child already added. It can't be added again",
    Node_addChild_3: "child must be non-null",
    Node_removeFromParentAndCleanup: "removeFromParentAndCleanup is deprecated. Use removeFromParent instead",
    Node_boundingBox: "boundingBox is deprecated. Use getBoundingBox instead",
    Node_removeChildByTag: "argument tag is an invalid tag",
    Node_removeChildByTag_2: "cocos2d: removeChildByTag(tag = %s): child not found!",
    Node_removeAllChildrenWithCleanup: "removeAllChildrenWithCleanup is deprecated. Use removeAllChildren instead",
    Node_stopActionByTag: "cc.Node.stopActionBy(): argument tag an invalid tag",
    Node_getActionByTag: "cc.Node.getActionByTag(): argument tag is an invalid tag",
    Node_resumeSchedulerAndActions: "resumeSchedulerAndActions is deprecated, please use resume instead.",
    Node_pauseSchedulerAndActions: "pauseSchedulerAndActions is deprecated, please use pause instead.",
    Node__arrayMakeObjectsPerformSelector: "Unknown callback function",
    Node_reorderChild: "child must be non-null",
    Node_runAction: "cc.Node.runAction(): action must be non-null",
    Node_schedule: "callback function must be non-null",
    Node_schedule_2: "interval must be positive",
    Node_initWithTexture: "cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.",
    AtlasNode_updateAtlasValues: "cc.AtlasNode.updateAtlasValues(): Shall be overridden in subclasses",
    AtlasNode_initWithTileFile: "",
    AtlasNode__initWithTexture: "cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.",
    _EventListenerKeyboard_checkAvailable: "cc._EventListenerKeyboard.checkAvailable(): Invalid EventListenerKeyboard!",
    _EventListenerTouchOneByOne_checkAvailable: "cc._EventListenerTouchOneByOne.checkAvailable(): Invalid EventListenerTouchOneByOne!",
    _EventListenerTouchAllAtOnce_checkAvailable: "cc._EventListenerTouchAllAtOnce.checkAvailable(): Invalid EventListenerTouchAllAtOnce!",
    _EventListenerAcceleration_checkAvailable: "cc._EventListenerAcceleration.checkAvailable(): _onAccelerationEvent must be non-nil",
    EventListener_create: "Invalid parameter.",
    __getListenerID: "Don't call this method if the event is for touch.",
    eventManager__forceAddEventListener: "Invalid scene graph priority!",
    eventManager_addListener: "0 priority is forbidden for fixed priority since it's used for scene graph based priority.",
    eventManager_removeListeners: "Invalid listener type!",
    eventManager_setPriority: "Can't set fixed priority with scene graph based listener.",
    eventManager_addListener_2: "Invalid parameters.",
    eventManager_addListener_3: "listener must be a cc.EventListener object when adding a fixed priority listener",
    eventManager_addListener_4: "The listener has been registered, please don't register it again.",
    LayerMultiplex_initWithLayers: "parameters should not be ending with null in Javascript",
    LayerMultiplex_switchTo: "Invalid index in MultiplexLayer switchTo message",
    LayerMultiplex_switchToAndReleaseMe: "Invalid index in MultiplexLayer switchTo message",
    LayerMultiplex_addLayer: "cc.Layer.addLayer(): layer should be non-null",
    EGLView_setDesignResolutionSize: "Resolution not valid",
    EGLView_setDesignResolutionSize_2: "should set resolutionPolicy",
    inputManager_handleTouchesBegin: "The touches is more than MAX_TOUCHES, nUnusedIndex = %s",
    swap: "cc.swap is being modified from original macro, please check usage",
    checkGLErrorDebug: "WebGL error %s",
    animationCache__addAnimationsWithDictionary: "cocos2d: cc.AnimationCache: No animations were found in provided dictionary.",
    animationCache__addAnimationsWithDictionary_2: "cc.AnimationCache. Invalid animation format",
    animationCache_addAnimations: "cc.AnimationCache.addAnimations(): File could not be found",
    animationCache__parseVersion1: "cocos2d: cc.AnimationCache: Animation '%s' found in dictionary without any frames - cannot add to animation cache.",
    animationCache__parseVersion1_2: "cocos2d: cc.AnimationCache: Animation '%s' refers to frame '%s' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.",
    animationCache__parseVersion1_3: "cocos2d: cc.AnimationCache: None of the frames for animation '%s' were found in the cc.SpriteFrameCache. Animation is not being added to the Animation Cache.",
    animationCache__parseVersion1_4: "cocos2d: cc.AnimationCache: An animation in your dictionary refers to a frame which is not in the cc.SpriteFrameCache. Some or all of the frames for the animation '%s' may be missing.",
    animationCache__parseVersion2: "cocos2d: CCAnimationCache: Animation '%s' found in dictionary without any frames - cannot add to animation cache.",
    animationCache__parseVersion2_2: "cocos2d: cc.AnimationCache: Animation '%s' refers to frame '%s' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.",
    animationCache_addAnimations_2: "cc.AnimationCache.addAnimations(): Invalid texture file name",
    Sprite_reorderChild: "cc.Sprite.reorderChild(): this child is not in children list",
    Sprite_ignoreAnchorPointForPosition: "cc.Sprite.ignoreAnchorPointForPosition(): it is invalid in cc.Sprite when using SpriteBatchNode",
    Sprite_setDisplayFrameWithAnimationName: "cc.Sprite.setDisplayFrameWithAnimationName(): Frame not found",
    Sprite_setDisplayFrameWithAnimationName_2: "cc.Sprite.setDisplayFrameWithAnimationName(): Invalid frame index",
    Sprite_setDisplayFrame: "setDisplayFrame is deprecated, please use setSpriteFrame instead.",
    Sprite__updateBlendFunc: "cc.Sprite._updateBlendFunc(): _updateBlendFunc doesn't work when the sprite is rendered using a cc.CCSpriteBatchNode",
    Sprite_initWithSpriteFrame: "cc.Sprite.initWithSpriteFrame(): spriteFrame should be non-null",
    Sprite_initWithSpriteFrameName: "cc.Sprite.initWithSpriteFrameName(): spriteFrameName should be non-null",
    Sprite_initWithSpriteFrameName1: " is null, please check.",
    Sprite_initWithFile: "cc.Sprite.initWithFile(): filename should be non-null",
    Sprite_setDisplayFrameWithAnimationName_3: "cc.Sprite.setDisplayFrameWithAnimationName(): animationName must be non-null",
    Sprite_reorderChild_2: "cc.Sprite.reorderChild(): child should be non-null",
    Sprite_addChild: "cc.Sprite.addChild(): cc.Sprite only supports cc.Sprites as children when using cc.SpriteBatchNode",
    Sprite_addChild_2: "cc.Sprite.addChild(): cc.Sprite only supports a sprite using same texture as children when using cc.SpriteBatchNode",
    Sprite_addChild_3: "cc.Sprite.addChild(): child should be non-null",
    Sprite_setTexture: "cc.Sprite.texture setter: Batched sprites should use the same texture as the batchnode",
    Sprite_updateQuadFromSprite: "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    Sprite_insertQuadFromSprite: "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    Sprite_addChild_4: "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
    Sprite_addChild_5: "cc.SpriteBatchNode.addChild(): cc.Sprite is not using the same texture",
    Sprite_initWithTexture: "Sprite.initWithTexture(): Argument must be non-nil ",
    Sprite_setSpriteFrame: "Invalid spriteFrameName",
    Sprite_setTexture_2: "Invalid argument: cc.Sprite.texture setter expects a CCTexture2D.",
    Sprite_updateQuadFromSprite_2: "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
    Sprite_insertQuadFromSprite_2: "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null",
    SpriteBatchNode_addSpriteWithoutQuad: "cc.SpriteBatchNode.addQuadFromSprite(): SpriteBatchNode only supports cc.Sprites as children",
    SpriteBatchNode_increaseAtlasCapacity: "cocos2d: CCSpriteBatchNode: resizing TextureAtlas capacity from %s to %s.",
    SpriteBatchNode_increaseAtlasCapacity_2: "cocos2d: WARNING: Not enough memory to resize the atlas",
    SpriteBatchNode_reorderChild: "cc.SpriteBatchNode.addChild(): Child doesn't belong to Sprite",
    SpriteBatchNode_removeChild: "cc.SpriteBatchNode.addChild(): sprite batch node should contain the child",
    SpriteBatchNode_addSpriteWithoutQuad_2: "cc.SpriteBatchNode.addQuadFromSprite(): child should be non-null",
    SpriteBatchNode_reorderChild_2: "cc.SpriteBatchNode.addChild(): child should be non-null",
    spriteFrameCache__getFrameConfig: "cocos2d: WARNING: originalWidth/Height not found on the cc.SpriteFrame. AnchorPoint won't work as expected. Regenrate the .plist",
    spriteFrameCache_addSpriteFrames: "cocos2d: WARNING: an alias with name %s already exists",
    spriteFrameCache__checkConflict: "cocos2d: WARNING: Sprite frame: %s has already been added by another source, please fix name conflit",
    spriteFrameCache_getSpriteFrame: "cocos2d: cc.SpriteFrameCahce: Frame %s not found",
    spriteFrameCache__getFrameConfig_2: "Please load the resource first : %s",
    spriteFrameCache_addSpriteFrames_2: "cc.SpriteFrameCache.addSpriteFrames(): plist should be non-null",
    spriteFrameCache_addSpriteFrames_3: "Argument must be non-nil",
    CCSpriteBatchNode_updateQuadFromSprite: "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    CCSpriteBatchNode_insertQuadFromSprite: "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    CCSpriteBatchNode_addChild: "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
    CCSpriteBatchNode_initWithTexture: "Sprite.initWithTexture(): Argument must be non-nil ",
    CCSpriteBatchNode_addChild_2: "cc.Sprite.addChild(): child should be non-null",
    CCSpriteBatchNode_setSpriteFrame: "Invalid spriteFrameName",
    CCSpriteBatchNode_setTexture: "Invalid argument: cc.Sprite texture setter expects a CCTexture2D.",
    CCSpriteBatchNode_updateQuadFromSprite_2: "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
    CCSpriteBatchNode_insertQuadFromSprite_2: "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null",
    CCSpriteBatchNode_addChild_3: "cc.SpriteBatchNode.addChild(): child should be non-null",
    TextureAtlas_initWithFile: "cocos2d: Could not open file: %s",
    TextureAtlas_insertQuad: "cc.TextureAtlas.insertQuad(): invalid totalQuads",
    TextureAtlas_initWithTexture: "cc.TextureAtlas.initWithTexture():texture should be non-null",
    TextureAtlas_updateQuad: "cc.TextureAtlas.updateQuad(): quad should be non-null",
    TextureAtlas_updateQuad_2: "cc.TextureAtlas.updateQuad(): Invalid index",
    TextureAtlas_insertQuad_2: "cc.TextureAtlas.insertQuad(): Invalid index",
    TextureAtlas_insertQuads: "cc.TextureAtlas.insertQuad(): Invalid index + amount",
    TextureAtlas_insertQuadFromIndex: "cc.TextureAtlas.insertQuadFromIndex(): Invalid newIndex",
    TextureAtlas_insertQuadFromIndex_2: "cc.TextureAtlas.insertQuadFromIndex(): Invalid fromIndex",
    TextureAtlas_removeQuadAtIndex: "cc.TextureAtlas.removeQuadAtIndex(): Invalid index",
    TextureAtlas_removeQuadsAtIndex: "cc.TextureAtlas.removeQuadsAtIndex(): index + amount out of bounds",
    TextureAtlas_moveQuadsFromIndex: "cc.TextureAtlas.moveQuadsFromIndex(): move is out of bounds",
    TextureAtlas_moveQuadsFromIndex_2: "cc.TextureAtlas.moveQuadsFromIndex(): Invalid newIndex",
    TextureAtlas_moveQuadsFromIndex_3: "cc.TextureAtlas.moveQuadsFromIndex(): Invalid oldIndex",
    textureCache_addPVRTCImage: "TextureCache:addPVRTCImage does not support on HTML5",
    textureCache_addETCImage: "TextureCache:addPVRTCImage does not support on HTML5",
    textureCache_textureForKey: "textureForKey is deprecated. Please use getTextureForKey instead.",
    textureCache_addPVRImage: "addPVRImage does not support on HTML5",
    textureCache_addUIImage: "cocos2d: Couldn't add UIImage in TextureCache",
    textureCache_dumpCachedTextureInfo: "cocos2d: '%s' id=%s %s x %s",
    textureCache_dumpCachedTextureInfo_2: "cocos2d: '%s' id= HTMLCanvasElement %s x %s",
    textureCache_dumpCachedTextureInfo_3: "cocos2d: TextureCache dumpDebugInfo: %s textures, HTMLCanvasElement for %s KB (%s MB)",
    textureCache_addUIImage_2: "cc.Texture.addUIImage(): image should be non-null",
    Texture2D_initWithETCFile: "initWithETCFile does not support on HTML5",
    Texture2D_initWithPVRFile: "initWithPVRFile does not support on HTML5",
    Texture2D_initWithPVRTCData: "initWithPVRTCData does not support on HTML5",
    Texture2D_addImage: "cc.Texture.addImage(): path should be non-null",
    Texture2D_initWithImage: "cocos2d: cc.Texture2D. Can't create Texture. UIImage is nil",
    Texture2D_initWithImage_2: "cocos2d: WARNING: Image (%s x %s) is bigger than the supported %s x %s",
    Texture2D_initWithString: "initWithString isn't supported on cocos2d-html5",
    Texture2D_initWithETCFile_2: "initWithETCFile does not support on HTML5",
    Texture2D_initWithPVRFile_2: "initWithPVRFile does not support on HTML5",
    Texture2D_initWithPVRTCData_2: "initWithPVRTCData does not support on HTML5",
    Texture2D_bitsPerPixelForFormat: "bitsPerPixelForFormat: %s, cannot give useful result, it's a illegal pixel format",
    Texture2D__initPremultipliedATextureWithImage: "cocos2d: cc.Texture2D: Using RGB565 texture since image has no alpha",
    Texture2D_addImage_2: "cc.Texture.addImage(): path should be non-null",
    Texture2D_initWithData: "NSInternalInconsistencyException",
    MissingFile: "Missing file: %s",
    radiansToDegress: "cc.radiansToDegress() should be called cc.radiansToDegrees()",
    RectWidth: "Rect width exceeds maximum margin: %s",
    RectHeight: "Rect height exceeds maximum margin: %s",
    EventManager__updateListeners: "If program goes here, there should be event in dispatch.",
    EventManager__updateListeners_2: "_inDispatch should be 1 here."
},
cc._logToWebPage = function(t) {
    if (cc._canvas) {
        var e = cc._logList
          , i = document;
        if (!e) {
            var n = i.createElement("Div")
              , e = n.style;
            n.setAttribute("id", "logInfoDiv"),
            cc._canvas.parentNode.appendChild(n),
            n.setAttribute("width", "200"),
            n.setAttribute("height", cc._canvas.height),
            e.zIndex = "99999",
            e.position = "absolute",
            e.top = "0",
            e.left = "0",
            e = cc._logList = i.createElement("textarea"),
            i = e.style,
            e.setAttribute("rows", "20"),
            e.setAttribute("cols", "30"),
            e.setAttribute("disabled", !0),
            n.appendChild(e),
            i.backgroundColor = "transparent",
            i.borderBottom = "1px solid #cccccc",
            i.borderRightWidth = "0px",
            i.borderLeftWidth = "0px",
            i.borderTopWidth = "0px",
            i.borderTopStyle = "none",
            i.borderRightStyle = "none",
            i.borderLeftStyle = "none",
            i.padding = "0px",
            i.margin = 0
        }
        e.value = e.value + t + "\r\n",
        e.scrollTop = e.scrollHeight
    }
}
,
cc._formatString = function(t) {
    if (!cc.isObject(t))
        return t;
    try {
        return JSON.stringify(t)
    } catch (e) {
        return ""
    }
}
,
cc._initDebugSetting = function(t) {
    var e = cc.game;
    if (t !== e.DEBUG_MODE_NONE) {
        var i;
        t > e.DEBUG_MODE_ERROR ? (i = cc._logToWebPage.bind(cc),
        cc.error = function() {
            i("ERROR :  " + cc.formatStr.apply(cc, arguments))
        }
        ,
        cc.assert = function(t, e) {
            if (!t && e) {
                for (var n = 2; n < arguments.length; n++)
                    e = e.replace(/(%s)|(%d)/, cc._formatString(arguments[n]));
                i("Assert: " + e)
            }
        }
        ,
        t !== e.DEBUG_MODE_ERROR_FOR_WEB_PAGE && (cc.warn = function() {
            i("WARN :  " + cc.formatStr.apply(cc, arguments))
        }
        ),
        t === e.DEBUG_MODE_INFO_FOR_WEB_PAGE && (cc.log = function() {
            i(cc.formatStr.apply(cc, arguments))
        }
        )) : console && console.log.apply && (cc.error = function() {
            return console.error.apply(console, arguments)
        }
        ,
        cc.assert = function(t, e) {
            if (!t && e) {
                for (var i = 2; i < arguments.length; i++)
                    e = e.replace(/(%s)|(%d)/, cc._formatString(arguments[i]));
                throw Error(e)
            }
        }
        ,
        t !== e.DEBUG_MODE_ERROR && (cc.warn = function() {
            return console.warn.apply(console, arguments)
        }
        ),
        t === e.DEBUG_MODE_INFO && (cc.log = function() {
            return console.log.apply(console, arguments)
        }
        ))
    }
}
,
cc.loader.loadBinary = function(t, e) {
    var i = this
      , n = this.getXMLHttpRequest()
      , r = "load " + t + " failed!";
    n.open("GET", t, !0),
    cc.loader.loadBinary._IEFilter ? (n.setRequestHeader("Accept-Charset", "x-user-defined"),
    n.onreadystatechange = function() {
        if (4 === n.readyState && 200 === n.status) {
            var t = cc._convertResponseBodyToText(n.responseBody);
            e(null, i._str2Uint8Array(t))
        } else
            e(r)
    }
    ) : (n.overrideMimeType && n.overrideMimeType("text/plain; charset=x-user-defined"),
    n.onload = function() {
        4 === n.readyState && 200 === n.status ? e(null, i._str2Uint8Array(n.responseText)) : e(r)
    }
    ),
    n.send(null)
}
,
cc.loader.loadBinary._IEFilter = /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) && window.IEBinaryToArray_ByteStr && window.IEBinaryToArray_ByteStr_Last,
cc.loader._str2Uint8Array = function(t) {
    if (!t)
        return null;
    for (var e = new Uint8Array(t.length), i = 0; i < t.length; i++)
        e[i] = 255 & t.charCodeAt(i);
    return e
}
,
cc.loader.loadBinarySync = function(t) {
    var e = this.getXMLHttpRequest()
      , i = "load " + t + " failed!";
    if (e.open("GET", t, !1),
    t = null,
    cc.loader.loadBinary._IEFilter) {
        if (e.setRequestHeader("Accept-Charset", "x-user-defined"),
        e.send(null),
        200 !== e.status)
            return cc.log(i),
            null;
        (e = cc._convertResponseBodyToText(e.responseBody)) && (t = this._str2Uint8Array(e))
    } else {
        if (e.overrideMimeType && e.overrideMimeType("text/plain; charset=x-user-defined"),
        e.send(null),
        200 !== e.status)
            return cc.log(i),
            null;
        t = this._str2Uint8Array(e.responseText)
    }
    return t
}
,
window.Uint8Array = window.Uint8Array || window.Array,
cc.loader.loadBinary._IEFilter) {
    var IEBinaryToArray_ByteStr_Script = '<!-- IEBinaryToArray_ByteStr -->\r\nFunction IEBinaryToArray_ByteStr(Binary)\r\n   IEBinaryToArray_ByteStr = CStr(Binary)\r\nEnd Function\r\nFunction IEBinaryToArray_ByteStr_Last(Binary)\r\n   Dim lastIndex\r\n   lastIndex = LenB(Binary)\r\n   if lastIndex mod 2 Then\r\n       IEBinaryToArray_ByteStr_Last = Chr( AscB( MidB( Binary, lastIndex, 1 ) ) )\r\n   Else\r\n       IEBinaryToArray_ByteStr_Last = ""\r\n   End If\r\nEnd Function\r\n'
      , myVBScript = document.createElement("script");
    myVBScript.type = "text/vbscript",
    myVBScript.textContent = IEBinaryToArray_ByteStr_Script,
    document.body.appendChild(myVBScript),
    cc._convertResponseBodyToText = function(t) {
        for (var e = {}, i = 0; 256 > i; i++)
            for (var n = 0; 256 > n; n++)
                e[String.fromCharCode(i + 256 * n)] = String.fromCharCode(i) + String.fromCharCode(n);
        return i = IEBinaryToArray_ByteStr(t),
        t = IEBinaryToArray_ByteStr_Last(t),
        i.replace(/[\s\S]/g, function(t) {
            return e[t]
        }) + t
    }
}
cc = cc || {},
cc._loadingImage = "data:image/gif;base64,R0lGODlhEAAQALMNAD8/P7+/vyoqKlVVVX9/fxUVFUBAQGBgYMDAwC8vL5CQkP///wAAAP///wAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFAAANACwAAAAAEAAQAAAEO5DJSau9OOvNex0IMnDIsiCkiW6g6BmKYlBFkhSUEgQKlQCARG6nEBwOgl+QApMdCIRD7YZ5RjlGpCUCACH5BAUAAA0ALAAAAgAOAA4AAAQ6kLGB0JA4M7QW0hrngRllkYyhKAYqKUGguAws0ypLS8JxCLQDgXAIDg+FRKIA6v0SAECCBpXSkstMBAAh+QQFAAANACwAAAAACgAQAAAEOJDJORAac6K1kDSKYmydpASBUl0mqmRfaGTCcQgwcxDEke+9XO2WkxQSiUIuAQAkls0n7JgsWq8RACH5BAUAAA0ALAAAAAAOAA4AAAQ6kMlplDIzTxWC0oxwHALnDQgySAdBHNWFLAvCukc215JIZihVIZEogDIJACBxnCSXTcmwGK1ar1hrBAAh+QQFAAANACwAAAAAEAAKAAAEN5DJKc4RM+tDyNFTkSQF5xmKYmQJACTVpQSBwrpJNteZSGYoFWjIGCAQA2IGsVgglBOmEyoxIiMAIfkEBQAADQAsAgAAAA4ADgAABDmQSVZSKjPPBEDSGucJxyGA1XUQxAFma/tOpDlnhqIYN6MEAUXvF+zldrMBAjHoIRYLhBMqvSmZkggAIfkEBQAADQAsBgAAAAoAEAAABDeQyUmrnSWlYhMASfeFVbZdjHAcgnUQxOHCcqWylKEohqUEAYVkgEAMfkEJYrFA6HhKJsJCNFoiACH5BAUAAA0ALAIAAgAOAA4AAAQ3kMlJq704611SKloCAEk4lln3DQgyUMJxCBKyLAh1EMRR3wiDQmHY9SQslyIQUMRmlmVTIyRaIgA7",
cc._fpsImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAAgCAYAAAD9qabkAAAKQ2lDQ1BJQ0MgcHJvZmlsZQAAeNqdU3dYk/cWPt/3ZQ9WQtjwsZdsgQAiI6wIyBBZohCSAGGEEBJAxYWIClYUFRGcSFXEgtUKSJ2I4qAouGdBiohai1VcOO4f3Ke1fXrv7e371/u855zn/M55zw+AERImkeaiagA5UoU8Otgfj09IxMm9gAIVSOAEIBDmy8JnBcUAAPADeXh+dLA//AGvbwACAHDVLiQSx+H/g7pQJlcAIJEA4CIS5wsBkFIAyC5UyBQAyBgAsFOzZAoAlAAAbHl8QiIAqg0A7PRJPgUA2KmT3BcA2KIcqQgAjQEAmShHJAJAuwBgVYFSLALAwgCgrEAiLgTArgGAWbYyRwKAvQUAdo5YkA9AYACAmUIszAAgOAIAQx4TzQMgTAOgMNK/4KlfcIW4SAEAwMuVzZdL0jMUuJXQGnfy8ODiIeLCbLFCYRcpEGYJ5CKcl5sjE0jnA0zODAAAGvnRwf44P5Dn5uTh5mbnbO/0xaL+a/BvIj4h8d/+vIwCBAAQTs/v2l/l5dYDcMcBsHW/a6lbANpWAGjf+V0z2wmgWgrQevmLeTj8QB6eoVDIPB0cCgsL7SViob0w44s+/zPhb+CLfvb8QB7+23rwAHGaQJmtwKOD/XFhbnauUo7nywRCMW735yP+x4V//Y4p0eI0sVwsFYrxWIm4UCJNx3m5UpFEIcmV4hLpfzLxH5b9CZN3DQCshk/ATrYHtctswH7uAQKLDljSdgBAfvMtjBoLkQAQZzQyefcAAJO/+Y9AKwEAzZek4wAAvOgYXKiUF0zGCAAARKCBKrBBBwzBFKzADpzBHbzAFwJhBkRADCTAPBBCBuSAHAqhGJZBGVTAOtgEtbADGqARmuEQtMExOA3n4BJcgetwFwZgGJ7CGLyGCQRByAgTYSE6iBFijtgizggXmY4EImFINJKApCDpiBRRIsXIcqQCqUJqkV1II/ItchQ5jVxA+pDbyCAyivyKvEcxlIGyUQPUAnVAuagfGorGoHPRdDQPXYCWomvRGrQePYC2oqfRS+h1dAB9io5jgNExDmaM2WFcjIdFYIlYGibHFmPlWDVWjzVjHVg3dhUbwJ5h7wgkAouAE+wIXoQQwmyCkJBHWExYQ6gl7CO0EroIVwmDhDHCJyKTqE+0JXoS+cR4YjqxkFhGrCbuIR4hniVeJw4TX5NIJA7JkuROCiElkDJJC0lrSNtILaRTpD7SEGmcTCbrkG3J3uQIsoCsIJeRt5APkE+S+8nD5LcUOsWI4kwJoiRSpJQSSjVlP+UEpZ8yQpmgqlHNqZ7UCKqIOp9aSW2gdlAvU4epEzR1miXNmxZDy6Qto9XQmmlnafdoL+l0ugndgx5Fl9CX0mvoB+nn6YP0dwwNhg2Dx0hiKBlrGXsZpxi3GS+ZTKYF05eZyFQw1zIbmWeYD5hvVVgq9ip8FZHKEpU6lVaVfpXnqlRVc1U/1XmqC1SrVQ+rXlZ9pkZVs1DjqQnUFqvVqR1Vu6k2rs5Sd1KPUM9RX6O+X/2C+mMNsoaFRqCGSKNUY7fGGY0hFsYyZfFYQtZyVgPrLGuYTWJbsvnsTHYF+xt2L3tMU0NzqmasZpFmneZxzQEOxrHg8DnZnErOIc4NznstAy0/LbHWaq1mrX6tN9p62r7aYu1y7Rbt69rvdXCdQJ0snfU6bTr3dQm6NrpRuoW623XP6j7TY+t56Qn1yvUO6d3RR/Vt9KP1F+rv1u/RHzcwNAg2kBlsMThj8MyQY+hrmGm40fCE4agRy2i6kcRoo9FJoye4Ju6HZ+M1eBc+ZqxvHGKsNN5l3Gs8YWJpMtukxKTF5L4pzZRrmma60bTTdMzMyCzcrNisyeyOOdWca55hvtm82/yNhaVFnMVKizaLx5balnzLBZZNlvesmFY+VnlW9VbXrEnWXOss623WV2xQG1ebDJs6m8u2qK2brcR2m23fFOIUjynSKfVTbtox7PzsCuya7AbtOfZh9iX2bfbPHcwcEh3WO3Q7fHJ0dcx2bHC866ThNMOpxKnD6VdnG2ehc53zNRemS5DLEpd2lxdTbaeKp26fesuV5RruutK10/Wjm7ub3K3ZbdTdzD3Ffav7TS6bG8ldwz3vQfTw91jicczjnaebp8LzkOcvXnZeWV77vR5Ps5wmntYwbcjbxFvgvct7YDo+PWX6zukDPsY+Ap96n4e+pr4i3z2+I37Wfpl+B/ye+zv6y/2P+L/hefIW8U4FYAHBAeUBvYEagbMDawMfBJkEpQc1BY0FuwYvDD4VQgwJDVkfcpNvwBfyG/ljM9xnLJrRFcoInRVaG/owzCZMHtYRjobPCN8Qfm+m+UzpzLYIiOBHbIi4H2kZmRf5fRQpKjKqLupRtFN0cXT3LNas5Fn7Z72O8Y+pjLk722q2cnZnrGpsUmxj7Ju4gLiquIF4h/hF8ZcSdBMkCe2J5MTYxD2J43MC52yaM5zkmlSWdGOu5dyiuRfm6c7Lnnc8WTVZkHw4hZgSl7I/5YMgQlAvGE/lp25NHRPyhJuFT0W+oo2iUbG3uEo8kuadVpX2ON07fUP6aIZPRnXGMwlPUit5kRmSuSPzTVZE1t6sz9lx2S05lJyUnKNSDWmWtCvXMLcot09mKyuTDeR55m3KG5OHyvfkI/lz89sVbIVM0aO0Uq5QDhZML6greFsYW3i4SL1IWtQz32b+6vkjC4IWfL2QsFC4sLPYuHhZ8eAiv0W7FiOLUxd3LjFdUrpkeGnw0n3LaMuylv1Q4lhSVfJqedzyjlKD0qWlQyuCVzSVqZTJy26u9Fq5YxVhlWRV72qX1VtWfyoXlV+scKyorviwRrjm4ldOX9V89Xlt2treSrfK7etI66Trbqz3Wb+vSr1qQdXQhvANrRvxjeUbX21K3nShemr1js20zcrNAzVhNe1bzLas2/KhNqP2ep1/XctW/a2rt77ZJtrWv913e/MOgx0VO97vlOy8tSt4V2u9RX31btLugt2PGmIbur/mft24R3dPxZ6Pe6V7B/ZF7+tqdG9s3K+/v7IJbVI2jR5IOnDlm4Bv2pvtmne1cFoqDsJB5cEn36Z8e+NQ6KHOw9zDzd+Zf7f1COtIeSvSOr91rC2jbaA9ob3v6IyjnR1eHUe+t/9+7zHjY3XHNY9XnqCdKD3x+eSCk+OnZKeenU4/PdSZ3Hn3TPyZa11RXb1nQ8+ePxd07ky3X/fJ897nj13wvHD0Ivdi2yW3S609rj1HfnD94UivW2/rZffL7Vc8rnT0Tes70e/Tf/pqwNVz1/jXLl2feb3vxuwbt24m3Ry4Jbr1+Hb27Rd3Cu5M3F16j3iv/L7a/eoH+g/qf7T+sWXAbeD4YMBgz8NZD+8OCYee/pT/04fh0kfMR9UjRiONj50fHxsNGr3yZM6T4aeypxPPyn5W/3nrc6vn3/3i+0vPWPzY8Av5i8+/rnmp83Lvq6mvOscjxx+8znk98ab8rc7bfe+477rfx70fmSj8QP5Q89H6Y8en0E/3Pud8/vwv94Tz+4A5JREAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfcAgcQLxxUBNp/AAAQZ0lEQVR42u2be3QVVZbGv1N17829eRLyIKAEOiISEtPhJTJAYuyBDmhWjAEx4iAGBhxA4wABbVAMWUAeykMCM+HRTcBRWkNH2l5moS0LCCrQTkYeQWBQSCAIgYRXEpKbW/XNH5zS4noR7faPEeu31l0h4dSpvc+t/Z199jkFWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhY/H9D/MR9qfKnLj/00U71aqfJn9+HCkCR/Wk36ddsgyJ/1wF4fkDfqqm9/gPsUeTnVr6a2xlQfnxdI7zs0W7irzD17Ytb2WT7EeNv/r4ox1O3Quf2QP2pgt9utwfout4FQE8AVBSlnaRmfvAURQkg2RlAbwB9AThlW5L0GaiKojhJhgOIBqDa7XaPrusdPtr5kQwF0BVAAoBIABRCKDd5aFUhRDAAw57eAOwAhKIoupft3zoqhB1AqLwuHIBut9uFt02qqvqRDJR2dAEQJj/BAOjn56dqmma+xiaECAEQAWAggLsB6A6HQ2iaZggBhBAqgEAAnQB0kzaEmT4hAITT6VQ8Ho/HJAKKECJQtr8LwD1y/A1/vcdfEUIEyfZ9AcQbYvZ942Px88L2UwlJR0dH0EMPPbRj5syZPUeNGrXR7Xb/641xIwJ1XY9NSUlZm52dfW+XLl1w8uRJzJ8//+OGhoYJqqqe1TSt1Wsm9NN1PSIqKmr12rVrR5WUlHy1bdu2AQCumWc3IYRD1/UwVVXnFRQUTIuNjUVzczN2797dWFJSkq8oymZd15sAGAEnFEUJ1nX9nzIzM1dnZmZGh4SE4OTJk5g5c+Zf29vbp9pstrMej6fVOyhIhgAYU1hY+B+hoaGoqKg4XVlZea+XTULTNFdCQsLGiRMnPuR2u3UhBOV9eeDAAWXTpk095DUe6WsoyRE5OTlr0tLSAux2O/bs2cO5c+e+pijKUpIXSHaQVAGkvPLKK++6XK4OksJLCFlXV2cvKSlJBFAjhU+x2WwhHo9nUHp6+urMzMy7wsLCUF9fjxdffPHjxsbGiTab7WuPx9NiEutOuq4PyMjI+M+srKyYqKgoHD58GDNmzNjq8XhyVFU9b/q+LH7hBAEYu3PnTlZVVRFAGgCX6f/tAHoOHDjwa0p27txp/JO9e/f+QM7cipw9nfL3kQBKt2zZQpJ87rnn6mQmoHilw2EACs+cOUOSrK+vZ1NTE0nyo48+IoBpxswoBcMJ4Ndjx471kOTFixe5d+9ekqTH42H//v13A4jyzpAURfEH0H/OnDnthu1z5sw558MmFUCPWbNmnaMP3nrrLZoyDmP8Hl68eDFJ8siRI9/Yc+zYMQKYKdtAztrTrl27xptRXV1NAKMAOAyBBBA/Y8aMdpLs6Ojgxx9//E37+++//29yvFXppwvAwMcee8xjtDHsuXLlCqOjo//ia3wsfpkoALqFhoZuIckJEyackimm3dQmEMDUmpoakmRISMhhAHOHDx/eQJIbN24kgKEyMAHAFRMTs2XXrl1saWkhSZ0kp0+ffhrAr3wEW/S8efOukORLL72kA1gKYMPWrVtJkk899dRJAHeYrgsEsIQkjx8/TgDvAPjd448/3kaSb7zxBmUa7vC6z53BwcFbSHL9+vU6Sc6aNes8gF5ewWAH0PfVV18lSQL4DMBGIcQ6AKtcLleBFC2jXtFt8ODBe0iyoqKCAJYByC8qKmJDQwOzsrK+MAmqo1OnTveHhoa+GRkZ+XZkZOSWiIiIvzgcjk9mzpypkWRmZuZpmbYbGV4AgPnNzc1sa2sjgN0A5iQmJtaSZHl5OQHcb/K3s81mW0uSTU1NBFAFYFbfvn1Pk+Tbb79NAA8IIVzW42/hByA+Pz/fLR/2ZXIda05NI/z9/TeR5J49ewhgqlxTrtI0jY2NjQQw3zTLuWJiYjaUlJToS5Ys6fjkk080kwDEeAmADcA9GzZsIElGRUW9CyAWwLApU6Y0kOSKFSsog9QICGdERMTGsrIyZmVlEcC9AB4IDw/fTpLbtm0jgN94CUAnAJmVlZVcs2aNZ/LkyRdJcvbs2b4EwAkgZfPmzTxw4AABFAN4BkC6vFeUSewcAO5duXIlSTIhIaEawGMAxgKYAmAGgCS73e5vrKVk/yGythANYEhCQsIhkly+fDkBpKqqGmL6DgIALDKN/3yZpVWQZGVlJQE8aPI3KiMjo5okV61aRQAjAPQBMPfIkSN0u90EUCBtsPiFEwpgbn19PdetW2fM5N4zQ9ekpKQqkty0aRMBpMjiWM6JEydIkoqirJUFJ6iq6pAPVy8A6cZMehMBUACEuVyuFwG8HBwcPEIWx367ZMkSjSQXLVrUJouTRorrkAHdA8BdQogsAOsKCwtJkmPGjDkvMw2bDDo/ADEjRoz4XylyFbm5uY0mAbjLyyZ/AOOrq6tZVlbWsWDBgo69e/eyoqKCgwcPPg4gSQaoIRbp27dvN7KF+tLSUr28vJwFBQXtMpvpYRIM7+wrAkDeqVOnePbsWQIoNKfzpiXPg8uXLydJJicnNwF4f+nSpW6STEtLq5fjYwhk1wkTJtSQ5Ouvv04AqTKj+N2xY8dIkgEBAW/Ie1v8wncRegwZMmQvSfbr12+3Ua33WqPfOWbMmP0kWVpaSgCDZAqcfejQIWNZsEGKgvnh9gfQb9myZd8nAEJVVZtMkUNk8CcNHTq0liR1XWdYWNhmH1mJIme80OnTp18x1rp5eXkEsNJms92Fb7e/IgEsvHz5Mp999tkmAI/l5uZeMC0B7vEqqAYAyL106RJJsra2lpWVld+sucePH38ZQG+5NncBeOrgwYMkqbe3t/Po0aOsra011wAWyl0H7x0JJ4DE+fPnu0kyPT29DsDdUrBuyNKEEAkAdpw/f/6GeoEM8GUmfwEgPCIiopwkGxsbabPZPgOw6L777vvm4p49e26VGYjFLxUhhD+ApLKyMp44ccIoVnXybgbgzkcfffRzklyzZg0BDJYCMMmoCwQFBXkLgLGWvvcWAgBToSsKwNPTp09vMR7UuLi4rwH0lgU8c/Db5ezbeeTIkRWzZ8++aMxu+fn5BPCADBwHgP4LFy701NXVEUAJgAnPP/98kyxMNgHo53A4zH77BQQETMvPz7+Um5vbBuAlAFMSExPPmdbVL0qh8Acw8fDhw5SCchVAEYAVb775JknyhRdeaJYztHfxMwLAaqNwCGC2FArv8x0hAHKNLGPKlCme5OTk/Zs3bzb7O0wKiiG8KXl5ed8IxenTp0mSR48e1UmyW7duWywBuD2xyQcgFECgoih+8H1gyJgZV5Lkyy+/3CbTRIePtl2HDBmyw1QBHyGDdXZdXR1JUghRKkXBjOMHCoBdpr0L3nvvPZLkF198wejo6O0A4lVVDTb74HQ6AwD8Wq7Jh8rgGgDgQ13XjVR8qaxJuADMbmlpYXl5uV5UVNRWUFDgfv/993Vj/ZydnU1c37eHXML4S3viAcQqitJD2l104cIFY8lTKsXSBWBMVVWVcd9yed2A1NTUQ6Zl00CvLMMOoHdubm6zFIlWOf5+PsY/Kj09vdrU11QAwwGsv3jxIk21m2DZr10I0RXAuAcffPBgaWkpV69eTYfDcdiwUxY0w6xw+flX8L1xApjevXv3lREREaW6rofB93aPDUDQpEmTMgHgtddeqwBwEd/utZvpqK6uPgEAcXFxkA94NwB9unfvjrNnz4LklwDcf08iIqv66Zs2bXrl4YcfxooVKxAbG7uqrq5uAYA2TdOEqqpGYIi2tjbl6aeffu/YsWPv5uTk7JaC1wHg4Pnz542MwoVvTx+21dbWYvjw4WLixIl+2dnZ9lGjRgmSTE1NRUpKCkwFTGiaxtTU1OXTpk3707Bhw/6g67pDipnT4biuj7qut+Lbk3Vf1tTUXI9qu91Pjq1QFEUBgJaWFgBo8yGOQ8eNGxcAAOvXr/8QwBUfYygAKL169eoCABcuXACAWtn2hOGv0+kMNO1KiPDw8F4A4rZv3/7R1KlTR0+bNu1ht9u9r1+/fqitrQXJgwDarRC6/QjPzs4+QJIffPCB9/aQmSAA43ft2mW0e1QGoi8CAPyLsZccExNTC2BlRkbGRdOyYJCP2csBIN6UAZzCd7cBbQCijYp/dXU1ExMTz6SmptaMHj36f9LS0vYlJCRsl6mxIWSdu3fv/g5J7t+/nwC2AShMTk6+SJKff/45AWRLYbD7+fndAeDf5BJnLoCCyZMnt5JkdnZ2C4B/F0KEm1Pu+Pj4rST55ZdfEsBWAK+mpaVdMo3raDn7KwDuSEpK+m+S3LBhAwG8DuCtHTt2UBbpjgC408vvcFVV15HkuXPnjMp+p5uMf0RcXNyHJNnQ0EBVVfcCWBQXF3fG+Jv0yxABPwB5LS0tRmFxN4BlTzzxxGWSXLx4sS5F3GGFy+1Hp5SUlJq6ujoWFxdTpsZ2H+0iIyMj/0iSWVlZX5mr5jfJFroPGzasxlhTnjp1iiTZ3NxMl8tlrCd9pfa9SkpKSJI5OTmnZOageLUZZqxvfVFWVkZcPwdgNwnSCKPqb17jkmR8fPzfZMDZ5CRsFBmNI7h95s2b1yhT7/MAYmStwCx4vy0uLqa3v5qmEcCfvSr1QQAeXb16NY3Cm3HQ55133iGAp+SxZTNhKSkpfzUddkrFjYevzAQCeGjp0qXfsYckY2NjTwD4leGDLCL2HTdunNtoY+zWSHFcIHdsFCtcfuZ1vO9Eqs3m7/F47sb1k2qX/f3997W2tl7BjWfpBYDOzzzzzIVJkyZh0KBBCwEsB3AJvl9AETabLcDj8dwRFRW1ctasWb8JCgpSzp07d62wsPC/Wltb8xRFadR1/ZqPXYbgAQMGbI2Pjw/+6quv9ldVVT0r01ezuPRJSUn5Y9euXXVd11WzDaqq6kePHm3+7LPPRgO4KlNuxWazhXo8nuTk5OSXMjIyEl0uFxoaGtqKior+dPXq1VdUVT0jj7r68ieoT58+vx8yZMjdx48fP1JVVTVF9m20VW02WyfZf97YsWPjXS4X6urqWvPy8jYCWCyEuEDS8FdVFKWzruv//OSTTy5OTk7uqWkaPv3007qysrJ8RVH+LI8ym8/rB3Tu3HnRI488knLo0KG2ffv2ZQI4C98vP6mqqoZqmpaclpa2cOTIkX39/f3R0NDQUVxc/G5TU9PLqqrWa5rWLH1QVFUN0TStX1JSUvH48eP7BwYG4uDBg1cKCgpeBbBe2u+2Qug2EwD5N5sMPuNtMe8XP4TT6Qxoa2sbIGeXvUKIK7d4IISiKC5d1wPljOfA9bPwzYqiXNV13dd6Uqiq6qdpml2mpe02m63d4/G4vcTF5fF47LJf71nJA6BZVVW3pmntuPHlmAD5wk6Q9NnbHp9vHaqq6tA0zU/64PZhk1FfCZB9G/23ALiqKEqzD39tpvbGUqoFwFUhRLP3yzpCCDtJpxyXDulfG27+pqRR3DXsUWVd4Yq0x/taVQjhIhksC8L+ABpM9ljBf5sKwI8pIBr75L5E4vvu+UNeG/a+hv+AL7yFH8qPtOfHjtOP6V/Bja8D6z/B2Nys/1u9Xv33tLf4GfF/LC4GCJwByWIAAAAASUVORK5CYII=",
cc._loaderImage = "data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAAAlAAD/4QMpaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjAtYzA2MCA2MS4xMzQ3NzcsIDIwMTAvMDIvMTItMTc6MzI6MDAgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjM4MDBEMDY2QTU1MjExRTFBQTAzQjEzMUNFNzMxRkQwIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjM4MDBEMDY1QTU1MjExRTFBQTAzQjEzMUNFNzMxRkQwIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzUgV2luZG93cyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkU2RTk0OEM4OERCNDExRTE5NEUyRkE3M0M3QkE1NTlEIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkU2RTk0OEM5OERCNDExRTE5NEUyRkE3M0M3QkE1NTlEIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+/+4ADkFkb2JlAGTAAAAAAf/bAIQADQkJCQoJDQoKDRMMCwwTFhENDREWGhUVFhUVGhkUFhUVFhQZGR0fIB8dGScnKionJzk4ODg5QEBAQEBAQEBAQAEODAwOEA4RDw8RFA4RDhQVERISERUfFRUXFRUfKB0ZGRkZHSgjJiAgICYjLCwoKCwsNzc1NzdAQEBAQEBAQEBA/8AAEQgAyACgAwEiAAIRAQMRAf/EALAAAAEFAQEAAAAAAAAAAAAAAAQAAgMFBgcBAQEAAwEBAAAAAAAAAAAAAAAAAQMEAgUQAAIBAgIEBwoLBgQGAwAAAAECAwAEEQUhMRIGQVFxsTITFGGBwdEiQlKSMzWRoeFicqKyI1NzFYJjJDQWB9KjVCbxwkNkJWXik3QRAAIBAgMFBQcDBQEAAAAAAAABAhEDIRIEMUFRcTJhwVIUBZGhsSJyEzOB0ULhYpIjUxX/2gAMAwEAAhEDEQA/AMJSpUqAVKlXuFAeUq9wpUB5XuFe4V6ooDzZHDox0CnGMinzwl7Z8NajaHeoO3vmTBZBtp9YUIqTEV5ROxHKnWRnaU8VRMhFBUjpV7hSoSeUq9pUB5Sr2lhQHlKvcK8oBV7hSFSRrtaKAZs07YNPM1pG2xJIAw1jSeandry/8X4m8VCKkWwaWwam7Xl/4v1W8VLtmX/i/VbxUoKkWwakSM407tmX/i/VbxUmzGwjQsjdY41IARie/U0IbZO0kNtCXnOCkEBeFu4KI3Bs7DNb27ya+jDx3kJeEnpJJEcQVbWDsk17u5urd591ucZkWhym2Vnd9RkCDEpFxDRpbw0bunu5mlp2De2FMLYXOD2wB2xbOeraUcYGJ72mlSUiqzzdzMd3Z3mixltA2yzcK/NlHM1DQyRXce1HocdNOEfJXZ88y9ZojOqhiBszIRiHQ8Y4cK5TvHuzLljHNMqxNoDjLFraHHnjPxcNCGVbxEUzYNTx5jZSxhpW6qTzlwJ+DCvO2Zf+L9VvFSgqyHYNLYNTdssPxfibxUu15f8Ai/VPiqCakOwa82DU/a8v/F+JvFTDdWPBL8R8VKCvYRYV5UzoMAy6QdIIqI0B4KJtxiRQwou16QoGUkntH5Tz0RbZbmF2hktraSVBo2lUkY8tDye0flPPXTslVUyiyVRsjqUOA4yMT8dW2ram2m6UVTNq9S7EIyUVJydMTn/6DnP+im9Wl+g5z/opvVrpteEhQWY4AaSTwAVf5WPiZh/9S5/zj7zltzlmYWkfWXNvJDGTgGcYDHirR7i7mSbwXParsFMrgb7w6jKw/wCmnc9I14kF3vpvCljbMyWMOJL4aEiB8qU/ObUK7HYWVrl1pFZWiCOCBQqKOLjPGTrNZZqKbUXVHq2nNwTuJRk1VpbgXN8s7Rk5ym0UQQzhIG2NAjhxHWbI+gCBVjBBFbwxwQqEiiUJGg1BVGAFe7dV28WYLYZFmF2Th1UD7JGjymGyn1iK5OyzIBGB1HgrLZhamzumQAGJwSqnSCh1q3GOCodxt4cxurdcpzuN4cyhiWaF5Bg09udUmnWw1H/jV9nFuJ7Quo+8h8peThFA+047vduyMtk7fYqTl07YFdfUufMPzT5p71UdtlmYXaGS2t3mQHAsgxANdadYJopLe4QS2867EsZ4QfCNYrCFbjdDPmgkYyWFxgVf04ifJf6ScNdRUW1XBb6FU5TjF5EpSSrGu/s5lN+g5z/opvVpfoOc/wCim9WtdHnatvObJXDW7xLGhB8nrPaY9/HCr+tEdPCVaSeDoYLnqF63lzW4/PFSW3ecxbI84VSzWUwUaSdg0DXXK5nvAipnd6qgKvWnQO7pri9ZUEmm3Vl2j1kr8pRlFRyquBNZjGxQ/S56Y1S2fu9OVueon11Szahoou06QoQUXadIVCD2FJJ7R+U89dMydv8Axdn+TH9muZye0flPPXQstlK5Tbka1gUjlC1q0vVLkeb6r+O3Tx9xcY1nt8c0NrZCyiOE1108NYjGv1joo7Js1jzKyScYLIvkzL6LDwHXVJksH9Sb49dKNq0tj1jA6uriOCL+02FWX7iVtZX1/AzaHTyeoauKn2MX9W79zebiZCuR5MjSrhfXuEtwTrUeZH+yNfdrRNcxI6IzhXlJEak6WIGJ2Rw4ChWnChndtlVBLMdQA0k1gbXNMzzDfDLs6mjaPKppJbWwJ1bOwwxw43OnHh71YT3DpfWUJmFlb5jHHDdeXBHIsrRea5TSqvxqG04cNN62vetoCS4tre5mgnkGE9q+3DKOkuI2WX6LDQRRHWDh1UCtwj7QRg2wdl8Djgw1qe7XvW0BQ3kfZ7mSLgU+T9E6RVbnuVrnWVSWqj+Lt8ZbRuHEdKPkYVcZ2MJY5fSGyeVar45+rkWQHAqccalPE5km1htWK5nK4Wnt5FuUBUwOMG4nGkA/BXUrW4S6torlOjMgcd/xVn7rLo7zKs0uEjCNeSvdwoBhgsZxX1l2j36k3Lu+uyprdj5Vs5A+i/lD48a0aaVJOPi7jB6lbzWozpjB48pf1NDXNN4vfl7+Z4BXS65pvF78vfzPAK71XTHmZ/S/yT+jvJ7L3fHytz1E+upbL+Qj5W56jfXWRnsIYKLtekKEFGWvSFQgyjk9o/Keet3YthlMP/5x9msJJ7R+U89biyb/AMXEv7gD6tadL1T+kwepRrC39ZkLDMbiwMvUHRPG0bjlGg8ore/23sxBldxfMPLupNhT8yL/AORNZbdzJ484scytxgLqJY5LZj6Q2sV5G1Vud1mjjyG0ij0NEGSZToKyhjtqw4waztuiXA3qKTbSxltfGhbZlE95ZtZqxVbgiOZhrER9ph3Svk9+pJILZ4Y4DGBFCUMKjRsGPobPFhUfW0NJmljE2xJcIrcI2vFUEln1lRXd6lrazXT9GCNpD+yNqoI7mOVduNw6nzlOIoPOUa6yye1XXcbMR5GdQ3xY0BSbj31/FcTQZirJ+q431q7anbHCTZ72Bw7lbPrKBMcBWNNgbMBBh+bsjBdni0VJ1lARZs6yWiupxCuMDy6KpS2IwOo6DTr3Mre3e5tZZVUM4ZBjqOOJoWO4jkXajcOOMHGgDISvWIrdAkKR80+TzVl908bPPL3LzxOuHdifxVfiTAg92qI/w+/8gGgSyN/mR7XPVlp0lF/3L3mbVKtu5Hjbk/8AHE2Fc03i9+Xv5ngFdKNc13i9+Xv5ngFaNV0x5nn+l/kn9HeEWXu+PlbnqJ9dS2Xu9OVueon11kZ7CGCjLXpCgxRlr0hUIPYUcntH5Tz1s8vb+Bt1/dqPirGSe0flPPWusG/g4Py15q06XqlyMWvVYQ+ruI9xJOqzO9hOto/sP8tbGOFIrmWeM7IuMDMnAXXQJOUjQeOsJk0nY96ip0CYunrjaHx1t+srPJUbXBm2LrFPikwTOb+T+VhbZxGMrDXp83x1QSy2tucJpUjPETp+Cn5/ftaRvKvtp3Kx48HG3erHMzOxZiWZtLMdJNQSbbL71Vk6yynViOkqnEEfOWtPbXi3EQkGg6mXiNckjeSJxJGxR10qw0GtxuxmvbImD4CZMFlA4fRfv0BqesqqzTMZNMEDbIHtHH2QeCiZJSqMQdOGiue53mz3czQwsRbIcNHnkec3c4qAMuriz68gTIToxwOOnlp0MjxMJYW741Gs3RVldtbygE/dMcHX/moDaxTiWNZB53B3arb8/wC+4SOF4sf/AKxU9kcBsfOGHfoUHtG/RbzY5Die5HHhXdvavqiZ9Q8Jdlq4/gbKua7xe/L38zwCuhpf2Uk/Zo50kmwJKIdogDjw1VzzeL35e/meAVp1LTgqY4nn+mRauzqmqwrjzCLL3fHytz1E+upLL+Qj5W56jfXWRnroYKLtekKEFF2vSFQg9hSSe0flPPWosm/hIfoLzVl5PaPynnrRWb/w0X0F5q06XqlyM2sVYx5gmbFre/t71NY2T+0h8VbSO5SWNJUOKSAMp7jDGspmMPaLRlXS6eWve1/FRO7WYdbZm1Y/eW/R7qHxHRXGojlm3ulid6aVbaW+OALvgCLq2Hm9WxHKWqjhj6xsK1e8dm15l4niG1LZkswGsxtrPeOmsvayBJA1VItlWjptLuTdPMo7LtjRDq9naK4+WF9IrUW7BaHOljGqVHB7w2hzVoZt87d8vaNYSLl02CcRsDEbJbj71Uu7UBkvJ7/D7q2QoDxySaAO8MTXdxRVMpRp5XZOWdF/ms7R5XdyKfKWJsO/5PhrG5XlNxmEywW6bTnTxAAcJNbGSMXkM1pjgbiNo1PziPJ+Os7u7m/6ReM00ZOgxSpqYYHT3wRXMKN4ll9zUG4bQfNshu8sZVuEA2hirA4qe/VOwwrVbzbww5mI44UKRRYkbWG0S3JWctbd7u5WFfOOLHiUdJqmaipfLsIsObhWe001lMkMVvJNjhghIALMcBxCs7fxXQmkupx1bXDswGPlaTidVaEyKNXkoo4eBV+Sq7L7Vs9zcBgeyQ4GQ/MB1crmoim2orezqcowTuSeEY48jQ7oZX2PLzdyLhNd6RjrEY6I7+uspvH78vfzPAK6UAAAFGAGgAcArmu8Xvy9/M8ArTfio24RW5nnaG67uou3H/KPuqT2X8hHytz1G+upLL3enK3PUb66ys9RDBRdr0hQgou06QqEGUkntH5Tz1e238vF9BeaqKT2j8p56vbb+Xi+gvNWjTdUuRn1XTHmTh8KrJTJlt8t1CPIY44cGnpJVjTJYkmjaN9Ib4u7V923njTethRauZJV3PaW1rfLIiXEDYg6R4VYc9CXW7thfOZbKdbGZtLW8uPVY/u3GrkNUkM9zlcxUjbhfWOA90cRq4gv4LhdqN+VToNYWmnRm9NNVWNTyHc6VWBv8wt4YeHqm6xyPmroq1Z7WGFLSxTq7WLSuPSdjrkfumq5yHXDUeA92oO2SKpVumNAaoJLMXH3myp0rpJ4uKhc3tbDM5BMri1zAj79j7KTiY8TcdBpcsith0286o+sPCagEX9Pzg4zXUCp6QYse8oouCG3tk6m1BYv05W6T+IdyolxbHDAAa2OgDlNCz3ryN2WxBd5PJMg1t81eId2ukqnLlTBbfcuY+9uJLiRcvtPvHdsHK+cfRHcHDWsyawjyy0WBcDI3lTP6TeIcFV+S5OmXx9bJg1048o8Cj0V8Jq2DVu09nL80up7OxHi+oal3P8AXB/IsZS8T/YOV65zvCcc7vfzPAK3ivWCz445zeH954BXOr6I8yfSfyz+jvCLP3fHytz1G+upLP3fHytz1E+usbPaQ0UXadIUIKLtekKhB7Ckk9o/Keer22/l4/oLzVRSe0flPPV7b/y8X0F5q0abqlyM+q6Y8yQsBTDMor1o8aiaE1pbluMqS3sbLLHIhSRQyngqukhaJ9uBjo+H5aOa3ao2t34qouRlLajTalGP8v0IY8ylXQ+PKPFU/bYXOLPge6CKia0LaxTOxHu1Q7cuBd9yPEJ7TbjXKO8CajbMIF6CNIeNvJHjqIWJ7tSpYkalqVblwIdyG+RGXur0hXYJFxal+Dhq5y3slkv3Y2pD0pTr+QUClpJRUdo9XW4OLrTHtM16cZLLWkeC7y4jvlNEpcRtw1Ux27Ci448NZrTFy3nn3IQWxlgGrDZ3pza7/M8ArZo+ArF5171uvp+CqdV0R5l/psUrs2vB3hdl7vTlbnqJ9dS2Xu+PlbnqJ9dY2eshooq16QoQUXa9IVCD2FLJ7RuU89WNtmUSQqkgYMgw0accKrpPaPynnrZWG4Vi+VWmY5tnMWXG+XrIYnA0rhj0mdcTgdNdwnKDqjmduM1SRR/qlr8/4KX6pa8T/BVzDuLZXudRZblmbxXcPUNPc3KqCIwrbOzgrHEnHjoyD+3eSXkht7DeKG4umDGOJVUklfouThXfmbnZ7Cvy1vt9pmv1W1+d8FL9VteJvgq5yrcOGfLmzHN80iyyETPbptAEFo2ZG8pmUa1OFNn3Ky6W/sbDKM5hv5bx2WTZA+7RF2y52WOPJTzE+z2Dy1vt9pT/AKpacTerS/U7Tib1a04/t7kDXPY03jhN0W6sQ7K7W3q2dnrMccaDy/8At80kuZfqWYxWNtlcvUPPhiGYhWDeUy7IwYU8xPs9g8tb7faUn6pacTerTxm9oOBvVq3v9z927aynuId44LiWKNnjhAXF2UYhRg516qpsryjLr21665zFLSTaK9U2GOA87SwqY37knRU+BzOzags0s1Oyr+BKM6sxwP6tSDPLMen6vy0rvdm3Sxlu7K/S7WDDrFUDUTxgnTU826eXW7KlxmqQuwDBXUKcD+1Xee/wXuKX5XDGWLapSVcOyhEM/seJ/V+WnjeGx4pPV+Wkm6kKZlFay3Jlt7iFpYZY8ASVK6DjtDDA0f8A0Tl340/1f8Ndx8xJVWXB0KbktFFpNzdVXAC/qOwA0CQni2flrO3Vwbm5lnI2TKxbDirX/wBE5d+NcfV/wVR7xZPa5U9utvI8nWhmbbw0YEAYYAVxfhfy5rlKR4Fulu6X7mW1mzT8S4Yis/5CPlbnqJ9dSWfu9OVueon11mZvQ2i7XpChKKtekKhBlNJ7R+U89bDfGTb3a3ZX0Lcj6kdY+T2j8p560288m1kWQr6MJ+ylSAr+2cnV5renjs3H1loX+3j9XvbbtxLN9lqW4UnV5jdnjtXHxihtyZNjeSBu5J9k1BJe7xy7W5CJ/wCzuD/mTVTf2+fq97LJuLrPsNRueS7W6aJ/38x+vLVXuY+xvHaNxbf2GoCezf8A36j/APsSf8w1sLnqczTefJluYoLm5uo5F61sBshItP1cNFYe1f8A3ir/APfE/wCZUe9bB94r5jwuPsrQFhmG4l/Z2M17HdW90tuu3IkTHaCjWdIw0VVZdks9/C06yJFEp2dp+E1bbqybGTZ8vpQD7L1XRv8A7blT96Oda7tpNuuNE37Cq9KSisjyuUoxrStKllHbLlWTXsMs8chuSuwEPDqwoLe5y+YRE/gLzmqRekvKKtd4327yM/ulHxmrHJStySWVRyrjxKI2XC/CTlnlPPKTpTdFbP0L1bgrf5Lp0G3dPhQHwV0S1lzBsns3sESR8Crh9WAJGjSOKuU3E+zdZQ3oJh8IArdZXFDmOTpHa3i2+YrI2KtKy4ricBsBuHHgFXSo440+Wa2qqxjvM9uMoy+WvzWpLCWWWE28HxL6e43ojgkeSCBY1Ri5BGIUDT51cl3vm276BBqSEH4WbxV0tlkyXJcxTMb+OW6uY9mGHrCzDQwwAbTp2uKuTZ9N1uYsfRRR8WPhrm419mSSjRyiqxVK7y23B/ftuTm2oSdJyzNVw3BFn7vTlbnqF9dS2fu9OVueon11lZuQ2iLdsGFD05H2dNQGV0ntG5Tz1dWm9N1b2kVq8EVwsI2UaQaQOKhmitZGLOmk68DhSFvY+gfWNSAg7z3Qvo7yKCKIohiaNR5LKxx8qpxvjcqS0VpbxvwOAcRQPZ7D0G9Y0uz2HoH1jUCpLY7zXlpbm3eKO5QuzjrBqZji3x17PvNcyT288VvDBJbMWUovS2hslW7mFQ9nsPQPrGl2ew9A+saCod/WNxtbYsrfb17WBxx5ddD2281xC88klvDcSXEnWuzrqOGGC9zRUPZ7D0G9Y0uzWHoH1jQVCLreq6ntZbaO3it1mGy7RjTs1X2mYy20ZiCq8ZOODcdEdmsPQb1jS7PYegfWNdJuLqnQiSUlRqpFLmryxtH1Ma7Qw2gNNPOdSt0oI27p007s9h6B9Y0uz2HoH1jXX3Z+I4+1b8IJdX89xLHKQFMXQUahpxoiPN5P+onfU+A0/s9h6DesaXZ7D0D6xpG7OLbUtu0StW5JJx2bBsmbtiSiEk+cxoCWWSaVpZOk2vDVo0VYdnsPQb1jSNvZcCH1jSd2c+p1XAmFqEOmOPEfaH+BQd1ueo211IzrgFUYKNAAqI1WztCpUqVCRUqVKgFSpUqAVKlSoBUqVKgFSpUqAVKlSoBUqVKgFSpUqAVKlSoD/9k=";
var cc = cc || {}
  , ClassManager = {
    id: 0 | 998 * Math.random(),
    instanceId: 0 | 998 * Math.random(),
    getNewID: function() {
        return this.id++
    },
    getNewInstanceId: function() {
        return this.instanceId++
    }
};
switch (function() {
    var t = /\b_super\b/;
    cc.Class = function() {}
    ,
    cc.Class.extend = function(e) {
        function i() {
            this.__instanceId = ClassManager.getNewInstanceId(),
            this.ctor && this.ctor.apply(this, arguments)
        }
        var n = this.prototype
          , r = Object.create(n)
          , c = ClassManager.getNewID();
        ClassManager[c] = n;
        var s = {
            writable: !0,
            enumerable: !1,
            configurable: !0
        };
        r.__instanceId = null,
        i.id = c,
        s.value = c,
        Object.defineProperty(r, "__pid", s),
        i.prototype = r,
        s.value = i,
        Object.defineProperty(i.prototype, "constructor", s),
        this.__getters__ && (i.__getters__ = cc.clone(this.__getters__)),
        this.__setters__ && (i.__setters__ = cc.clone(this.__setters__));
        for (var c = 0, o = arguments.length; c < o; ++c) {
            var a, h = arguments[c];
            for (a in h) {
                var l = "function" == typeof h[a]
                  , u = "function" == typeof n[a]
                  , d = t.test(h[a]);
                if (l && u && d ? (s.value = function(t, e) {
                    return function() {
                        var i = this._super;
                        this._super = n[t];
                        var r = e.apply(this, arguments);
                        return this._super = i,
                        r
                    }
                }(a, h[a]),
                Object.defineProperty(r, a, s)) : l ? (s.value = h[a],
                Object.defineProperty(r, a, s)) : r[a] = h[a],
                l) {
                    var _, p;
                    if (this.__getters__ && this.__getters__[a]) {
                        var f, l = this.__getters__[a];
                        for (f in this.__setters__)
                            if (this.__setters__[f] === l) {
                                p = f;
                                break
                            }
                        cc.defineGetterSetter(r, l, h[a], h[p] ? h[p] : r[p], a, p)
                    }
                    if (this.__setters__ && this.__setters__[a]) {
                        l = this.__setters__[a];
                        for (f in this.__getters__)
                            if (this.__getters__[f] === l) {
                                _ = f;
                                break
                            }
                        cc.defineGetterSetter(r, l, h[_] ? h[_] : r[_], h[a], _, a)
                    }
                }
            }
        }
        return i.extend = cc.Class.extend,
        i.implement = function(t) {
            for (var e in t)
                r[e] = t[e]
        }
        ,
        i
    }
}(),
cc.defineGetterSetter = function(t, e, i, n, r, c) {
    if (t.__defineGetter__)
        i && t.__defineGetter__(e, i),
        n && t.__defineSetter__(e, n);
    else {
        if (!Object.defineProperty)
            throw Error("browser does not support getters");
        var s = {
            enumerable: !1,
            configurable: !0
        };
        i && (s.get = i),
        n && (s.set = n),
        Object.defineProperty(t, e, s)
    }
    if (!r && !c)
        for (var s = null != i, o = void 0 != n, a = Object.getOwnPropertyNames(t), h = 0; h < a.length; h++) {
            var l = a[h];
            if ((t.__lookupGetter__ ? !t.__lookupGetter__(l) : !Object.getOwnPropertyDescriptor(t, l)) && "function" == typeof t[l]) {
                var u = t[l];
                if (s && u === i && (r = l,
                !o || c))
                    break;
                if (o && u === n && (c = l,
                !s || r))
                    break
            }
        }
    t = t.constructor,
    r && (t.__getters__ || (t.__getters__ = {}),
    t.__getters__[r] = e),
    c && (t.__setters__ || (t.__setters__ = {}),
    t.__setters__[c] = e)
}
,
cc.clone = function(t) {
    var e, i = t.constructor ? new t.constructor : {};
    for (e in t) {
        var n = t[e];
        i[e] = "object" != typeof n || !n || n instanceof cc.Node || n instanceof HTMLElement ? n : cc.clone(n)
    }
    return i
}
,
cc.inject = function(t, e) {
    for (var i in t)
        e[i] = t[i]
}
,
cc = cc || {},
cc._tmp = cc._tmp || {},
cc.associateWithNative = function(t, e) {}
,
cc.KEY = {
    none: 0,
    back: 6,
    menu: 18,
    backspace: 8,
    tab: 9,
    enter: 13,
    shift: 16,
    ctrl: 17,
    alt: 18,
    pause: 19,
    capslock: 20,
    escape: 27,
    space: 32,
    pageup: 33,
    pagedown: 34,
    end: 35,
    home: 36,
    left: 37,
    up: 38,
    right: 39,
    down: 40,
    select: 41,
    insert: 45,
    Delete: 46,
    0: 48,
    1: 49,
    2: 50,
    3: 51,
    4: 52,
    5: 53,
    6: 54,
    7: 55,
    8: 56,
    9: 57,
    a: 65,
    b: 66,
    c: 67,
    d: 68,
    e: 69,
    f: 70,
    g: 71,
    h: 72,
    i: 73,
    j: 74,
    k: 75,
    l: 76,
    m: 77,
    n: 78,
    o: 79,
    p: 80,
    q: 81,
    r: 82,
    s: 83,
    t: 84,
    u: 85,
    v: 86,
    w: 87,
    x: 88,
    y: 89,
    z: 90,
    num0: 96,
    num1: 97,
    num2: 98,
    num3: 99,
    num4: 100,
    num5: 101,
    num6: 102,
    num7: 103,
    num8: 104,
    num9: 105,
    "*": 106,
    "+": 107,
    "-": 109,
    numdel: 110,
    "/": 111,
    f1: 112,
    f2: 113,
    f3: 114,
    f4: 115,
    f5: 116,
    f6: 117,
    f7: 118,
    f8: 119,
    f9: 120,
    f10: 121,
    f11: 122,
    f12: 123,
    numlock: 144,
    scrolllock: 145,
    ";": 186,
    semicolon: 186,
    equal: 187,
    "=": 187,
    ",": 188,
    comma: 188,
    dash: 189,
    ".": 190,
    period: 190,
    forwardslash: 191,
    grave: 192,
    "[": 219,
    openbracket: 219,
    backslash: 220,
    "]": 221,
    closebracket: 221,
    quote: 222,
    dpadLeft: 1e3,
    dpadRight: 1001,
    dpadUp: 1003,
    dpadDown: 1004,
    dpadCenter: 1005
},
cc.FMT_JPG = 0,
cc.FMT_PNG = 1,
cc.FMT_TIFF = 2,
cc.FMT_RAWDATA = 3,
cc.FMT_WEBP = 4,
cc.FMT_UNKNOWN = 5,
cc.getImageFormatByData = function(t) {
    return 8 < t.length && 137 === t[0] && 80 === t[1] && 78 === t[2] && 71 === t[3] && 13 === t[4] && 10 === t[5] && 26 === t[6] && 10 === t[7] ? cc.FMT_PNG : 2 < t.length && (73 === t[0] && 73 === t[1] || 77 === t[0] && 77 === t[1] || 255 === t[0] && 216 === t[1]) ? cc.FMT_TIFF : cc.FMT_UNKNOWN
}
,
cc.inherits = function(t, e) {
    function i() {}
    i.prototype = e.prototype,
    t.superClass_ = e.prototype,
    t.prototype = new i,
    t.prototype.constructor = t
}
,
cc.base = function(t, e, i) {
    var n = arguments.callee.caller;
    if (n.superClass_)
        return ret = n.superClass_.constructor.apply(t, Array.prototype.slice.call(arguments, 1));
    for (var r = Array.prototype.slice.call(arguments, 2), c = !1, s = t.constructor; s; s = s.superClass_ && s.superClass_.constructor)
        if (s.prototype[e] === n)
            c = !0;
        else if (c)
            return s.prototype[e].apply(t, r);
    if (t[e] === n)
        return t.constructor.prototype[e].apply(t, r);
    throw Error("cc.base called from a method of one name to a method of a different name")
}
,
cc.Point = function(t, e) {
    this.x = t || 0,
    this.y = e || 0
}
,
cc.p = function(t, e) {
    return void 0 === t ? {
        x: 0,
        y: 0
    } : void 0 === e ? {
        x: t.x,
        y: t.y
    } : {
        x: t,
        y: e
    }
}
,
cc.pointEqualToPoint = function(t, e) {
    return t && e && t.x === e.x && t.y === e.y
}
,
cc.Size = function(t, e) {
    this.width = t || 0,
    this.height = e || 0
}
,
cc.size = function(t, e) {
    return void 0 === t ? {
        width: 0,
        height: 0
    } : void 0 === e ? {
        width: t.width,
        height: t.height
    } : {
        width: t,
        height: e
    }
}
,
cc.sizeEqualToSize = function(t, e) {
    return t && e && t.width === e.width && t.height === e.height
}
,
cc.Rect = function(t, e, i, n) {
    this.x = t || 0,
    this.y = e || 0,
    this.width = i || 0,
    this.height = n || 0
}
,
cc.rect = function(t, e, i, n) {
    return void 0 === t ? {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    } : void 0 === e ? {
        x: t.x,
        y: t.y,
        width: t.width,
        height: t.height
    } : {
        x: t,
        y: e,
        width: i,
        height: n
    }
}
,
cc.rectEqualToRect = function(t, e) {
    return t && e && t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height
}
,
cc._rectEqualToZero = function(t) {
    return t && 0 === t.x && 0 === t.y && 0 === t.width && 0 === t.height
}
,
cc.rectContainsRect = function(t, e) {
    return !(!t || !e) && !(t.x >= e.x || t.y >= e.y || t.x + t.width <= e.x + e.width || t.y + t.height <= e.y + e.height)
}
,
cc.rectGetMaxX = function(t) {
    return t.x + t.width
}
,
cc.rectGetMidX = function(t) {
    return t.x + t.width / 2
}
,
cc.rectGetMinX = function(t) {
    return t.x
}
,
cc.rectGetMaxY = function(t) {
    return t.y + t.height
}
,
cc.rectGetMidY = function(t) {
    return t.y + t.height / 2
}
,
cc.rectGetMinY = function(t) {
    return t.y
}
,
cc.rectContainsPoint = function(t, e) {
    return e.x >= cc.rectGetMinX(t) && e.x <= cc.rectGetMaxX(t) && e.y >= cc.rectGetMinY(t) && e.y <= cc.rectGetMaxY(t)
}
,
cc.rectIntersectsRect = function(t, e) {
    var i = t.y + t.height
      , n = e.x + e.width
      , r = e.y + e.height;
    return !(t.x + t.width < e.x || n < t.x || i < e.y || r < t.y)
}
,
cc.rectOverlapsRect = function(t, e) {
    return !(t.x + t.width < e.x || e.x + e.width < t.x || t.y + t.height < e.y || e.y + e.height < t.y)
}
,
cc.rectUnion = function(t, e) {
    var i = cc.rect(0, 0, 0, 0);
    return i.x = Math.min(t.x, e.x),
    i.y = Math.min(t.y, e.y),
    i.width = Math.max(t.x + t.width, e.x + e.width) - i.x,
    i.height = Math.max(t.y + t.height, e.y + e.height) - i.y,
    i
}
,
cc.rectIntersection = function(t, e) {
    var i = cc.rect(Math.max(cc.rectGetMinX(t), cc.rectGetMinX(e)), Math.max(cc.rectGetMinY(t), cc.rectGetMinY(e)), 0, 0);
    return i.width = Math.min(cc.rectGetMaxX(t), cc.rectGetMaxX(e)) - cc.rectGetMinX(i),
    i.height = Math.min(cc.rectGetMaxY(t), cc.rectGetMaxY(e)) - cc.rectGetMinY(i),
    i
}
,
cc.SAXParser = cc.Class.extend({
    _parser: null,
    _isSupportDOMParser: null,
    ctor: function() {
        window.DOMParser ? (this._isSupportDOMParser = !0,
        this._parser = new DOMParser) : this._isSupportDOMParser = !1
    },
    parse: function(t) {
        return this._parseXML(t)
    },
    _parseXML: function(t) {
        var e;
        return this._isSupportDOMParser ? e = this._parser.parseFromString(t, "text/xml") : (e = new ActiveXObject("Microsoft.XMLDOM"),
        e.async = "false",
        e.loadXML(t)),
        e
    }
}),
cc.PlistParser = cc.SAXParser.extend({
    parse: function(t) {
        if (t = this._parseXML(t).documentElement,
        "plist" !== t.tagName)
            return cc.warn("Not a plist file!"),
            {};
        for (var e = null, i = 0, n = t.childNodes.length; i < n && (e = t.childNodes[i],
        1 !== e.nodeType); i++)
            ;
        return this._parseNode(e)
    },
    _parseNode: function(t) {
        var e = null
          , i = t.tagName;
        if ("dict" === i)
            e = this._parseDict(t);
        else if ("array" === i)
            e = this._parseArray(t);
        else if ("string" === i)
            if (1 === t.childNodes.length)
                e = t.firstChild.nodeValue;
            else
                for (e = "",
                i = 0; i < t.childNodes.length; i++)
                    e += t.childNodes[i].nodeValue;
        else
            "false" === i ? e = !1 : "true" === i ? e = !0 : "real" === i ? e = parseFloat(t.firstChild.nodeValue) : "integer" === i && (e = parseInt(t.firstChild.nodeValue, 10));
        return e
    },
    _parseArray: function(t) {
        for (var e = [], i = 0, n = t.childNodes.length; i < n; i++) {
            var r = t.childNodes[i];
            1 === r.nodeType && e.push(this._parseNode(r))
        }
        return e
    },
    _parseDict: function(t) {
        for (var e = {}, i = null, n = 0, r = t.childNodes.length; n < r; n++) {
            var c = t.childNodes[n];
            1 === c.nodeType && ("key" === c.tagName ? i = c.firstChild.nodeValue : e[i] = this._parseNode(c))
        }
        return e
    }
}),
cc.saxParser = new cc.SAXParser,
cc.plistParser = new cc.PlistParser,
cc._txtLoader = {
    load: function(t, e, i, n) {
        cc.loader.loadTxt(t, n)
    }
},
cc.loader.register(["txt", "xml", "vsh", "fsh", "atlas"], cc._txtLoader),
cc._jsonLoader = {
    load: function(t, e, i, n) {
        cc.loader.loadJson(t, n)
    }
},
cc.loader.register(["json", "ExportJson"], cc._jsonLoader),
cc._jsLoader = {
    load: function(t, e, i, n) {
        cc.loader.loadJs(t, n)
    }
},
cc.loader.register(["js"], cc._jsLoader),
cc._imgLoader = {
    load: function(t, e, i, n) {
        cc.loader.cache[e] = cc.loader.loadImg(t, function(t, i) {
            return t ? n(t) : (cc.textureCache.handleLoadedTexture(e),
            void n(null, i))
        })
    }
},
cc.loader.register("png jpg bmp jpeg gif ico tiff webp".split(" "), cc._imgLoader),
cc._serverImgLoader = {
    load: function(t, e, i, n) {
        cc.loader.cache[e] = cc.loader.loadImg(i.src, function(t, i) {
            return t ? n(t) : (cc.textureCache.handleLoadedTexture(e),
            void n(null, i))
        })
    }
},
cc.loader.register(["serverImg"], cc._serverImgLoader),
cc._plistLoader = {
    load: function(t, e, i, n) {
        cc.loader.loadTxt(t, function(t, e) {
            return t ? n(t) : void n(null, cc.plistParser.parse(e))
        })
    }
},
cc.loader.register(["plist"], cc._plistLoader),
cc._fontLoader = {
    TYPE: {
        ".eot": "embedded-opentype",
        ".ttf": "truetype",
        ".ttc": "truetype",
        ".woff": "woff",
        ".svg": "svg"
    },
    _loadFont: function(t, e, i) {
        var n = document
          , r = cc.path
          , c = this.TYPE
          , s = document.createElement("style");
        s.type = "text/css",
        n.body.appendChild(s);
        var o = ""
          , o = isNaN(t - 0) ? o + ("@font-face { font-family:" + t + "; src:") : o + ("@font-face { font-family:'" + t + "'; src:");
        if (e instanceof Array)
            for (var a = 0, h = e.length; a < h; a++)
                i = r.extname(e[a]).toLowerCase(),
                o += "url('" + e[a] + "') format('" + c[i] + "')",
                o += a === h - 1 ? ";" : ",";
        else
            i = i.toLowerCase(),
            o += "url('" + e + "') format('" + c[i] + "');";
        s.textContent += o + "}",
        e = document.createElement("div"),
        i = e.style,
        i.fontFamily = t,
        e.innerHTML = ".",
        i.position = "absolute",
        i.left = "-100px",
        i.top = "-100px",
        n.body.appendChild(e)
    },
    load: function(t, e, i, n) {
        e = i.type,
        t = i.name,
        e = i.srcs,
        cc.isString(i) ? (e = cc.path.extname(i),
        t = cc.path.basename(i, e),
        this._loadFont(t, i, e)) : this._loadFont(t, e),
        document.fonts ? document.fonts.load("1em " + t).then(function() {
            n(null, !0)
        }, function(t) {
            n(t)
        }) : n(null, !0)
    }
},
cc.loader.register("font eot ttf woff svg ttc".split(" "), cc._fontLoader),
cc._binaryLoader = {
    load: function(t, e, i, n) {
        cc.loader.loadBinary(t, n)
    }
},
cc._csbLoader = {
    load: function(t, e, i, n) {
        cc.loader.loadCsb(t, n)
    }
},
cc.loader.register(["csb"], cc._csbLoader),
window.CocosEngine = cc.ENGINE_VERSION = "Cocos2d-JS v3.10",
cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL = 0,
cc.DIRECTOR_STATS_POSITION = cc.p(0, 0),
cc.DIRECTOR_FPS_INTERVAL = .5,
cc.COCOSNODE_RENDER_SUBPIXEL = 1,
cc.SPRITEBATCHNODE_RENDER_SUBPIXEL = 1,
cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA = 1,
cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP = 0,
cc.TEXTURE_ATLAS_USE_VAO = 0,
cc.TEXTURE_NPOT_SUPPORT = 0,
cc.RETINA_DISPLAY_SUPPORT = 1,
cc.RETINA_DISPLAY_FILENAME_SUFFIX = "-hd",
cc.USE_LA88_LABELS = 1,
cc.SPRITE_DEBUG_DRAW = 0,
cc.SPRITEBATCHNODE_DEBUG_DRAW = 0,
cc.LABELBMFONT_DEBUG_DRAW = 0,
cc.LABELATLAS_DEBUG_DRAW = 0,
cc.IS_RETINA_DISPLAY_SUPPORTED = 1,
cc.DEFAULT_ENGINE = cc.ENGINE_VERSION + "-canvas",
cc.ENABLE_STACKABLE_ACTIONS = 1,
cc.ENABLE_GL_STATE_CACHE = 1,
cc.$ = function(t) {
    var e = this === cc ? document : this;
    return (t = t instanceof HTMLElement ? t : e.querySelector(t)) && (t.find = t.find || cc.$,
    t.hasClass = t.hasClass || function(t) {
        return this.className.match(RegExp("(\\s|^)" + t + "(\\s|$)"))
    }
    ,
    t.addClass = t.addClass || function(t) {
        return this.hasClass(t) || (this.className && (this.className += " "),
        this.className += t),
        this
    }
    ,
    t.removeClass = t.removeClass || function(t) {
        return this.hasClass(t) && (this.className = this.className.replace(t, "")),
        this
    }
    ,
    t.remove = t.remove || function() {
        return this.parentNode && this.parentNode.removeChild(this),
        this
    }
    ,
    t.appendTo = t.appendTo || function(t) {
        return t.appendChild(this),
        this
    }
    ,
    t.prependTo = t.prependTo || function(t) {
        return t.childNodes[0] ? t.insertBefore(this, t.childNodes[0]) : t.appendChild(this),
        this
    }
    ,
    t.transforms = t.transforms || function() {
        return this.style[cc.$.trans] = cc.$.translate(this.position) + cc.$.rotate(this.rotation) + cc.$.scale(this.scale) + cc.$.skew(this.skew),
        this
    }
    ,
    t.position = t.position || {
        x: 0,
        y: 0
    },
    t.rotation = t.rotation || 0,
    t.scale = t.scale || {
        x: 1,
        y: 1
    },
    t.skew = t.skew || {
        x: 0,
        y: 0
    },
    t.translates = function(t, e) {
        return this.position.x = t,
        this.position.y = e,
        this.transforms(),
        this
    }
    ,
    t.rotate = function(t) {
        return this.rotation = t,
        this.transforms(),
        this
    }
    ,
    t.resize = function(t, e) {
        return this.scale.x = t,
        this.scale.y = e,
        this.transforms(),
        this
    }
    ,
    t.setSkew = function(t, e) {
        return this.skew.x = t,
        this.skew.y = e,
        this.transforms(),
        this
    }
    ),
    t
}
,
cc.sys.browserType) {
case cc.sys.BROWSER_TYPE_FIREFOX:
    cc.$.pfx = "Moz",
    cc.$.hd = !0;
    break;
case cc.sys.BROWSER_TYPE_CHROME:
case cc.sys.BROWSER_TYPE_SAFARI:
    cc.$.pfx = "webkit",
    cc.$.hd = !0;
    break;
case cc.sys.BROWSER_TYPE_OPERA:
    cc.$.pfx = "O",
    cc.$.hd = !1;
    break;
case cc.sys.BROWSER_TYPE_IE:
    cc.$.pfx = "ms",
    cc.$.hd = !1;
    break;
default:
    cc.$.pfx = "webkit",
    cc.$.hd = !0
}
switch (cc.$.trans = cc.$.pfx + "Transform",
cc.$.translate = cc.$.hd ? function(t) {
    return "translate3d(" + t.x + "px, " + t.y + "px, 0) "
}
: function(t) {
    return "translate(" + t.x + "px, " + t.y + "px) "
}
,
cc.$.rotate = cc.$.hd ? function(t) {
    return "rotateZ(" + t + "deg) "
}
: function(t) {
    return "rotate(" + t + "deg) "
}
,
cc.$.scale = function(t) {
    return "scale(" + t.x + ", " + t.y + ") "
}
,
cc.$.skew = function(t) {
    return "skewX(" + -t.x + "deg) skewY(" + t.y + "deg)"
}
,
cc.$new = function(t) {
    return cc.$(document.createElement(t))
}
,
cc.$.findpos = function(t) {
    var e = 0
      , i = 0;
    do
        e += t.offsetLeft,
        i += t.offsetTop;
    while (t = t.offsetParent);
    return {
        x: e,
        y: i
    }
}
,
cc.INVALID_INDEX = -1,
cc.PI = Math.PI,
cc.FLT_MAX = parseFloat("3.402823466e+38F"),
cc.FLT_MIN = parseFloat("1.175494351e-38F"),
cc.RAD = cc.PI / 180,
cc.DEG = 180 / cc.PI,
cc.UINT_MAX = 4294967295,
cc.swap = function(t, e, i) {
    if (!cc.isObject(i) || cc.isUndefined(i.x) || cc.isUndefined(i.y))
        cc.log(cc._LogInfos.swap);
    else {
        var n = i[t];
        i[t] = i[e],
        i[e] = n
    }
}
,
cc.lerp = function(t, e, i) {
    return t + (e - t) * i
}
,
cc.rand = function() {
    return 16777215 * Math.random()
}
,
cc.randomMinus1To1 = function() {
    return 2 * (Math.random() - .5)
}
,
cc.random0To1 = Math.random,
cc.degreesToRadians = function(t) {
    return t * cc.RAD
}
,
cc.radiansToDegrees = function(t) {
    return t * cc.DEG
}
,
cc.radiansToDegress = function(t) {
    return cc.log(cc._LogInfos.radiansToDegress),
    t * cc.DEG
}
,
cc.REPEAT_FOREVER = Number.MAX_VALUE - 1,
cc.nodeDrawSetup = function(t) {
    t._shaderProgram && (t._shaderProgram.use(),
    t._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4())
}
,
cc.enableDefaultGLStates = function() {}
,
cc.disableDefaultGLStates = function() {}
,
cc.incrementGLDraws = function(t) {
    cc.g_NumberOfDraws += t
}
,
cc.FLT_EPSILON = 1.192092896e-7,
cc.contentScaleFactor = cc.IS_RETINA_DISPLAY_SUPPORTED ? function() {
    return cc.director.getContentScaleFactor()
}
: function() {
    return 1
}
,
cc.pointPointsToPixels = function(t) {
    var e = cc.contentScaleFactor();
    return cc.p(t.x * e, t.y * e)
}
,
cc.pointPixelsToPoints = function(t) {
    var e = cc.contentScaleFactor();
    return cc.p(t.x / e, t.y / e)
}
,
cc._pointPixelsToPointsOut = function(t, e) {
    var i = cc.contentScaleFactor();
    e.x = t.x / i,
    e.y = t.y / i
}
,
cc.sizePointsToPixels = function(t) {
    var e = cc.contentScaleFactor();
    return cc.size(t.width * e, t.height * e)
}
,
cc.sizePixelsToPoints = function(t) {
    var e = cc.contentScaleFactor();
    return cc.size(t.width / e, t.height / e)
}
,
cc._sizePixelsToPointsOut = function(t, e) {
    var i = cc.contentScaleFactor();
    e.width = t.width / i,
    e.height = t.height / i
}
,
cc.rectPixelsToPoints = cc.IS_RETINA_DISPLAY_SUPPORTED ? function(t) {
    var e = cc.contentScaleFactor();
    return cc.rect(t.x / e, t.y / e, t.width / e, t.height / e)
}
: function(t) {
    return t
}
,
cc.rectPointsToPixels = cc.IS_RETINA_DISPLAY_SUPPORTED ? function(t) {
    var e = cc.contentScaleFactor();
    return cc.rect(t.x * e, t.y * e, t.width * e, t.height * e)
}
: function(t) {
    return t
}
,
cc.ONE = 1,
cc.ZERO = 0,
cc.SRC_ALPHA = 770,
cc.SRC_ALPHA_SATURATE = 776,
cc.SRC_COLOR = 768,
cc.DST_ALPHA = 772,
cc.DST_COLOR = 774,
cc.ONE_MINUS_SRC_ALPHA = 771,
cc.ONE_MINUS_SRC_COLOR = 769,
cc.ONE_MINUS_DST_ALPHA = 773,
cc.ONE_MINUS_DST_COLOR = 775,
cc.ONE_MINUS_CONSTANT_ALPHA = 32772,
cc.ONE_MINUS_CONSTANT_COLOR = 32770,
cc.LINEAR = 9729,
cc.REPEAT = 10497,
cc.CLAMP_TO_EDGE = 33071,
cc.MIRRORED_REPEAT = 33648,
cc.BLEND_SRC = cc.SRC_ALPHA,
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function() {
    cc._renderType === cc.game.RENDER_TYPE_WEBGL && cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA && (cc.BLEND_SRC = cc.ONE)
}),
cc.BLEND_DST = cc.ONE_MINUS_SRC_ALPHA,
cc.checkGLErrorDebug = function() {
    if (cc.renderMode === cc.game.RENDER_TYPE_WEBGL) {
        var t = cc._renderContext.getError();
        t && cc.log(cc._LogInfos.checkGLErrorDebug, t)
    }
}
,
cc.DEVICE_ORIENTATION_PORTRAIT = 0,
cc.DEVICE_ORIENTATION_LANDSCAPE_LEFT = 1,
cc.DEVICE_ORIENTATION_PORTRAIT_UPSIDE_DOWN = 2,
cc.DEVICE_ORIENTATION_LANDSCAPE_RIGHT = 3,
cc.DEVICE_MAX_ORIENTATIONS = 2,
cc.VERTEX_ATTRIB_FLAG_NONE = 0,
cc.VERTEX_ATTRIB_FLAG_POSITION = 1,
cc.VERTEX_ATTRIB_FLAG_COLOR = 2,
cc.VERTEX_ATTRIB_FLAG_TEX_COORDS = 4,
cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX = cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS,
cc.GL_ALL = 0,
cc.VERTEX_ATTRIB_POSITION = 0,
cc.VERTEX_ATTRIB_COLOR = 1,
cc.VERTEX_ATTRIB_TEX_COORDS = 2,
cc.VERTEX_ATTRIB_MAX = 3,
cc.UNIFORM_PMATRIX = 0,
cc.UNIFORM_MVMATRIX = 1,
cc.UNIFORM_MVPMATRIX = 2,
cc.UNIFORM_TIME = 3,
cc.UNIFORM_SINTIME = 4,
cc.UNIFORM_COSTIME = 5,
cc.UNIFORM_RANDOM01 = 6,
cc.UNIFORM_SAMPLER = 7,
cc.UNIFORM_MAX = 8,
cc.SHADER_POSITION_TEXTURECOLOR = "ShaderPositionTextureColor",
cc.SHADER_POSITION_TEXTURECOLORALPHATEST = "ShaderPositionTextureColorAlphaTest",
cc.SHADER_POSITION_COLOR = "ShaderPositionColor",
cc.SHADER_POSITION_TEXTURE = "ShaderPositionTexture",
cc.SHADER_POSITION_TEXTURE_UCOLOR = "ShaderPositionTexture_uColor",
cc.SHADER_POSITION_TEXTUREA8COLOR = "ShaderPositionTextureA8Color",
cc.SHADER_POSITION_UCOLOR = "ShaderPosition_uColor",
cc.SHADER_POSITION_LENGTHTEXTURECOLOR = "ShaderPositionLengthTextureColor",
cc.UNIFORM_PMATRIX_S = "CC_PMatrix",
cc.UNIFORM_MVMATRIX_S = "CC_MVMatrix",
cc.UNIFORM_MVPMATRIX_S = "CC_MVPMatrix",
cc.UNIFORM_TIME_S = "CC_Time",
cc.UNIFORM_SINTIME_S = "CC_SinTime",
cc.UNIFORM_COSTIME_S = "CC_CosTime",
cc.UNIFORM_RANDOM01_S = "CC_Random01",
cc.UNIFORM_SAMPLER_S = "CC_Texture0",
cc.UNIFORM_ALPHA_TEST_VALUE_S = "CC_alpha_value",
cc.ATTRIBUTE_NAME_COLOR = "a_color",
cc.ATTRIBUTE_NAME_POSITION = "a_position",
cc.ATTRIBUTE_NAME_TEX_COORD = "a_texCoord",
cc.ITEM_SIZE = 32,
cc.CURRENT_ITEM = 3233828865,
cc.ZOOM_ACTION_TAG = 3233828866,
cc.NORMAL_TAG = 8801,
cc.SELECTED_TAG = 8802,
cc.DISABLE_TAG = 8803,
cc.arrayVerifyType = function(t, e) {
    if (t && 0 < t.length)
        for (var i = 0; i < t.length; i++)
            if (!(t[i]instanceof e))
                return cc.log("element type is wrong!"),
                !1;
    return !0
}
,
cc.arrayRemoveObject = function(t, e) {
    for (var i = 0, n = t.length; i < n; i++)
        if (t[i] === e) {
            t.splice(i, 1);
            break
        }
}
,
cc.arrayRemoveArray = function(t, e) {
    for (var i = 0, n = e.length; i < n; i++)
        cc.arrayRemoveObject(t, e[i])
}
,
cc.arrayAppendObjectsToIndex = function(t, e, i) {
    return t.splice.apply(t, [i, 0].concat(e)),
    t
}
,
cc.copyArray = function(t) {
    var e, i = t.length, n = Array(i);
    for (e = 0; e < i; e += 1)
        n[e] = t[e];
    return n
}
,
cc = cc || {},
cc._tmp = cc._tmp || {},
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function() {
    if (cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
        cc.color = function(t, e, i, n, r, c) {
            return void 0 === t ? new cc.Color(0,0,0,255,r,c) : cc.isString(t) ? (t = cc.hexToColor(t),
            new cc.Color(t.r,t.g,t.b,t.a)) : cc.isObject(t) ? new cc.Color(t.r,t.g,t.b,t.a,t.arrayBuffer,t.offset) : new cc.Color(t,e,i,n,r,c)
        }
        ,
        cc.Color = function(t, e, i, n, r, c) {
            this._arrayBuffer = r || new ArrayBuffer(cc.Color.BYTES_PER_ELEMENT),
            this._offset = c || 0,
            r = this._arrayBuffer,
            c = this._offset;
            var s = Uint8Array.BYTES_PER_ELEMENT;
            this._rU8 = new Uint8Array(r,c,1),
            this._gU8 = new Uint8Array(r,c + s,1),
            this._bU8 = new Uint8Array(r,c + 2 * s,1),
            this._aU8 = new Uint8Array(r,c + 3 * s,1),
            this._rU8[0] = t || 0,
            this._gU8[0] = e || 0,
            this._bU8[0] = i || 0,
            this._aU8[0] = null == n ? 255 : n,
            void 0 === n && (this.a_undefined = !0)
        }
        ,
        cc.Color.BYTES_PER_ELEMENT = 4;
        var t = cc.Color.prototype;
        t._getR = function() {
            return this._rU8[0]
        }
        ,
        t._setR = function(t) {
            this._rU8[0] = 0 > t ? 0 : t
        }
        ,
        t._getG = function() {
            return this._gU8[0]
        }
        ,
        t._setG = function(t) {
            this._gU8[0] = 0 > t ? 0 : t
        }
        ,
        t._getB = function() {
            return this._bU8[0]
        }
        ,
        t._setB = function(t) {
            this._bU8[0] = 0 > t ? 0 : t
        }
        ,
        t._getA = function() {
            return this._aU8[0]
        }
        ,
        t._setA = function(t) {
            this._aU8[0] = 0 > t ? 0 : t
        }
        ,
        cc.defineGetterSetter(t, "r", t._getR, t._setR),
        cc.defineGetterSetter(t, "g", t._getG, t._setG),
        cc.defineGetterSetter(t, "b", t._getB, t._setB),
        cc.defineGetterSetter(t, "a", t._getA, t._setA),
        cc.assert(cc.isFunction(cc._tmp.PrototypeColor), cc._LogInfos.MissingFile, "CCTypesPropertyDefine.js"),
        cc._tmp.PrototypeColor(),
        delete cc._tmp.PrototypeColor,
        cc.Vertex2F = function(t, e, i, n) {
            this._arrayBuffer = i || new ArrayBuffer(cc.Vertex2F.BYTES_PER_ELEMENT),
            this._offset = n || 0,
            this._xF32 = new Float32Array(this._arrayBuffer,this._offset,1),
            this._yF32 = new Float32Array(this._arrayBuffer,this._offset + 4,1),
            this._xF32[0] = t || 0,
            this._yF32[0] = e || 0
        }
        ,
        cc.Vertex2F.BYTES_PER_ELEMENT = 8,
        t = cc.Vertex2F.prototype,
        t._getX = function() {
            return this._xF32[0]
        }
        ,
        t._setX = function(t) {
            this._xF32[0] = t
        }
        ,
        t._getY = function() {
            return this._yF32[0]
        }
        ,
        t._setY = function(t) {
            this._yF32[0] = t
        }
        ,
        cc.defineGetterSetter(t, "x", t._getX, t._setX),
        cc.defineGetterSetter(t, "y", t._getY, t._setY),
        cc.Vertex3F = function(t, e, i, n, r) {
            this._arrayBuffer = n || new ArrayBuffer(cc.Vertex3F.BYTES_PER_ELEMENT),
            this._offset = r || 0,
            n = this._arrayBuffer,
            r = this._offset,
            this._xF32 = new Float32Array(n,r,1),
            this._xF32[0] = t || 0,
            this._yF32 = new Float32Array(n,r + Float32Array.BYTES_PER_ELEMENT,1),
            this._yF32[0] = e || 0,
            this._zF32 = new Float32Array(n,r + 2 * Float32Array.BYTES_PER_ELEMENT,1),
            this._zF32[0] = i || 0
        }
        ,
        cc.Vertex3F.BYTES_PER_ELEMENT = 12,
        t = cc.Vertex3F.prototype,
        t._getX = function() {
            return this._xF32[0]
        }
        ,
        t._setX = function(t) {
            this._xF32[0] = t
        }
        ,
        t._getY = function() {
            return this._yF32[0]
        }
        ,
        t._setY = function(t) {
            this._yF32[0] = t
        }
        ,
        t._getZ = function() {
            return this._zF32[0]
        }
        ,
        t._setZ = function(t) {
            this._zF32[0] = t
        }
        ,
        cc.defineGetterSetter(t, "x", t._getX, t._setX),
        cc.defineGetterSetter(t, "y", t._getY, t._setY),
        cc.defineGetterSetter(t, "z", t._getZ, t._setZ),
        cc.Tex2F = function(t, e, i, n) {
            this._arrayBuffer = i || new ArrayBuffer(cc.Tex2F.BYTES_PER_ELEMENT),
            this._offset = n || 0,
            this._uF32 = new Float32Array(this._arrayBuffer,this._offset,1),
            this._vF32 = new Float32Array(this._arrayBuffer,this._offset + 4,1),
            this._uF32[0] = t || 0,
            this._vF32[0] = e || 0
        }
        ,
        cc.Tex2F.BYTES_PER_ELEMENT = 8,
        t = cc.Tex2F.prototype,
        t._getU = function() {
            return this._uF32[0]
        }
        ,
        t._setU = function(t) {
            this._uF32[0] = t
        }
        ,
        t._getV = function() {
            return this._vF32[0]
        }
        ,
        t._setV = function(t) {
            this._vF32[0] = t
        }
        ,
        cc.defineGetterSetter(t, "u", t._getU, t._setU),
        cc.defineGetterSetter(t, "v", t._getV, t._setV),
        cc.Quad2 = function(t, e, i, n, r, c) {
            this._arrayBuffer = r || new ArrayBuffer(cc.Quad2.BYTES_PER_ELEMENT),
            this._offset = c || 0,
            r = this._arrayBuffer,
            c = cc.Vertex2F.BYTES_PER_ELEMENT,
            this._tl = t ? new cc.Vertex2F(t.x,t.y,r,0) : new cc.Vertex2F(0,0,r,0),
            this._tr = e ? new cc.Vertex2F(e.x,e.y,r,c) : new cc.Vertex2F(0,0,r,c),
            this._bl = i ? new cc.Vertex2F(i.x,i.y,r,2 * c) : new cc.Vertex2F(0,0,r,2 * c),
            this._br = n ? new cc.Vertex2F(n.x,n.y,r,3 * c) : new cc.Vertex2F(0,0,r,3 * c)
        }
        ,
        cc.Quad2.BYTES_PER_ELEMENT = 32,
        t = cc.Quad2.prototype,
        t._getTL = function() {
            return this._tl
        }
        ,
        t._setTL = function(t) {
            this._tl.x = t.x,
            this._tl.y = t.y
        }
        ,
        t._getTR = function() {
            return this._tr
        }
        ,
        t._setTR = function(t) {
            this._tr.x = t.x,
            this._tr.y = t.y
        }
        ,
        t._getBL = function() {
            return this._bl
        }
        ,
        t._setBL = function(t) {
            this._bl.x = t.x,
            this._bl.y = t.y
        }
        ,
        t._getBR = function() {
            return this._br
        }
        ,
        t._setBR = function(t) {
            this._br.x = t.x,
            this._br.y = t.y
        }
        ,
        cc.defineGetterSetter(t, "tl", t._getTL, t._setTL),
        cc.defineGetterSetter(t, "tr", t._getTR, t._setTR),
        cc.defineGetterSetter(t, "bl", t._getBL, t._setBL),
        cc.defineGetterSetter(t, "br", t._getBR, t._setBR),
        cc.Quad3 = function(t, e, i, n) {
            this.bl = t || new cc.Vertex3F(0,0,0),
            this.br = e || new cc.Vertex3F(0,0,0),
            this.tl = i || new cc.Vertex3F(0,0,0),
            this.tr = n || new cc.Vertex3F(0,0,0)
        }
        ,
        cc.V3F_C4B_T2F = function(t, e, i, n, r) {
            this._arrayBuffer = n || new ArrayBuffer(cc.V3F_C4B_T2F.BYTES_PER_ELEMENT),
            this._offset = r || 0,
            n = this._arrayBuffer,
            r = this._offset;
            var c = cc.Vertex3F.BYTES_PER_ELEMENT;
            this._vertices = t ? new cc.Vertex3F(t.x,t.y,t.z,n,r) : new cc.Vertex3F(0,0,0,n,r),
            this._colors = e ? cc.color(e.r, e.g, e.b, e.a, n, r + c) : cc.color(0, 0, 0, 0, n, r + c),
            this._texCoords = i ? new cc.Tex2F(i.u,i.v,n,r + c + cc.Color.BYTES_PER_ELEMENT) : new cc.Tex2F(0,0,n,r + c + cc.Color.BYTES_PER_ELEMENT)
        }
        ,
        cc.V3F_C4B_T2F.BYTES_PER_ELEMENT = 24,
        t = cc.V3F_C4B_T2F.prototype,
        t._getVertices = function() {
            return this._vertices
        }
        ,
        t._setVertices = function(t) {
            var e = this._vertices;
            e.x = t.x,
            e.y = t.y,
            e.z = t.z
        }
        ,
        t._getColor = function() {
            return this._colors
        }
        ,
        t._setColor = function(t) {
            var e = this._colors;
            e.r = t.r,
            e.g = t.g,
            e.b = t.b,
            e.a = t.a
        }
        ,
        t._getTexCoords = function() {
            return this._texCoords
        }
        ,
        t._setTexCoords = function(t) {
            this._texCoords.u = t.u,
            this._texCoords.v = t.v
        }
        ,
        cc.defineGetterSetter(t, "vertices", t._getVertices, t._setVertices),
        cc.defineGetterSetter(t, "colors", t._getColor, t._setColor),
        cc.defineGetterSetter(t, "texCoords", t._getTexCoords, t._setTexCoords),
        cc.V3F_C4B_T2F_Quad = function(t, e, i, n, r, c) {
            this._arrayBuffer = r || new ArrayBuffer(cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT),
            this._offset = c || 0,
            r = this._arrayBuffer,
            c = this._offset;
            var s = cc.V3F_C4B_T2F.BYTES_PER_ELEMENT;
            this._tl = t ? new cc.V3F_C4B_T2F(t.vertices,t.colors,t.texCoords,r,c) : new cc.V3F_C4B_T2F(null,null,null,r,c),
            this._bl = e ? new cc.V3F_C4B_T2F(e.vertices,e.colors,e.texCoords,r,c + s) : new cc.V3F_C4B_T2F(null,null,null,r,c + s),
            this._tr = i ? new cc.V3F_C4B_T2F(i.vertices,i.colors,i.texCoords,r,c + 2 * s) : new cc.V3F_C4B_T2F(null,null,null,r,c + 2 * s),
            this._br = n ? new cc.V3F_C4B_T2F(n.vertices,n.colors,n.texCoords,r,c + 3 * s) : new cc.V3F_C4B_T2F(null,null,null,r,c + 3 * s)
        }
        ,
        cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT = 96,
        t = cc.V3F_C4B_T2F_Quad.prototype,
        t._getTL = function() {
            return this._tl
        }
        ,
        t._setTL = function(t) {
            var e = this._tl;
            e.vertices = t.vertices,
            e.colors = t.colors,
            e.texCoords = t.texCoords
        }
        ,
        t._getBL = function() {
            return this._bl
        }
        ,
        t._setBL = function(t) {
            var e = this._bl;
            e.vertices = t.vertices,
            e.colors = t.colors,
            e.texCoords = t.texCoords
        }
        ,
        t._getTR = function() {
            return this._tr
        }
        ,
        t._setTR = function(t) {
            var e = this._tr;
            e.vertices = t.vertices,
            e.colors = t.colors,
            e.texCoords = t.texCoords
        }
        ,
        t._getBR = function() {
            return this._br
        }
        ,
        t._setBR = function(t) {
            var e = this._br;
            e.vertices = t.vertices,
            e.colors = t.colors,
            e.texCoords = t.texCoords
        }
        ,
        t._getArrayBuffer = function() {
            return this._arrayBuffer
        }
        ,
        cc.defineGetterSetter(t, "tl", t._getTL, t._setTL),
        cc.defineGetterSetter(t, "tr", t._getTR, t._setTR),
        cc.defineGetterSetter(t, "bl", t._getBL, t._setBL),
        cc.defineGetterSetter(t, "br", t._getBR, t._setBR),
        cc.defineGetterSetter(t, "arrayBuffer", t._getArrayBuffer, null),
        cc.V3F_C4B_T2F_QuadZero = function() {
            return new cc.V3F_C4B_T2F_Quad
        }
        ,
        cc.V3F_C4B_T2F_QuadCopy = function(t) {
            if (!t)
                return cc.V3F_C4B_T2F_QuadZero();
            var e = t.tl
              , i = t.bl
              , n = t.tr;
            return t = t.br,
            {
                tl: {
                    vertices: {
                        x: e.vertices.x,
                        y: e.vertices.y,
                        z: e.vertices.z
                    },
                    colors: {
                        r: e.colors.r,
                        g: e.colors.g,
                        b: e.colors.b,
                        a: e.colors.a
                    },
                    texCoords: {
                        u: e.texCoords.u,
                        v: e.texCoords.v
                    }
                },
                bl: {
                    vertices: {
                        x: i.vertices.x,
                        y: i.vertices.y,
                        z: i.vertices.z
                    },
                    colors: {
                        r: i.colors.r,
                        g: i.colors.g,
                        b: i.colors.b,
                        a: i.colors.a
                    },
                    texCoords: {
                        u: i.texCoords.u,
                        v: i.texCoords.v
                    }
                },
                tr: {
                    vertices: {
                        x: n.vertices.x,
                        y: n.vertices.y,
                        z: n.vertices.z
                    },
                    colors: {
                        r: n.colors.r,
                        g: n.colors.g,
                        b: n.colors.b,
                        a: n.colors.a
                    },
                    texCoords: {
                        u: n.texCoords.u,
                        v: n.texCoords.v
                    }
                },
                br: {
                    vertices: {
                        x: t.vertices.x,
                        y: t.vertices.y,
                        z: t.vertices.z
                    },
                    colors: {
                        r: t.colors.r,
                        g: t.colors.g,
                        b: t.colors.b,
                        a: t.colors.a
                    },
                    texCoords: {
                        u: t.texCoords.u,
                        v: t.texCoords.v
                    }
                }
            }
        }
        ,
        cc.V3F_C4B_T2F_QuadsCopy = function(t) {
            if (!t)
                return [];
            for (var e = [], i = 0; i < t.length; i++)
                e.push(cc.V3F_C4B_T2F_QuadCopy(t[i]));
            return e
        }
        ,
        cc.V2F_C4B_T2F = function(t, e, i, n, r) {
            this._arrayBuffer = n || new ArrayBuffer(cc.V2F_C4B_T2F.BYTES_PER_ELEMENT),
            this._offset = r || 0,
            n = this._arrayBuffer,
            r = this._offset;
            var c = cc.Vertex2F.BYTES_PER_ELEMENT;
            this._vertices = t ? new cc.Vertex2F(t.x,t.y,n,r) : new cc.Vertex2F(0,0,n,r),
            this._colors = e ? cc.color(e.r, e.g, e.b, e.a, n, r + c) : cc.color(0, 0, 0, 0, n, r + c),
            this._texCoords = i ? new cc.Tex2F(i.u,i.v,n,r + c + cc.Color.BYTES_PER_ELEMENT) : new cc.Tex2F(0,0,n,r + c + cc.Color.BYTES_PER_ELEMENT)
        }
        ,
        cc.V2F_C4B_T2F.BYTES_PER_ELEMENT = 20,
        t = cc.V2F_C4B_T2F.prototype,
        t._getVertices = function() {
            return this._vertices
        }
        ,
        t._setVertices = function(t) {
            this._vertices.x = t.x,
            this._vertices.y = t.y
        }
        ,
        t._getColor = function() {
            return this._colors
        }
        ,
        t._setColor = function(t) {
            var e = this._colors;
            e.r = t.r,
            e.g = t.g,
            e.b = t.b,
            e.a = t.a
        }
        ,
        t._getTexCoords = function() {
            return this._texCoords
        }
        ,
        t._setTexCoords = function(t) {
            this._texCoords.u = t.u,
            this._texCoords.v = t.v
        }
        ,
        cc.defineGetterSetter(t, "vertices", t._getVertices, t._setVertices),
        cc.defineGetterSetter(t, "colors", t._getColor, t._setColor),
        cc.defineGetterSetter(t, "texCoords", t._getTexCoords, t._setTexCoords),
        cc.V2F_C4B_T2F_Triangle = function(t, e, i, n, r) {
            this._arrayBuffer = n || new ArrayBuffer(cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT),
            this._offset = r || 0,
            n = this._arrayBuffer,
            r = this._offset;
            var c = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
            this._a = t ? new cc.V2F_C4B_T2F(t.vertices,t.colors,t.texCoords,n,r) : new cc.V2F_C4B_T2F(null,null,null,n,r),
            this._b = e ? new cc.V2F_C4B_T2F(e.vertices,e.colors,e.texCoords,n,r + c) : new cc.V2F_C4B_T2F(null,null,null,n,r + c),
            this._c = i ? new cc.V2F_C4B_T2F(i.vertices,i.colors,i.texCoords,n,r + 2 * c) : new cc.V2F_C4B_T2F(null,null,null,n,r + 2 * c)
        }
        ,
        cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT = 60,
        t = cc.V2F_C4B_T2F_Triangle.prototype,
        t._getA = function() {
            return this._a
        }
        ,
        t._setA = function(t) {
            var e = this._a;
            e.vertices = t.vertices,
            e.colors = t.colors,
            e.texCoords = t.texCoords
        }
        ,
        t._getB = function() {
            return this._b
        }
        ,
        t._setB = function(t) {
            var e = this._b;
            e.vertices = t.vertices,
            e.colors = t.colors,
            e.texCoords = t.texCoords
        }
        ,
        t._getC = function() {
            return this._c
        }
        ,
        t._setC = function(t) {
            var e = this._c;
            e.vertices = t.vertices,
            e.colors = t.colors,
            e.texCoords = t.texCoords
        }
        ,
        cc.defineGetterSetter(t, "a", t._getA, t._setA),
        cc.defineGetterSetter(t, "b", t._getB, t._setB),
        cc.defineGetterSetter(t, "c", t._getC, t._setC)
    }
}),
cc._tmp.PrototypeColor = function() {
    var t = cc.color;
    t._getWhite = function() {
        return t(255, 255, 255)
    }
    ,
    t._getYellow = function() {
        return t(255, 255, 0)
    }
    ,
    t._getBlue = function() {
        return t(0, 0, 255)
    }
    ,
    t._getGreen = function() {
        return t(0, 255, 0)
    }
    ,
    t._getRed = function() {
        return t(255, 0, 0)
    }
    ,
    t._getMagenta = function() {
        return t(255, 0, 255)
    }
    ,
    t._getBlack = function() {
        return t(0, 0, 0)
    }
    ,
    t._getOrange = function() {
        return t(255, 127, 0)
    }
    ,
    t._getGray = function() {
        return t(166, 166, 166)
    }
    ,
    cc.defineGetterSetter(t, "WHITE", t._getWhite),
    cc.defineGetterSetter(t, "YELLOW", t._getYellow),
    cc.defineGetterSetter(t, "BLUE", t._getBlue),
    cc.defineGetterSetter(t, "GREEN", t._getGreen),
    cc.defineGetterSetter(t, "RED", t._getRed),
    cc.defineGetterSetter(t, "MAGENTA", t._getMagenta),
    cc.defineGetterSetter(t, "BLACK", t._getBlack),
    cc.defineGetterSetter(t, "ORANGE", t._getOrange),
    cc.defineGetterSetter(t, "GRAY", t._getGray),
    cc.BlendFunc._disable = function() {
        return new cc.BlendFunc(cc.ONE,cc.ZERO)
    }
    ,
    cc.BlendFunc._alphaPremultiplied = function() {
        return new cc.BlendFunc(cc.ONE,cc.ONE_MINUS_SRC_ALPHA)
    }
    ,
    cc.BlendFunc._alphaNonPremultiplied = function() {
        return new cc.BlendFunc(cc.SRC_ALPHA,cc.ONE_MINUS_SRC_ALPHA)
    }
    ,
    cc.BlendFunc._additive = function() {
        return new cc.BlendFunc(cc.SRC_ALPHA,cc.ONE)
    }
    ,
    cc.defineGetterSetter(cc.BlendFunc, "DISABLE", cc.BlendFunc._disable),
    cc.defineGetterSetter(cc.BlendFunc, "ALPHA_PREMULTIPLIED", cc.BlendFunc._alphaPremultiplied),
    cc.defineGetterSetter(cc.BlendFunc, "ALPHA_NON_PREMULTIPLIED", cc.BlendFunc._alphaNonPremultiplied),
    cc.defineGetterSetter(cc.BlendFunc, "ADDITIVE", cc.BlendFunc._additive)
}
,
cc.Color = function(t, e, i, n) {
    this.r = t || 0,
    this.g = e || 0,
    this.b = i || 0,
    this.a = null == n ? 255 : n
}
,
cc.color = function(t, e, i, n) {
    return void 0 === t ? {
        r: 0,
        g: 0,
        b: 0,
        a: 255
    } : cc.isString(t) ? cc.hexToColor(t) : cc.isObject(t) ? {
        r: t.r,
        g: t.g,
        b: t.b,
        a: null == t.a ? 255 : t.a
    } : {
        r: t,
        g: e,
        b: i,
        a: null == n ? 255 : n
    }
}
,
cc.colorEqual = function(t, e) {
    return t.r === e.r && t.g === e.g && t.b === e.b
}
,
cc.Acceleration = function(t, e, i, n) {
    this.x = t || 0,
    this.y = e || 0,
    this.z = i || 0,
    this.timestamp = n || 0
}
,
cc.Vertex2F = function(t, e) {
    this.x = t || 0,
    this.y = e || 0
}
,
cc.vertex2 = function(t, e) {
    return new cc.Vertex2F(t,e)
}
,
cc.Vertex3F = function(t, e, i) {
    this.x = t || 0,
    this.y = e || 0,
    this.z = i || 0
}
,
cc.vertex3 = function(t, e, i) {
    return new cc.Vertex3F(t,e,i)
}
,
cc.Tex2F = function(t, e) {
    this.u = t || 0,
    this.v = e || 0
}
,
cc.tex2 = function(t, e) {
    return new cc.Tex2F(t,e)
}
,
cc.BlendFunc = function(t, e) {
    this.src = t,
    this.dst = e
}
,
cc.blendFuncDisable = function() {
    return new cc.BlendFunc(cc.ONE,cc.ZERO)
}
,
cc.hexToColor = function(t) {
    return t = t.replace(/^#?/, "0x"),
    t = parseInt(t),
    cc.color(t >> 16, (t >> 8) % 256, t % 256)
}
,
cc.colorToHex = function(t) {
    var e = t.r.toString(16)
      , i = t.g.toString(16)
      , n = t.b.toString(16);
    return "#" + (16 > t.r ? "0" + e : e) + (16 > t.g ? "0" + i : i) + (16 > t.b ? "0" + n : n)
}
,
cc.TEXT_ALIGNMENT_LEFT = 0,
cc.TEXT_ALIGNMENT_CENTER = 1,
cc.TEXT_ALIGNMENT_RIGHT = 2,
cc.VERTICAL_TEXT_ALIGNMENT_TOP = 0,
cc.VERTICAL_TEXT_ALIGNMENT_CENTER = 1,
cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM = 2,
cc._Dictionary = cc.Class.extend({
    _keyMapTb: null,
    _valueMapTb: null,
    __currId: 0,
    ctor: function() {
        this._keyMapTb = {},
        this._valueMapTb = {},
        this.__currId = 2 << (0 | 10 * Math.random())
    },
    __getKey: function() {
        return this.__currId++,
        "key_" + this.__currId
    },
    setObject: function(t, e) {
        if (null != e) {
            var i = this.__getKey();
            this._keyMapTb[i] = e,
            this._valueMapTb[i] = t
        }
    },
    objectForKey: function(t) {
        if (null == t)
            return null;
        var e, i = this._keyMapTb;
        for (e in i)
            if (i[e] === t)
                return this._valueMapTb[e];
        return null
    },
    valueForKey: function(t) {
        return this.objectForKey(t)
    },
    removeObjectForKey: function(t) {
        if (null != t) {
            var e, i = this._keyMapTb;
            for (e in i)
                if (i[e] === t) {
                    delete this._valueMapTb[e],
                    delete i[e];
                    break
                }
        }
    },
    removeObjectsForKeys: function(t) {
        if (null != t)
            for (var e = 0; e < t.length; e++)
                this.removeObjectForKey(t[e])
    },
    allKeys: function() {
        var t, e = [], i = this._keyMapTb;
        for (t in i)
            e.push(i[t]);
        return e
    },
    removeAllObjects: function() {
        this._keyMapTb = {},
        this._valueMapTb = {}
    },
    count: function() {
        return this.allKeys().length
    }
}),
cc.FontDefinition = function(t) {
    if (this.fontName = "Arial",
    this.fontSize = 12,
    this.textAlign = cc.TEXT_ALIGNMENT_CENTER,
    this.verticalAlign = cc.VERTICAL_TEXT_ALIGNMENT_TOP,
    this.fillStyle = cc.color(255, 255, 255, 255),
    this.boundingHeight = this.boundingWidth = 0,
    this.strokeEnabled = !1,
    this.strokeStyle = cc.color(255, 255, 255, 255),
    this.lineWidth = 1,
    this.fontWeight = this.fontStyle = this.lineHeight = "normal",
    this.shadowEnabled = !1,
    this.shadowBlur = this.shadowOffsetY = this.shadowOffsetX = 0,
    this.shadowOpacity = 1,
    t && t instanceof Object)
        for (var e in t)
            this[e] = t[e]
}
,
cc.FontDefinition.prototype._getCanvasFontStr = function() {
    return this.fontStyle + " " + this.fontWeight + " " + this.fontSize + "px/" + (this.lineHeight.charAt ? this.lineHeight : this.lineHeight + "px") + " '" + this.fontName + "'"
}
,
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function() {
    cc._renderType === cc.game.RENDER_TYPE_CANVAS && (cc.assert(cc.isFunction(cc._tmp.PrototypeColor), cc._LogInfos.MissingFile, "CCTypesPropertyDefine.js"),
    cc._tmp.PrototypeColor(),
    delete cc._tmp.PrototypeColor)
}),
cc.Touches = [],
cc.TouchesIntergerDict = {},
cc.DENSITYDPI_DEVICE = "device-dpi",
cc.DENSITYDPI_HIGH = "high-dpi",
cc.DENSITYDPI_MEDIUM = "medium-dpi",
cc.DENSITYDPI_LOW = "low-dpi",
cc.__BrowserGetter = {
    init: function() {
        this.html = document.getElementsByTagName("html")[0]
    },
    availWidth: function(t) {
        return t && t !== this.html ? t.clientWidth : window.innerWidth
    },
    availHeight: function(t) {
        return t && t !== this.html ? t.clientHeight : window.innerHeight
    },
    meta: {
        width: "device-width"
    },
    adaptationType: cc.sys.browserType
},
-1 < window.navigator.userAgent.indexOf("OS 8_1_") && (cc.__BrowserGetter.adaptationType = cc.sys.BROWSER_TYPE_MIUI),
cc.sys.os === cc.sys.OS_IOS && (cc.__BrowserGetter.adaptationType = cc.sys.BROWSER_TYPE_SAFARI),
cc.__BrowserGetter.adaptationType) {
case cc.sys.BROWSER_TYPE_SAFARI:
    cc.__BrowserGetter.meta["minimal-ui"] = "true",
    cc.__BrowserGetter.availWidth = function(t) {
        return t.clientWidth
    }
    ,
    cc.__BrowserGetter.availHeight = function(t) {
        return t.clientHeight
    }
    ;
    break;
case cc.sys.BROWSER_TYPE_CHROME:
    cc.__BrowserGetter.__defineGetter__("target-densitydpi", function() {
        return cc.view._targetDensityDPI
    });
case cc.sys.BROWSER_TYPE_SOUGOU:
case cc.sys.BROWSER_TYPE_UC:
    cc.__BrowserGetter.availWidth = function(t) {
        return t.clientWidth
    }
    ,
    cc.__BrowserGetter.availHeight = function(t) {
        return t.clientHeight
    }
    ;
    break;
case cc.sys.BROWSER_TYPE_MIUI:
    cc.__BrowserGetter.init = function(t) {
        if (!t.__resizeWithBrowserSize) {
            var e = function() {
                t.setDesignResolutionSize(t._designResolutionSize.width, t._designResolutionSize.height, t._resolutionPolicy),
                window.removeEventListener("resize", e, !1)
            };
            window.addEventListener("resize", e, !1)
        }
    }
}
cc.EGLView = cc.Class.extend({
    _delegate: null,
    _frameSize: null,
    _designResolutionSize: null,
    _originalDesignResolutionSize: null,
    _viewPortRect: null,
    _visibleRect: null,
    _retinaEnabled: !1,
    _autoFullScreen: 0,
    _devicePixelRatio: 1,
    _viewName: "",
    _resizeCallback: null,
    _scaleX: 1,
    _originalScaleX: 1,
    _scaleY: 1,
    _originalScaleY: 1,
    _indexBitsUsed: 0,
    _maxTouches: 5,
    _resolutionPolicy: null,
    _rpExactFit: null,
    _rpShowAll: null,
    _rpNoBorder: null,
    _rpFixedHeight: null,
    _rpFixedWidth: null,
    _initialized: !1,
    _captured: !1,
    _wnd: null,
    _hDC: null,
    _hRC: null,
    _supportTouch: !1,
    _contentTranslateLeftTop: null,
    _frame: null,
    _frameZoomFactor: 1,
    __resizeWithBrowserSize: !1,
    _isAdjustViewPort: !0,
    _targetDensityDPI: null,
    ctor: function() {
        var t = document
          , e = cc.ContainerStrategy
          , i = cc.ContentStrategy;
        cc.__BrowserGetter.init(this),
        this._frame = cc.container.parentNode === t.body ? t.documentElement : cc.container.parentNode,
        this._frameSize = cc.size(0, 0),
        this._initFrameSize();
        var t = cc._canvas.width
          , n = cc._canvas.height;
        this._designResolutionSize = cc.size(t, n),
        this._originalDesignResolutionSize = cc.size(t, n),
        this._viewPortRect = cc.rect(0, 0, t, n),
        this._visibleRect = cc.rect(0, 0, t, n),
        this._contentTranslateLeftTop = {
            left: 0,
            top: 0
        },
        this._viewName = "Cocos2dHTML5",
        t = cc.sys,
        this.enableRetina(t.os === t.OS_IOS || t.os === t.OS_OSX),
        cc.visibleRect && cc.visibleRect.init(this._visibleRect),
        this._rpExactFit = new cc.ResolutionPolicy(e.EQUAL_TO_FRAME,i.EXACT_FIT),
        this._rpShowAll = new cc.ResolutionPolicy(e.PROPORTION_TO_FRAME,i.SHOW_ALL),
        this._rpNoBorder = new cc.ResolutionPolicy(e.EQUAL_TO_FRAME,i.NO_BORDER),
        this._rpFixedHeight = new cc.ResolutionPolicy(e.EQUAL_TO_FRAME,i.FIXED_HEIGHT),
        this._rpFixedWidth = new cc.ResolutionPolicy(e.EQUAL_TO_FRAME,i.FIXED_WIDTH),
        this._hDC = cc._canvas,
        this._hRC = cc._renderContext,
        this._targetDensityDPI = cc.DENSITYDPI_HIGH
    },
    _resizeEvent: function() {
        var t;
        t = this.setDesignResolutionSize ? this : cc.view;
        var e = t._frameSize.width
          , i = t._frameSize.height;
        t._initFrameSize(),
        t._frameSize.width === e && t._frameSize.height === i || (t._resizeCallback && t._resizeCallback.call(),
        e = t._originalDesignResolutionSize.width,
        i = t._originalDesignResolutionSize.height,
        0 < e && t.setDesignResolutionSize(e, i, t._resolutionPolicy))
    },
    setTargetDensityDPI: function(t) {
        this._targetDensityDPI = t,
        this._adjustViewportMeta()
    },
    getTargetDensityDPI: function() {
        return this._targetDensityDPI
    },
    resizeWithBrowserSize: function(t) {
        t ? this.__resizeWithBrowserSize || (this.__resizeWithBrowserSize = !0,
        window.addEventListener("resize", this._resizeEvent),
        window.addEventListener("orientationchange", this._resizeEvent)) : this.__resizeWithBrowserSize && (this.__resizeWithBrowserSize = !1,
        window.removeEventListener("resize", this._resizeEvent),
        window.removeEventListener("orientationchange", this._resizeEvent))
    },
    setResizeCallback: function(t) {
        (cc.isFunction(t) || null == t) && (this._resizeCallback = t)
    },
    _initFrameSize: function() {
        var t = this._frameSize;
        t.width = cc.__BrowserGetter.availWidth(this._frame),
        t.height = cc.__BrowserGetter.availHeight(this._frame)
    },
    _adjustSizeKeepCanvasSize: function() {
        var t = this._originalDesignResolutionSize.width
          , e = this._originalDesignResolutionSize.height;
        0 < t && this.setDesignResolutionSize(t, e, this._resolutionPolicy)
    },
    _setViewportMeta: function(t, e) {
        var i = document.getElementById("cocosMetaElement");
        i && e && document.head.removeChild(i);
        var n, r, c, s = document.getElementsByName("viewport"), s = s ? s[0] : null;
        n = s ? s.content : "",
        i = i || document.createElement("meta"),
        i.id = "cocosMetaElement",
        i.name = "viewport",
        i.content = "";
        for (r in t)
            -1 == n.indexOf(r) ? n += "," + r + "=" + t[r] : e && (c = RegExp(r + "s*=s*[^,]+"),
            n.replace(c, r + "=" + t[r]));
        /^,/.test(n) && (n = n.substr(1)),
        i.content = n,
        s && (s.content = n),
        document.head.appendChild(i)
    },
    _adjustViewportMeta: function() {
        this._isAdjustViewPort && this._setViewportMeta(cc.__BrowserGetter.meta, !1)
    },
    _setScaleXYForRenderTexture: function() {
        var t = cc.contentScaleFactor();
        this._scaleY = this._scaleX = t
    },
    _resetScale: function() {
        this._scaleX = this._originalScaleX,
        this._scaleY = this._originalScaleY
    },
    _adjustSizeToBrowser: function() {},
    initialize: function() {
        this._initialized = !0
    },
    adjustViewPort: function(t) {
        this._isAdjustViewPort = t
    },
    enableRetina: function(t) {
        this._retinaEnabled = !!t
    },
    isRetinaEnabled: function() {
        return this._retinaEnabled
    },
    enableAutoFullScreen: function(t) {
        this._autoFullScreen = !!t
    },
    isAutoFullScreenEnabled: function() {
        return this._autoFullScreen
    },
    end: function() {},
    isOpenGLReady: function() {
        return null !== this._hDC && null !== this._hRC
    },
    setFrameZoomFactor: function(t) {
        this._frameZoomFactor = t,
        this.centerWindow(),
        cc.director.setProjection(cc.director.getProjection())
    },
    swapBuffers: function() {},
    setIMEKeyboardState: function(t) {},
    setContentTranslateLeftTop: function(t, e) {
        this._contentTranslateLeftTop = {
            left: t,
            top: e
        }
    },
    getContentTranslateLeftTop: function() {
        return this._contentTranslateLeftTop
    },
    getCanvasSize: function() {
        return cc.size(cc._canvas.width, cc._canvas.height)
    },
    getFrameSize: function() {
        return cc.size(this._frameSize.width, this._frameSize.height)
    },
    setFrameSize: function(t, e) {
        this._frameSize.width = t,
        this._frameSize.height = e,
        this._frame.style.width = t + "px",
        this._frame.style.height = e + "px",
        this._resizeEvent(),
        cc.director.setProjection(cc.director.getProjection())
    },
    centerWindow: function() {},
    getVisibleSize: function() {
        return cc.size(this._visibleRect.width, this._visibleRect.height)
    },
    getVisibleSizeInPixel: function() {
        return cc.size(this._visibleRect.width * this._scaleX, this._visibleRect.height * this._scaleY)
    },
    getVisibleOrigin: function() {
        return cc.p(this._visibleRect.x, this._visibleRect.y)
    },
    getVisibleOriginInPixel: function() {
        return cc.p(this._visibleRect.x * this._scaleX, this._visibleRect.y * this._scaleY)
    },
    canSetContentScaleFactor: function() {
        return !0
    },
    getResolutionPolicy: function() {
        return this._resolutionPolicy
    },
    setResolutionPolicy: function(t) {
        if (t instanceof cc.ResolutionPolicy)
            this._resolutionPolicy = t;
        else {
            var e = cc.ResolutionPolicy;
            t === e.EXACT_FIT && (this._resolutionPolicy = this._rpExactFit),
            t === e.SHOW_ALL && (this._resolutionPolicy = this._rpShowAll),
            t === e.NO_BORDER && (this._resolutionPolicy = this._rpNoBorder),
            t === e.FIXED_HEIGHT && (this._resolutionPolicy = this._rpFixedHeight),
            t === e.FIXED_WIDTH && (this._resolutionPolicy = this._rpFixedWidth)
        }
    },
    setDesignResolutionSize: function(t, e, i) {
        if (0 < t || 0 < e)
            if (this.setResolutionPolicy(i),
            i = this._resolutionPolicy) {
                i.preApply(this),
                cc.sys.isMobile && this._adjustViewportMeta(),
                this._initFrameSize(),
                this._originalDesignResolutionSize.width = this._designResolutionSize.width = t,
                this._originalDesignResolutionSize.height = this._designResolutionSize.height = e;
                var n = i.apply(this, this._designResolutionSize);
                n.scale && 2 === n.scale.length && (this._scaleX = n.scale[0],
                this._scaleY = n.scale[1]),
                n.viewport && (t = this._viewPortRect,
                e = this._visibleRect,
                n = n.viewport,
                t.x = n.x,
                t.y = n.y,
                t.width = n.width,
                t.height = n.height,
                e.x = -t.x / this._scaleX,
                e.y = -t.y / this._scaleY,
                e.width = cc._canvas.width / this._scaleX,
                e.height = cc._canvas.height / this._scaleY,
                cc._renderContext.setOffset && cc._renderContext.setOffset(t.x, -t.y)),
                t = cc.director,
                t._winSizeInPoints.width = this._designResolutionSize.width,
                t._winSizeInPoints.height = this._designResolutionSize.height,
                i.postApply(this),
                cc.winSize.width = t._winSizeInPoints.width,
                cc.winSize.height = t._winSizeInPoints.height,
                cc._renderType === cc.game.RENDER_TYPE_WEBGL && t.setGLDefaultValues(),
                this._originalScaleX = this._scaleX,
                this._originalScaleY = this._scaleY,
                cc.DOM && cc.DOM._resetEGLViewDiv(),
                cc.visibleRect && cc.visibleRect.init(this._visibleRect)
            } else
                cc.log(cc._LogInfos.EGLView_setDesignResolutionSize_2);
        else
            cc.log(cc._LogInfos.EGLView_setDesignResolutionSize)
    },
    getDesignResolutionSize: function() {
        return cc.size(this._designResolutionSize.width, this._designResolutionSize.height)
    },
    setRealPixelResolution: function(t, e, i) {
        this._setViewportMeta({
            width: t,
            "target-densitydpi": cc.DENSITYDPI_DEVICE
        }, !0),
        document.body.style.width = t + "px",
        document.body.style.left = "0px",
        document.body.style.top = "0px",
        this.setDesignResolutionSize(t, e, i)
    },
    setViewPortInPoints: function(t, e, i, n) {
        var r = this._frameZoomFactor
          , c = this._scaleX
          , s = this._scaleY;
        cc._renderContext.viewport(t * c * r + this._viewPortRect.x * r, e * s * r + this._viewPortRect.y * r, i * c * r, n * s * r)
    },
    setScissorInPoints: function(t, e, i, n) {
        var r = this._frameZoomFactor
          , c = this._scaleX
          , s = this._scaleY;
        cc._renderContext.scissor(t * c * r + this._viewPortRect.x * r, e * s * r + this._viewPortRect.y * r, i * c * r, n * s * r)
    },
    isScissorEnabled: function() {
        var t = cc._renderContext;
        return t.isEnabled(t.SCISSOR_TEST)
    },
    getScissorRect: function() {
        var t = cc._renderContext
          , e = this._scaleX
          , i = this._scaleY
          , t = t.getParameter(t.SCISSOR_BOX);
        return cc.rect((t[0] - this._viewPortRect.x) / e, (t[1] - this._viewPortRect.y) / i, t[2] / e, t[3] / i)
    },
    setViewName: function(t) {
        null != t && 0 < t.length && (this._viewName = t)
    },
    getViewName: function() {
        return this._viewName
    },
    getViewPortRect: function() {
        return this._viewPortRect
    },
    getScaleX: function() {
        return this._scaleX
    },
    getScaleY: function() {
        return this._scaleY
    },
    getDevicePixelRatio: function() {
        return this._devicePixelRatio
    },
    convertToLocationInView: function(t, e, i) {
        return {
            x: this._devicePixelRatio * (t - i.left),
            y: this._devicePixelRatio * (i.top + i.height - e)
        }
    },
    _convertMouseToLocationInView: function(t, e) {
        var i = this._viewPortRect;
        t.x = (this._devicePixelRatio * (t.x - e.left) - i.x) / this._scaleX,
        t.y = (this._devicePixelRatio * (e.top + e.height - t.y) - i.y) / this._scaleY
    },
    _convertTouchesWithScale: function(t) {
        for (var e, i, n, r = this._viewPortRect, c = this._scaleX, s = this._scaleY, o = 0; o < t.length; o++)
            e = t[o],
            i = e._point,
            n = e._prevPoint,
            e._setPoint((i.x - r.x) / c, (i.y - r.y) / s),
            e._setPrevPoint((n.x - r.x) / c, (n.y - r.y) / s)
    }
}),
cc.EGLView._getInstance = function() {
    return this._instance || (this._instance = this._instance || new cc.EGLView,
    this._instance.initialize()),
    this._instance
}
,
cc.ContainerStrategy = cc.Class.extend({
    preApply: function(t) {},
    apply: function(t, e) {},
    postApply: function(t) {},
    _setupContainer: function(t, e, i) {
        var n = t._frame;
        cc.view._autoFullScreen && cc.sys.isMobile && n === document.documentElement && cc.screen.autoFullScreen(n);
        var n = cc._canvas
          , r = cc.container;
        r.style.width = n.style.width = e + "px",
        r.style.height = n.style.height = i + "px",
        r = t._devicePixelRatio = 1,
        t.isRetinaEnabled() && (r = t._devicePixelRatio = window.devicePixelRatio || 1),
        n.width = e * r,
        n.height = i * r,
        cc._renderContext.resetCache && cc._renderContext.resetCache(),
        t = document.body;
        var c;
        t && (c = t.style) && (c.paddingTop = c.paddingTop || "0px",
        c.paddingRight = c.paddingRight || "0px",
        c.paddingBottom = c.paddingBottom || "0px",
        c.paddingLeft = c.paddingLeft || "0px",
        c.borderTop = c.borderTop || "0px",
        c.borderRight = c.borderRight || "0px",
        c.borderBottom = c.borderBottom || "0px",
        c.borderLeft = c.borderLeft || "0px",
        c.marginTop = c.marginTop || "0px",
        c.marginRight = c.marginRight || "0px",
        c.marginBottom = c.marginBottom || "0px",
        c.marginLeft = c.marginLeft || "0px")
    },
    _fixContainer: function() {
        document.body.insertBefore(cc.container, document.body.firstChild);
        var t = document.body.style;
        t.width = window.innerWidth + "px",
        t.height = window.innerHeight + "px",
        t.overflow = "hidden",
        t = cc.container.style,
        t.position = "fixed",
        t.left = t.top = "0px",
        document.body.scrollTop = 0
    }
}),
cc.ContentStrategy = cc.Class.extend({
    _result: {
        scale: [1, 1],
        viewport: null
    },
    _buildResult: function(t, e, i, n, r, c) {
        return 2 > Math.abs(t - i) && (i = t),
        2 > Math.abs(e - n) && (n = e),
        t = cc.rect(Math.round((t - i) / 2), Math.round((e - n) / 2), i, n),
        this._result.scale = [r, c],
        this._result.viewport = t,
        this._result
    },
    preApply: function(t) {},
    apply: function(t, e) {
        return {
            scale: [1, 1]
        }
    },
    postApply: function(t) {}
}),
function() {
    var t = cc.ContainerStrategy.extend({
        apply: function(t) {
            this._setupContainer(t, t._frameSize.width, t._frameSize.height)
        }
    })
      , e = cc.ContainerStrategy.extend({
        apply: function(t, e) {
            var i, n, r = t._frameSize.width, c = t._frameSize.height, s = cc.container.style, o = e.width, a = e.height, h = r / o, l = c / a;
            h < l ? (i = r,
            n = a * h) : (i = o * l,
            n = c),
            o = Math.round((r - i) / 2),
            n = Math.round((c - n) / 2),
            this._setupContainer(t, r - 2 * o, c - 2 * n),
            s.marginLeft = o + "px",
            s.marginRight = o + "px",
            s.marginTop = n + "px",
            s.marginBottom = n + "px"
        }
    });
    t.extend({
        preApply: function(t) {
            this._super(t),
            t._frame = document.documentElement
        },
        apply: function(t) {
            this._super(t),
            this._fixContainer()
        }
    }),
    e.extend({
        preApply: function(t) {
            this._super(t),
            t._frame = document.documentElement
        },
        apply: function(t, e) {
            this._super(t, e),
            this._fixContainer()
        }
    });
    var i = cc.ContainerStrategy.extend({
        apply: function(t) {
            this._setupContainer(t, cc._canvas.width, cc._canvas.height)
        }
    });
    cc.ContainerStrategy.EQUAL_TO_FRAME = new t,
    cc.ContainerStrategy.PROPORTION_TO_FRAME = new e,
    cc.ContainerStrategy.ORIGINAL_CONTAINER = new i;
    var t = cc.ContentStrategy.extend({
        apply: function(t, e) {
            var i = cc._canvas.width
              , n = cc._canvas.height;
            return this._buildResult(i, n, i, n, i / e.width, n / e.height)
        }
    })
      , e = cc.ContentStrategy.extend({
        apply: function(t, e) {
            var i, n, r = cc._canvas.width, c = cc._canvas.height, s = e.width, o = e.height, a = r / s, h = c / o, l = 0;
            return a < h ? (l = a,
            i = r,
            n = o * l) : (l = h,
            i = s * l,
            n = c),
            this._buildResult(r, c, i, n, l, l)
        }
    })
      , i = cc.ContentStrategy.extend({
        apply: function(t, e) {
            var i, n, r, c = cc._canvas.width, s = cc._canvas.height, o = e.width, a = e.height, h = c / o, l = s / a;
            return h < l ? (i = l,
            n = o * i,
            r = s) : (i = h,
            n = c,
            r = a * i),
            this._buildResult(c, s, n, r, i, i)
        }
    })
      , n = cc.ContentStrategy.extend({
        apply: function(t, e) {
            var i = cc._canvas.width
              , n = cc._canvas.height
              , r = n / e.height;
            return this._buildResult(i, n, i, n, r, r)
        },
        postApply: function(t) {
            cc.director._winSizeInPoints = t.getVisibleSize()
        }
    })
      , r = cc.ContentStrategy.extend({
        apply: function(t, e) {
            var i = cc._canvas.width
              , n = cc._canvas.height
              , r = i / e.width;
            return this._buildResult(i, n, i, n, r, r)
        },
        postApply: function(t) {
            cc.director._winSizeInPoints = t.getVisibleSize()
        }
    });
    cc.ContentStrategy.EXACT_FIT = new t,
    cc.ContentStrategy.SHOW_ALL = new e,
    cc.ContentStrategy.NO_BORDER = new i,
    cc.ContentStrategy.FIXED_HEIGHT = new n,
    cc.ContentStrategy.FIXED_WIDTH = new r
}(),
cc.ResolutionPolicy = cc.Class.extend({
    _containerStrategy: null,
    _contentStrategy: null,
    ctor: function(t, e) {
        this.setContainerStrategy(t),
        this.setContentStrategy(e)
    },
    preApply: function(t) {
        this._containerStrategy.preApply(t),
        this._contentStrategy.preApply(t)
    },
    apply: function(t, e) {
        return this._containerStrategy.apply(t, e),
        this._contentStrategy.apply(t, e)
    },
    postApply: function(t) {
        this._containerStrategy.postApply(t),
        this._contentStrategy.postApply(t)
    },
    setContainerStrategy: function(t) {
        t instanceof cc.ContainerStrategy && (this._containerStrategy = t)
    },
    setContentStrategy: function(t) {
        t instanceof cc.ContentStrategy && (this._contentStrategy = t)
    }
}),
cc.ResolutionPolicy.EXACT_FIT = 0,
cc.ResolutionPolicy.NO_BORDER = 1,
cc.ResolutionPolicy.SHOW_ALL = 2,
cc.ResolutionPolicy.FIXED_HEIGHT = 3,
cc.ResolutionPolicy.FIXED_WIDTH = 4,
cc.ResolutionPolicy.UNKNOWN = 5,
cc.screen = {
    _supportsFullScreen: !1,
    _preOnFullScreenChange: null,
    _touchEvent: "",
    _fn: null,
    _fnMap: [["requestFullscreen", "exitFullscreen", "fullscreenchange", "fullscreenEnabled", "fullscreenElement"], ["requestFullScreen", "exitFullScreen", "fullScreenchange", "fullScreenEnabled", "fullScreenElement"], ["webkitRequestFullScreen", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitIsFullScreen", "webkitCurrentFullScreenElement"], ["mozRequestFullScreen", "mozCancelFullScreen", "mozfullscreenchange", "mozFullScreen", "mozFullScreenElement"], ["msRequestFullscreen", "msExitFullscreen", "MSFullscreenChange", "msFullscreenEnabled", "msFullscreenElement"]],
    init: function() {
        this._fn = {};
        var t, e, i, n = this._fnMap;
        for (t = 0,
        l = n.length; t < l; t++)
            if ((e = n[t]) && e[1]in document) {
                for (t = 0,
                i = e.length; t < i; t++)
                    this._fn[n[0][t]] = e[t];
                break
            }
        this._supportsFullScreen = "undefined" != typeof this._fn.requestFullscreen,
        this._touchEvent = "ontouchstart"in window ? "touchstart" : "mousedown"
    },
    fullScreen: function() {
        return !!this._supportsFullScreen && (void 0 !== document[this._fn.fullscreenElement] && null !== document[this._fn.fullscreenElement])
    },
    requestFullScreen: function(t, e) {
        if (this._supportsFullScreen) {
            if (t = t || document.documentElement,
            e) {
                var i = this._fn.fullscreenchange;
                this._preOnFullScreenChange && document.removeEventListener(i, this._preOnFullScreenChange),
                this._preOnFullScreenChange = e,
                document.addEventListener(i, e, !1)
            }
            return t[this._fn.requestFullscreen]()
        }
    },
    exitFullScreen: function() {
        return !this._supportsFullScreen || document[this._fn.exitFullscreen]()
    },
    autoFullScreen: function(t, e) {
        function i() {
            r.requestFullScreen(t, e),
            n.removeEventListener(r._touchEvent, i)
        }
        t = t || document.body;
        var n = cc._canvas || t
          , r = this;
        this.requestFullScreen(t, e),
        n.addEventListener(this._touchEvent, i)
    }
},
cc.screen.init(),
cc.visibleRect = {
    topLeft: cc.p(0, 0),
    topRight: cc.p(0, 0),
    top: cc.p(0, 0),
    bottomLeft: cc.p(0, 0),
    bottomRight: cc.p(0, 0),
    bottom: cc.p(0, 0),
    center: cc.p(0, 0),
    left: cc.p(0, 0),
    right: cc.p(0, 0),
    width: 0,
    height: 0,
    init: function(t) {
        var e = this.width = t.width
          , i = this.height = t.height
          , n = t.x;
        t = t.y;
        var r = t + i
          , c = n + e;
        this.topLeft.x = n,
        this.topLeft.y = r,
        this.topRight.x = c,
        this.topRight.y = r,
        this.top.x = n + e / 2,
        this.top.y = r,
        this.bottomLeft.x = n,
        this.bottomLeft.y = t,
        this.bottomRight.x = c,
        this.bottomRight.y = t,
        this.bottom.x = n + e / 2,
        this.bottom.y = t,
        this.center.x = n + e / 2,
        this.center.y = t + i / 2,
        this.left.x = n,
        this.left.y = t + i / 2,
        this.right.x = c,
        this.right.y = t + i / 2
    }
},
cc.UIInterfaceOrientationLandscapeLeft = -90,
cc.UIInterfaceOrientationLandscapeRight = 90,
cc.UIInterfaceOrientationPortraitUpsideDown = 180,
cc.UIInterfaceOrientationPortrait = 0,
cc.inputManager = {
    _mousePressed: !1,
    _isRegisterEvent: !1,
    _preTouchPoint: cc.p(0, 0),
    _prevMousePoint: cc.p(0, 0),
    _preTouchPool: [],
    _preTouchPoolPointer: 0,
    _touches: [],
    _touchesIntegerDict: {},
    _indexBitsUsed: 0,
    _maxTouches: 5,
    _accelEnabled: !1,
    _accelInterval: 1 / 30,
    _accelMinus: 1,
    _accelCurTime: 0,
    _acceleration: null,
    _accelDeviceEvent: null,
    _getUnUsedIndex: function() {
        for (var t = this._indexBitsUsed, e = 0; e < this._maxTouches; e++) {
            if (!(1 & t))
                return this._indexBitsUsed |= 1 << e,
                e;
            t >>= 1
        }
        return -1
    },
    _removeUsedIndexBit: function(t) {
        0 > t || t >= this._maxTouches || (t = ~(1 << t),
        this._indexBitsUsed &= t)
    },
    _glView: null,
    handleTouchesBegin: function(t) {
        for (var e, i, n, r = [], c = this._touchesIntegerDict, s = 0, o = t.length; s < o; s++)
            if (e = t[s],
            n = e.getID(),
            i = c[n],
            null == i) {
                var a = this._getUnUsedIndex();
                -1 === a ? cc.log(cc._LogInfos.inputManager_handleTouchesBegin, a) : (i = this._touches[a] = new cc.Touch(e._point.x,e._point.y,e.getID()),
                i._setPrevPoint(e._prevPoint),
                c[n] = a,
                r.push(i))
            }
        0 < r.length && (this._glView._convertTouchesWithScale(r),
        t = new cc.EventTouch(r),
        t._eventCode = cc.EventTouch.EventCode.BEGAN,
        cc.eventManager.dispatchEvent(t))
    },
    handleTouchesMove: function(t) {
        for (var e, i, n = [], r = this._touches, c = 0, s = t.length; c < s; c++)
            e = t[c],
            i = e.getID(),
            i = this._touchesIntegerDict[i],
            null != i && r[i] && (r[i]._setPoint(e._point),
            r[i]._setPrevPoint(e._prevPoint),
            n.push(r[i]));
        0 < n.length && (this._glView._convertTouchesWithScale(n),
        t = new cc.EventTouch(n),
        t._eventCode = cc.EventTouch.EventCode.MOVED,
        cc.eventManager.dispatchEvent(t))
    },
    handleTouchesEnd: function(t) {
        t = this.getSetOfTouchesEndOrCancel(t),
        0 < t.length && (this._glView._convertTouchesWithScale(t),
        t = new cc.EventTouch(t),
        t._eventCode = cc.EventTouch.EventCode.ENDED,
        cc.eventManager.dispatchEvent(t))
    },
    handleTouchesCancel: function(t) {
        t = this.getSetOfTouchesEndOrCancel(t),
        0 < t.length && (this._glView._convertTouchesWithScale(t),
        t = new cc.EventTouch(t),
        t._eventCode = cc.EventTouch.EventCode.CANCELLED,
        cc.eventManager.dispatchEvent(t))
    },
    getSetOfTouchesEndOrCancel: function(t) {
        for (var e, i, n, r = [], c = this._touches, s = this._touchesIntegerDict, o = 0, a = t.length; o < a; o++)
            e = t[o],
            n = e.getID(),
            i = s[n],
            null != i && c[i] && (c[i]._setPoint(e._point),
            c[i]._setPrevPoint(e._prevPoint),
            r.push(c[i]),
            this._removeUsedIndexBit(i),
            delete s[n]);
        return r
    },
    getHTMLElementPosition: function(t) {
        var e = document.documentElement
          , i = window
          , n = null
          , n = cc.isFunction(t.getBoundingClientRect) ? t.getBoundingClientRect() : t instanceof HTMLCanvasElement ? {
            left: 0,
            top: 0,
            width: t.width,
            height: t.height
        } : {
            left: 0,
            top: 0,
            width: parseInt(t.style.width),
            height: parseInt(t.style.height)
        };
        return {
            left: n.left + i.pageXOffset - e.clientLeft,
            top: n.top + i.pageYOffset - e.clientTop,
            width: n.width,
            height: n.height
        }
    },
    getPreTouch: function(t) {
        for (var e = null, i = this._preTouchPool, n = t.getID(), r = i.length - 1; 0 <= r; r--)
            if (i[r].getID() === n) {
                e = i[r];
                break
            }
        return e || (e = t),
        e
    },
    setPreTouch: function(t) {
        for (var e = !1, i = this._preTouchPool, n = t.getID(), r = i.length - 1; 0 <= r; r--)
            if (i[r].getID() === n) {
                i[r] = t,
                e = !0;
                break
            }
        e || (50 >= i.length ? i.push(t) : (i[this._preTouchPoolPointer] = t,
        this._preTouchPoolPointer = (this._preTouchPoolPointer + 1) % 50))
    },
    getTouchByXY: function(t, e, i) {
        var n = this._preTouchPoint;
        return t = this._glView.convertToLocationInView(t, e, i),
        e = new cc.Touch(t.x,t.y),
        e._setPrevPoint(n.x, n.y),
        n.x = t.x,
        n.y = t.y,
        e
    },
    getMouseEvent: function(t, e, i) {
        var n = this._prevMousePoint;
        return this._glView._convertMouseToLocationInView(t, e),
        e = new cc.EventMouse(i),
        e.setLocation(t.x, t.y),
        e._setPrevCursor(n.x, n.y),
        n.x = t.x,
        n.y = t.y,
        e
    },
    getPointByEvent: function(t, e) {
        return null != t.pageX ? {
            x: t.pageX,
            y: t.pageY
        } : (e.left -= document.body.scrollLeft,
        e.top -= document.body.scrollTop,
        {
            x: t.clientX,
            y: t.clientY
        })
    },
    getTouchesByEvent: function(t, e) {
        for (var i, n, r = [], c = this._glView, s = this._preTouchPoint, o = t.changedTouches.length, a = 0; a < o; a++)
            if (i = t.changedTouches[a]) {
                var h;
                h = cc.sys.BROWSER_TYPE_FIREFOX === cc.sys.browserType ? c.convertToLocationInView(i.pageX, i.pageY, e) : c.convertToLocationInView(i.clientX, i.clientY, e),
                null != i.identifier ? (i = new cc.Touch(h.x,h.y,i.identifier),
                n = this.getPreTouch(i).getLocation(),
                i._setPrevPoint(n.x, n.y),
                this.setPreTouch(i)) : (i = new cc.Touch(h.x,h.y),
                i._setPrevPoint(s.x, s.y)),
                s.x = h.x,
                s.y = h.y,
                r.push(i)
            }
        return r
    },
    registerSystemEvent: function(t) {
        if (!this._isRegisterEvent) {
            this._glView = cc.view;
            var e = this
              , i = "mouse"in cc.sys.capabilities
              , n = "touches"in cc.sys.capabilities
              , r = !1;
            if (cc.sys.isMobile && (r = !0),
            i && (window.addEventListener("mousedown", function() {
                e._mousePressed = !0
            }, !1),
            window.addEventListener("mouseup", function(i) {
                if (!r) {
                    var n = e._mousePressed;
                    if (e._mousePressed = !1,
                    n) {
                        var n = e.getHTMLElementPosition(t)
                          , c = e.getPointByEvent(i, n);
                        cc.rectContainsPoint(new cc.Rect(n.left,n.top,n.width,n.height), c) || (e.handleTouchesEnd([e.getTouchByXY(c.x, c.y, n)]),
                        n = e.getMouseEvent(c, n, cc.EventMouse.UP),
                        n.setButton(i.button),
                        cc.eventManager.dispatchEvent(n))
                    }
                }
            }, !1),
            t.addEventListener("mousedown", function(i) {
                if (!r) {
                    e._mousePressed = !0;
                    var n = e.getHTMLElementPosition(t)
                      , c = e.getPointByEvent(i, n);
                    e.handleTouchesBegin([e.getTouchByXY(c.x, c.y, n)]),
                    n = e.getMouseEvent(c, n, cc.EventMouse.DOWN),
                    n.setButton(i.button),
                    cc.eventManager.dispatchEvent(n),
                    i.stopPropagation(),
                    i.preventDefault(),
                    t.focus()
                }
            }, !1),
            t.addEventListener("mouseup", function(i) {
                if (!r) {
                    e._mousePressed = !1;
                    var n = e.getHTMLElementPosition(t)
                      , c = e.getPointByEvent(i, n);
                    e.handleTouchesEnd([e.getTouchByXY(c.x, c.y, n)]),
                    n = e.getMouseEvent(c, n, cc.EventMouse.UP),
                    n.setButton(i.button),
                    cc.eventManager.dispatchEvent(n),
                    i.stopPropagation(),
                    i.preventDefault()
                }
            }, !1),
            t.addEventListener("mousemove", function(i) {
                if (!r) {
                    var n = e.getHTMLElementPosition(t)
                      , c = e.getPointByEvent(i, n);
                    e.handleTouchesMove([e.getTouchByXY(c.x, c.y, n)]),
                    n = e.getMouseEvent(c, n, cc.EventMouse.MOVE),
                    e._mousePressed ? n.setButton(i.button) : n.setButton(null),
                    cc.eventManager.dispatchEvent(n),
                    i.stopPropagation(),
                    i.preventDefault()
                }
            }, !1),
            t.addEventListener("mousewheel", function(i) {
                var n = e.getHTMLElementPosition(t)
                  , r = e.getPointByEvent(i, n)
                  , n = e.getMouseEvent(r, n, cc.EventMouse.SCROLL);
                n.setButton(i.button),
                n.setScrollData(0, i.wheelDelta),
                cc.eventManager.dispatchEvent(n),
                i.stopPropagation(),
                i.preventDefault()
            }, !1),
            t.addEventListener("DOMMouseScroll", function(i) {
                var n = e.getHTMLElementPosition(t)
                  , r = e.getPointByEvent(i, n)
                  , n = e.getMouseEvent(r, n, cc.EventMouse.SCROLL);
                n.setButton(i.button),
                n.setScrollData(0, -120 * i.detail),
                cc.eventManager.dispatchEvent(n),
                i.stopPropagation(),
                i.preventDefault()
            }, !1)),
            window.navigator.msPointerEnabled) {
                var c, i = {
                    MSPointerDown: e.handleTouchesBegin,
                    MSPointerMove: e.handleTouchesMove,
                    MSPointerUp: e.handleTouchesEnd,
                    MSPointerCancel: e.handleTouchesCancel
                };
                for (c in i)
                    (function(i, n) {
                        t.addEventListener(i, function(i) {
                            var r = e.getHTMLElementPosition(t);
                            r.left -= document.documentElement.scrollLeft,
                            r.top -= document.documentElement.scrollTop,
                            n.call(e, [e.getTouchByXY(i.clientX, i.clientY, r)]),
                            i.stopPropagation()
                        }, !1)
                    }
                    )(c, i[c])
            }
            n && (t.addEventListener("touchstart", function(i) {
                if (i.changedTouches) {
                    var n = e.getHTMLElementPosition(t);
                    n.left -= document.body.scrollLeft,
                    n.top -= document.body.scrollTop,
                    e.handleTouchesBegin(e.getTouchesByEvent(i, n)),
                    i.stopPropagation(),
                    i.preventDefault(),
                    t.focus()
                }
            }, !1),
            t.addEventListener("touchmove", function(i) {
                if (i.changedTouches) {
                    var n = e.getHTMLElementPosition(t);
                    n.left -= document.body.scrollLeft,
                    n.top -= document.body.scrollTop,
                    e.handleTouchesMove(e.getTouchesByEvent(i, n)),
                    i.stopPropagation(),
                    i.preventDefault()
                }
            }, !1),
            t.addEventListener("touchend", function(i) {
                if (i.changedTouches) {
                    var n = e.getHTMLElementPosition(t);
                    n.left -= document.body.scrollLeft,
                    n.top -= document.body.scrollTop,
                    e.handleTouchesEnd(e.getTouchesByEvent(i, n)),
                    i.stopPropagation(),
                    i.preventDefault()
                }
            }, !1),
            t.addEventListener("touchcancel", function(i) {
                if (i.changedTouches) {
                    var n = e.getHTMLElementPosition(t);
                    n.left -= document.body.scrollLeft,
                    n.top -= document.body.scrollTop,
                    e.handleTouchesCancel(e.getTouchesByEvent(i, n)),
                    i.stopPropagation(),
                    i.preventDefault()
                }
            }, !1)),
            this._registerKeyboardEvent(),
            this._registerAccelerometerEvent(),
            this._isRegisterEvent = !0
        }
    },
    _registerKeyboardEvent: function() {},
    _registerAccelerometerEvent: function() {},
    update: function(t) {
        this._accelCurTime > this._accelInterval && (this._accelCurTime -= this._accelInterval,
        cc.eventManager.dispatchEvent(new cc.EventAcceleration(this._acceleration))),
        this._accelCurTime += t
    }
},
_p = cc.inputManager,
_p.setAccelerometerEnabled = function(t) {
    this._accelEnabled !== t && (this._accelEnabled = t,
    t = cc.director.getScheduler(),
    this._accelCurTime = 0,
    t.scheduleUpdate(this))
}
,
_p.setAccelerometerInterval = function(t) {
    this._accelInterval !== t && (this._accelInterval = t)
}
,
_p._registerKeyboardEvent = function() {
    cc._canvas.addEventListener("keydown", function(t) {
        cc.eventManager.dispatchEvent(new cc.EventKeyboard(t.keyCode,(!0))),
        t.stopPropagation(),
        t.preventDefault()
    }, !1),
    cc._canvas.addEventListener("keyup", function(t) {
        cc.eventManager.dispatchEvent(new cc.EventKeyboard(t.keyCode,(!1))),
        t.stopPropagation(),
        t.preventDefault()
    }, !1)
}
,
_p._registerAccelerometerEvent = function() {
    var t = window;
    this._acceleration = new cc.Acceleration,
    this._accelDeviceEvent = t.DeviceMotionEvent || t.DeviceOrientationEvent,
    cc.sys.browserType === cc.sys.BROWSER_TYPE_MOBILE_QQ && (this._accelDeviceEvent = window.DeviceOrientationEvent);
    var e = this._accelDeviceEvent === t.DeviceMotionEvent ? "devicemotion" : "deviceorientation"
      , i = navigator.userAgent;
    (/Android/.test(i) || /Adr/.test(i) && cc.sys.browserType === cc.BROWSER_TYPE_UC) && (this._minus = -1),
    t.addEventListener(e, this.didAccelerate.bind(this), !1)
}
,
_p.didAccelerate = function(t) {
    var e = window;
    if (this._accelEnabled) {
        var i, n, r, c = this._acceleration;
        this._accelDeviceEvent === window.DeviceMotionEvent ? (r = t.accelerationIncludingGravity,
        i = this._accelMinus * r.x * .1,
        n = this._accelMinus * r.y * .1,
        r = .1 * r.z) : (i = t.gamma / 90 * .981,
        n = .981 * -(t.beta / 90),
        r = t.alpha / 90 * .981),
        cc.sys.os === cc.sys.OS_ANDROID ? (c.x = -i,
        c.y = -n) : (c.x = i,
        c.y = n),
        c.z = r,
        c.timestamp = t.timeStamp || Date.now(),
        t = c.x,
        e.orientation === cc.UIInterfaceOrientationLandscapeRight ? (c.x = -c.y,
        c.y = t) : e.orientation === cc.UIInterfaceOrientationLandscapeLeft ? (c.x = c.y,
        c.y = -t) : e.orientation === cc.UIInterfaceOrientationPortraitUpsideDown && (c.x = -c.x,
        c.y = -c.y)
    }
}
,
delete _p,
cc.AffineTransform = function(t, e, i, n, r, c) {
    this.a = t,
    this.b = e,
    this.c = i,
    this.d = n,
    this.tx = r,
    this.ty = c
}
,
cc.affineTransformMake = function(t, e, i, n, r, c) {
    return {
        a: t,
        b: e,
        c: i,
        d: n,
        tx: r,
        ty: c
    }
}
,
cc.pointApplyAffineTransform = function(t, e, i) {
    var n;
    return void 0 === i ? (i = e,
    n = t.x,
    t = t.y) : (n = t,
    t = e),
    {
        x: i.a * n + i.c * t + i.tx,
        y: i.b * n + i.d * t + i.ty
    }
}
,
cc._pointApplyAffineTransform = function(t, e, i) {
    return cc.pointApplyAffineTransform(t, e, i)
}
,
cc.sizeApplyAffineTransform = function(t, e) {
    return {
        width: e.a * t.width + e.c * t.height,
        height: e.b * t.width + e.d * t.height
    }
}
,
cc.affineTransformMakeIdentity = function() {
    return {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
    }
}
,
cc.affineTransformIdentity = function() {
    return {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
    }
}
,
cc.rectApplyAffineTransform = function(t, e) {
    var i = cc.rectGetMinY(t)
      , n = cc.rectGetMinX(t)
      , r = cc.rectGetMaxX(t)
      , c = cc.rectGetMaxY(t)
      , s = cc.pointApplyAffineTransform(n, i, e)
      , i = cc.pointApplyAffineTransform(r, i, e)
      , n = cc.pointApplyAffineTransform(n, c, e)
      , o = cc.pointApplyAffineTransform(r, c, e)
      , r = Math.min(s.x, i.x, n.x, o.x)
      , c = Math.max(s.x, i.x, n.x, o.x)
      , a = Math.min(s.y, i.y, n.y, o.y)
      , s = Math.max(s.y, i.y, n.y, o.y);
    return cc.rect(r, a, c - r, s - a)
}
,
cc._rectApplyAffineTransformIn = function(t, e) {
    var i = cc.rectGetMinY(t)
      , n = cc.rectGetMinX(t)
      , r = cc.rectGetMaxX(t)
      , c = cc.rectGetMaxY(t)
      , s = cc.pointApplyAffineTransform(n, i, e)
      , i = cc.pointApplyAffineTransform(r, i, e)
      , n = cc.pointApplyAffineTransform(n, c, e)
      , o = cc.pointApplyAffineTransform(r, c, e)
      , r = Math.min(s.x, i.x, n.x, o.x)
      , c = Math.max(s.x, i.x, n.x, o.x)
      , a = Math.min(s.y, i.y, n.y, o.y)
      , s = Math.max(s.y, i.y, n.y, o.y);
    return t.x = r,
    t.y = a,
    t.width = c - r,
    t.height = s - a,
    t
}
,
cc.affineTransformTranslate = function(t, e, i) {
    return {
        a: t.a,
        b: t.b,
        c: t.c,
        d: t.d,
        tx: t.tx + t.a * e + t.c * i,
        ty: t.ty + t.b * e + t.d * i
    }
}
,
cc.affineTransformScale = function(t, e, i) {
    return {
        a: t.a * e,
        b: t.b * e,
        c: t.c * i,
        d: t.d * i,
        tx: t.tx,
        ty: t.ty
    }
}
,
cc.affineTransformRotate = function(t, e) {
    var i = Math.sin(e)
      , n = Math.cos(e);
    return {
        a: t.a * n + t.c * i,
        b: t.b * n + t.d * i,
        c: t.c * n - t.a * i,
        d: t.d * n - t.b * i,
        tx: t.tx,
        ty: t.ty
    }
}
,
cc.affineTransformConcat = function(t, e) {
    return {
        a: t.a * e.a + t.b * e.c,
        b: t.a * e.b + t.b * e.d,
        c: t.c * e.a + t.d * e.c,
        d: t.c * e.b + t.d * e.d,
        tx: t.tx * e.a + t.ty * e.c + e.tx,
        ty: t.tx * e.b + t.ty * e.d + e.ty
    }
}
,
cc.affineTransformConcatIn = function(t, e) {
    var i = t.a
      , n = t.b
      , r = t.c
      , c = t.d
      , s = t.tx
      , o = t.ty;
    return t.a = i * e.a + n * e.c,
    t.b = i * e.b + n * e.d,
    t.c = r * e.a + c * e.c,
    t.d = r * e.b + c * e.d,
    t.tx = s * e.a + o * e.c + e.tx,
    t.ty = s * e.b + o * e.d + e.ty,
    t
}
,
cc.affineTransformEqualToTransform = function(t, e) {
    return t.a === e.a && t.b === e.b && t.c === e.c && t.d === e.d && t.tx === e.tx && t.ty === e.ty
}
,
cc.affineTransformInvert = function(t) {
    var e = 1 / (t.a * t.d - t.b * t.c);
    return {
        a: e * t.d,
        b: -e * t.b,
        c: -e * t.c,
        d: e * t.a,
        tx: e * (t.c * t.ty - t.d * t.tx),
        ty: e * (t.b * t.tx - t.a * t.ty)
    }
}
,
cc.POINT_EPSILON = parseFloat("1.192092896e-07F"),
cc.pNeg = function(t) {
    return cc.p(-t.x, -t.y)
}
,
cc.pAdd = function(t, e) {
    return cc.p(t.x + e.x, t.y + e.y)
}
,
cc.pSub = function(t, e) {
    return cc.p(t.x - e.x, t.y - e.y)
}
,
cc.pMult = function(t, e) {
    return cc.p(t.x * e, t.y * e)
}
,
cc.pMidpoint = function(t, e) {
    return cc.pMult(cc.pAdd(t, e), .5)
}
,
cc.pDot = function(t, e) {
    return t.x * e.x + t.y * e.y
}
,
cc.pCross = function(t, e) {
    return t.x * e.y - t.y * e.x
}
,
cc.pPerp = function(t) {
    return cc.p(-t.y, t.x)
}
,
cc.pRPerp = function(t) {
    return cc.p(t.y, -t.x)
}
,
cc.pProject = function(t, e) {
    return cc.pMult(e, cc.pDot(t, e) / cc.pDot(e, e))
}
,
cc.pRotate = function(t, e) {
    return cc.p(t.x * e.x - t.y * e.y, t.x * e.y + t.y * e.x)
}
,
cc.pUnrotate = function(t, e) {
    return cc.p(t.x * e.x + t.y * e.y, t.y * e.x - t.x * e.y)
}
,
cc.pLengthSQ = function(t) {
    return cc.pDot(t, t)
}
,
cc.pDistanceSQ = function(t, e) {
    return cc.pLengthSQ(cc.pSub(t, e))
}
,
cc.pLength = function(t) {
    return Math.sqrt(cc.pLengthSQ(t))
}
,
cc.pDistance = function(t, e) {
    return cc.pLength(cc.pSub(t, e))
}
,
cc.pNormalize = function(t) {
    var e = cc.pLength(t);
    return 0 === e ? cc.p(t) : cc.pMult(t, 1 / e)
}
,
cc.pForAngle = function(t) {
    return cc.p(Math.cos(t), Math.sin(t))
}
,
cc.pToAngle = function(t) {
    return Math.atan2(t.y, t.x)
}
,
cc.clampf = function(t, e, i) {
    if (e > i) {
        var n = e;
        e = i,
        i = n
    }
    return t < e ? e : t < i ? t : i
}
,
cc.pClamp = function(t, e, i) {
    return cc.p(cc.clampf(t.x, e.x, i.x), cc.clampf(t.y, e.y, i.y))
}
,
cc.pFromSize = function(t) {
    return cc.p(t.width, t.height)
}
,
cc.pCompOp = function(t, e) {
    return cc.p(e(t.x), e(t.y))
}
,
cc.pLerp = function(t, e, i) {
    return cc.pAdd(cc.pMult(t, 1 - i), cc.pMult(e, i))
}
,
cc.pFuzzyEqual = function(t, e, i) {
    return t.x - i <= e.x && e.x <= t.x + i && t.y - i <= e.y && e.y <= t.y + i
}
,
cc.pCompMult = function(t, e) {
    return cc.p(t.x * e.x, t.y * e.y)
}
,
cc.pAngleSigned = function(t, e) {
    var i = cc.pNormalize(t)
      , n = cc.pNormalize(e)
      , i = Math.atan2(i.x * n.y - i.y * n.x, cc.pDot(i, n));
    return Math.abs(i) < cc.POINT_EPSILON ? 0 : i
}
,
cc.pAngle = function(t, e) {
    var i = Math.acos(cc.pDot(cc.pNormalize(t), cc.pNormalize(e)));
    return Math.abs(i) < cc.POINT_EPSILON ? 0 : i
}
,
cc.pRotateByAngle = function(t, e, i) {
    t = cc.pSub(t, e);
    var n = Math.cos(i);
    i = Math.sin(i);
    var r = t.x;
    return t.x = r * n - t.y * i + e.x,
    t.y = r * i + t.y * n + e.y,
    t
}
,
cc.pLineIntersect = function(t, e, i, n, r) {
    if (t.x === e.x && t.y === e.y || i.x === n.x && i.y === n.y)
        return !1;
    var c = e.x - t.x;
    e = e.y - t.y;
    var s = n.x - i.x;
    n = n.y - i.y;
    var o = t.x - i.x;
    return t = t.y - i.y,
    i = n * c - s * e,
    r.x = s * t - n * o,
    r.y = c * t - e * o,
    0 === i ? 0 === r.x || 0 === r.y : (r.x /= i,
    r.y /= i,
    !0)
}
,
cc.pSegmentIntersect = function(t, e, i, n) {
    var r = cc.p(0, 0);
    return !!(cc.pLineIntersect(t, e, i, n, r) && 0 <= r.x && 1 >= r.x && 0 <= r.y && 1 >= r.y)
}
,
cc.pIntersectPoint = function(t, e, i, n) {
    var r = cc.p(0, 0);
    return cc.pLineIntersect(t, e, i, n, r) ? (i = cc.p(0, 0),
    i.x = t.x + r.x * (e.x - t.x),
    i.y = t.y + r.x * (e.y - t.y),
    i) : cc.p(0, 0)
}
,
cc.pSameAs = function(t, e) {
    return null != t && null != e && (t.x === e.x && t.y === e.y)
}
,
cc.pZeroIn = function(t) {
    t.x = 0,
    t.y = 0
}
,
cc.pIn = function(t, e) {
    t.x = e.x,
    t.y = e.y
}
,
cc.pMultIn = function(t, e) {
    t.x *= e,
    t.y *= e
}
,
cc.pSubIn = function(t, e) {
    t.x -= e.x,
    t.y -= e.y
}
,
cc.pAddIn = function(t, e) {
    t.x += e.x,
    t.y += e.y
}
,
cc.pNormalizeIn = function(t) {
    cc.pMultIn(t, 1 / Math.sqrt(t.x * t.x + t.y * t.y))
}
,
cc.vertexLineToPolygon = function(t, e, i, n, r) {
    if (r += n,
    !(1 >= r)) {
        e *= .5;
        for (var c, s = r - 1, o = n; o < r; o++) {
            c = 2 * o;
            var a, h = cc.p(t[2 * o], t[2 * o + 1]);
            if (0 === o)
                a = cc.pPerp(cc.pNormalize(cc.pSub(h, cc.p(t[2 * (o + 1)], t[2 * (o + 1) + 1]))));
            else if (o === s)
                a = cc.pPerp(cc.pNormalize(cc.pSub(cc.p(t[2 * (o - 1)], t[2 * (o - 1) + 1]), h)));
            else {
                a = cc.p(t[2 * (o - 1)], t[2 * (o - 1) + 1]);
                var l = cc.p(t[2 * (o + 1)], t[2 * (o + 1) + 1])
                  , u = cc.pNormalize(cc.pSub(l, h))
                  , d = cc.pNormalize(cc.pSub(a, h))
                  , _ = Math.acos(cc.pDot(u, d));
                a = _ < cc.degreesToRadians(70) ? cc.pPerp(cc.pNormalize(cc.pMidpoint(u, d))) : _ < cc.degreesToRadians(170) ? cc.pNormalize(cc.pMidpoint(u, d)) : cc.pPerp(cc.pNormalize(cc.pSub(l, a)))
            }
            a = cc.pMult(a, e),
            i[2 * c] = h.x + a.x,
            i[2 * c + 1] = h.y + a.y,
            i[2 * (c + 1)] = h.x - a.x,
            i[2 * (c + 1) + 1] = h.y - a.y
        }
        for (o = 0 === n ? 0 : n - 1; o < s; o++)
            c = 2 * o,
            t = c + 2,
            e = cc.vertex2(i[2 * c], i[2 * c + 1]),
            r = cc.vertex2(i[2 * (c + 1)], i[2 * (c + 1) + 1]),
            c = cc.vertex2(i[2 * t], i[2 * t]),
            n = cc.vertex2(i[2 * (t + 1)], i[2 * (t + 1) + 1]),
            e = !cc.vertexLineIntersect(e.x, e.y, n.x, n.y, r.x, r.y, c.x, c.y),
            !e.isSuccess && (0 > e.value || 1 < e.value) && (e.isSuccess = !0),
            e.isSuccess && (i[2 * t] = n.x,
            i[2 * t + 1] = n.y,
            i[2 * (t + 1)] = c.x,
            i[2 * (t + 1) + 1] = c.y)
    }
}
,
cc.vertexLineIntersect = function(t, e, i, n, r, c, s, o) {
    return t === i && e === n || r === s && c === o ? {
        isSuccess: !1,
        value: 0
    } : (i -= t,
    n -= e,
    r -= t,
    c -= e,
    s -= t,
    o -= e,
    t = Math.sqrt(i * i + n * n),
    i /= t,
    n /= t,
    e = r * i + c * n,
    c = c * i - r * n,
    r = e,
    e = s * i + o * n,
    o = o * i - s * n,
    s = e,
    c === o ? {
        isSuccess: !1,
        value: 0
    } : {
        isSuccess: !0,
        value: (s + (r - s) * o / (o - c)) / t
    })
}
,
cc.vertexListIsClockwise = function(t) {
    for (var e = 0, i = t.length; e < i; e++) {
        var n = t[(e + 1) % i]
          , r = t[(e + 2) % i];
        if (0 < cc.pCross(cc.pSub(n, t[e]), cc.pSub(r, n)))
            return !1
    }
    return !0
}
,
cc.CGAffineToGL = function(t, e) {
    e[2] = e[3] = e[6] = e[7] = e[8] = e[9] = e[11] = e[14] = 0,
    e[10] = e[15] = 1,
    e[0] = t.a,
    e[4] = t.c,
    e[12] = t.tx,
    e[1] = t.b,
    e[5] = t.d,
    e[13] = t.ty
}
,
cc.GLToCGAffine = function(t, e) {
    e.a = t[0],
    e.c = t[4],
    e.tx = t[12],
    e.b = t[1],
    e.d = t[5],
    e.ty = t[13]
}
,
cc.Touch = cc.Class.extend({
    _point: null,
    _prevPoint: null,
    _id: 0,
    _startPointCaptured: !1,
    _startPoint: null,
    ctor: function(t, e, i) {
        this.setTouchInfo(i, t, e)
    },
    getLocation: function() {
        return {
            x: this._point.x,
            y: this._point.y
        }
    },
    getLocationX: function() {
        return this._point.x
    },
    getLocationY: function() {
        return this._point.y
    },
    getPreviousLocation: function() {
        return {
            x: this._prevPoint.x,
            y: this._prevPoint.y
        }
    },
    getStartLocation: function() {
        return {
            x: this._startPoint.x,
            y: this._startPoint.y
        }
    },
    getDelta: function() {
        return cc.pSub(this._point, this._prevPoint)
    },
    getLocationInView: function() {
        return {
            x: this._point.x,
            y: this._point.y
        }
    },
    getPreviousLocationInView: function() {
        return {
            x: this._prevPoint.x,
            y: this._prevPoint.y
        }
    },
    getStartLocationInView: function() {
        return {
            x: this._startPoint.x,
            y: this._startPoint.y
        }
    },
    getID: function() {
        return this._id
    },
    getId: function() {
        return cc.log("getId is deprecated. Please use getID instead."),
        this._id
    },
    setTouchInfo: function(t, e, i) {
        this._prevPoint = this._point,
        this._point = cc.p(e || 0, i || 0),
        this._id = t,
        this._startPointCaptured || (this._startPoint = cc.p(this._point),
        this._startPointCaptured = !0)
    },
    _setPoint: function(t, e) {
        void 0 === e ? (this._point.x = t.x,
        this._point.y = t.y) : (this._point.x = t,
        this._point.y = e)
    },
    _setPrevPoint: function(t, e) {
        this._prevPoint = void 0 === e ? cc.p(t.x, t.y) : cc.p(t || 0, e || 0)
    }
}),
cc.Event = cc.Class.extend({
    _type: 0,
    _isStopped: !1,
    _currentTarget: null,
    _setCurrentTarget: function(t) {
        this._currentTarget = t
    },
    ctor: function(t) {
        this._type = t
    },
    getType: function() {
        return this._type
    },
    stopPropagation: function() {
        this._isStopped = !0
    },
    isStopped: function() {
        return this._isStopped
    },
    getCurrentTarget: function() {
        return this._currentTarget
    }
}),
cc.Event.TOUCH = 0,
cc.Event.KEYBOARD = 1,
cc.Event.ACCELERATION = 2,
cc.Event.MOUSE = 3,
cc.Event.FOCUS = 4,
cc.Event.CUSTOM = 6,
cc.EventCustom = cc.Event.extend({
    _eventName: null,
    _userData: null,
    ctor: function(t) {
        cc.Event.prototype.ctor.call(this, cc.Event.CUSTOM),
        this._eventName = t
    },
    setUserData: function(t) {
        this._userData = t
    },
    getUserData: function() {
        return this._userData
    },
    getEventName: function() {
        return this._eventName
    }
}),
cc.EventMouse = cc.Event.extend({
    _eventType: 0,
    _button: 0,
    _x: 0,
    _y: 0,
    _prevX: 0,
    _prevY: 0,
    _scrollX: 0,
    _scrollY: 0,
    ctor: function(t) {
        cc.Event.prototype.ctor.call(this, cc.Event.MOUSE),
        this._eventType = t
    },
    setScrollData: function(t, e) {
        this._scrollX = t,
        this._scrollY = e
    },
    getScrollX: function() {
        return this._scrollX
    },
    getScrollY: function() {
        return this._scrollY
    },
    setLocation: function(t, e) {
        this._x = t,
        this._y = e
    },
    getLocation: function() {
        return {
            x: this._x,
            y: this._y
        }
    },
    getLocationInView: function() {
        return {
            x: this._x,
            y: cc.view._designResolutionSize.height - this._y
        }
    },
    _setPrevCursor: function(t, e) {
        this._prevX = t,
        this._prevY = e
    },
    getDelta: function() {
        return {
            x: this._x - this._prevX,
            y: this._y - this._prevY
        }
    },
    getDeltaX: function() {
        return this._x - this._prevX
    },
    getDeltaY: function() {
        return this._y - this._prevY
    },
    setButton: function(t) {
        this._button = t
    },
    getButton: function() {
        return this._button
    },
    getLocationX: function() {
        return this._x
    },
    getLocationY: function() {
        return this._y
    }
}),
cc.EventMouse.NONE = 0,
cc.EventMouse.DOWN = 1,
cc.EventMouse.UP = 2,
cc.EventMouse.MOVE = 3,
cc.EventMouse.SCROLL = 4,
cc.EventMouse.BUTTON_LEFT = 0,
cc.EventMouse.BUTTON_RIGHT = 2,
cc.EventMouse.BUTTON_MIDDLE = 1,
cc.EventMouse.BUTTON_4 = 3,
cc.EventMouse.BUTTON_5 = 4,
cc.EventMouse.BUTTON_6 = 5,
cc.EventMouse.BUTTON_7 = 6,
cc.EventMouse.BUTTON_8 = 7,
cc.EventTouch = cc.Event.extend({
    _eventCode: 0,
    _touches: null,
    ctor: function(t) {
        cc.Event.prototype.ctor.call(this, cc.Event.TOUCH),
        this._touches = t || []
    },
    getEventCode: function() {
        return this._eventCode
    },
    getTouches: function() {
        return this._touches
    },
    _setEventCode: function(t) {
        this._eventCode = t
    },
    _setTouches: function(t) {
        this._touches = t
    }
}),
cc.EventTouch.MAX_TOUCHES = 5,
cc.EventTouch.EventCode = {
    BEGAN: 0,
    MOVED: 1,
    ENDED: 2,
    CANCELLED: 3
},
cc.EventFocus = cc.Event.extend({
    _widgetGetFocus: null,
    _widgetLoseFocus: null,
    ctor: function(t, e) {
        cc.Event.prototype.ctor.call(this, cc.Event.FOCUS),
        this._widgetGetFocus = e,
        this._widgetLoseFocus = t
    }
}),
cc.EventListener = cc.Class.extend({
    _onEvent: null,
    _type: 0,
    _listenerID: null,
    _registered: !1,
    _fixedPriority: 0,
    _node: null,
    _paused: !0,
    _isEnabled: !0,
    ctor: function(t, e, i) {
        this._onEvent = i,
        this._type = t || 0,
        this._listenerID = e || ""
    },
    _setPaused: function(t) {
        this._paused = t
    },
    _isPaused: function() {
        return this._paused
    },
    _setRegistered: function(t) {
        this._registered = t
    },
    _isRegistered: function() {
        return this._registered
    },
    _getType: function() {
        return this._type
    },
    _getListenerID: function() {
        return this._listenerID
    },
    _setFixedPriority: function(t) {
        this._fixedPriority = t
    },
    _getFixedPriority: function() {
        return this._fixedPriority
    },
    _setSceneGraphPriority: function(t) {
        this._node = t
    },
    _getSceneGraphPriority: function() {
        return this._node
    },
    checkAvailable: function() {
        return null !== this._onEvent
    },
    clone: function() {
        return null
    },
    setEnabled: function(t) {
        this._isEnabled = t
    },
    isEnabled: function() {
        return this._isEnabled
    },
    retain: function() {},
    release: function() {}
}),
cc.EventListener.UNKNOWN = 0,
cc.EventListener.TOUCH_ONE_BY_ONE = 1,
cc.EventListener.TOUCH_ALL_AT_ONCE = 2,
cc.EventListener.KEYBOARD = 3,
cc.EventListener.MOUSE = 4,
cc.EventListener.ACCELERATION = 5,
cc.EventListener.ACCELERATION = 6,
cc.EventListener.CUSTOM = 8,
cc.EventListener.FOCUS = 7,
cc._EventListenerCustom = cc.EventListener.extend({
    _onCustomEvent: null,
    ctor: function(t, e) {
        this._onCustomEvent = e;
        var i = this;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.CUSTOM, t, function(t) {
            null !== i._onCustomEvent && i._onCustomEvent(t)
        })
    },
    checkAvailable: function() {
        return cc.EventListener.prototype.checkAvailable.call(this) && null !== this._onCustomEvent
    },
    clone: function() {
        return new cc._EventListenerCustom(this._listenerID,this._onCustomEvent)
    }
}),
cc._EventListenerCustom.create = function(t, e) {
    return new cc._EventListenerCustom(t,e)
}
,
cc._EventListenerMouse = cc.EventListener.extend({
    onMouseDown: null,
    onMouseUp: null,
    onMouseMove: null,
    onMouseScroll: null,
    ctor: function() {
        var t = this;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.MOUSE, cc._EventListenerMouse.LISTENER_ID, function(e) {
            var i = cc.EventMouse;
            switch (e._eventType) {
            case i.DOWN:
                t.onMouseDown && t.onMouseDown(e);
                break;
            case i.UP:
                t.onMouseUp && t.onMouseUp(e);
                break;
            case i.MOVE:
                t.onMouseMove && t.onMouseMove(e);
                break;
            case i.SCROLL:
                t.onMouseScroll && t.onMouseScroll(e)
            }
        })
    },
    clone: function() {
        var t = new cc._EventListenerMouse;
        return t.onMouseDown = this.onMouseDown,
        t.onMouseUp = this.onMouseUp,
        t.onMouseMove = this.onMouseMove,
        t.onMouseScroll = this.onMouseScroll,
        t
    },
    checkAvailable: function() {
        return !0
    }
}),
cc._EventListenerMouse.LISTENER_ID = "__cc_mouse",
cc._EventListenerMouse.create = function() {
    return new cc._EventListenerMouse
}
,
cc._EventListenerTouchOneByOne = cc.EventListener.extend({
    _claimedTouches: null,
    swallowTouches: !1,
    onTouchBegan: null,
    onTouchMoved: null,
    onTouchEnded: null,
    onTouchCancelled: null,
    ctor: function() {
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ONE_BY_ONE, cc._EventListenerTouchOneByOne.LISTENER_ID, null),
        this._claimedTouches = []
    },
    setSwallowTouches: function(t) {
        this.swallowTouches = t
    },
    isSwallowTouches: function() {
        return this.swallowTouches
    },
    clone: function() {
        var t = new cc._EventListenerTouchOneByOne;
        return t.onTouchBegan = this.onTouchBegan,
        t.onTouchMoved = this.onTouchMoved,
        t.onTouchEnded = this.onTouchEnded,
        t.onTouchCancelled = this.onTouchCancelled,
        t.swallowTouches = this.swallowTouches,
        t
    },
    checkAvailable: function() {
        return !!this.onTouchBegan || (cc.log(cc._LogInfos._EventListenerTouchOneByOne_checkAvailable),
        !1)
    }
}),
cc._EventListenerTouchOneByOne.LISTENER_ID = "__cc_touch_one_by_one",
cc._EventListenerTouchOneByOne.create = function() {
    return new cc._EventListenerTouchOneByOne
}
,
cc._EventListenerTouchAllAtOnce = cc.EventListener.extend({
    onTouchesBegan: null,
    onTouchesMoved: null,
    onTouchesEnded: null,
    onTouchesCancelled: null,
    ctor: function() {
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ALL_AT_ONCE, cc._EventListenerTouchAllAtOnce.LISTENER_ID, null)
    },
    clone: function() {
        var t = new cc._EventListenerTouchAllAtOnce;
        return t.onTouchesBegan = this.onTouchesBegan,
        t.onTouchesMoved = this.onTouchesMoved,
        t.onTouchesEnded = this.onTouchesEnded,
        t.onTouchesCancelled = this.onTouchesCancelled,
        t
    },
    checkAvailable: function() {
        return null !== this.onTouchesBegan || null !== this.onTouchesMoved || null !== this.onTouchesEnded || null !== this.onTouchesCancelled || (cc.log(cc._LogInfos._EventListenerTouchAllAtOnce_checkAvailable),
        !1)
    }
}),
cc._EventListenerTouchAllAtOnce.LISTENER_ID = "__cc_touch_all_at_once",
cc._EventListenerTouchAllAtOnce.create = function() {
    return new cc._EventListenerTouchAllAtOnce
}
,
cc.EventListener.create = function(t) {
    cc.assert(t && t.event, cc._LogInfos.EventListener_create);
    var e = t.event;
    delete t.event;
    var i = null;
    e === cc.EventListener.TOUCH_ONE_BY_ONE ? i = new cc._EventListenerTouchOneByOne : e === cc.EventListener.TOUCH_ALL_AT_ONCE ? i = new cc._EventListenerTouchAllAtOnce : e === cc.EventListener.MOUSE ? i = new cc._EventListenerMouse : e === cc.EventListener.CUSTOM ? (i = new cc._EventListenerCustom(t.eventName,t.callback),
    delete t.eventName,
    delete t.callback) : e === cc.EventListener.KEYBOARD ? i = new cc._EventListenerKeyboard : e === cc.EventListener.ACCELERATION ? (i = new cc._EventListenerAcceleration(t.callback),
    delete t.callback) : e === cc.EventListener.FOCUS && (i = new cc._EventListenerFocus);
    for (var n in t)
        i[n] = t[n];
    return i
}
,
cc._EventListenerFocus = cc.EventListener.extend({
    clone: function() {
        var t = new cc._EventListenerFocus;
        return t.onFocusChanged = this.onFocusChanged,
        t
    },
    checkAvailable: function() {
        return !!this.onFocusChanged || (cc.log("Invalid EventListenerFocus!"),
        !1)
    },
    onFocusChanged: null,
    ctor: function() {
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.FOCUS, cc._EventListenerFocus.LISTENER_ID, function(t) {
            this.onFocusChanged && this.onFocusChanged(t._widgetLoseFocus, t._widgetGetFocus)
        })
    }
}),
cc._EventListenerFocus.LISTENER_ID = "__cc_focus_event",
cc._EventListenerVector = cc.Class.extend({
    _fixedListeners: null,
    _sceneGraphListeners: null,
    gt0Index: 0,
    ctor: function() {
        this._fixedListeners = [],
        this._sceneGraphListeners = []
    },
    size: function() {
        return this._fixedListeners.length + this._sceneGraphListeners.length
    },
    empty: function() {
        return 0 === this._fixedListeners.length && 0 === this._sceneGraphListeners.length
    },
    push: function(t) {
        0 === t._getFixedPriority() ? this._sceneGraphListeners.push(t) : this._fixedListeners.push(t)
    },
    clearSceneGraphListeners: function() {
        this._sceneGraphListeners.length = 0
    },
    clearFixedListeners: function() {
        this._fixedListeners.length = 0
    },
    clear: function() {
        this._sceneGraphListeners.length = 0,
        this._fixedListeners.length = 0
    },
    getFixedPriorityListeners: function() {
        return this._fixedListeners
    },
    getSceneGraphPriorityListeners: function() {
        return this._sceneGraphListeners
    }
}),
cc.__getListenerID = function(t) {
    var e = cc.Event
      , i = t.getType();
    return i === e.ACCELERATION ? cc._EventListenerAcceleration.LISTENER_ID : i === e.CUSTOM ? t.getEventName() : i === e.KEYBOARD ? cc._EventListenerKeyboard.LISTENER_ID : i === e.MOUSE ? cc._EventListenerMouse.LISTENER_ID : i === e.FOCUS ? cc._EventListenerFocus.LISTENER_ID : (i === e.TOUCH && cc.log(cc._LogInfos.__getListenerID),
    "")
}
,
cc.eventManager = {
    DIRTY_NONE: 0,
    DIRTY_FIXED_PRIORITY: 1,
    DIRTY_SCENE_GRAPH_PRIORITY: 2,
    DIRTY_ALL: 3,
    _listenersMap: {},
    _priorityDirtyFlagMap: {},
    _nodeListenersMap: {},
    _nodePriorityMap: {},
    _globalZOrderNodeMap: {},
    _toAddedListeners: [],
    _dirtyNodes: [],
    _inDispatch: 0,
    _isEnabled: !1,
    _nodePriorityIndex: 0,
    _internalCustomListenerIDs: [cc.game.EVENT_HIDE, cc.game.EVENT_SHOW],
    _setDirtyForNode: function(t) {
        null != this._nodeListenersMap[t.__instanceId] && this._dirtyNodes.push(t),
        t = t.getChildren();
        for (var e = 0, i = t.length; e < i; e++)
            this._setDirtyForNode(t[e])
    },
    pauseTarget: function(t, e) {
        var i, n, r = this._nodeListenersMap[t.__instanceId];
        if (r)
            for (i = 0,
            n = r.length; i < n; i++)
                r[i]._setPaused(!0);
        if (!0 === e)
            for (r = t.getChildren(),
            i = 0,
            n = r.length; i < n; i++)
                this.pauseTarget(r[i], !0)
    },
    resumeTarget: function(t, e) {
        var i, n, r = this._nodeListenersMap[t.__instanceId];
        if (r)
            for (i = 0,
            n = r.length; i < n; i++)
                r[i]._setPaused(!1);
        if (this._setDirtyForNode(t),
        !0 === e)
            for (r = t.getChildren(),
            i = 0,
            n = r.length; i < n; i++)
                this.resumeTarget(r[i], !0)
    },
    _addListener: function(t) {
        0 === this._inDispatch ? this._forceAddEventListener(t) : this._toAddedListeners.push(t)
    },
    _forceAddEventListener: function(t) {
        var e = t._getListenerID()
          , i = this._listenersMap[e];
        i || (i = new cc._EventListenerVector,
        this._listenersMap[e] = i),
        i.push(t),
        0 === t._getFixedPriority() ? (this._setDirty(e, this.DIRTY_SCENE_GRAPH_PRIORITY),
        e = t._getSceneGraphPriority(),
        null === e && cc.log(cc._LogInfos.eventManager__forceAddEventListener),
        this._associateNodeAndEventListener(e, t),
        e.isRunning() && this.resumeTarget(e)) : this._setDirty(e, this.DIRTY_FIXED_PRIORITY)
    },
    _getListeners: function(t) {
        return this._listenersMap[t]
    },
    _updateDirtyFlagForSceneGraph: function() {
        if (0 !== this._dirtyNodes.length) {
            for (var t, e, i = this._dirtyNodes, n = this._nodeListenersMap, r = 0, c = i.length; r < c; r++)
                if (t = n[i[r].__instanceId])
                    for (var s = 0, o = t.length; s < o; s++)
                        (e = t[s]) && this._setDirty(e._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY);
            this._dirtyNodes.length = 0
        }
    },
    _removeAllListenersInVector: function(t) {
        if (t)
            for (var e, i = 0; i < t.length; )
                e = t[i],
                e._setRegistered(!1),
                null != e._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(e._getSceneGraphPriority(), e),
                e._setSceneGraphPriority(null)),
                0 === this._inDispatch ? cc.arrayRemoveObject(t, e) : ++i
    },
    _removeListenersForListenerID: function(t) {
        var e = this._listenersMap[t];
        if (e) {
            var i = e.getFixedPriorityListeners()
              , n = e.getSceneGraphPriorityListeners();
            this._removeAllListenersInVector(n),
            this._removeAllListenersInVector(i),
            delete this._priorityDirtyFlagMap[t],
            this._inDispatch || (e.clear(),
            delete this._listenersMap[t])
        }
        for (i = this._toAddedListeners,
        e = 0; e < i.length; )
            (n = i[e]) && n._getListenerID() === t ? cc.arrayRemoveObject(i, n) : ++e
    },
    _sortEventListeners: function(t) {
        var e = this.DIRTY_NONE
          , i = this._priorityDirtyFlagMap;
        i[t] && (e = i[t]),
        e !== this.DIRTY_NONE && (i[t] = this.DIRTY_NONE,
        e & this.DIRTY_FIXED_PRIORITY && this._sortListenersOfFixedPriority(t),
        e & this.DIRTY_SCENE_GRAPH_PRIORITY && ((e = cc.director.getRunningScene()) ? this._sortListenersOfSceneGraphPriority(t, e) : i[t] = this.DIRTY_SCENE_GRAPH_PRIORITY))
    },
    _sortListenersOfSceneGraphPriority: function(t, e) {
        var i = this._getListeners(t);
        if (i) {
            var n = i.getSceneGraphPriorityListeners();
            n && 0 !== n.length && (this._nodePriorityIndex = 0,
            this._nodePriorityMap = {},
            this._visitTarget(e, !0),
            i.getSceneGraphPriorityListeners().sort(this._sortEventListenersOfSceneGraphPriorityDes))
        }
    },
    _sortEventListenersOfSceneGraphPriorityDes: function(t, e) {
        var i = cc.eventManager._nodePriorityMap
          , n = t._getSceneGraphPriority()
          , r = e._getSceneGraphPriority();
        return e && r && i[r.__instanceId] ? t && n && i[n.__instanceId] ? i[e._getSceneGraphPriority().__instanceId] - i[t._getSceneGraphPriority().__instanceId] : 1 : -1
    },
    _sortListenersOfFixedPriority: function(t) {
        if (t = this._listenersMap[t]) {
            var e = t.getFixedPriorityListeners();
            if (e && 0 !== e.length) {
                e.sort(this._sortListenersOfFixedPriorityAsc);
                for (var i = 0, n = e.length; i < n && !(0 <= e[i]._getFixedPriority()); )
                    ++i;
                t.gt0Index = i
            }
        }
    },
    _sortListenersOfFixedPriorityAsc: function(t, e) {
        return t._getFixedPriority() - e._getFixedPriority()
    },
    _onUpdateListeners: function(t) {
        if (t = this._listenersMap[t]) {
            var e, i, n = t.getFixedPriorityListeners(), r = t.getSceneGraphPriorityListeners();
            if (r)
                for (e = 0; e < r.length; )
                    i = r[e],
                    i._isRegistered() ? ++e : cc.arrayRemoveObject(r, i);
            if (n)
                for (e = 0; e < n.length; )
                    i = n[e],
                    i._isRegistered() ? ++e : cc.arrayRemoveObject(n, i);
            r && 0 === r.length && t.clearSceneGraphListeners(),
            n && 0 === n.length && t.clearFixedListeners()
        }
    },
    _updateListeners: function(t) {
        var e = this._inDispatch;
        if (cc.assert(0 < e, cc._LogInfos.EventManager__updateListeners),
        !(1 < e)) {
            t.getType() === cc.Event.TOUCH ? (this._onUpdateListeners(cc._EventListenerTouchOneByOne.LISTENER_ID),
            this._onUpdateListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID)) : this._onUpdateListeners(cc.__getListenerID(t)),
            cc.assert(1 === e, cc._LogInfos.EventManager__updateListeners_2),
            t = this._listenersMap;
            var i, e = this._priorityDirtyFlagMap;
            for (i in t)
                t[i].empty() && (delete e[i],
                delete t[i]);
            if (i = this._toAddedListeners,
            0 !== i.length) {
                for (t = 0,
                e = i.length; t < e; t++)
                    this._forceAddEventListener(i[t]);
                this._toAddedListeners.length = 0
            }
        }
    },
    _onTouchEventCallback: function(t, e) {
        if (!t._isRegistered)
            return !1;
        var i = e.event
          , n = e.selTouch;
        i._setCurrentTarget(t._node);
        var r, c = !1, s = i.getEventCode(), o = cc.EventTouch.EventCode;
        return s === o.BEGAN ? t.onTouchBegan && (c = t.onTouchBegan(n, i)) && t._registered && t._claimedTouches.push(n) : 0 < t._claimedTouches.length && -1 !== (r = t._claimedTouches.indexOf(n)) && (c = !0,
        s === o.MOVED && t.onTouchMoved ? t.onTouchMoved(n, i) : s === o.ENDED ? (t.onTouchEnded && t.onTouchEnded(n, i),
        t._registered && t._claimedTouches.splice(r, 1)) : s === o.CANCELLED && (t.onTouchCancelled && t.onTouchCancelled(n, i),
        t._registered && t._claimedTouches.splice(r, 1))),
        i.isStopped() ? (cc.eventManager._updateListeners(i),
        !0) : !!(c && t._registered && t.swallowTouches) && (e.needsMutableSet && e.touches.splice(n, 1),
        !0)
    },
    _dispatchTouchEvent: function(t) {
        this._sortEventListeners(cc._EventListenerTouchOneByOne.LISTENER_ID),
        this._sortEventListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
        var e = this._getListeners(cc._EventListenerTouchOneByOne.LISTENER_ID)
          , i = this._getListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
        if (null !== e || null !== i) {
            var n = t.getTouches()
              , r = cc.copyArray(n)
              , c = {
                event: t,
                needsMutableSet: e && i,
                touches: r,
                selTouch: null
            };
            if (e)
                for (var s = 0; s < n.length; s++)
                    if (c.selTouch = n[s],
                    this._dispatchEventToListeners(e, this._onTouchEventCallback, c),
                    t.isStopped())
                        return;
            if (i && 0 < r.length && (this._dispatchEventToListeners(i, this._onTouchesEventCallback, {
                event: t,
                touches: r
            }),
            t.isStopped()))
                return;
            this._updateListeners(t)
        }
    },
    _onTouchesEventCallback: function(t, e) {
        if (!t._registered)
            return !1;
        var i = cc.EventTouch.EventCode
          , n = e.event
          , r = e.touches
          , c = n.getEventCode();
        return n._setCurrentTarget(t._node),
        c === i.BEGAN && t.onTouchesBegan ? t.onTouchesBegan(r, n) : c === i.MOVED && t.onTouchesMoved ? t.onTouchesMoved(r, n) : c === i.ENDED && t.onTouchesEnded ? t.onTouchesEnded(r, n) : c === i.CANCELLED && t.onTouchesCancelled && t.onTouchesCancelled(r, n),
        !!n.isStopped() && (cc.eventManager._updateListeners(n),
        !0)
    },
    _associateNodeAndEventListener: function(t, e) {
        var i = this._nodeListenersMap[t.__instanceId];
        i || (i = [],
        this._nodeListenersMap[t.__instanceId] = i),
        i.push(e)
    },
    _dissociateNodeAndEventListener: function(t, e) {
        var i = this._nodeListenersMap[t.__instanceId];
        i && (cc.arrayRemoveObject(i, e),
        0 === i.length && delete this._nodeListenersMap[t.__instanceId])
    },
    _dispatchEventToListeners: function(t, e, i) {
        var n, r = !1, c = t.getFixedPriorityListeners(), s = t.getSceneGraphPriorityListeners(), o = 0;
        if (c && 0 !== c.length)
            for (; o < t.gt0Index; ++o)
                if (n = c[o],
                n.isEnabled() && !n._isPaused() && n._isRegistered() && e(n, i)) {
                    r = !0;
                    break
                }
        if (s && !r)
            for (t = 0; t < s.length; t++)
                if (n = s[t],
                n.isEnabled() && !n._isPaused() && n._isRegistered() && e(n, i)) {
                    r = !0;
                    break
                }
        if (c && !r)
            for (; o < c.length && (n = c[o],
            !n.isEnabled() || n._isPaused() || !n._isRegistered() || !e(n, i)); ++o)
                ;
    },
    _setDirty: function(t, e) {
        var i = this._priorityDirtyFlagMap;
        i[t] = null == i[t] ? e : e | i[t]
    },
    _visitTarget: function(t, e) {
        var i = t.getChildren()
          , n = 0
          , r = i.length
          , c = this._globalZOrderNodeMap
          , s = this._nodeListenersMap;
        if (0 < r) {
            for (var o; n < r && ((o = i[n]) && 0 > o.getLocalZOrder()); n++)
                this._visitTarget(o, !1);
            for (null != s[t.__instanceId] && (c[t.getGlobalZOrder()] || (c[t.getGlobalZOrder()] = []),
            c[t.getGlobalZOrder()].push(t.__instanceId)); n < r; n++)
                (o = i[n]) && this._visitTarget(o, !1)
        } else
            null != s[t.__instanceId] && (c[t.getGlobalZOrder()] || (c[t.getGlobalZOrder()] = []),
            c[t.getGlobalZOrder()].push(t.__instanceId));
        if (e) {
            var a, i = [];
            for (a in c)
                i.push(a);
            for (i.sort(this._sortNumberAsc),
            a = i.length,
            o = this._nodePriorityMap,
            n = 0; n < a; n++)
                for (r = c[i[n]],
                s = 0; s < r.length; s++)
                    o[r[s]] = ++this._nodePriorityIndex;
            this._globalZOrderNodeMap = {}
        }
    },
    _sortNumberAsc: function(t, e) {
        return t - e
    },
    addListener: function(t, e) {
        if (cc.assert(t && e, cc._LogInfos.eventManager_addListener_2),
        t instanceof cc.EventListener) {
            if (t._isRegistered())
                return void cc.log(cc._LogInfos.eventManager_addListener_4)
        } else
            cc.assert(!cc.isNumber(e), cc._LogInfos.eventManager_addListener_3),
            t = cc.EventListener.create(t);
        if (t.checkAvailable()) {
            if (cc.isNumber(e)) {
                if (0 === e)
                    return void cc.log(cc._LogInfos.eventManager_addListener);
                t._setSceneGraphPriority(null),
                t._setFixedPriority(e),
                t._setRegistered(!0),
                t._setPaused(!1)
            } else
                t._setSceneGraphPriority(e),
                t._setFixedPriority(0),
                t._setRegistered(!0);
            return this._addListener(t),
            t
        }
    },
    addCustomListener: function(t, e) {
        var i = new cc._EventListenerCustom(t,e);
        return this.addListener(i, 1),
        i
    },
    removeListener: function(t) {
        if (null != t) {
            var e, i, n = this._listenersMap;
            for (i in n) {
                var r = n[i]
                  , c = r.getFixedPriorityListeners();
                if (e = r.getSceneGraphPriorityListeners(),
                (e = this._removeListenerInVector(e, t)) ? this._setDirty(t._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY) : (e = this._removeListenerInVector(c, t)) && this._setDirty(t._getListenerID(), this.DIRTY_FIXED_PRIORITY),
                r.empty() && (delete this._priorityDirtyFlagMap[t._getListenerID()],
                delete n[i]),
                e)
                    break
            }
            if (!e)
                for (n = this._toAddedListeners,
                i = 0,
                r = n.length; i < r; i++)
                    if (c = n[i],
                    c === t) {
                        cc.arrayRemoveObject(n, c),
                        c._setRegistered(!1);
                        break
                    }
        }
    },
    _removeListenerInCallback: function(t, e) {
        if (null == t)
            return !1;
        for (var i = 0, n = t.length; i < n; i++) {
            var r = t[i];
            if (r._onCustomEvent === e || r._onEvent === e)
                return r._setRegistered(!1),
                null != r._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(r._getSceneGraphPriority(), r),
                r._setSceneGraphPriority(null)),
                0 === this._inDispatch && cc.arrayRemoveObject(t, r),
                !0
        }
        return !1
    },
    _removeListenerInVector: function(t, e) {
        if (null == t)
            return !1;
        for (var i = 0, n = t.length; i < n; i++) {
            var r = t[i];
            if (r === e)
                return r._setRegistered(!1),
                null != r._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(r._getSceneGraphPriority(), r),
                r._setSceneGraphPriority(null)),
                0 === this._inDispatch && cc.arrayRemoveObject(t, r),
                !0
        }
        return !1
    },
    removeListeners: function(t, e) {
        if (t instanceof cc.Node) {
            delete this._nodePriorityMap[t.__instanceId],
            cc.arrayRemoveObject(this._dirtyNodes, t);
            var i = this._nodeListenersMap[t.__instanceId];
            if (i) {
                for (var n = cc.copyArray(i), i = 0; i < n.length; i++)
                    this.removeListener(n[i]);
                n.length = 0
            }
            for (n = this._toAddedListeners,
            i = 0; i < n.length; ) {
                var r = n[i];
                r._getSceneGraphPriority() === t ? (r._setSceneGraphPriority(null),
                r._setRegistered(!1),
                n.splice(i, 1)) : ++i
            }
            if (!0 === e)
                for (n = t.getChildren(),
                i = 0,
                r = n.length; i < r; i++)
                    this.removeListeners(n[i], !0)
        } else
            t === cc.EventListener.TOUCH_ONE_BY_ONE ? this._removeListenersForListenerID(cc._EventListenerTouchOneByOne.LISTENER_ID) : t === cc.EventListener.TOUCH_ALL_AT_ONCE ? this._removeListenersForListenerID(cc._EventListenerTouchAllAtOnce.LISTENER_ID) : t === cc.EventListener.MOUSE ? this._removeListenersForListenerID(cc._EventListenerMouse.LISTENER_ID) : t === cc.EventListener.ACCELERATION ? this._removeListenersForListenerID(cc._EventListenerAcceleration.LISTENER_ID) : t === cc.EventListener.KEYBOARD ? this._removeListenersForListenerID(cc._EventListenerKeyboard.LISTENER_ID) : cc.log(cc._LogInfos.eventManager_removeListeners)
    },
    removeCustomListeners: function(t) {
        this._removeListenersForListenerID(t)
    },
    removeAllListeners: function() {
        var t, e = this._listenersMap, i = this._internalCustomListenerIDs;
        for (t in e)
            -1 === i.indexOf(t) && this._removeListenersForListenerID(t)
    },
    setPriority: function(t, e) {
        if (null != t) {
            var i, n = this._listenersMap;
            for (i in n) {
                var r = n[i].getFixedPriorityListeners();
                if (r && -1 !== r.indexOf(t)) {
                    null != t._getSceneGraphPriority() && cc.log(cc._LogInfos.eventManager_setPriority),
                    t._getFixedPriority() !== e && (t._setFixedPriority(e),
                    this._setDirty(t._getListenerID(), this.DIRTY_FIXED_PRIORITY));
                    break
                }
            }
        }
    },
    setEnabled: function(t) {
        this._isEnabled = t
    },
    isEnabled: function() {
        return this._isEnabled
    },
    dispatchEvent: function(t) {
        if (this._isEnabled) {
            if (this._updateDirtyFlagForSceneGraph(),
            this._inDispatch++,
            !t || !t.getType)
                throw Error("event is undefined");
            if (t.getType() === cc.Event.TOUCH)
                this._dispatchTouchEvent(t);
            else {
                var e = cc.__getListenerID(t);
                this._sortEventListeners(e),
                e = this._listenersMap[e],
                null != e && this._dispatchEventToListeners(e, this._onListenerCallback, t),
                this._updateListeners(t)
            }
            this._inDispatch--
        }
    },
    _onListenerCallback: function(t, e) {
        return e._setCurrentTarget(t._getSceneGraphPriority()),
        t._onEvent(e),
        e.isStopped()
    },
    dispatchCustomEvent: function(t, e) {
        var i = new cc.EventCustom(t);
        i.setUserData(e),
        this.dispatchEvent(i)
    }
},
cc.EventAcceleration = cc.Event.extend({
    _acc: null,
    ctor: function(t) {
        cc.Event.prototype.ctor.call(this, cc.Event.ACCELERATION),
        this._acc = t
    }
}),
cc.EventKeyboard = cc.Event.extend({
    _keyCode: 0,
    _isPressed: !1,
    ctor: function(t, e) {
        cc.Event.prototype.ctor.call(this, cc.Event.KEYBOARD),
        this._keyCode = t,
        this._isPressed = e
    }
}),
cc._EventListenerAcceleration = cc.EventListener.extend({
    _onAccelerationEvent: null,
    ctor: function(t) {
        this._onAccelerationEvent = t;
        var e = this;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.ACCELERATION, cc._EventListenerAcceleration.LISTENER_ID, function(t) {
            e._onAccelerationEvent(t._acc, t)
        })
    },
    checkAvailable: function() {
        return cc.assert(this._onAccelerationEvent, cc._LogInfos._EventListenerAcceleration_checkAvailable),
        !0
    },
    clone: function() {
        return new cc._EventListenerAcceleration(this._onAccelerationEvent)
    }
}),
cc._EventListenerAcceleration.LISTENER_ID = "__cc_acceleration",
cc._EventListenerAcceleration.create = function(t) {
    return new cc._EventListenerAcceleration(t)
}
,
cc._EventListenerKeyboard = cc.EventListener.extend({
    onKeyPressed: null,
    onKeyReleased: null,
    ctor: function() {
        var t = this;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.KEYBOARD, cc._EventListenerKeyboard.LISTENER_ID, function(e) {
            e._isPressed ? t.onKeyPressed && t.onKeyPressed(e._keyCode, e) : t.onKeyReleased && t.onKeyReleased(e._keyCode, e)
        })
    },
    clone: function() {
        var t = new cc._EventListenerKeyboard;
        return t.onKeyPressed = this.onKeyPressed,
        t.onKeyReleased = this.onKeyReleased,
        t
    },
    checkAvailable: function() {
        return null !== this.onKeyPressed || null !== this.onKeyReleased || (cc.log(cc._LogInfos._EventListenerKeyboard_checkAvailable),
        !1)
    }
}),
cc._EventListenerKeyboard.LISTENER_ID = "__cc_keyboard",
cc._EventListenerKeyboard.create = function() {
    return new cc._EventListenerKeyboard
}
,
cc.rendererCanvas = {
    childrenOrderDirty: !0,
    _transformNodePool: [],
    _renderCmds: [],
    _isCacheToCanvasOn: !1,
    _cacheToCanvasCmds: {},
    _cacheInstanceIds: [],
    _currentID: 0,
    _clearColor: cc.color(),
    _clearFillStyle: "rgb(0, 0, 0)",
    getRenderCmd: function(t) {
        return t._createRenderCmd()
    },
    rendering: function(t) {
        var e, i = this._renderCmds, n = cc.view.getScaleX(), r = cc.view.getScaleY(), c = t || cc._renderContext;
        for (c.computeRealOffsetY(),
        t = 0,
        e = i.length; t < e; t++)
            i[t].rendering(c, n, r)
    },
    _renderingToCacheCanvas: function(t, e, i, n) {
        t || cc.log("The context of RenderTexture is invalid."),
        i = cc.isUndefined(i) ? 1 : i,
        n = cc.isUndefined(n) ? 1 : n,
        e = e || this._currentID;
        var r, c, s = this._cacheToCanvasCmds[e];
        for (t.computeRealOffsetY(),
        r = 0,
        c = s.length; r < c; r++)
            s[r].rendering(t, i, n);
        s.length = 0,
        t = this._cacheInstanceIds,
        delete this._cacheToCanvasCmds[e],
        cc.arrayRemoveObject(t, e),
        0 === t.length ? this._isCacheToCanvasOn = !1 : this._currentID = t[t.length - 1]
    },
    _turnToCacheMode: function(t) {
        this._isCacheToCanvasOn = !0,
        t = t || 0,
        this._cacheToCanvasCmds[t] = [],
        -1 === this._cacheInstanceIds.indexOf(t) && this._cacheInstanceIds.push(t),
        this._currentID = t
    },
    _turnToNormalMode: function() {
        this._isCacheToCanvasOn = !1
    },
    resetFlag: function() {
        this.childrenOrderDirty = !1,
        this._transformNodePool.length = 0
    },
    transform: function() {
        var t = this._transformNodePool;
        t.sort(this._sortNodeByLevelAsc);
        for (var e = 0, i = t.length; e < i; e++)
            0 !== t[e]._dirtyFlag && t[e].updateStatus();
        t.length = 0
    },
    transformDirty: function() {
        return 0 < this._transformNodePool.length
    },
    _sortNodeByLevelAsc: function(t, e) {
        return t._curLevel - e._curLevel
    },
    pushDirtyNode: function(t) {
        this._transformNodePool.push(t)
    },
    clear: function() {
        var t = cc._canvas
          , e = cc._renderContext
          , i = e.getContext();
        i.setTransform(1, 0, 0, 1, 0, 0),
        i.clearRect(0, 0, t.width, t.height),
        0 === this._clearColor.r && 0 === this._clearColor.g && 0 === this._clearColor.b || (e.setFillStyle(this._clearFillStyle),
        e.setGlobalAlpha(this._clearColor.a),
        i.fillRect(0, 0, t.width, t.height))
    },
    clearRenderCommands: function() {
        this._renderCmds.length = 0,
        this._cacheInstanceIds.length = 0,
        this._isCacheToCanvasOn = !1
    },
    pushRenderCommand: function(t) {
        if (t._needDraw)
            if (this._isCacheToCanvasOn) {
                var e = this._cacheToCanvasCmds[this._currentID];
                -1 === e.indexOf(t) && e.push(t)
            } else
                -1 === this._renderCmds.indexOf(t) && this._renderCmds.push(t)
    }
},
function() {
    cc.CanvasContextWrapper = function(t) {
        this._context = t,
        this._saveCount = 0,
        this._currentAlpha = t.globalAlpha,
        this._currentCompositeOperation = t.globalCompositeOperation,
        this._currentFillStyle = t.fillStyle,
        this._currentStrokeStyle = t.strokeStyle,
        this._offsetY = this._offsetX = 0,
        this._realOffsetY = this.height,
        this._armatureMode = 0
    }
    ;
    var t = cc.CanvasContextWrapper.prototype;
    t.resetCache = function() {
        var t = this._context;
        this._currentAlpha = t.globalAlpha,
        this._currentCompositeOperation = t.globalCompositeOperation,
        this._currentFillStyle = t.fillStyle,
        this._currentStrokeStyle = t.strokeStyle,
        this._realOffsetY = this._context.canvas.height + this._offsetY
    }
    ,
    t.setOffset = function(t, e) {
        this._offsetX = t,
        this._offsetY = e,
        this._realOffsetY = this._context.canvas.height + this._offsetY
    }
    ,
    t.computeRealOffsetY = function() {
        this._realOffsetY = this._context.canvas.height + this._offsetY
    }
    ,
    t.setViewScale = function(t, e) {
        this._scaleX = t,
        this._scaleY = e
    }
    ,
    t.getContext = function() {
        return this._context
    }
    ,
    t.save = function() {
        this._context.save(),
        this._saveCount++
    }
    ,
    t.restore = function() {
        this._context.restore(),
        this._saveCount--
    }
    ,
    t.setGlobalAlpha = function(t) {
        0 < this._saveCount ? this._context.globalAlpha = t : this._currentAlpha !== t && (this._currentAlpha = t,
        this._context.globalAlpha = t)
    }
    ,
    t.setCompositeOperation = function(t) {
        0 < this._saveCount ? this._context.globalCompositeOperation = t : this._currentCompositeOperation !== t && (this._currentCompositeOperation = t,
        this._context.globalCompositeOperation = t)
    }
    ,
    t.setFillStyle = function(t) {
        0 < this._saveCount ? this._context.fillStyle = t : this._currentFillStyle !== t && (this._currentFillStyle = t,
        this._context.fillStyle = t)
    }
    ,
    t.setStrokeStyle = function(t) {
        0 < this._saveCount ? this._context.strokeStyle = t : this._currentStrokeStyle !== t && (this._currentStrokeStyle = t,
        this._context.strokeStyle = t)
    }
    ,
    t.setTransform = function(t, e, i) {
        0 < this._armatureMode ? (this.restore(),
        this.save(),
        this._context.transform(t.a, -t.b, -t.c, t.d, t.tx * e, -(t.ty * i))) : this._context.setTransform(t.a, -t.b, -t.c, t.d, this._offsetX + t.tx * e, this._realOffsetY - t.ty * i)
    }
    ,
    t._switchToArmatureMode = function(t, e, i, n) {
        t ? (this._armatureMode++,
        this._context.setTransform(e.a, e.c, e.b, e.d, this._offsetX + e.tx * i, this._realOffsetY - e.ty * n),
        this.save()) : (this._armatureMode--,
        this.restore())
    }
}(),
cc.rendererWebGL = {
    childrenOrderDirty: !0,
    _transformNodePool: [],
    _renderCmds: [],
    _isCacheToBufferOn: !1,
    _cacheToBufferCmds: {},
    _cacheInstanceIds: [],
    _currentID: 0,
    _clearColor: cc.color(),
    getRenderCmd: function(t) {
        return t._createRenderCmd()
    },
    rendering: function(t) {
        var e, i = this._renderCmds, n = t || cc._renderContext;
        for (t = 0,
        e = i.length; t < e; t++)
            i[t].rendering(n)
    },
    _turnToCacheMode: function(t) {
        this._isCacheToBufferOn = !0,
        t = t || 0,
        this._cacheToBufferCmds[t] = [],
        this._cacheInstanceIds.push(t),
        this._currentID = t
    },
    _turnToNormalMode: function() {
        this._isCacheToBufferOn = !1
    },
    _renderingToBuffer: function(t) {
        t = t || this._currentID;
        var e, i, n = this._cacheToBufferCmds[t], r = cc._renderContext, c = this._cacheInstanceIds;
        for (e = 0,
        i = n.length; e < i; e++)
            n[e].rendering(r);
        n.length = 0,
        delete this._cacheToBufferCmds[t],
        cc.arrayRemoveObject(c, t),
        0 === c.length ? this._isCacheToBufferOn = !1 : this._currentID = c[c.length - 1]
    },
    resetFlag: function() {
        this.childrenOrderDirty = !1,
        this._transformNodePool.length = 0
    },
    transform: function() {
        var t = this._transformNodePool;
        t.sort(this._sortNodeByLevelAsc);
        for (var e = 0, i = t.length; e < i; e++)
            t[e].updateStatus();
        t.length = 0
    },
    transformDirty: function() {
        return 0 < this._transformNodePool.length
    },
    _sortNodeByLevelAsc: function(t, e) {
        return t._curLevel - e._curLevel
    },
    pushDirtyNode: function(t) {
        this._transformNodePool.push(t)
    },
    clearRenderCommands: function() {
        this._renderCmds.length = 0
    },
    clear: function() {
        var t = cc._renderContext;
        t.clearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearColor.a),
        t.clear(t.COLOR_BUFFER_BIT | t.DEPTH_BUFFER_BIT)
    },
    setDepthTest: function(t) {
        var e = cc._renderContext;
        t ? (e.clearDepth(1),
        e.enable(e.DEPTH_TEST),
        e.depthFunc(e.LEQUAL)) : e.disable(e.DEPTH_TEST)
    },
    pushRenderCommand: function(t) {
        if (t._needDraw)
            if (this._isCacheToBufferOn) {
                var e = this._cacheToBufferCmds[this._currentID];
                -1 === e.indexOf(t) && e.push(t)
            } else
                -1 === this._renderCmds.indexOf(t) && this._renderCmds.push(t)
    }
},
cc._tmp.PrototypeCCNode = function() {
    var t = cc.Node.prototype;
    cc.defineGetterSetter(t, "x", t.getPositionX, t.setPositionX),
    cc.defineGetterSetter(t, "y", t.getPositionY, t.setPositionY),
    cc.defineGetterSetter(t, "width", t._getWidth, t._setWidth),
    cc.defineGetterSetter(t, "height", t._getHeight, t._setHeight),
    cc.defineGetterSetter(t, "anchorX", t._getAnchorX, t._setAnchorX),
    cc.defineGetterSetter(t, "anchorY", t._getAnchorY, t._setAnchorY),
    cc.defineGetterSetter(t, "skewX", t.getSkewX, t.setSkewX),
    cc.defineGetterSetter(t, "skewY", t.getSkewY, t.setSkewY),
    cc.defineGetterSetter(t, "zIndex", t.getLocalZOrder, t.setLocalZOrder),
    cc.defineGetterSetter(t, "vertexZ", t.getVertexZ, t.setVertexZ),
    cc.defineGetterSetter(t, "rotation", t.getRotation, t.setRotation),
    cc.defineGetterSetter(t, "rotationX", t.getRotationX, t.setRotationX),
    cc.defineGetterSetter(t, "rotationY", t.getRotationY, t.setRotationY),
    cc.defineGetterSetter(t, "scale", t.getScale, t.setScale),
    cc.defineGetterSetter(t, "scaleX", t.getScaleX, t.setScaleX),
    cc.defineGetterSetter(t, "scaleY", t.getScaleY, t.setScaleY),
    cc.defineGetterSetter(t, "children", t.getChildren),
    cc.defineGetterSetter(t, "childrenCount", t.getChildrenCount),
    cc.defineGetterSetter(t, "parent", t.getParent, t.setParent),
    cc.defineGetterSetter(t, "visible", t.isVisible, t.setVisible),
    cc.defineGetterSetter(t, "running", t.isRunning),
    cc.defineGetterSetter(t, "ignoreAnchor", t.isIgnoreAnchorPointForPosition, t.ignoreAnchorPointForPosition),
    cc.defineGetterSetter(t, "actionManager", t.getActionManager, t.setActionManager),
    cc.defineGetterSetter(t, "scheduler", t.getScheduler, t.setScheduler),
    cc.defineGetterSetter(t, "shaderProgram", t.getShaderProgram, t.setShaderProgram),
    cc.defineGetterSetter(t, "opacity", t.getOpacity, t.setOpacity),
    cc.defineGetterSetter(t, "opacityModifyRGB", t.isOpacityModifyRGB),
    cc.defineGetterSetter(t, "cascadeOpacity", t.isCascadeOpacityEnabled, t.setCascadeOpacityEnabled),
    cc.defineGetterSetter(t, "color", t.getColor, t.setColor),
    cc.defineGetterSetter(t, "cascadeColor", t.isCascadeColorEnabled, t.setCascadeColorEnabled)
}
,
cc.NODE_TAG_INVALID = -1,
cc.s_globalOrderOfArrival = 1,
cc.Node = cc.Class.extend({
    _localZOrder: 0,
    _globalZOrder: 0,
    _vertexZ: 0,
    _rotationX: 0,
    _rotationY: 0,
    _scaleX: 1,
    _scaleY: 1,
    _position: null,
    _normalizedPosition: null,
    _usingNormalizedPosition: !1,
    _normalizedPositionDirty: !1,
    _skewX: 0,
    _skewY: 0,
    _children: null,
    _visible: !0,
    _anchorPoint: null,
    _contentSize: null,
    _running: !1,
    _parent: null,
    _ignoreAnchorPointForPosition: !1,
    tag: cc.NODE_TAG_INVALID,
    userData: null,
    userObject: null,
    _reorderChildDirty: !1,
    _shaderProgram: null,
    arrivalOrder: 0,
    _actionManager: null,
    _scheduler: null,
    _eventDispatcher: null,
    _additionalTransformDirty: !1,
    _additionalTransform: null,
    _componentContainer: null,
    _isTransitionFinished: !1,
    _className: "Node",
    _showNode: !1,
    _name: "",
    _realOpacity: 255,
    _realColor: null,
    _cascadeColorEnabled: !1,
    _cascadeOpacityEnabled: !1,
    _renderCmd: null,
    _camera: null,
    ctor: function() {
        this._initNode(),
        this._initRendererCmd()
    },
    _initNode: function() {
        this._anchorPoint = cc.p(0, 0),
        this._contentSize = cc.size(0, 0),
        this._position = cc.p(0, 0),
        this._normalizedPosition = cc.p(0, 0),
        this._children = [];
        var t = cc.director;
        this._actionManager = t.getActionManager(),
        this._scheduler = t.getScheduler(),
        this._additionalTransform = cc.affineTransformMakeIdentity(),
        cc.ComponentContainer && (this._componentContainer = new cc.ComponentContainer(this)),
        this._realOpacity = 255,
        this._realColor = cc.color(255, 255, 255, 255),
        this._cascadeOpacityEnabled = this._cascadeColorEnabled = !1
    },
    init: function() {
        return !0
    },
    _arrayMakeObjectsPerformSelector: function(t, e) {
        if (t && 0 !== t.length) {
            var i, n, r = t.length;
            switch (i = cc.Node._stateCallbackType,
            e) {
            case i.onEnter:
                for (i = 0; i < r; i++)
                    (n = t[i]) && n.onEnter();
                break;
            case i.onExit:
                for (i = 0; i < r; i++)
                    (n = t[i]) && n.onExit();
                break;
            case i.onEnterTransitionDidFinish:
                for (i = 0; i < r; i++)
                    (n = t[i]) && n.onEnterTransitionDidFinish();
                break;
            case i.cleanup:
                for (i = 0; i < r; i++)
                    (n = t[i]) && n.cleanup();
                break;
            case i.updateTransform:
                for (i = 0; i < r; i++)
                    (n = t[i]) && n.updateTransform();
                break;
            case i.onExitTransitionDidStart:
                for (i = 0; i < r; i++)
                    (n = t[i]) && n.onExitTransitionDidStart();
                break;
            case i.sortAllChildren:
                for (i = 0; i < r; i++)
                    (n = t[i]) && n.sortAllChildren();
                break;
            default:
                cc.assert(0, cc._LogInfos.Node__arrayMakeObjectsPerformSelector)
            }
        }
    },
    attr: function(t) {
        for (var e in t)
            this[e] = t[e]
    },
    getSkewX: function() {
        return this._skewX
    },
    setSkewX: function(t) {
        this._skewX = t,
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getSkewY: function() {
        return this._skewY
    },
    setSkewY: function(t) {
        this._skewY = t,
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    setLocalZOrder: function(t) {
        this._localZOrder = t,
        this._parent && this._parent.reorderChild(this, t),
        cc.eventManager._setDirtyForNode(this)
    },
    _setLocalZOrder: function(t) {
        this._localZOrder = t
    },
    getLocalZOrder: function() {
        return this._localZOrder
    },
    getZOrder: function() {
        return cc.log(cc._LogInfos.Node_getZOrder),
        this.getLocalZOrder()
    },
    setZOrder: function(t) {
        cc.log(cc._LogInfos.Node_setZOrder),
        this.setLocalZOrder(t)
    },
    setGlobalZOrder: function(t) {
        this._globalZOrder !== t && (this._globalZOrder = t,
        cc.eventManager._setDirtyForNode(this))
    },
    getGlobalZOrder: function() {
        return this._globalZOrder
    },
    getVertexZ: function() {
        return this._vertexZ
    },
    setVertexZ: function(t) {
        this._vertexZ = t
    },
    getRotation: function() {
        return this._rotationX !== this._rotationY && cc.log(cc._LogInfos.Node_getRotation),
        this._rotationX
    },
    setRotation: function(t) {
        this._rotationX = this._rotationY = t,
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getRotationX: function() {
        return this._rotationX
    },
    setRotationX: function(t) {
        this._rotationX = t,
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getRotationY: function() {
        return this._rotationY
    },
    setRotationY: function(t) {
        this._rotationY = t,
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getScale: function() {
        return this._scaleX !== this._scaleY && cc.log(cc._LogInfos.Node_getScale),
        this._scaleX
    },
    setScale: function(t, e) {
        this._scaleX = t,
        this._scaleY = e || 0 === e ? e : t,
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getScaleX: function() {
        return this._scaleX
    },
    setScaleX: function(t) {
        this._scaleX = t,
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getScaleY: function() {
        return this._scaleY
    },
    setScaleY: function(t) {
        this._scaleY = t,
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    setPosition: function(t, e) {
        var i = this._position;
        if (void 0 === e) {
            if (i.x === t.x && i.y === t.y)
                return;
            i.x = t.x,
            i.y = t.y
        } else {
            if (i.x === t && i.y === e)
                return;
            i.x = t,
            i.y = e
        }
        this._usingNormalizedPosition = !1,
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    setNormalizedPosition: function(t, e) {
        var i = this._normalizedPosition;
        void 0 === e ? (i.x = t.x,
        i.y = t.y) : (i.x = t,
        i.y = e),
        this._normalizedPositionDirty = this._usingNormalizedPosition = !0,
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getPosition: function() {
        return cc.p(this._position)
    },
    getNormalizedPosition: function() {
        return cc.p(this._normalizedPosition)
    },
    getPositionX: function() {
        return this._position.x
    },
    setPositionX: function(t) {
        this._position.x = t,
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getPositionY: function() {
        return this._position.y
    },
    setPositionY: function(t) {
        this._position.y = t,
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getChildrenCount: function() {
        return this._children.length
    },
    getChildren: function() {
        return this._children
    },
    isVisible: function() {
        return this._visible
    },
    setVisible: function(t) {
        this._visible !== t && (this._visible = t,
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty),
        cc.renderer.childrenOrderDirty = !0)
    },
    getAnchorPoint: function() {
        return cc.p(this._anchorPoint)
    },
    setAnchorPoint: function(t, e) {
        var i = this._anchorPoint;
        if (void 0 === e) {
            if (t.x === i.x && t.y === i.y)
                return;
            i.x = t.x,
            i.y = t.y
        } else {
            if (t === i.x && e === i.y)
                return;
            i.x = t,
            i.y = e
        }
        this._renderCmd._updateAnchorPointInPoint()
    },
    _getAnchorX: function() {
        return this._anchorPoint.x
    },
    _setAnchorX: function(t) {
        this._anchorPoint.x !== t && (this._anchorPoint.x = t,
        this._renderCmd._updateAnchorPointInPoint())
    },
    _getAnchorY: function() {
        return this._anchorPoint.y
    },
    _setAnchorY: function(t) {
        this._anchorPoint.y !== t && (this._anchorPoint.y = t,
        this._renderCmd._updateAnchorPointInPoint())
    },
    getAnchorPointInPoints: function() {
        return this._renderCmd.getAnchorPointInPoints()
    },
    _getWidth: function() {
        return this._contentSize.width
    },
    _setWidth: function(t) {
        this._contentSize.width = t,
        this._renderCmd._updateAnchorPointInPoint()
    },
    _getHeight: function() {
        return this._contentSize.height
    },
    _setHeight: function(t) {
        this._contentSize.height = t,
        this._renderCmd._updateAnchorPointInPoint()
    },
    getContentSize: function() {
        return cc.size(this._contentSize)
    },
    setContentSize: function(t, e) {
        var i = this._contentSize;
        if (void 0 === e) {
            if (t.width === i.width && t.height === i.height)
                return;
            i.width = t.width,
            i.height = t.height
        } else {
            if (t === i.width && e === i.height)
                return;
            i.width = t,
            i.height = e
        }
        this._renderCmd._updateAnchorPointInPoint()
    },
    isRunning: function() {
        return this._running
    },
    getParent: function() {
        return this._parent
    },
    setParent: function(t) {
        this._parent = t
    },
    isIgnoreAnchorPointForPosition: function() {
        return this._ignoreAnchorPointForPosition
    },
    ignoreAnchorPointForPosition: function(t) {
        t !== this._ignoreAnchorPointForPosition && (this._ignoreAnchorPointForPosition = t,
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty))
    },
    getTag: function() {
        return this.tag
    },
    setTag: function(t) {
        this.tag = t
    },
    setName: function(t) {
        this._name = t
    },
    getName: function() {
        return this._name
    },
    getUserData: function() {
        return this.userData
    },
    setUserData: function(t) {
        this.userData = t
    },
    getUserObject: function() {
        return this.userObject
    },
    setUserObject: function(t) {
        this.userObject !== t && (this.userObject = t)
    },
    getOrderOfArrival: function() {
        return this.arrivalOrder
    },
    setOrderOfArrival: function(t) {
        this.arrivalOrder = t
    },
    getActionManager: function() {
        return this._actionManager || (this._actionManager = cc.director.getActionManager()),
        this._actionManager
    },
    setActionManager: function(t) {
        this._actionManager !== t && (this.stopAllActions(),
        this._actionManager = t)
    },
    getScheduler: function() {
        return this._scheduler || (this._scheduler = cc.director.getScheduler()),
        this._scheduler
    },
    setScheduler: function(t) {
        this._scheduler !== t && (this.unscheduleAllCallbacks(),
        this._scheduler = t)
    },
    boundingBox: function() {
        return cc.log(cc._LogInfos.Node_boundingBox),
        this.getBoundingBox()
    },
    getBoundingBox: function() {
        var t = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        return cc._rectApplyAffineTransformIn(t, this.getNodeToParentTransform())
    },
    cleanup: function() {
        this.stopAllActions(),
        this.unscheduleAllCallbacks(),
        cc.eventManager.removeListeners(this),
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.cleanup)
    },
    getChildByTag: function(t) {
        var e = this._children;
        if (null !== e)
            for (var i = 0; i < e.length; i++) {
                var n = e[i];
                if (n && n.tag === t)
                    return n
            }
        return null
    },
    getChildByName: function(t) {
        if (!t)
            return cc.log("Invalid name"),
            null;
        for (var e = this._children, i = 0, n = e.length; i < n; i++)
            if (e[i]._name === t)
                return e[i];
        return null
    },
    addChild: function(t, e, i) {
        e = void 0 === e ? t._localZOrder : e;
        var n, r = !1;
        cc.isUndefined(i) ? (i = void 0,
        n = t._name) : cc.isString(i) ? (n = i,
        i = void 0) : cc.isNumber(i) && (r = !0,
        n = ""),
        cc.assert(t, cc._LogInfos.Node_addChild_3),
        cc.assert(null === t._parent, "child already added. It can't be added again"),
        this._addChildHelper(t, e, i, n, r)
    },
    _addChildHelper: function(t, e, i, n, r) {
        this._children || (this._children = []),
        this._insertChild(t, e),
        r ? t.setTag(i) : t.setName(n),
        t.setParent(this),
        t.setOrderOfArrival(cc.s_globalOrderOfArrival++),
        this._running && (t.onEnter(),
        this._isTransitionFinished) && t.onEnterTransitionDidFinish(),
        this._cascadeColorEnabled && t._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty),
        this._cascadeOpacityEnabled && t._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
    },
    removeFromParent: function(t) {
        this._parent && (void 0 === t && (t = !0),
        this._parent.removeChild(this, t))
    },
    removeFromParentAndCleanup: function(t) {
        cc.log(cc._LogInfos.Node_removeFromParentAndCleanup),
        this.removeFromParent(t)
    },
    removeChild: function(t, e) {
        0 !== this._children.length && (void 0 === e && (e = !0),
        -1 < this._children.indexOf(t) && this._detachChild(t, e),
        cc.renderer.childrenOrderDirty = !0)
    },
    removeChildByTag: function(t, e) {
        t === cc.NODE_TAG_INVALID && cc.log(cc._LogInfos.Node_removeChildByTag);
        var i = this.getChildByTag(t);
        i ? this.removeChild(i, e) : cc.log(cc._LogInfos.Node_removeChildByTag_2, t)
    },
    removeAllChildrenWithCleanup: function(t) {
        this.removeAllChildren(t)
    },
    removeAllChildren: function(t) {
        var e = this._children;
        if (null !== e) {
            void 0 === t && (t = !0);
            for (var i = 0; i < e.length; i++) {
                var n = e[i];
                n && (this._running && (n.onExitTransitionDidStart(),
                n.onExit()),
                t && n.cleanup(),
                n.parent = null,
                n._renderCmd.detachFromParent())
            }
            this._children.length = 0,
            cc.renderer.childrenOrderDirty = !0
        }
    },
    _detachChild: function(t, e) {
        this._running && (t.onExitTransitionDidStart(),
        t.onExit()),
        e && t.cleanup(),
        t.parent = null,
        t._renderCmd.detachFromParent(),
        cc.arrayRemoveObject(this._children, t)
    },
    _insertChild: function(t, e) {
        cc.renderer.childrenOrderDirty = this._reorderChildDirty = !0,
        this._children.push(t),
        t._setLocalZOrder(e)
    },
    setNodeDirty: function() {
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    reorderChild: function(t, e) {
        cc.assert(t, cc._LogInfos.Node_reorderChild),
        cc.renderer.childrenOrderDirty = this._reorderChildDirty = !0,
        t.arrivalOrder = cc.s_globalOrderOfArrival,
        cc.s_globalOrderOfArrival++,
        t._setLocalZOrder(e),
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.orderDirty)
    },
    sortAllChildren: function() {
        if (this._reorderChildDirty) {
            var t, e, i, n = this._children, r = n.length;
            for (t = 1; t < r; t++) {
                for (i = n[t],
                e = t - 1; 0 <= e; ) {
                    if (i._localZOrder < n[e]._localZOrder)
                        n[e + 1] = n[e];
                    else {
                        if (!(i._localZOrder === n[e]._localZOrder && i.arrivalOrder < n[e].arrivalOrder))
                            break;
                        n[e + 1] = n[e]
                    }
                    e--
                }
                n[e + 1] = i
            }
            this._reorderChildDirty = !1
        }
    },
    draw: function(t) {},
    transformAncestors: function() {
        null !== this._parent && (this._parent.transformAncestors(),
        this._parent.transform())
    },
    onEnter: function() {
        this._isTransitionFinished = !1,
        this._running = !0,
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.onEnter),
        this.resume()
    },
    onEnterTransitionDidFinish: function() {
        this._isTransitionFinished = !0,
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.onEnterTransitionDidFinish)
    },
    onExitTransitionDidStart: function() {
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.onExitTransitionDidStart)
    },
    onExit: function() {
        this._running = !1,
        this.pause(),
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.onExit),
        this.removeAllComponents()
    },
    runAction: function(t) {
        return cc.assert(t, cc._LogInfos.Node_runAction),
        this.actionManager.addAction(t, this, !this._running),
        t
    },
    stopAllActions: function() {
        this.actionManager && this.actionManager.removeAllActionsFromTarget(this)
    },
    stopAction: function(t) {
        this.actionManager.removeAction(t)
    },
    stopActionByTag: function(t) {
        t === cc.ACTION_TAG_INVALID ? cc.log(cc._LogInfos.Node_stopActionByTag) : this.actionManager.removeActionByTag(t, this)
    },
    getActionByTag: function(t) {
        return t === cc.ACTION_TAG_INVALID ? (cc.log(cc._LogInfos.Node_getActionByTag),
        null) : this.actionManager.getActionByTag(t, this)
    },
    getNumberOfRunningActions: function() {
        return this.actionManager.numberOfRunningActionsInTarget(this)
    },
    scheduleUpdate: function() {
        this.scheduleUpdateWithPriority(0)
    },
    scheduleUpdateWithPriority: function(t) {
        this.scheduler.scheduleUpdate(this, t, !this._running)
    },
    unscheduleUpdate: function() {
        this.scheduler.unscheduleUpdate(this)
    },
    schedule: function(t, e, i, n, r) {
        var c = arguments.length;
        "function" == typeof t ? 1 === c ? (e = 0,
        i = cc.REPEAT_FOREVER,
        n = 0,
        r = this.__instanceId) : 2 === c ? "number" == typeof e ? (i = cc.REPEAT_FOREVER,
        n = 0,
        r = this.__instanceId) : (r = e,
        e = 0,
        i = cc.REPEAT_FOREVER,
        n = 0) : 3 === c ? ("string" == typeof i ? (r = i,
        i = cc.REPEAT_FOREVER) : r = this.__instanceId,
        n = 0) : 4 === c && (r = this.__instanceId) : 1 === c ? (e = 0,
        i = cc.REPEAT_FOREVER,
        n = 0) : 2 === c && (i = cc.REPEAT_FOREVER,
        n = 0),
        cc.assert(t, cc._LogInfos.Node_schedule),
        cc.assert(0 <= e, cc._LogInfos.Node_schedule_2),
        i = null == i ? cc.REPEAT_FOREVER : i,
        this.scheduler.schedule(t, this, e || 0, i, n || 0, !this._running, r)
    },
    scheduleOnce: function(t, e, i) {
        void 0 === i && (i = this.__instanceId),
        this.schedule(t, 0, 0, e, i)
    },
    unschedule: function(t) {
        t && this.scheduler.unschedule(t, this)
    },
    unscheduleAllCallbacks: function() {
        this.scheduler.unscheduleAllForTarget(this)
    },
    resumeSchedulerAndActions: function() {
        cc.log(cc._LogInfos.Node_resumeSchedulerAndActions),
        this.resume()
    },
    resume: function() {
        this.scheduler.resumeTarget(this),
        this.actionManager && this.actionManager.resumeTarget(this),
        cc.eventManager.resumeTarget(this)
    },
    pauseSchedulerAndActions: function() {
        cc.log(cc._LogInfos.Node_pauseSchedulerAndActions),
        this.pause()
    },
    pause: function() {
        this.scheduler.pauseTarget(this),
        this.actionManager && this.actionManager.pauseTarget(this),
        cc.eventManager.pauseTarget(this)
    },
    setAdditionalTransform: function(t) {
        return void 0 === t ? this._additionalTransformDirty = !1 : (this._additionalTransform = t,
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty),
        void (this._additionalTransformDirty = !0))
    },
    getParentToNodeTransform: function() {
        this._renderCmd.getParentToNodeTransform()
    },
    parentToNodeTransform: function() {
        return this.getParentToNodeTransform()
    },
    getNodeToWorldTransform: function() {
        for (var t = this.getNodeToParentTransform(), e = this._parent; null !== e; e = e.parent)
            t = cc.affineTransformConcat(t, e.getNodeToParentTransform());
        return t
    },
    nodeToWorldTransform: function() {
        return this.getNodeToWorldTransform()
    },
    getWorldToNodeTransform: function() {
        return cc.affineTransformInvert(this.getNodeToWorldTransform())
    },
    worldToNodeTransform: function() {
        return this.getWorldToNodeTransform()
    },
    convertToNodeSpace: function(t) {
        return cc.pointApplyAffineTransform(t, this.getWorldToNodeTransform())
    },
    convertToWorldSpace: function(t) {
        return t = t || cc.p(0, 0),
        cc.pointApplyAffineTransform(t, this.getNodeToWorldTransform())
    },
    convertToNodeSpaceAR: function(t) {
        return cc.pSub(this.convertToNodeSpace(t), this._renderCmd.getAnchorPointInPoints())
    },
    convertToWorldSpaceAR: function(t) {
        return t = t || cc.p(0, 0),
        t = cc.pAdd(t, this._renderCmd.getAnchorPointInPoints()),
        this.convertToWorldSpace(t)
    },
    _convertToWindowSpace: function(t) {
        return t = this.convertToWorldSpace(t),
        cc.director.convertToUI(t)
    },
    convertTouchToNodeSpace: function(t) {
        return t = t.getLocation(),
        this.convertToNodeSpace(t)
    },
    convertTouchToNodeSpaceAR: function(t) {
        return t = cc.director.convertToGL(t.getLocation()),
        this.convertToNodeSpaceAR(t)
    },
    update: function(t) {
        this._componentContainer && !this._componentContainer.isEmpty() && this._componentContainer.visit(t)
    },
    updateTransform: function() {
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.updateTransform)
    },
    retain: function() {},
    release: function() {},
    getComponent: function(t) {
        return this._componentContainer ? this._componentContainer.getComponent(t) : null
    },
    addComponent: function(t) {
        this._componentContainer && this._componentContainer.add(t)
    },
    removeComponent: function(t) {
        return !!this._componentContainer && this._componentContainer.remove(t)
    },
    removeAllComponents: function() {
        this._componentContainer && this._componentContainer.removeAll()
    },
    grid: null,
    visit: function(t) {
        this._renderCmd.visit(t)
    },
    transform: function(t, e) {
        this._renderCmd.transform(t, e)
    },
    nodeToParentTransform: function() {
        return this.getNodeToParentTransform()
    },
    getNodeToParentTransform: function(t) {
        var e = this._renderCmd.getNodeToParentTransform();
        if (t)
            for (var e = {
                a: e.a,
                b: e.b,
                c: e.c,
                d: e.d,
                tx: e.tx,
                ty: e.ty
            }, i = this._parent; null != i && i != t; i = i.getParent())
                cc.affineTransformConcatIn(e, i.getNodeToParentTransform());
        return e
    },
    getNodeToParentAffineTransform: function(t) {
        return this.getNodeToParentTransform(t)
    },
    getCamera: function() {
        return this._camera || (this._camera = new cc.Camera),
        this._camera
    },
    getGrid: function() {
        return this.grid
    },
    setGrid: function(t) {
        this.grid = t
    },
    getShaderProgram: function() {
        return this._renderCmd.getShaderProgram()
    },
    setShaderProgram: function(t) {
        this._renderCmd.setShaderProgram(t)
    },
    getGLServerState: function() {
        return 0
    },
    setGLServerState: function(t) {},
    getBoundingBoxToWorld: function() {
        var t = cc.rect(0, 0, this._contentSize.width, this._contentSize.height)
          , e = this.getNodeToWorldTransform()
          , t = cc.rectApplyAffineTransform(t, e);
        if (!this._children)
            return t;
        for (var i = this._children, n = 0; n < i.length; n++) {
            var r = i[n];
            r && r._visible && (r = r._getBoundingBoxToCurrentNode(e)) && (t = cc.rectUnion(t, r))
        }
        return t
    },
    _getBoundingBoxToCurrentNode: function(t) {
        var e = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        if (t = void 0 === t ? this.getNodeToParentTransform() : cc.affineTransformConcat(this.getNodeToParentTransform(), t),
        e = cc.rectApplyAffineTransform(e, t),
        !this._children)
            return e;
        for (var i = this._children, n = 0; n < i.length; n++) {
            var r = i[n];
            r && r._visible && (r = r._getBoundingBoxToCurrentNode(t)) && (e = cc.rectUnion(e, r))
        }
        return e
    },
    getOpacity: function() {
        return this._realOpacity
    },
    getDisplayedOpacity: function() {
        return this._renderCmd.getDisplayedOpacity()
    },
    setOpacity: function(t) {
        this._realOpacity = t,
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
    },
    updateDisplayedOpacity: function(t) {
        this._renderCmd._updateDisplayOpacity(t)
    },
    isCascadeOpacityEnabled: function() {
        return this._cascadeOpacityEnabled
    },
    setCascadeOpacityEnabled: function(t) {
        this._cascadeOpacityEnabled !== t && (this._cascadeOpacityEnabled = t,
        this._renderCmd.setCascadeOpacityEnabledDirty())
    },
    getColor: function() {
        var t = this._realColor;
        return cc.color(t.r, t.g, t.b, t.a)
    },
    getDisplayedColor: function() {
        return this._renderCmd.getDisplayedColor()
    },
    setColor: function(t) {
        var e = this._realColor;
        e.r = t.r,
        e.g = t.g,
        e.b = t.b,
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty)
    },
    updateDisplayedColor: function(t) {
        this._renderCmd._updateDisplayColor(t)
    },
    isCascadeColorEnabled: function() {
        return this._cascadeColorEnabled
    },
    setCascadeColorEnabled: function(t) {
        this._cascadeColorEnabled !== t && (this._cascadeColorEnabled = t,
        this._renderCmd.setCascadeColorEnabledDirty())
    },
    setOpacityModifyRGB: function(t) {},
    isOpacityModifyRGB: function() {
        return !1
    },
    _initRendererCmd: function() {
        this._renderCmd = cc.renderer.getRenderCmd(this)
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.Node.CanvasRenderCmd(this) : new cc.Node.WebGLRenderCmd(this)
    },
    enumerateChildren: function(t, e) {
        cc.assert(t && 0 != t.length, "Invalid name"),
        cc.assert(null != e, "Invalid callback function");
        var i = t.length
          , n = 0
          , r = i
          , c = !1;
        2 < i && "/" === t[0] && "/" === t[1] && (c = !0,
        n = 2,
        r -= 2);
        var s = !1;
        3 < i && "/" === t[i - 3] && "." === t[i - 2] && "." === t[i - 1] && (s = !0,
        r -= 3),
        i = t.substr(n, r),
        s && (i = "[[:alnum:]]+/" + i),
        c ? this.doEnumerateRecursive(this, i, e) : this.doEnumerate(i, e)
    },
    doEnumerateRecursive: function(t, e, i) {
        if (!t.doEnumerate(e, i))
            for (var n = t.getChildren(), r = n.length, c = 0; c < r && (t = n[c],
            !this.doEnumerateRecursive(t, e, i)); c++)
                ;
    },
    doEnumerate: function(t, e) {
        var i = t.indexOf("/")
          , n = t
          , r = !1;
        -1 !== i && (n = t.substr(0, i),
        r = !0);
        for (var c, i = !1, s = this._children, o = s.length, a = 0; a < o; a++)
            if (c = s[a],
            -1 !== c._name.indexOf(n))
                if (r) {
                    if (i = c.doEnumerate(t, e))
                        break
                } else if (e(c)) {
                    i = !0;
                    break
                }
        return i
    }
}),
cc.Node.create = function() {
    return new cc.Node
}
,
cc.Node._stateCallbackType = {
    onEnter: 1,
    onExit: 2,
    cleanup: 3,
    onEnterTransitionDidFinish: 4,
    updateTransform: 5,
    onExitTransitionDidStart: 6,
    sortAllChildren: 7
},
cc.assert(cc.isFunction(cc._tmp.PrototypeCCNode), cc._LogInfos.MissingFile, "BaseNodesPropertyDefine.js"),
cc._tmp.PrototypeCCNode(),
delete cc._tmp.PrototypeCCNode,
cc.CustomRenderCmd = function(t, e) {
    this._needDraw = !0,
    this._target = t,
    this._callback = e,
    this.rendering = function(t, e, i) {
        this._callback && this._callback.call(this._target, t, e, i)
    }
}
,
cc.Node._dirtyFlags = {
    transformDirty: 1,
    visibleDirty: 2,
    colorDirty: 4,
    opacityDirty: 8,
    cacheDirty: 16,
    orderDirty: 32,
    textDirty: 64,
    gradientDirty: 128,
    all: 255
},
cc.Node.RenderCmd = function(t) {
    this._dirtyFlag = 1,
    this._node = t,
    this._needDraw = !1,
    this._anchorPointInPoints = new cc.Point(0,0),
    this._transform = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
    },
    this._worldTransform = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
    },
    this._inverse = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
    },
    this._displayedOpacity = 255,
    this._displayedColor = cc.color(255, 255, 255, 255),
    this._cascadeOpacityEnabledDirty = this._cascadeColorEnabledDirty = !1,
    this._curLevel = -1
}
,
cc.Node.RenderCmd.prototype = {
    constructor: cc.Node.RenderCmd,
    getAnchorPointInPoints: function() {
        return cc.p(this._anchorPointInPoints)
    },
    getDisplayedColor: function() {
        var t = this._displayedColor;
        return cc.color(t.r, t.g, t.b, t.a)
    },
    getDisplayedOpacity: function() {
        return this._displayedOpacity
    },
    setCascadeColorEnabledDirty: function() {
        this._cascadeColorEnabledDirty = !0,
        this.setDirtyFlag(cc.Node._dirtyFlags.colorDirty)
    },
    setCascadeOpacityEnabledDirty: function() {
        this._cascadeOpacityEnabledDirty = !0,
        this.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
    },
    getParentToNodeTransform: function() {
        return this._dirtyFlag & cc.Node._dirtyFlags.transformDirty && (this._inverse = cc.affineTransformInvert(this.getNodeToParentTransform())),
        this._inverse
    },
    detachFromParent: function() {},
    _updateAnchorPointInPoint: function() {
        var t = this._anchorPointInPoints
          , e = this._node._contentSize
          , i = this._node._anchorPoint;
        t.x = e.width * i.x,
        t.y = e.height * i.y,
        this.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    setDirtyFlag: function(t) {
        0 === this._dirtyFlag && 0 !== t && cc.renderer.pushDirtyNode(this),
        this._dirtyFlag |= t
    },
    getParentRenderCmd: function() {
        return this._node && this._node._parent && this._node._parent._renderCmd ? this._node._parent._renderCmd : null
    },
    _updateDisplayColor: function(t) {
        var e, i = this._node, n = this._displayedColor, r = i._realColor;
        if (this._cascadeColorEnabledDirty && !i._cascadeColorEnabled) {
            for (n.r = r.r,
            n.g = r.g,
            n.b = r.b,
            n = new cc.Color(255,255,255,255),
            t = i._children,
            i = 0,
            r = t.length; i < r; i++)
                (e = t[i]) && e._renderCmd && e._renderCmd._updateDisplayColor(n);
            this._cascadeColorEnabledDirty = !1
        } else if (void 0 === t && (t = (t = i._parent) && t._cascadeColorEnabled ? t.getDisplayedColor() : cc.color.WHITE),
        n.r = 0 | r.r * t.r / 255,
        n.g = 0 | r.g * t.g / 255,
        n.b = 0 | r.b * t.b / 255,
        i._cascadeColorEnabled)
            for (t = i._children,
            i = 0,
            r = t.length; i < r; i++)
                (e = t[i]) && e._renderCmd && (e._renderCmd._updateDisplayColor(n),
                e._renderCmd._updateColor());
        this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.colorDirty
    },
    _updateDisplayOpacity: function(t) {
        var e, i, n = this._node;
        if (this._cascadeOpacityEnabledDirty && !n._cascadeOpacityEnabled) {
            for (this._displayedOpacity = n._realOpacity,
            e = n._children,
            t = 0,
            n = e.length; t < n; t++)
                (i = e[t]) && i._renderCmd && i._renderCmd._updateDisplayOpacity(255);
            this._cascadeOpacityEnabledDirty = !1
        } else if (void 0 === t && (e = n._parent,
        t = 255,
        e && e._cascadeOpacityEnabled && (t = e.getDisplayedOpacity())),
        this._displayedOpacity = n._realOpacity * t / 255,
        n._cascadeOpacityEnabled)
            for (e = n._children,
            t = 0,
            n = e.length; t < n; t++)
                (i = e[t]) && i._renderCmd && (i._renderCmd._updateDisplayOpacity(this._displayedOpacity),
                i._renderCmd._updateColor());
        this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.opacityDirty
    },
    _syncDisplayColor: function(t) {
        var e = this._node
          , i = this._displayedColor
          , n = e._realColor;
        void 0 === t && (t = (t = e._parent) && t._cascadeColorEnabled ? t.getDisplayedColor() : cc.color.WHITE),
        i.r = 0 | n.r * t.r / 255,
        i.g = 0 | n.g * t.g / 255,
        i.b = 0 | n.b * t.b / 255
    },
    _syncDisplayOpacity: function(t) {
        var e = this._node;
        if (void 0 === t) {
            var i = e._parent;
            t = 255,
            i && i._cascadeOpacityEnabled && (t = i.getDisplayedOpacity())
        }
        this._displayedOpacity = e._realOpacity * t / 255
    },
    _updateColor: function() {},
    updateStatus: function() {
        var t = cc.Node._dirtyFlags
          , e = this._dirtyFlag
          , i = e & t.colorDirty
          , n = e & t.opacityDirty;
        i && this._updateDisplayColor(),
        n && this._updateDisplayOpacity(),
        (i || n) && this._updateColor(),
        e & t.transformDirty && (this.transform(this.getParentRenderCmd(), !0),
        this._dirtyFlag ^= this._dirtyFlag & t.transformDirty),
        e & t.orderDirty && (this._dirtyFlag ^= this._dirtyFlag & t.orderDirty)
    },
    getNodeToParentTransform: function() {
        var t = this._node;
        if (t._usingNormalizedPosition && t._parent) {
            var e = t._parent._contentSize;
            t._position.x = t._normalizedPosition.x * e.width,
            t._position.y = t._normalizedPosition.y * e.height,
            t._normalizedPositionDirty = !1,
            this._dirtyFlag |= cc.Node._dirtyFlags.transformDirty
        }
        if (this._dirtyFlag & cc.Node._dirtyFlags.transformDirty) {
            e = this._transform,
            e.tx = t._position.x,
            e.ty = t._position.y;
            var i = 1
              , n = 0
              , r = 0
              , c = 1;
            t._rotationX && (c = .017453292519943295 * t._rotationX,
            r = Math.sin(c),
            c = Math.cos(c)),
            t._rotationY && (n = .017453292519943295 * t._rotationY,
            i = Math.cos(n),
            n = -Math.sin(n)),
            e.a = i,
            e.b = n,
            e.c = r,
            e.d = c;
            var s = t._scaleX
              , o = t._scaleY
              , a = this._anchorPointInPoints.x
              , h = this._anchorPointInPoints.y
              , l = 1e-6 > s && -1e-6 < s ? 1e-6 : s
              , u = 1e-6 > o && -1e-6 < o ? 1e-6 : o;
            1 === s && 1 === o || (i = e.a *= l,
            n = e.b *= l,
            r = e.c *= u,
            c = e.d *= u),
            (t._skewX || t._skewY) && (s = Math.tan(-t._skewX * Math.PI / 180),
            o = Math.tan(-t._skewY * Math.PI / 180),
            1 / 0 === s && (s = 99999999),
            1 / 0 === o && (o = 99999999),
            l = h * s,
            u = a * o,
            e.a = i - r * o,
            e.b = n - c * o,
            e.c = r - i * s,
            e.d = c - n * s,
            e.tx += i * l + r * u,
            e.ty += n * l + c * u),
            e.tx -= i * a + r * h,
            e.ty -= n * a + c * h,
            t._ignoreAnchorPointForPosition && (e.tx += a,
            e.ty += h),
            t._additionalTransformDirty && (this._transform = cc.affineTransformConcat(e, t._additionalTransform))
        }
        return this._transform
    },
    _syncStatus: function(t) {
        var e = cc.Node._dirtyFlags
          , i = this._dirtyFlag
          , n = t ? t._node : null;
        n && n._cascadeColorEnabled && t._dirtyFlag & e.colorDirty && (i |= e.colorDirty),
        n && n._cascadeOpacityEnabled && t._dirtyFlag & e.opacityDirty && (i |= e.opacityDirty),
        t && t._dirtyFlag & e.transformDirty && (i |= e.transformDirty);
        var n = i & e.colorDirty
          , r = i & e.opacityDirty;
        this._dirtyFlag = i,
        n && this._syncDisplayColor(),
        r && this._syncDisplayOpacity(),
        (n || r) && this._updateColor(),
        (cc._renderType === cc.game.RENDER_TYPE_WEBGL || i & e.transformDirty) && this.transform(t, !0),
        i & e.orderDirty && (this._dirtyFlag ^= this._dirtyFlag & e.orderDirty)
    },
    visitChildren: function() {
        var t, e = this._node, i = e._children, n = i.length;
        if (0 < n) {
            for (e.sortAllChildren(),
            e = 0; e < n && (t = i[e],
            0 > t._localZOrder); e++)
                t._renderCmd.visit(this);
            for (cc.renderer.pushRenderCommand(this); e < n; e++)
                i[e]._renderCmd.visit(this)
        } else
            cc.renderer.pushRenderCommand(this);
        this._dirtyFlag = 0
    }
},
function() {
    cc.Node.CanvasRenderCmd = function(t) {
        cc.Node.RenderCmd.call(this, t),
        this._cachedParent = null,
        this._cacheDirty = !1
    }
    ;
    var t = cc.Node.CanvasRenderCmd.prototype = Object.create(cc.Node.RenderCmd.prototype);
    t.constructor = cc.Node.CanvasRenderCmd,
    t.transform = function(t, e) {
        var i = this.getNodeToParentTransform()
          , n = this._worldTransform;
        if (this._cacheDirty = !0,
        t) {
            var r = t._worldTransform;
            n.a = i.a * r.a + i.b * r.c,
            n.b = i.a * r.b + i.b * r.d,
            n.c = i.c * r.a + i.d * r.c,
            n.d = i.c * r.b + i.d * r.d,
            n.tx = r.a * i.tx + r.c * i.ty + r.tx,
            n.ty = r.d * i.ty + r.ty + r.b * i.tx
        } else
            n.a = i.a,
            n.b = i.b,
            n.c = i.c,
            n.d = i.d,
            n.tx = i.tx,
            n.ty = i.ty;
        if (e && (i = this._node._children) && 0 !== i.length)
            for (n = 0,
            r = i.length; n < r; n++)
                i[n]._renderCmd.transform(this, e)
    }
    ,
    t.visit = function(t) {
        this._node._visible && ((t = t || this.getParentRenderCmd()) && (this._curLevel = t._curLevel + 1),
        this._syncStatus(t),
        this.visitChildren())
    }
    ,
    t.setDirtyFlag = function(t, e) {
        cc.Node.RenderCmd.prototype.setDirtyFlag.call(this, t, e),
        this._setCacheDirty(e),
        this._cachedParent && this._cachedParent.setDirtyFlag(t, !0)
    }
    ,
    t._setCacheDirty = function() {
        if (!1 === this._cacheDirty) {
            this._cacheDirty = !0;
            var t = this._cachedParent;
            t && t !== this && t._setNodeDirtyForCache && t._setNodeDirtyForCache()
        }
    }
    ,
    t._setCachedParent = function(t) {
        if (this._cachedParent !== t) {
            this._cachedParent = t;
            for (var e = this._node._children, i = 0, n = e.length; i < n; i++)
                e[i]._renderCmd._setCachedParent(t)
        }
    }
    ,
    t.detachFromParent = function() {
        this._cachedParent = null;
        for (var t, e = this._node._children, i = 0, n = e.length; i < n; i++)
            (t = e[i]) && t._renderCmd && t._renderCmd.detachFromParent()
    }
    ,
    t.setShaderProgram = function(t) {}
    ,
    t.getShaderProgram = function() {
        return null
    }
    ,
    cc.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc = function(t) {
        return t ? t.src === cc.SRC_ALPHA && t.dst === cc.ONE || t.src === cc.ONE && t.dst === cc.ONE ? "lighter" : t.src === cc.ZERO && t.dst === cc.SRC_ALPHA ? "destination-in" : t.src === cc.ZERO && t.dst === cc.ONE_MINUS_SRC_ALPHA ? "destination-out" : "source-over" : "source-over"
    }
}(),
function() {
    cc.Node.WebGLRenderCmd = function(t) {
        cc.Node.RenderCmd.call(this, t),
        t = new cc.math.Matrix4;
        var e = t.mat;
        e[2] = e[3] = e[6] = e[7] = e[8] = e[9] = e[11] = e[14] = 0,
        e[10] = e[15] = 1,
        this._transform4x4 = t,
        this._stackMatrix = new cc.math.Matrix4,
        this._camera = this._shaderProgram = null
    }
    ;
    var t = cc.Node.WebGLRenderCmd.prototype = Object.create(cc.Node.RenderCmd.prototype);
    t.constructor = cc.Node.WebGLRenderCmd,
    t._updateColor = function() {}
    ,
    t.visit = function(t) {
        var e = this._node;
        e._visible && (t = t || this.getParentRenderCmd(),
        e._parent && e._parent._renderCmd && (this._curLevel = e._parent._renderCmd._curLevel + 1),
        e = cc.current_stack,
        e.stack.push(e.top),
        this._syncStatus(t),
        e.top = this._stackMatrix,
        this.visitChildren(),
        e.top = e.stack.pop())
    }
    ,
    t.transform = function(t, e) {
        var i = this._transform4x4
          , n = this._stackMatrix
          , r = this._node
          , c = (t = t || this.getParentRenderCmd()) ? t._stackMatrix : cc.current_stack.top
          , s = this.getNodeToParentTransform();
        this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.transformDirty;
        var o = i.mat;
        if (o[0] = s.a,
        o[4] = s.c,
        o[12] = s.tx,
        o[1] = s.b,
        o[5] = s.d,
        o[13] = s.ty,
        o[14] = r._vertexZ,
        cc.kmMat4Multiply(n, c, i),
        null === r._camera || null !== r.grid && r.grid.isActive() || (c = this._anchorPointInPoints.x,
        s = this._anchorPointInPoints.y,
        0 !== c || 0 !== s ? (cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (c |= 0,
        s |= 0),
        o = cc.math.Matrix4.createByTranslation(c, s, 0, i),
        n.multiply(o),
        r._camera._locateForRenderer(n),
        o = cc.math.Matrix4.createByTranslation(-c, -s, 0, o),
        n.multiply(o),
        i.identity()) : r._camera._locateForRenderer(n)),
        e && r._children && 0 !== r._children.length)
            for (r = r._children,
            i = 0,
            n = r.length; i < n; i++)
                r[i]._renderCmd.transform(this, e)
    }
    ,
    t.setShaderProgram = function(t) {
        this._shaderProgram = t
    }
    ,
    t.getShaderProgram = function() {
        return this._shaderProgram
    }
}(),
cc.AtlasNode = cc.Node.extend({
    textureAtlas: null,
    quadsToDraw: 0,
    _itemsPerRow: 0,
    _itemsPerColumn: 0,
    _itemWidth: 0,
    _itemHeight: 0,
    _opacityModifyRGB: !1,
    _blendFunc: null,
    _ignoreContentScaleFactor: !1,
    _className: "AtlasNode",
    _texture: null,
    _textureForCanvas: null,
    ctor: function(t, e, i, n) {
        cc.Node.prototype.ctor.call(this),
        this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        },
        this._ignoreContentScaleFactor = !1,
        void 0 !== n && this.initWithTileFile(t, e, i, n)
    },
    _createRenderCmd: function() {
        this._renderCmd = cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.AtlasNode.CanvasRenderCmd(this) : new cc.AtlasNode.WebGLRenderCmd(this)
    },
    updateAtlasValues: function() {
        cc.log(cc._LogInfos.AtlasNode_updateAtlasValues)
    },
    getColor: function() {
        return this._opacityModifyRGB ? this._renderCmd._colorUnmodified : cc.Node.prototype.getColor.call(this)
    },
    setOpacityModifyRGB: function(t) {
        var e = this.color;
        this._opacityModifyRGB = t,
        this.setColor(e)
    },
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    setBlendFunc: function(t, e) {
        this._blendFunc = void 0 === e ? t : {
            src: t,
            dst: e
        }
    },
    setTextureAtlas: function(t) {
        this.textureAtlas = t
    },
    getTextureAtlas: function() {
        return this.textureAtlas
    },
    getQuadsToDraw: function() {
        return this.quadsToDraw
    },
    setQuadsToDraw: function(t) {
        this.quadsToDraw = t
    },
    initWithTileFile: function(t, e, i, n) {
        if (!t)
            throw Error("cc.AtlasNode.initWithTileFile(): title should not be null");
        return t = cc.textureCache.addImage(t),
        this.initWithTexture(t, e, i, n)
    },
    initWithTexture: function(t, e, i, n) {
        return this._renderCmd.initWithTexture(t, e, i, n)
    },
    setColor: function(t) {
        this._renderCmd.setColor(t)
    },
    setOpacity: function(t) {
        this._renderCmd.setOpacity(t)
    },
    getTexture: function() {
        return this._texture
    },
    setTexture: function(t) {
        this._texture = t
    },
    _setIgnoreContentScaleFactor: function(t) {
        this._ignoreContentScaleFactor = t
    }
}),
_p = cc.AtlasNode.prototype,
cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity),
cc.defineGetterSetter(_p, "color", _p.getColor, _p.setColor),
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture),
cc.EventHelper.prototype.apply(_p),
cc.AtlasNode.create = function(t, e, i, n) {
    return new cc.AtlasNode(t,e,i,n)
}
,
function() {
    cc.AtlasNode.CanvasRenderCmd = function(t) {
        cc.Node.CanvasRenderCmd.call(this, t),
        this._needDraw = !1,
        this._colorUnmodified = cc.color.WHITE,
        this._textureToRender = null
    }
    ;
    var t = cc.AtlasNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    t.constructor = cc.AtlasNode.CanvasRenderCmd,
    t.initWithTexture = function(t, e, i, n) {
        var r = this._node;
        return r._itemWidth = e,
        r._itemHeight = i,
        r._opacityModifyRGB = !0,
        r._texture = t,
        r._texture ? (this._textureToRender = t,
        this._calculateMaxItems(),
        r.quadsToDraw = n,
        !0) : (cc.log(cc._LogInfos.AtlasNode__initWithTexture),
        !1)
    }
    ,
    t.setColor = function(t) {
        var e = this._node._realColor;
        e.r === t.r && e.g === t.g && e.b === t.b || (this._colorUnmodified = t,
        this._changeTextureColor())
    }
    ,
    t._changeTextureColor = function() {
        var t = this._node._texture
          , e = this._colorUnmodified
          , i = t.getHtmlElementObj()
          , i = cc.rect(0, 0, i.width, i.height);
        t === this._textureToRender ? this._textureToRender = t._generateColorTexture(e.r, e.g, e.b, i) : t._generateColorTexture(e.r, e.g, e.b, i, this._textureToRender.getHtmlElementObj())
    }
    ,
    t.setOpacity = function(t) {
        cc.Node.prototype.setOpacity.call(this._node, t)
    }
    ,
    t._calculateMaxItems = function() {
        var t = this._node
          , e = t._texture.getContentSize();
        t._itemsPerColumn = 0 | e.height / t._itemHeight,
        t._itemsPerRow = 0 | e.width / t._itemWidth
    }
}(),
function() {
    cc.AtlasNode.WebGLRenderCmd = function(t) {
        cc.Node.WebGLRenderCmd.call(this, t),
        this._needDraw = !0,
        this._textureAtlas = null,
        this._colorUnmodified = cc.color.WHITE,
        this._uniformColor = this._colorF32Array = null,
        this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE_UCOLOR),
        this._uniformColor = cc._renderContext.getUniformLocation(this._shaderProgram.getProgram(), "u_color")
    }
    ;
    var t = cc.AtlasNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    t.constructor = cc.AtlasNode.WebGLRenderCmd,
    t._updateBlendFunc = function() {
        var t = this._node;
        this._textureAtlas.texture.hasPremultipliedAlpha() || (t._blendFunc.src = cc.SRC_ALPHA,
        t._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA)
    }
    ,
    t._updateOpacityModifyRGB = function() {
        this._node._opacityModifyRGB = this._textureAtlas.texture.hasPremultipliedAlpha()
    }
    ,
    t.rendering = function(t) {
        t = t || cc._renderContext;
        var e = this._node;
        this._shaderProgram.use(),
        this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix),
        cc.glBlendFunc(e._blendFunc.src, e._blendFunc.dst),
        this._uniformColor && this._colorF32Array && (t.uniform4fv(this._uniformColor, this._colorF32Array),
        this._textureAtlas.drawNumberOfQuads(e.quadsToDraw, 0))
    }
    ,
    t.initWithTexture = function(t, e, i, n) {
        var r = this._node;
        return r._itemWidth = e,
        r._itemHeight = i,
        this._colorUnmodified = cc.color.WHITE,
        r._opacityModifyRGB = !0,
        r._blendFunc.src = cc.BLEND_SRC,
        r._blendFunc.dst = cc.BLEND_DST,
        e = r._realColor,
        this._colorF32Array = new Float32Array([e.r / 255, e.g / 255, e.b / 255, r._realOpacity / 255]),
        this._textureAtlas = new cc.TextureAtlas,
        this._textureAtlas.initWithTexture(t, n),
        this._textureAtlas ? (this._updateBlendFunc(),
        this._updateOpacityModifyRGB(),
        this._calculateMaxItems(),
        r.quadsToDraw = n,
        !0) : (cc.log(cc._LogInfos.AtlasNode__initWithTexture),
        !1)
    }
    ,
    t.setColor = function(t) {
        var e = cc.color(t.r, t.g, t.b)
          , i = this._node;
        this._colorUnmodified = t,
        t = this._displayedOpacity,
        i._opacityModifyRGB && (e.r = e.r * t / 255,
        e.g = e.g * t / 255,
        e.b = e.b * t / 255),
        cc.Node.prototype.setColor.call(i, e)
    }
    ,
    t.setOpacity = function(t) {
        var e = this._node;
        cc.Node.prototype.setOpacity.call(e, t),
        e._opacityModifyRGB && (e.color = this._colorUnmodified)
    }
    ,
    t._updateColor = function() {
        var t = this._displayedColor;
        this._colorF32Array = new Float32Array([t.r / 255, t.g / 255, t.b / 255, this._displayedOpacity / 255])
    }
    ,
    t.getTexture = function() {
        return this._textureAtlas.texture
    }
    ,
    t.setTexture = function(t) {
        this._textureAtlas.texture = t,
        this._updateBlendFunc(),
        this._updateOpacityModifyRGB()
    }
    ,
    t._calculateMaxItems = function() {
        var t = this._node
          , e = this._textureAtlas.texture
          , i = e.getContentSize();
        t._ignoreContentScaleFactor && (i = e.getContentSizeInPixels()),
        t._itemsPerColumn = 0 | i.height / t._itemHeight,
        t._itemsPerRow = 0 | i.width / t._itemWidth
    }
}(),
cc._tmp.WebGLTexture2D = function() {
    cc.Texture2D = cc.Class.extend({
        _pVRHaveAlphaPremultiplied: !0,
        _pixelFormat: null,
        _pixelsWide: 0,
        _pixelsHigh: 0,
        _name: "",
        _contentSize: null,
        maxS: 0,
        maxT: 0,
        _hasPremultipliedAlpha: !1,
        _hasMipmaps: !1,
        shaderProgram: null,
        _textureLoaded: !1,
        _htmlElementObj: null,
        _webTextureObj: null,
        url: null,
        ctor: function() {
            this._contentSize = cc.size(0, 0),
            this._pixelFormat = cc.Texture2D.defaultPixelFormat
        },
        releaseTexture: function() {
            this._webTextureObj && cc._renderContext.deleteTexture(this._webTextureObj),
            cc.loader.release(this.url)
        },
        getPixelFormat: function() {
            return this._pixelFormat
        },
        getPixelsWide: function() {
            return this._pixelsWide
        },
        getPixelsHigh: function() {
            return this._pixelsHigh
        },
        getName: function() {
            return this._webTextureObj
        },
        getContentSize: function() {
            return cc.size(this._contentSize.width / cc.contentScaleFactor(), this._contentSize.height / cc.contentScaleFactor())
        },
        _getWidth: function() {
            return this._contentSize.width / cc.contentScaleFactor()
        },
        _getHeight: function() {
            return this._contentSize.height / cc.contentScaleFactor()
        },
        getContentSizeInPixels: function() {
            return this._contentSize
        },
        getMaxS: function() {
            return this.maxS
        },
        setMaxS: function(t) {
            this.maxS = t
        },
        getMaxT: function() {
            return this.maxT
        },
        setMaxT: function(t) {
            this.maxT = t
        },
        getShaderProgram: function() {
            return this.shaderProgram
        },
        setShaderProgram: function(t) {
            this.shaderProgram = t
        },
        hasPremultipliedAlpha: function() {
            return this._hasPremultipliedAlpha
        },
        hasMipmaps: function() {
            return this._hasMipmaps
        },
        description: function() {
            return "<cc.Texture2D | Name = " + this._name + " | Dimensions = " + this._pixelsWide + " x " + this._pixelsHigh + " | Coordinates = (" + this.maxS + ", " + this.maxT + ")>"
        },
        releaseData: function(t) {},
        keepData: function(t, e) {
            return t
        },
        initWithData: function(t, e, i, n, r) {
            var c = cc.Texture2D
              , s = cc._renderContext
              , o = s.RGBA
              , a = s.UNSIGNED_BYTE
              , h = i * cc.Texture2D._B[e] / 8;
            switch (0 === h % 8 ? s.pixelStorei(s.UNPACK_ALIGNMENT, 8) : 0 === h % 4 ? s.pixelStorei(s.UNPACK_ALIGNMENT, 4) : 0 === h % 2 ? s.pixelStorei(s.UNPACK_ALIGNMENT, 2) : s.pixelStorei(s.UNPACK_ALIGNMENT, 1),
            this._webTextureObj = s.createTexture(),
            cc.glBindTexture2D(this),
            s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, s.LINEAR),
            s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MAG_FILTER, s.LINEAR),
            s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE),
            s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE),
            e) {
            case c.PIXEL_FORMAT_RGBA8888:
                o = s.RGBA;
                break;
            case c.PIXEL_FORMAT_RGB888:
                o = s.RGB;
                break;
            case c.PIXEL_FORMAT_RGBA4444:
                a = s.UNSIGNED_SHORT_4_4_4_4;
                break;
            case c.PIXEL_FORMAT_RGB5A1:
                a = s.UNSIGNED_SHORT_5_5_5_1;
                break;
            case c.PIXEL_FORMAT_RGB565:
                a = s.UNSIGNED_SHORT_5_6_5;
                break;
            case c.PIXEL_FORMAT_AI88:
                o = s.LUMINANCE_ALPHA;
                break;
            case c.PIXEL_FORMAT_A8:
                o = s.ALPHA;
                break;
            case c.PIXEL_FORMAT_I8:
                o = s.LUMINANCE;
                break;
            default:
                cc.assert(0, cc._LogInfos.Texture2D_initWithData)
            }
            return s.texImage2D(s.TEXTURE_2D, 0, o, i, n, 0, o, a, t),
            this._contentSize.width = r.width,
            this._contentSize.height = r.height,
            this._pixelsWide = i,
            this._pixelsHigh = n,
            this._pixelFormat = e,
            this.maxS = r.width / i,
            this.maxT = r.height / n,
            this._hasMipmaps = this._hasPremultipliedAlpha = !1,
            this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE),
            this._textureLoaded = !0
        },
        drawAtPoint: function(t) {
            var e = [0, this.maxT, this.maxS, this.maxT, 0, 0, this.maxS, 0]
              , i = this._pixelsWide * this.maxS
              , n = this._pixelsHigh * this.maxT;
            t = [t.x, t.y, 0, i + t.x, t.y, 0, t.x, n + t.y, 0, i + t.x, n + t.y, 0],
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS),
            this._shaderProgram.use(),
            this._shaderProgram.setUniformsForBuiltins(),
            cc.glBindTexture2D(this),
            i = cc._renderContext,
            i.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, i.FLOAT, !1, 0, t),
            i.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, i.FLOAT, !1, 0, e),
            i.drawArrays(i.TRIANGLE_STRIP, 0, 4)
        },
        drawInRect: function(t) {
            var e = [0, this.maxT, this.maxS, this.maxT, 0, 0, this.maxS, 0];
            t = [t.x, t.y, t.x + t.width, t.y, t.x, t.y + t.height, t.x + t.width, t.y + t.height],
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS),
            this._shaderProgram.use(),
            this._shaderProgram.setUniformsForBuiltins(),
            cc.glBindTexture2D(this);
            var i = cc._renderContext;
            i.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, i.FLOAT, !1, 0, t),
            i.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, i.FLOAT, !1, 0, e),
            i.drawArrays(i.TRIANGLE_STRIP, 0, 4)
        },
        initWithImage: function(t) {
            if (null == t)
                return cc.log(cc._LogInfos.Texture2D_initWithImage),
                !1;
            var e = t.getWidth()
              , i = t.getHeight()
              , n = cc.configuration.getMaxTextureSize();
            return e > n || i > n ? (cc.log(cc._LogInfos.Texture2D_initWithImage_2, e, i, n, n),
            !1) : (this._textureLoaded = !0,
            this._initPremultipliedATextureWithImage(t, e, i))
        },
        initWithElement: function(t) {
            t && (this._webTextureObj = cc._renderContext.createTexture(),
            this._htmlElementObj = t,
            this._textureLoaded = !0)
        },
        getHtmlElementObj: function() {
            return this._htmlElementObj
        },
        isLoaded: function() {
            return this._textureLoaded
        },
        handleLoadedTexture: function(t) {
            if (t = void 0 !== t && t,
            cc.game._rendererInitialized) {
                if (!this._htmlElementObj) {
                    var e = cc.loader.getRes(this.url);
                    if (!e)
                        return;
                    this.initWithElement(e)
                }
                this._htmlElementObj.width && this._htmlElementObj.height && (e = cc._renderContext,
                cc.glBindTexture2D(this),
                e.pixelStorei(e.UNPACK_ALIGNMENT, 4),
                t && e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1),
                e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, this._htmlElementObj),
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR),
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR),
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE),
                this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE),
                cc.glBindTexture2D(null),
                t && e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0),
                e = this._htmlElementObj.height,
                this._pixelsWide = this._contentSize.width = this._htmlElementObj.width,
                this._pixelsHigh = this._contentSize.height = e,
                this._pixelFormat = cc.Texture2D.PIXEL_FORMAT_RGBA8888,
                this.maxT = this.maxS = 1,
                this._hasPremultipliedAlpha = t,
                this._hasMipmaps = !1,
                this.dispatchEvent("load"))
            }
        },
        initWithString: function(t, e, i, n, r, c) {
            return cc.log(cc._LogInfos.Texture2D_initWithString),
            null
        },
        initWithETCFile: function(t) {
            return cc.log(cc._LogInfos.Texture2D_initWithETCFile_2),
            !1
        },
        initWithPVRFile: function(t) {
            return cc.log(cc._LogInfos.Texture2D_initWithPVRFile_2),
            !1
        },
        initWithPVRTCData: function(t, e, i, n, r, c) {
            return cc.log(cc._LogInfos.Texture2D_initWithPVRTCData_2),
            !1
        },
        setTexParameters: function(t, e, i, n) {
            var r = cc._renderContext;
            void 0 !== e && (t = {
                minFilter: t,
                magFilter: e,
                wrapS: i,
                wrapT: n
            }),
            cc.assert(this._pixelsWide === cc.NextPOT(this._pixelsWide) && this._pixelsHigh === cc.NextPOT(this._pixelsHigh) || t.wrapS === r.CLAMP_TO_EDGE && t.wrapT === r.CLAMP_TO_EDGE, "WebGLRenderingContext.CLAMP_TO_EDGE should be used in NPOT textures"),
            cc.glBindTexture2D(this),
            r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, t.minFilter),
            r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, t.magFilter),
            r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, t.wrapS),
            r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, t.wrapT)
        },
        setAntiAliasTexParameters: function() {
            var t = cc._renderContext;
            cc.glBindTexture2D(this),
            this._hasMipmaps ? t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR_MIPMAP_NEAREST) : t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR),
            t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.LINEAR)
        },
        setAliasTexParameters: function() {
            var t = cc._renderContext;
            cc.glBindTexture2D(this),
            this._hasMipmaps ? t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST_MIPMAP_NEAREST) : t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST),
            t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST)
        },
        generateMipmap: function() {
            cc.assert(this._pixelsWide === cc.NextPOT(this._pixelsWide) && this._pixelsHigh === cc.NextPOT(this._pixelsHigh), "Mimpap texture only works in POT textures"),
            cc.glBindTexture2D(this),
            cc._renderContext.generateMipmap(cc._renderContext.TEXTURE_2D),
            this._hasMipmaps = !0
        },
        stringForFormat: function() {
            return cc.Texture2D._M[this._pixelFormat]
        },
        bitsPerPixelForFormat: function(t) {
            t = t || this._pixelFormat;
            var e = cc.Texture2D._B[t];
            return null != e ? e : (cc.log(cc._LogInfos.Texture2D_bitsPerPixelForFormat, t),
            -1)
        },
        _initPremultipliedATextureWithImage: function(t, e, i) {
            var n = cc.Texture2D
              , r = t.getData()
              , c = null
              , c = null
              , s = t.hasAlpha()
              , o = cc.size(t.getWidth(), t.getHeight())
              , a = n.defaultPixelFormat
              , h = t.getBitsPerComponent();
            s || (8 <= h ? a = n.PIXEL_FORMAT_RGB888 : (cc.log(cc._LogInfos.Texture2D__initPremultipliedATextureWithImage),
            a = n.PIXEL_FORMAT_RGB565));
            var l = e * i;
            if (a === n.PIXEL_FORMAT_RGB565)
                if (s)
                    for (r = new Uint16Array(e * i),
                    c = t.getData(),
                    h = 0; h < l; ++h)
                        r[h] = (c[h] >> 0 & 255) >> 3 << 11 | (c[h] >> 8 & 255) >> 2 << 5 | (c[h] >> 16 & 255) >> 3 << 0;
                else
                    for (r = new Uint16Array(e * i),
                    c = t.getData(),
                    h = 0; h < l; ++h)
                        r[h] = (255 & c[h]) >> 3 << 11 | (255 & c[h]) >> 2 << 5 | (255 & c[h]) >> 3 << 0;
            else if (a === n.PIXEL_FORMAT_RGBA4444)
                for (r = new Uint16Array(e * i),
                c = t.getData(),
                h = 0; h < l; ++h)
                    r[h] = (c[h] >> 0 & 255) >> 4 << 12 | (c[h] >> 8 & 255) >> 4 << 8 | (c[h] >> 16 & 255) >> 4 << 4 | (c[h] >> 24 & 255) >> 4 << 0;
            else if (a === n.PIXEL_FORMAT_RGB5A1)
                for (r = new Uint16Array(e * i),
                c = t.getData(),
                h = 0; h < l; ++h)
                    r[h] = (c[h] >> 0 & 255) >> 3 << 11 | (c[h] >> 8 & 255) >> 3 << 6 | (c[h] >> 16 & 255) >> 3 << 1 | (c[h] >> 24 & 255) >> 7 << 0;
            else if (a === n.PIXEL_FORMAT_A8)
                for (r = new Uint8Array(e * i),
                c = t.getData(),
                h = 0; h < l; ++h)
                    r[h] = c >> 24 & 255;
            if (s && a === n.PIXEL_FORMAT_RGB888)
                for (c = t.getData(),
                r = new Uint8Array(e * i * 3),
                h = 0; h < l; ++h)
                    r[3 * h] = c >> 0 & 255,
                    r[3 * h + 1] = c >> 8 & 255,
                    r[3 * h + 2] = c >> 16 & 255;
            return this.initWithData(r, a, e, i, o),
            t.getData(),
            this._hasPremultipliedAlpha = t.isPremultipliedAlpha(),
            !0
        },
        addLoadedEventListener: function(t, e) {
            this.addEventListener("load", t, e)
        },
        removeLoadedEventListener: function(t) {
            this.removeEventListener("load", t)
        }
    })
}
,
cc._tmp.WebGLTextureAtlas = function() {
    var t = cc.TextureAtlas.prototype;
    t._setupVBO = function() {
        var t = cc._renderContext;
        this._buffersVBO[0] = t.createBuffer(),
        this._buffersVBO[1] = t.createBuffer(),
        this._quadsWebBuffer = t.createBuffer(),
        this._mapBuffers()
    }
    ,
    t._mapBuffers = function() {
        var t = cc._renderContext;
        t.bindBuffer(t.ARRAY_BUFFER, this._quadsWebBuffer),
        t.bufferData(t.ARRAY_BUFFER, this._quadsArrayBuffer, t.DYNAMIC_DRAW),
        t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]),
        t.bufferData(t.ELEMENT_ARRAY_BUFFER, this._indices, t.STATIC_DRAW)
    }
    ,
    t.drawNumberOfQuads = function(t, e) {
        if (e = e || 0,
        0 !== t && this.texture && this.texture.isLoaded()) {
            var i = cc._renderContext;
            cc.glBindTexture2D(this.texture),
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX),
            i.bindBuffer(i.ARRAY_BUFFER, this._quadsWebBuffer),
            this.dirty && (i.bufferData(i.ARRAY_BUFFER, this._quadsArrayBuffer, i.DYNAMIC_DRAW),
            this.dirty = !1),
            i.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, i.FLOAT, !1, 24, 0),
            i.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, i.UNSIGNED_BYTE, !0, 24, 12),
            i.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, i.FLOAT, !1, 24, 16),
            i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]),
            cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP ? i.drawElements(i.TRIANGLE_STRIP, 6 * t, i.UNSIGNED_SHORT, 6 * e * this._indices.BYTES_PER_ELEMENT) : i.drawElements(i.TRIANGLES, 6 * t, i.UNSIGNED_SHORT, 6 * e * this._indices.BYTES_PER_ELEMENT),
            cc.g_NumberOfDraws++
        }
    }
}
,
cc._tmp.WebGLTextureCache = function() {
    var t = cc.textureCache;
    t.handleLoadedTexture = function(t) {
        var e, i = this._textures;
        cc.game._rendererInitialized || (i = this._loadedTexturesBefore),
        e = i[t],
        e || (e = i[t] = new cc.Texture2D,
        e.url = t),
        ".png" === cc.path.extname(t) ? e.handleLoadedTexture(!0) : e.handleLoadedTexture()
    }
    ,
    t.addImage = function(t, e, i) {
        cc.assert(t, cc._LogInfos.Texture2D_addImage_2);
        var n = this._textures;
        cc.game._rendererInitialized || (n = this._loadedTexturesBefore);
        var r = n[t] || n[cc.loader._getAliase(t)];
        return r ? (r.isLoaded() ? e && e.call(i, r) : r.addEventListener("load", function() {
            e && e.call(i, r)
        }, i),
        r) : (r = n[t] = new cc.Texture2D,
        r.url = t,
        (cc.loader._checkIsImageURL(t) ? cc.loader.load : cc.loader.loadImg).call(cc.loader, t, function(r, c) {
            if (r)
                return e && e.call(i, r);
            cc.textureCache.handleLoadedTexture(t);
            var s = n[t];
            e && e.call(i, s)
        }),
        r)
    }
    ,
    t.addImageAsync = t.addImage,
    t = null
}
,
cc._tmp.PrototypeTexture2D = function() {
    var t = cc.Texture2D;
    t.PVRImagesHavePremultipliedAlpha = function(t) {
        cc.PVRHaveAlphaPremultiplied_ = t
    }
    ,
    t.PIXEL_FORMAT_RGBA8888 = 2,
    t.PIXEL_FORMAT_RGB888 = 3,
    t.PIXEL_FORMAT_RGB565 = 4,
    t.PIXEL_FORMAT_A8 = 5,
    t.PIXEL_FORMAT_I8 = 6,
    t.PIXEL_FORMAT_AI88 = 7,
    t.PIXEL_FORMAT_RGBA4444 = 8,
    t.PIXEL_FORMAT_RGB5A1 = 7,
    t.PIXEL_FORMAT_PVRTC4 = 9,
    t.PIXEL_FORMAT_PVRTC2 = 10,
    t.PIXEL_FORMAT_DEFAULT = t.PIXEL_FORMAT_RGBA8888,
    t.defaultPixelFormat = t.PIXEL_FORMAT_DEFAULT;
    var e = cc.Texture2D._M = {};
    e[t.PIXEL_FORMAT_RGBA8888] = "RGBA8888",
    e[t.PIXEL_FORMAT_RGB888] = "RGB888",
    e[t.PIXEL_FORMAT_RGB565] = "RGB565",
    e[t.PIXEL_FORMAT_A8] = "A8",
    e[t.PIXEL_FORMAT_I8] = "I8",
    e[t.PIXEL_FORMAT_AI88] = "AI88",
    e[t.PIXEL_FORMAT_RGBA4444] = "RGBA4444",
    e[t.PIXEL_FORMAT_RGB5A1] = "RGB5A1",
    e[t.PIXEL_FORMAT_PVRTC4] = "PVRTC4",
    e[t.PIXEL_FORMAT_PVRTC2] = "PVRTC2",
    e = cc.Texture2D._B = {},
    e[t.PIXEL_FORMAT_RGBA8888] = 32,
    e[t.PIXEL_FORMAT_RGB888] = 24,
    e[t.PIXEL_FORMAT_RGB565] = 16,
    e[t.PIXEL_FORMAT_A8] = 8,
    e[t.PIXEL_FORMAT_I8] = 8,
    e[t.PIXEL_FORMAT_AI88] = 16,
    e[t.PIXEL_FORMAT_RGBA4444] = 16,
    e[t.PIXEL_FORMAT_RGB5A1] = 16,
    e[t.PIXEL_FORMAT_PVRTC4] = 4,
    e[t.PIXEL_FORMAT_PVRTC2] = 3,
    t = cc.Texture2D.prototype,
    cc.defineGetterSetter(t, "name", t.getName),
    cc.defineGetterSetter(t, "pixelFormat", t.getPixelFormat),
    cc.defineGetterSetter(t, "pixelsWidth", t.getPixelsWide),
    cc.defineGetterSetter(t, "pixelsHeight", t.getPixelsHigh),
    cc.defineGetterSetter(t, "width", t._getWidth),
    cc.defineGetterSetter(t, "height", t._getHeight)
}
,
cc._tmp.PrototypeTextureAtlas = function() {
    var t = cc.TextureAtlas.prototype;
    cc.defineGetterSetter(t, "totalQuads", t.getTotalQuads),
    cc.defineGetterSetter(t, "capacity", t.getCapacity),
    cc.defineGetterSetter(t, "quads", t.getQuads, t.setQuads)
}
,
cc.ALIGN_CENTER = 51,
cc.ALIGN_TOP = 19,
cc.ALIGN_TOP_RIGHT = 18,
cc.ALIGN_RIGHT = 50,
cc.ALIGN_BOTTOM_RIGHT = 34,
cc.ALIGN_BOTTOM = 35,
cc.ALIGN_BOTTOM_LEFT = 33,
cc.ALIGN_LEFT = 49,
cc.ALIGN_TOP_LEFT = 17,
cc.PVRHaveAlphaPremultiplied_ = !1,
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function() {
    if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
        var t = {
            _contentSize: null,
            _textureLoaded: !1,
            _htmlElementObj: null,
            url: null,
            _pattern: null,
            ctor: function() {
                this._contentSize = cc.size(0, 0),
                this._textureLoaded = !1,
                this._htmlElementObj = null,
                this._pattern = ""
            },
            getPixelsWide: function() {
                return this._contentSize.width
            },
            getPixelsHigh: function() {
                return this._contentSize.height
            },
            getContentSize: function() {
                var t = cc.contentScaleFactor();
                return cc.size(this._contentSize.width / t, this._contentSize.height / t)
            },
            _getWidth: function() {
                return this._contentSize.width / cc.contentScaleFactor()
            },
            _getHeight: function() {
                return this._contentSize.height / cc.contentScaleFactor()
            },
            getContentSizeInPixels: function() {
                return this._contentSize
            },
            initWithElement: function(t) {
                t && (this._htmlElementObj = t,
                this._contentSize.width = t.width,
                this._contentSize.height = t.height,
                this._textureLoaded = !0)
            },
            getHtmlElementObj: function() {
                return this._htmlElementObj
            },
            isLoaded: function() {
                return this._textureLoaded
            },
            handleLoadedTexture: function() {
                if (!this._textureLoaded) {
                    if (!this._htmlElementObj) {
                        var t = cc.loader.getRes(this.url);
                        if (!t)
                            return;
                        this.initWithElement(t)
                    }
                    t = this._htmlElementObj,
                    this._contentSize.width = t.width,
                    this._contentSize.height = t.height,
                    this.dispatchEvent("load")
                }
            },
            description: function() {
                return "<cc.Texture2D | width = " + this._contentSize.width + " height " + this._contentSize.height + ">"
            },
            initWithData: function(t, e, i, n, r) {
                return !1
            },
            initWithImage: function(t) {
                return !1
            },
            initWithString: function(t, e, i, n, r, c) {
                return !1
            },
            releaseTexture: function() {
                cc.loader.release(this.url)
            },
            getName: function() {
                return null
            },
            getMaxS: function() {
                return 1
            },
            setMaxS: function(t) {},
            getMaxT: function() {
                return 1
            },
            setMaxT: function(t) {},
            getPixelFormat: function() {
                return null
            },
            getShaderProgram: function() {
                return null
            },
            setShaderProgram: function(t) {},
            hasPremultipliedAlpha: function() {
                return !1
            },
            hasMipmaps: function() {
                return !1
            },
            releaseData: function(t) {},
            keepData: function(t, e) {
                return t
            },
            drawAtPoint: function(t) {},
            drawInRect: function(t) {},
            initWithETCFile: function(t) {
                return cc.log(cc._LogInfos.Texture2D_initWithETCFile),
                !1
            },
            initWithPVRFile: function(t) {
                return cc.log(cc._LogInfos.Texture2D_initWithPVRFile),
                !1
            },
            initWithPVRTCData: function(t, e, i, n, r, c) {
                return cc.log(cc._LogInfos.Texture2D_initWithPVRTCData),
                !1
            },
            setTexParameters: function(t, e, i, n) {
                void 0 !== e && (t = {
                    minFilter: t,
                    magFilter: e,
                    wrapS: i,
                    wrapT: n
                }),
                this._pattern = t.wrapS === cc.REPEAT && t.wrapT === cc.REPEAT ? "repeat" : t.wrapS === cc.REPEAT ? "repeat-x" : t.wrapT === cc.REPEAT ? "repeat-y" : ""
            },
            setAntiAliasTexParameters: function() {},
            setAliasTexParameters: function() {},
            generateMipmap: function() {},
            stringForFormat: function() {
                return ""
            },
            bitsPerPixelForFormat: function(t) {
                return -1
            },
            addLoadedEventListener: function(t, e) {
                this.addEventListener("load", t, e)
            },
            removeLoadedEventListener: function(t) {
                this.removeEventListener("load", t)
            },
            _generateColorTexture: function() {},
            _generateTextureCacheForColor: function() {
                if (this.channelCache)
                    return this.channelCache;
                var t = [document.createElement("canvas"), document.createElement("canvas"), document.createElement("canvas"), document.createElement("canvas")]
                  , e = this._htmlElementObj
                  , i = e.width
                  , n = e.height;
                t[0].width = i,
                t[0].height = n,
                t[1].width = i,
                t[1].height = n,
                t[2].width = i,
                t[2].height = n,
                t[3].width = i,
                t[3].height = n;
                var r = t[3].getContext("2d");
                r.drawImage(e, 0, 0);
                for (var c, r = r.getImageData(0, 0, i, n).data, s = 0; 4 > s; s++) {
                    c = t[s].getContext("2d");
                    for (var o = c.getImageData(0, 0, i, n), a = o.data, h = 0; h < r.length; h += 4)
                        a[h] = 0 === s ? r[h] : 0,
                        a[h + 1] = 1 === s ? r[h + 1] : 0,
                        a[h + 2] = 2 === s ? r[h + 2] : 0,
                        a[h + 3] = r[h + 3];
                    c.putImageData(o, 0, 0)
                }
                return e.onload = null,
                this.channelCache = t
            },
            _grayElementObj: null,
            _backupElement: null,
            _isGray: !1,
            _switchToGray: function(t) {
                this._textureLoaded && this._isGray !== t && ((this._isGray = t) ? (this._backupElement = this._htmlElementObj,
                this._grayElementObj || (this._grayElementObj = cc.Texture2D._generateGrayTexture(this._htmlElementObj)),
                this._htmlElementObj = this._grayElementObj) : null !== this._backupElement && (this._htmlElementObj = this._backupElement))
            }
        };
        t._generateColorTexture = cc.sys._supportCanvasNewBlendModes ? function(t, e, i, n, r) {
            var c = !1;
            r ? c = !0 : r = document.createElement("canvas");
            var s = this._htmlElementObj;
            n || (n = cc.rect(0, 0, s.width, s.height)),
            r.width = n.width,
            r.height = n.height;
            var o = r.getContext("2d");
            return o.globalCompositeOperation = "source-over",
            o.fillStyle = "rgb(" + (0 | t) + "," + (0 | e) + "," + (0 | i) + ")",
            o.fillRect(0, 0, n.width, n.height),
            o.globalCompositeOperation = "multiply",
            o.drawImage(s, n.x, n.y, n.width, n.height, 0, 0, n.width, n.height),
            o.globalCompositeOperation = "destination-atop",
            o.drawImage(s, n.x, n.y, n.width, n.height, 0, 0, n.width, n.height),
            c ? r : (t = new cc.Texture2D,
            t.initWithElement(r),
            t.handleLoadedTexture(),
            t)
        }
        : function(t, e, i, n, r) {
            var c = !1;
            r ? c = !0 : r = document.createElement("canvas");
            var s = this._htmlElementObj;
            n || (n = cc.rect(0, 0, s.width, s.height));
            var o, a, s = n.x;
            if (o = n.y,
            a = n.width,
            n = n.height,
            a && n) {
                r.width = a,
                r.height = n;
                var h = r.getContext("2d")
                  , l = cc.textureCache.getTextureColors(this);
                return h.globalCompositeOperation = "lighter",
                h.drawImage(l[3], s, o, a, n, 0, 0, a, n),
                0 < t && (h.globalAlpha = t / 255,
                h.drawImage(l[0], s, o, a, n, 0, 0, a, n)),
                0 < e && (h.globalAlpha = e / 255,
                h.drawImage(l[1], s, o, a, n, 0, 0, a, n)),
                0 < i && (h.globalAlpha = i / 255,
                h.drawImage(l[2], s, o, a, n, 0, 0, a, n)),
                c ? r : (t = new cc.Texture2D,
                t.initWithElement(r),
                t.handleLoadedTexture(),
                t)
            }
        }
        ,
        cc.Texture2D = cc.Class.extend(t),
        cc.Texture2D._generateGrayTexture = function(t, e, i) {
            if (null === t)
                return null;
            i = i || document.createElement("canvas"),
            e = e || cc.rect(0, 0, t.width, t.height),
            i.width = e.width,
            i.height = e.height;
            var n = i.getContext("2d");
            n.drawImage(t, e.x, e.y, e.width, e.height, 0, 0, e.width, e.height),
            t = n.getImageData(0, 0, e.width, e.height),
            e = t.data;
            for (var r = 0, c = e.length; r < c; r += 4)
                e[r] = e[r + 1] = e[r + 2] = .34 * e[r] + .5 * e[r + 1] + .16 * e[r + 2];
            return n.putImageData(t, 0, 0),
            i
        }
    } else
        cc._renderType === cc.game.RENDER_TYPE_WEBGL && (cc.assert(cc.isFunction(cc._tmp.WebGLTexture2D), cc._LogInfos.MissingFile, "TexturesWebGL.js"),
        cc._tmp.WebGLTexture2D(),
        delete cc._tmp.WebGLTexture2D);
    cc.EventHelper.prototype.apply(cc.Texture2D.prototype),
    cc.assert(cc.isFunction(cc._tmp.PrototypeTexture2D), cc._LogInfos.MissingFile, "TexturesPropertyDefine.js"),
    cc._tmp.PrototypeTexture2D(),
    delete cc._tmp.PrototypeTexture2D
}),
cc.textureCache = {
    _textures: {},
    _textureColorsCache: {},
    _textureKeySeq: 0 | 1e3 * Math.random(),
    _loadedTexturesBefore: {},
    _initializingRenderer: function() {
        var t, e = this._loadedTexturesBefore, i = this._textures;
        for (t in e) {
            var n = e[t];
            n.handleLoadedTexture(),
            i[t] = n
        }
        this._loadedTexturesBefore = {}
    },
    addPVRTCImage: function(t) {
        cc.log(cc._LogInfos.textureCache_addPVRTCImage)
    },
    addETCImage: function(t) {
        cc.log(cc._LogInfos.textureCache_addETCImage)
    },
    description: function() {
        return "<TextureCache | Number of textures = " + this._textures.length + ">";
    },
    textureForKey: function(t) {
        return cc.log(cc._LogInfos.textureCache_textureForKey),
        this.getTextureForKey(t)
    },
    getTextureForKey: function(t) {
        return this._textures[t] || this._textures[cc.loader._getAliase(t)]
    },
    getKeyByTexture: function(t) {
        for (var e in this._textures)
            if (this._textures[e] === t)
                return e;
        return null
    },
    _generalTextureKey: function(t) {
        return "_textureKey_" + t
    },
    getTextureColors: function(t) {
        var e = t._htmlElementObj
          , i = this.getKeyByTexture(e);
        return i || (i = e instanceof HTMLImageElement ? e.src : this._generalTextureKey(t.__instanceId)),
        this._textureColorsCache[i] || (this._textureColorsCache[i] = t._generateTextureCacheForColor()),
        this._textureColorsCache[i]
    },
    addPVRImage: function(t) {
        cc.log(cc._LogInfos.textureCache_addPVRImage)
    },
    removeAllTextures: function() {
        var t, e = this._textures;
        for (t in e)
            e[t] && e[t].releaseTexture();
        this._textures = {}
    },
    removeTexture: function(t) {
        if (t) {
            var e, i = this._textures;
            for (e in i)
                i[e] === t && (i[e].releaseTexture(),
                delete i[e])
        }
    },
    removeTextureForKey: function(t) {
        null != t && this._textures[t] && delete this._textures[t]
    },
    cacheImage: function(t, e) {
        if (e instanceof cc.Texture2D)
            this._textures[t] = e;
        else {
            var i = new cc.Texture2D;
            i.initWithElement(e),
            i.handleLoadedTexture(),
            this._textures[t] = i
        }
    },
    addUIImage: function(t, e) {
        if (cc.assert(t, cc._LogInfos.textureCache_addUIImage_2),
        e && this._textures[e])
            return this._textures[e];
        var i = new cc.Texture2D;
        return i.initWithImage(t),
        null != e ? this._textures[e] = i : cc.log(cc._LogInfos.textureCache_addUIImage),
        i
    },
    dumpCachedTextureInfo: function() {
        var t, e = 0, i = 0, n = this._textures;
        for (t in n) {
            var r = n[t];
            e++,
            r.getHtmlElementObj()instanceof HTMLImageElement ? cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo, t, r.getHtmlElementObj().src, r.pixelsWidth, r.pixelsHeight) : cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_2, t, r.pixelsWidth, r.pixelsHeight),
            i += r.pixelsWidth * r.pixelsHeight * 4
        }
        n = this._textureColorsCache;
        for (t in n) {
            var c, r = n[t];
            for (c in r) {
                var s = r[c];
                e++,
                cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_2, t, s.width, s.height),
                i += s.width * s.height * 4
            }
        }
        cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_3, e, i / 1024, (i / 1048576).toFixed(2))
    },
    _clear: function() {
        this._textures = {},
        this._textureColorsCache = {},
        this._textureKeySeq = 0 | 1e3 * Math.random(),
        this._loadedTexturesBefore = {}
    }
},
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function() {
    if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
        var t = cc.textureCache;
        t.handleLoadedTexture = function(t) {
            var e = this._textures
              , i = e[t];
            i || (i = e[t] = new cc.Texture2D,
            i.url = t),
            i.handleLoadedTexture()
        }
        ,
        t.addImage = function(t, e, i) {
            cc.assert(t, cc._LogInfos.Texture2D_addImage);
            var n = this._textures
              , r = n[t] || n[cc.loader._getAliase(t)];
            return r ? (r.isLoaded() ? e && e.call(i, r) : r.addEventListener("load", function() {
                e && e.call(i, r)
            }, i),
            r) : (r = n[t] = new cc.Texture2D,
            r.url = t,
            (cc.loader._checkIsImageURL(t) ? cc.loader.load : cc.loader.loadImg).call(cc.loader, t, function(r, c) {
                if (r)
                    return e && e.call(i, r);
                cc.textureCache.handleLoadedTexture(t);
                var s = n[t];
                e && e.call(i, s)
            }),
            r)
        }
        ,
        t.addImageAsync = t.addImage,
        t = null
    } else
        cc._renderType === cc.game.RENDER_TYPE_WEBGL && (cc.assert(cc.isFunction(cc._tmp.WebGLTextureCache), cc._LogInfos.MissingFile, "TexturesWebGL.js"),
        cc._tmp.WebGLTextureCache(),
        delete cc._tmp.WebGLTextureCache)
}),
cc.TextureAtlas = cc.Class.extend({
    dirty: !1,
    texture: null,
    _indices: null,
    _buffersVBO: null,
    _capacity: 0,
    _quads: null,
    _quadsArrayBuffer: null,
    _quadsWebBuffer: null,
    _quadsReader: null,
    ctor: function(t, e) {
        this._buffersVBO = [],
        cc.isString(t) ? this.initWithFile(t, e) : t instanceof cc.Texture2D && this.initWithTexture(t, e)
    },
    getTotalQuads: function() {
        return this._totalQuads
    },
    getCapacity: function() {
        return this._capacity
    },
    getTexture: function() {
        return this.texture
    },
    setTexture: function(t) {
        this.texture = t
    },
    setDirty: function(t) {
        this.dirty = t
    },
    isDirty: function() {
        return this.dirty
    },
    getQuads: function() {
        return this._quads
    },
    setQuads: function(t) {
        this._quads = t
    },
    _copyQuadsToTextureAtlas: function(t, e) {
        if (t)
            for (var i = 0; i < t.length; i++)
                this._setQuadToArray(t[i], e + i)
    },
    _setQuadToArray: function(t, e) {
        var i = this._quads;
        i[e] ? (i[e].bl = t.bl,
        i[e].br = t.br,
        i[e].tl = t.tl,
        i[e].tr = t.tr) : i[e] = new cc.V3F_C4B_T2F_Quad(t.tl,t.bl,t.tr,t.br,this._quadsArrayBuffer,e * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT)
    },
    description: function() {
        return "<cc.TextureAtlas | totalQuads =" + this._totalQuads + ">"
    },
    _setupIndices: function() {
        if (0 !== this._capacity)
            for (var t = this._indices, e = this._capacity, i = 0; i < e; i++)
                cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP ? (t[6 * i + 0] = 4 * i + 0,
                t[6 * i + 1] = 4 * i + 0,
                t[6 * i + 2] = 4 * i + 2,
                t[6 * i + 3] = 4 * i + 1,
                t[6 * i + 4] = 4 * i + 3,
                t[6 * i + 5] = 4 * i + 3) : (t[6 * i + 0] = 4 * i + 0,
                t[6 * i + 1] = 4 * i + 1,
                t[6 * i + 2] = 4 * i + 2,
                t[6 * i + 3] = 4 * i + 3,
                t[6 * i + 4] = 4 * i + 2,
                t[6 * i + 5] = 4 * i + 1)
    },
    _setupVBO: function() {
        var t = cc._renderContext;
        this._buffersVBO[0] = t.createBuffer(),
        this._buffersVBO[1] = t.createBuffer(),
        this._quadsWebBuffer = t.createBuffer(),
        this._mapBuffers()
    },
    _mapBuffers: function() {
        var t = cc._renderContext;
        t.bindBuffer(t.ARRAY_BUFFER, this._quadsWebBuffer),
        t.bufferData(t.ARRAY_BUFFER, this._quadsArrayBuffer, t.DYNAMIC_DRAW),
        t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]),
        t.bufferData(t.ELEMENT_ARRAY_BUFFER, this._indices, t.STATIC_DRAW)
    },
    initWithFile: function(t, e) {
        var i = cc.textureCache.addImage(t);
        return i ? this.initWithTexture(i, e) : (cc.log(cc._LogInfos.TextureAtlas_initWithFile, t),
        !1)
    },
    initWithTexture: function(t, e) {
        cc.assert(t, cc._LogInfos.TextureAtlas_initWithTexture),
        this._capacity = e |= 0,
        this._totalQuads = 0,
        this.texture = t,
        this._quads = [],
        this._indices = new Uint16Array(6 * e);
        var i = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
        if (this._quadsArrayBuffer = new ArrayBuffer(i * e),
        this._quadsReader = new Uint8Array(this._quadsArrayBuffer),
        (!this._quads || !this._indices) && 0 < e)
            return !1;
        for (var n = this._quads, r = 0; r < e; r++)
            n[r] = new cc.V3F_C4B_T2F_Quad(null,null,null,null,this._quadsArrayBuffer,r * i);
        return this._setupIndices(),
        this._setupVBO(),
        this.dirty = !0
    },
    updateQuad: function(t, e) {
        cc.assert(t, cc._LogInfos.TextureAtlas_updateQuad),
        cc.assert(0 <= e && e < this._capacity, cc._LogInfos.TextureAtlas_updateQuad_2),
        this._totalQuads = Math.max(e + 1, this._totalQuads),
        this._setQuadToArray(t, e),
        this.dirty = !0
    },
    insertQuad: function(t, e) {
        if (cc.assert(e < this._capacity, cc._LogInfos.TextureAtlas_insertQuad_2),
        this._totalQuads++,
        this._totalQuads > this._capacity)
            cc.log(cc._LogInfos.TextureAtlas_insertQuad);
        else {
            var i = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT
              , n = e * i
              , r = (this._totalQuads - 1 - e) * i;
            this._quads[this._totalQuads - 1] = new cc.V3F_C4B_T2F_Quad(null,null,null,null,this._quadsArrayBuffer,(this._totalQuads - 1) * i),
            this._quadsReader.set(this._quadsReader.subarray(n, n + r), n + i),
            this._setQuadToArray(t, e),
            this.dirty = !0
        }
    },
    insertQuads: function(t, e, i) {
        i = i || t.length,
        cc.assert(e + i <= this._capacity, cc._LogInfos.TextureAtlas_insertQuads);
        var n = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
        if (this._totalQuads += i,
        this._totalQuads > this._capacity)
            cc.log(cc._LogInfos.TextureAtlas_insertQuad);
        else {
            var r, c = e * n, s = (this._totalQuads - 1 - e - i) * n, o = this._totalQuads - 1 - i;
            for (r = 0; r < i; r++)
                this._quads[o + r] = new cc.V3F_C4B_T2F_Quad(null,null,null,null,this._quadsArrayBuffer,(this._totalQuads - 1) * n);
            for (this._quadsReader.set(this._quadsReader.subarray(c, c + s), c + n * i),
            r = 0; r < i; r++)
                this._setQuadToArray(t[r], e + r);
            this.dirty = !0
        }
    },
    insertQuadFromIndex: function(t, e) {
        if (t !== e) {
            cc.assert(0 <= e || e < this._totalQuads, cc._LogInfos.TextureAtlas_insertQuadFromIndex),
            cc.assert(0 <= t || t < this._totalQuads, cc._LogInfos.TextureAtlas_insertQuadFromIndex_2);
            var i, n = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, r = this._quadsReader, c = r.subarray(t * n, n);
            t > e ? (i = e * n,
            r.set(r.subarray(i, i + (t - e) * n), i + n),
            r.set(c, i)) : (i = (t + 1) * n,
            r.set(r.subarray(i, i + (e - t) * n), i - n),
            r.set(c, e * n)),
            this.dirty = !0
        }
    },
    removeQuadAtIndex: function(t) {
        cc.assert(t < this._totalQuads, cc._LogInfos.TextureAtlas_removeQuadAtIndex);
        var e = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
        if (this._totalQuads--,
        this._quads.length = this._totalQuads,
        t !== this._totalQuads) {
            var i = (t + 1) * e;
            this._quadsReader.set(this._quadsReader.subarray(i, i + (this._totalQuads - t) * e), i - e)
        }
        this.dirty = !0
    },
    removeQuadsAtIndex: function(t, e) {
        if (cc.assert(t + e <= this._totalQuads, cc._LogInfos.TextureAtlas_removeQuadsAtIndex),
        this._totalQuads -= e,
        t !== this._totalQuads) {
            var i = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT
              , n = (t + e) * i
              , r = t * i;
            this._quadsReader.set(this._quadsReader.subarray(n, n + (this._totalQuads - t) * i), r)
        }
        this.dirty = !0
    },
    removeAllQuads: function() {
        this._totalQuads = this._quads.length = 0
    },
    _setDirty: function(t) {
        this.dirty = t
    },
    resizeCapacity: function(t) {
        if (t === this._capacity)
            return !0;
        var e = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT
          , i = this._capacity;
        this._totalQuads = Math.min(this._totalQuads, t);
        var n = this._capacity = 0 | t
          , r = this._totalQuads;
        if (null === this._quads)
            for (this._quads = [],
            this._quadsArrayBuffer = new ArrayBuffer(e * n),
            this._quadsReader = new Uint8Array(this._quadsArrayBuffer),
            t = 0; t < n; t++)
                this._quads = new cc.V3F_C4B_T2F_Quad(null,null,null,null,this._quadsArrayBuffer,t * e);
        else {
            var c, s, o = this._quads;
            if (n > i) {
                for (c = [],
                s = new ArrayBuffer(e * n),
                t = 0; t < r; t++)
                    c[t] = new cc.V3F_C4B_T2F_Quad(o[t].tl,o[t].bl,o[t].tr,o[t].br,s,t * e);
                for (; t < n; t++)
                    c[t] = new cc.V3F_C4B_T2F_Quad(null,null,null,null,s,t * e)
            } else
                for (r = Math.max(r, n),
                c = [],
                s = new ArrayBuffer(e * n),
                t = 0; t < r; t++)
                    c[t] = new cc.V3F_C4B_T2F_Quad(o[t].tl,o[t].bl,o[t].tr,o[t].br,s,t * e);
            this._quadsReader = new Uint8Array(s),
            this._quads = c,
            this._quadsArrayBuffer = s
        }
        return null === this._indices ? this._indices = new Uint16Array(6 * n) : n > i ? (e = new Uint16Array(6 * n),
        e.set(this._indices, 0),
        this._indices = e) : this._indices = this._indices.subarray(0, 6 * n),
        this._setupIndices(),
        this._mapBuffers(),
        this.dirty = !0
    },
    increaseTotalQuadsWith: function(t) {
        this._totalQuads += t
    },
    moveQuadsFromIndex: function(t, e, i) {
        if (void 0 === i) {
            if (i = e,
            e = this._totalQuads - t,
            cc.assert(i + (this._totalQuads - t) <= this._capacity, cc._LogInfos.TextureAtlas_moveQuadsFromIndex),
            0 === e)
                return
        } else if (cc.assert(i + e <= this._totalQuads, cc._LogInfos.TextureAtlas_moveQuadsFromIndex_2),
        cc.assert(t < this._totalQuads, cc._LogInfos.TextureAtlas_moveQuadsFromIndex_3),
        t === i)
            return;
        var n = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT
          , r = t * n
          , c = e * n
          , s = this._quadsReader
          , o = s.subarray(r, r + c)
          , a = i * n;
        i < t ? (e = i * n,
        s.set(s.subarray(e, e + (t - i) * n), e + c)) : (e = (t + e) * n,
        s.set(s.subarray(e, e + (i - t) * n), r)),
        s.set(o, a),
        this.dirty = !0
    },
    fillWithEmptyQuadsFromIndex: function(t, e) {
        for (var i = e * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, n = new Uint8Array(this._quadsArrayBuffer,t * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,i), r = 0; r < i; r++)
            n[r] = 0
    },
    drawQuads: function() {
        this.drawNumberOfQuads(this._totalQuads, 0)
    },
    _releaseBuffer: function() {
        var t = cc._renderContext;
        this._buffersVBO && (this._buffersVBO[0] && t.deleteBuffer(this._buffersVBO[0]),
        this._buffersVBO[1] && t.deleteBuffer(this._buffersVBO[1])),
        this._quadsWebBuffer && t.deleteBuffer(this._quadsWebBuffer)
    }
}),
_p = cc.TextureAtlas.prototype,
cc.defineGetterSetter(_p, "totalQuads", _p.getTotalQuads),
cc.defineGetterSetter(_p, "capacity", _p.getCapacity),
cc.defineGetterSetter(_p, "quads", _p.getQuads, _p.setQuads),
cc.TextureAtlas.create = function(t, e) {
    return new cc.TextureAtlas(t,e)
}
,
cc.TextureAtlas.createWithTexture = cc.TextureAtlas.create,
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function() {
    cc._renderType === cc.game.RENDER_TYPE_WEBGL && (cc.assert(cc.isFunction(cc._tmp.WebGLTextureAtlas), cc._LogInfos.MissingFile, "TexturesWebGL.js"),
    cc._tmp.WebGLTextureAtlas(),
    delete cc._tmp.WebGLTextureAtlas)
}),
cc.assert(cc.isFunction(cc._tmp.PrototypeTextureAtlas), cc._LogInfos.MissingFile, "TexturesPropertyDefine.js"),
cc._tmp.PrototypeTextureAtlas(),
delete cc._tmp.PrototypeTextureAtlas,
cc.Scene = cc.Node.extend({
    _className: "Scene",
    ctor: function() {
        cc.Node.prototype.ctor.call(this),
        this._ignoreAnchorPointForPosition = !0,
        this.setAnchorPoint(.5, .5),
        this.setContentSize(cc.director.getWinSize())
    }
}),
cc.Scene.create = function() {
    return new cc.Scene
}
,
cc.LoaderScene = cc.Scene.extend({
    _interval: null,
    _label: null,
    _className: "LoaderScene",
    cb: null,
    target: null,
    init: function() {
        var t = this
          , e = 200
          , i = t._bgLayer = new cc.LayerColor(cc.color(32, 32, 32, 255));
        t.addChild(i, 0);
        var n = 24
          , r = -e / 2 + 100;
        return cc._loaderImage && (cc.loader.loadImg(cc._loaderImage, {
            isCrossOrigin: !1
        }, function(i, n) {
            e = n.height,
            t._initStage(n, cc.visibleRect.center)
        }),
        n = 14,
        r = -e / 2 - 10),
        n = t._label = new cc.LabelTTF(window.famobi.__("Loading... ") + "0%","Arial",n),
        n.setPosition(cc.pAdd(cc.visibleRect.center, cc.p(0, r))),
        n.setColor(cc.color(180, 180, 180)),
        i.addChild(this._label, 10),
        !0
    },
    _initStage: function(t, e) {
        var i = this._texture2d = new cc.Texture2D;
        i.initWithElement(t),
        i.handleLoadedTexture(),
        i = this._logo = new cc.Sprite(i),
        i.setScale(cc.contentScaleFactor()),
        i.x = e.x,
        i.y = e.y,
        this._bgLayer.addChild(i, 10)
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this),
        this.schedule(this._startLoading, .3)
    },
    onExit: function() {
        cc.Node.prototype.onExit.call(this),
        this._label.setString(window.famobi.__("Loading... ") + "0%")
    },
    initWithResources: function(t, e, i) {
        cc.isString(t) && (t = [t]),
        this.resources = t || [],
        this.cb = e,
        this.target = i
    },
    _startLoading: function() {
        var t = this;
        t.unschedule(t._startLoading),
        cc.loader.load(t.resources, function(e, i, n) {
            e = Math.min(n / i * 100 | 0, 100),
            t._label.setString(window.famobi.__("Loading... ") + e + "%")
        }, function() {
            t.cb && t.cb.call(t.target)
        })
    },
    _updateTransform: function() {
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty),
        this._bgLayer._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty),
        this._label._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty),
        this._logo._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    }
}),
cc.LoaderScene.preload = function(t, e, i) {
    var n = cc;
    return n.loaderScene || (n.loaderScene = new cc.LoaderScene,
    n.loaderScene.init(),
    cc.eventManager.addCustomListener(cc.Director.EVENT_PROJECTION_CHANGED, function() {
        n.loaderScene._updateTransform()
    })),
    n.loaderScene.initWithResources(t, e, i),
    cc.director.runScene(n.loaderScene),
    n.loaderScene
}
,
cc.Layer = cc.Node.extend({
    _className: "Layer",
    ctor: function() {
        var t = cc.Node.prototype;
        t.ctor.call(this),
        this._ignoreAnchorPointForPosition = !0,
        t.setAnchorPoint.call(this, .5, .5),
        t.setContentSize.call(this, cc.winSize)
    },
    init: function() {
        return this._ignoreAnchorPointForPosition = !0,
        this.setAnchorPoint(.5, .5),
        this.setContentSize(cc.winSize),
        this._cascadeOpacityEnabled = this._cascadeColorEnabled = !1,
        !0
    },
    bake: function() {
        this._renderCmd.bake()
    },
    unbake: function() {
        this._renderCmd.unbake()
    },
    isBaked: function() {
        return this._renderCmd._isBaked
    },
    addChild: function(t, e, i) {
        cc.Node.prototype.addChild.call(this, t, e, i),
        this._renderCmd._bakeForAddChild(t)
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.Layer.CanvasRenderCmd(this) : new cc.Layer.WebGLRenderCmd(this)
    }
}),
cc.Layer.create = function() {
    return new cc.Layer
}
,
cc.LayerColor = cc.Layer.extend({
    _blendFunc: null,
    _className: "LayerColor",
    getBlendFunc: function() {
        return this._blendFunc
    },
    changeWidthAndHeight: function(t, e) {
        this.width = t,
        this.height = e
    },
    changeWidth: function(t) {
        this.width = t
    },
    changeHeight: function(t) {
        this.height = t
    },
    setOpacityModifyRGB: function(t) {},
    isOpacityModifyRGB: function() {
        return !1
    },
    ctor: function(t, e, i) {
        cc.Layer.prototype.ctor.call(this),
        this._blendFunc = new cc.BlendFunc(cc.SRC_ALPHA,cc.ONE_MINUS_SRC_ALPHA),
        cc.LayerColor.prototype.init.call(this, t, e, i)
    },
    init: function(t, e, i) {
        cc._renderType !== cc.game.RENDER_TYPE_CANVAS && (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_COLOR));
        var n = cc.director.getWinSize();
        return t = t || cc.color(0, 0, 0, 255),
        e = void 0 === e ? n.width : e,
        i = void 0 === i ? n.height : i,
        n = this._realColor,
        n.r = t.r,
        n.g = t.g,
        n.b = t.b,
        this._realOpacity = t.a,
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty | cc.Node._dirtyFlags.opacityDirty),
        cc.LayerColor.prototype.setContentSize.call(this, e, i),
        !0
    },
    setBlendFunc: function(t, e) {
        var i = this._blendFunc;
        void 0 === e ? (i.src = t.src,
        i.dst = t.dst) : (i.src = t,
        i.dst = e),
        this._renderCmd.updateBlendFunc(i)
    },
    _setWidth: function(t) {
        cc.Node.prototype._setWidth.call(this, t),
        this._renderCmd._updateSquareVerticesWidth(t)
    },
    _setHeight: function(t) {
        cc.Node.prototype._setHeight.call(this, t),
        this._renderCmd._updateSquareVerticesHeight(t)
    },
    setContentSize: function(t, e) {
        cc.Layer.prototype.setContentSize.call(this, t, e),
        this._renderCmd._updateSquareVertices(t, e)
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.LayerColor.CanvasRenderCmd(this) : new cc.LayerColor.WebGLRenderCmd(this)
    }
}),
cc.LayerColor.create = function(t, e, i) {
    return new cc.LayerColor(t,e,i)
}
,
function() {
    var t = cc.LayerColor.prototype;
    cc.defineGetterSetter(t, "width", t._getWidth, t._setWidth),
    cc.defineGetterSetter(t, "height", t._getHeight, t._setHeight)
}(),
cc.LayerGradient = cc.LayerColor.extend({
    _endColor: null,
    _startOpacity: 255,
    _endOpacity: 255,
    _alongVector: null,
    _compressedInterpolation: !1,
    _className: "LayerGradient",
    _colorStops: [],
    ctor: function(t, e, i, n) {
        cc.LayerColor.prototype.ctor.call(this),
        this._endColor = cc.color(0, 0, 0, 255),
        this._alongVector = cc.p(0, -1),
        this._endOpacity = this._startOpacity = 255,
        n && n instanceof Array ? (this._colorStops = n,
        n.splice(0, 0, {
            p: 0,
            color: t || cc.color.BLACK
        }),
        n.push({
            p: 1,
            color: e || cc.color.BLACK
        })) : this._colorStops = [{
            p: 0,
            color: t || cc.color.BLACK
        }, {
            p: 1,
            color: e || cc.color.BLACK
        }],
        cc.LayerGradient.prototype.init.call(this, t, e, i, n)
    },
    init: function(t, e, i, n) {
        return t = t || cc.color(0, 0, 0, 255),
        e = e || cc.color(0, 0, 0, 255),
        i = i || cc.p(0, -1),
        n = this._endColor,
        this._startOpacity = t.a,
        n.r = e.r,
        n.g = e.g,
        n.b = e.b,
        this._endOpacity = e.a,
        this._alongVector = i,
        this._compressedInterpolation = !0,
        cc.LayerColor.prototype.init.call(this, cc.color(t.r, t.g, t.b, 255)),
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty | cc.Node._dirtyFlags.opacityDirty | cc.Node._dirtyFlags.gradientDirty),
        !0
    },
    setContentSize: function(t, e) {
        cc.LayerColor.prototype.setContentSize.call(this, t, e),
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
    },
    _setWidth: function(t) {
        cc.LayerColor.prototype._setWidth.call(this, t),
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
    },
    _setHeight: function(t) {
        cc.LayerColor.prototype._setHeight.call(this, t),
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
    },
    getStartColor: function() {
        return cc.color(this._realColor)
    },
    setStartColor: function(t) {
        this.color = t;
        var e = this._colorStops;
        e && 0 < e.length && (e = e[0].color,
        e.r = t.r,
        e.g = t.g,
        e.b = t.b)
    },
    setEndColor: function(t) {
        var e = this._endColor;
        e.r = t.r,
        e.g = t.g,
        e.b = t.b,
        (e = this._colorStops) && 0 < e.length && (e = e[e.length - 1].color,
        e.r = t.r,
        e.g = t.g,
        e.b = t.b),
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty)
    },
    getEndColor: function() {
        return cc.color(this._endColor)
    },
    setStartOpacity: function(t) {
        this._startOpacity = t;
        var e = this._colorStops;
        e && 0 < e.length && (e[0].color.a = t),
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
    },
    getStartOpacity: function() {
        return this._startOpacity
    },
    setEndOpacity: function(t) {
        this._endOpacity = t;
        var e = this._colorStops;
        e && 0 < e.length && (e[e.length - 1].color.a = t),
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
    },
    getEndOpacity: function() {
        return this._endOpacity
    },
    setVector: function(t) {
        this._alongVector.x = t.x,
        this._alongVector.y = t.y,
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
    },
    getVector: function() {
        return cc.p(this._alongVector.x, this._alongVector.y)
    },
    isCompressedInterpolation: function() {
        return this._compressedInterpolation
    },
    setCompressedInterpolation: function(t) {
        this._compressedInterpolation = t,
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
    },
    getColorStops: function() {
        return this._colorStops
    },
    setColorStops: function(t) {
        this._colorStops = t,
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty | cc.Node._dirtyFlags.opacityDirty | cc.Node._dirtyFlags.gradientDirty)
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.LayerGradient.CanvasRenderCmd(this) : new cc.LayerGradient.WebGLRenderCmd(this)
    }
}),
cc.LayerGradient.create = function(t, e, i, n) {
    return new cc.LayerGradient(t,e,i,n)
}
,
function() {
    var t = cc.LayerGradient.prototype;
    cc.defineGetterSetter(t, "startColor", t.getStartColor, t.setStartColor),
    cc.defineGetterSetter(t, "endColor", t.getEndColor, t.setEndColor),
    cc.defineGetterSetter(t, "startOpacity", t.getStartOpacity, t.setStartOpacity),
    cc.defineGetterSetter(t, "endOpacity", t.getEndOpacity, t.setEndOpacity),
    cc.defineGetterSetter(t, "vector", t.getVector, t.setVector),
    cc.defineGetterSetter(t, "colorStops", t.getColorStops, t.setColorStops)
}(),
cc.LayerMultiplex = cc.Layer.extend({
    _enabledLayer: 0,
    _layers: null,
    _className: "LayerMultiplex",
    ctor: function(t) {
        cc.Layer.prototype.ctor.call(this),
        t instanceof Array ? cc.LayerMultiplex.prototype.initWithLayers.call(this, t) : cc.LayerMultiplex.prototype.initWithLayers.call(this, Array.prototype.slice.call(arguments))
    },
    initWithLayers: function(t) {
        return 0 < t.length && null == t[t.length - 1] && cc.log(cc._LogInfos.LayerMultiplex_initWithLayers),
        this._layers = t,
        this._enabledLayer = 0,
        this.addChild(this._layers[this._enabledLayer]),
        !0
    },
    switchTo: function(t) {
        t >= this._layers.length ? cc.log(cc._LogInfos.LayerMultiplex_switchTo) : (this.removeChild(this._layers[this._enabledLayer], !0),
        this._enabledLayer = t,
        this.addChild(this._layers[t]))
    },
    switchToAndReleaseMe: function(t) {
        t >= this._layers.length ? cc.log(cc._LogInfos.LayerMultiplex_switchToAndReleaseMe) : (this.removeChild(this._layers[this._enabledLayer], !0),
        this._layers[this._enabledLayer] = null,
        this._enabledLayer = t,
        this.addChild(this._layers[t]))
    },
    addLayer: function(t) {
        t ? this._layers.push(t) : cc.log(cc._LogInfos.LayerMultiplex_addLayer)
    }
}),
cc.LayerMultiplex.create = function() {
    return new cc.LayerMultiplex(Array.prototype.slice.call(arguments))
}
,
function() {
    cc.Layer.CanvasRenderCmd = function(t) {
        cc.Node.CanvasRenderCmd.call(this, t),
        this._isBaked = !1,
        this._bakeSprite = null,
        this._updateCache = 2
    }
    ;
    var t = cc.Layer.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    t.constructor = cc.Layer.CanvasRenderCmd,
    t._setCacheDirty = function(t) {
        t && 0 === this._updateCache && (this._updateCache = 2),
        !1 === this._cacheDirty && (this._cacheDirty = !0,
        (t = this._cachedParent) && t !== this && t._setNodeDirtyForCache && t._setNodeDirtyForCache())
    }
    ,
    t.updateStatus = function() {
        var t = cc.Node._dirtyFlags;
        this._dirtyFlag & t.orderDirty && (this._cacheDirty = !0,
        0 === this._updateCache && (this._updateCache = 2),
        this._dirtyFlag ^= this._dirtyFlag & t.orderDirty),
        cc.Node.RenderCmd.prototype.updateStatus.call(this)
    }
    ,
    t._syncStatus = function(t) {
        var e = cc.Node._dirtyFlags;
        this._dirtyFlag & e.orderDirty && (this._cacheDirty = !0,
        0 === this._updateCache && (this._updateCache = 2),
        this._dirtyFlag ^= this._dirtyFlag & e.orderDirty),
        cc.Node.RenderCmd.prototype._syncStatus.call(this, t)
    }
    ,
    t.transform = function(t, e) {
        var i = this._worldTransform
          , n = i.a
          , r = i.b
          , c = i.c
          , s = i.d;
        cc.Node.CanvasRenderCmd.prototype.transform.call(this, t, e),
        i.a === n && i.b === r && i.c === c && i.d === s || 0 !== this._updateCache || (this._updateCache = 2)
    }
    ,
    t.bake = function() {
        if (!this._isBaked) {
            this._needDraw = !0,
            this._isBaked = this._cacheDirty = cc.renderer.childrenOrderDirty = !0,
            0 === this._updateCache && (this._updateCache = 2);
            for (var t = this._node._children, e = 0, i = t.length; e < i; e++)
                t[e]._renderCmd._setCachedParent(this);
            this._bakeSprite || (this._bakeSprite = new cc.BakeSprite,
            this._bakeSprite.setAnchorPoint(0, 0))
        }
    }
    ,
    t.unbake = function() {
        if (this._isBaked) {
            cc.renderer.childrenOrderDirty = !0,
            this._isBaked = this._needDraw = !1,
            this._cacheDirty = !0,
            0 === this._updateCache && (this._updateCache = 2);
            for (var t = this._node._children, e = 0, i = t.length; e < i; e++)
                t[e]._renderCmd._setCachedParent(null)
        }
    }
    ,
    t.isBaked = function() {
        return this._isBaked
    }
    ,
    t.rendering = function() {
        if (this._cacheDirty) {
            var t = this._node
              , e = t._children
              , i = this._bakeSprite;
            this.transform(this.getParentRenderCmd(), !0);
            var n = this._getBoundingBoxForBake();
            n.width = 0 | n.width + .5,
            n.height = 0 | n.height + .5;
            var r = i.getCacheContext()
              , c = r.getContext();
            if (i.setPosition(n.x, n.y),
            0 < this._updateCache) {
                for (i.resetCanvasSize(n.width, n.height),
                r.setOffset(0 - n.x, c.canvas.height - n.height + n.y),
                t.sortAllChildren(),
                cc.renderer._turnToCacheMode(this.__instanceId),
                t = 0,
                n = e.length; t < n; t++)
                    e[t].visit(this);
                cc.renderer._renderingToCacheCanvas(r, this.__instanceId),
                i.transform(),
                this._updateCache--
            }
            this._cacheDirty = !1
        }
    }
    ,
    t.visit = function(t) {
        if (this._isBaked) {
            var e = this._node
              , i = e._children.length;
            e._visible && 0 !== i && (this._syncStatus(t),
            cc.renderer.pushRenderCommand(this),
            this._bakeSprite.visit(this),
            this._dirtyFlag = 0)
        } else
            cc.Node.CanvasRenderCmd.prototype.visit.call(this, t)
    }
    ,
    t._bakeForAddChild = function(t) {
        t._parent === this._node && this._isBaked && t._renderCmd._setCachedParent(this)
    }
    ,
    t._getBoundingBoxForBake = function() {
        var t = null
          , e = this._node;
        if (!e._children || 0 === e._children.length)
            return cc.rect(0, 0, 10, 10);
        for (var i = e.getNodeToWorldTransform(), e = e._children, n = 0, r = e.length; n < r; n++) {
            var c = e[n];
            c && c._visible && (t ? (c = c._getBoundingBoxToCurrentNode(i)) && (t = cc.rectUnion(t, c)) : t = c._getBoundingBoxToCurrentNode(i))
        }
        return t
    }
}(),
function() {
    cc.LayerColor.CanvasRenderCmd = function(t) {
        cc.Layer.CanvasRenderCmd.call(this, t),
        this._needDraw = !0,
        this._blendFuncStr = "source-over",
        this._bakeRenderCmd = new cc.CustomRenderCmd(this,this._bakeRendering)
    }
    ;
    var t = cc.LayerColor.CanvasRenderCmd.prototype = Object.create(cc.Layer.CanvasRenderCmd.prototype);
    t.constructor = cc.LayerColor.CanvasRenderCmd,
    t.unbake = function() {
        cc.Layer.CanvasRenderCmd.prototype.unbake.call(this),
        this._needDraw = !0
    }
    ,
    t.rendering = function(t, e, i) {
        t = t || cc._renderContext;
        var n = t.getContext()
          , r = this._node
          , c = this._displayedColor
          , s = this._displayedOpacity / 255
          , o = r._contentSize.width
          , r = r._contentSize.height;
        0 !== s && (t.setCompositeOperation(this._blendFuncStr),
        t.setGlobalAlpha(s),
        t.setFillStyle("rgba(" + (0 | c.r) + "," + (0 | c.g) + "," + (0 | c.b) + ", 1)"),
        t.setTransform(this._worldTransform, e, i),
        n.fillRect(0, 0, o * e, -r * i),
        cc.g_NumberOfDraws++)
    }
    ,
    t.updateBlendFunc = function(t) {
        this._blendFuncStr = cc.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc(t)
    }
    ,
    t._updateSquareVertices = t._updateSquareVerticesWidth = t._updateSquareVerticesHeight = function() {}
    ,
    t._bakeRendering = function() {
        if (this._cacheDirty) {
            var t = this._node
              , e = this._bakeSprite
              , i = t._children
              , n = i.length;
            this.transform(this.getParentRenderCmd(), !0);
            var r = this._getBoundingBoxForBake();
            r.width = 0 | r.width + .5,
            r.height = 0 | r.height + .5;
            var c = e.getCacheContext()
              , s = c.getContext();
            if (e.setPosition(r.x, r.y),
            0 < this._updateCache) {
                if (s.fillStyle = c._currentFillStyle,
                e.resetCanvasSize(r.width, r.height),
                c.setOffset(0 - r.x, s.canvas.height - r.height + r.y),
                cc.renderer._turnToCacheMode(this.__instanceId),
                0 < n) {
                    for (t.sortAllChildren(),
                    t = 0; t < n && (r = i[t],
                    0 > r._localZOrder); t++)
                        r._renderCmd.visit(this);
                    for (cc.renderer.pushRenderCommand(this); t < n; t++)
                        i[t]._renderCmd.visit(this)
                } else
                    cc.renderer.pushRenderCommand(this);
                cc.renderer._renderingToCacheCanvas(c, this.__instanceId),
                e.transform(),
                this._updateCache--
            }
            this._cacheDirty = !1
        }
    }
    ,
    t.visit = function(t) {
        this._isBaked ? this._node._visible && (this._syncStatus(t),
        cc.renderer.pushRenderCommand(this._bakeRenderCmd),
        this._bakeSprite._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty),
        this._bakeSprite.visit(this),
        this._dirtyFlag = 0) : cc.Node.CanvasRenderCmd.prototype.visit.call(this)
    }
    ,
    t._getBoundingBoxForBake = function() {
        var t = this._node
          , e = cc.rect(0, 0, t._contentSize.width, t._contentSize.height)
          , i = t.getNodeToWorldTransform()
          , e = cc.rectApplyAffineTransform(e, t.getNodeToWorldTransform());
        if (!t._children || 0 === t._children.length)
            return e;
        for (var t = t._children, n = 0; n < t.length; n++) {
            var r = t[n];
            r && r._visible && (r = r._getBoundingBoxToCurrentNode(i),
            e = cc.rectUnion(e, r))
        }
        return e
    }
}(),
function() {
    cc.LayerGradient.RenderCmd = {
        updateStatus: function() {
            var t = cc.Node._dirtyFlags;
            this._dirtyFlag & t.gradientDirty && (this._dirtyFlag |= t.colorDirty,
            this._dirtyFlag ^= this._dirtyFlag & t.gradientDirty),
            cc.Node.RenderCmd.prototype.updateStatus.call(this)
        }
    },
    cc.LayerGradient.CanvasRenderCmd = function(t) {
        cc.LayerColor.CanvasRenderCmd.call(this, t),
        this._needDraw = !0,
        this._startPoint = cc.p(0, 0),
        this._endPoint = cc.p(0, 0),
        this._endStopStr = this._startStopStr = null
    }
    ;
    var t = cc.LayerGradient.CanvasRenderCmd.prototype = Object.create(cc.LayerColor.CanvasRenderCmd.prototype);
    cc.inject(cc.LayerGradient.RenderCmd, t),
    t.constructor = cc.LayerGradient.CanvasRenderCmd,
    t.rendering = function(t, e, i) {
        t = t || cc._renderContext;
        var n = t.getContext()
          , r = this._node
          , c = this._displayedOpacity / 255;
        if (0 !== c) {
            var s = r._contentSize.width
              , o = r._contentSize.height;
            if (t.setCompositeOperation(this._blendFuncStr),
            t.setGlobalAlpha(c),
            c = n.createLinearGradient(this._startPoint.x * e, this._startPoint.y * i, this._endPoint.x * e, this._endPoint.y * i),
            r._colorStops)
                for (var a = 0; a < r._colorStops.length; a++)
                    c.addColorStop(r._colorStops[a].p, this._colorStopsStr[a]);
            else
                c.addColorStop(0, this._startStopStr),
                c.addColorStop(1, this._endStopStr);
            t.setFillStyle(c),
            t.setTransform(this._worldTransform, e, i),
            n.fillRect(0, 0, s * e, -o * i),
            cc.g_NumberOfDraws++
        }
    }
    ,
    t._syncStatus = function(t) {
        var e = cc.Node._dirtyFlags
          , i = this._dirtyFlag;
        i & e.gradientDirty && (this._dirtyFlag |= e.colorDirty,
        this._dirtyFlag = i & e.gradientDirty ^ i),
        cc.Node.RenderCmd.prototype._syncStatus.call(this, t)
    }
    ,
    t._updateColor = function() {
        var t = this._node
          , e = t._contentSize
          , i = .5 * e.width
          , e = .5 * e.height;
        this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.gradientDirty;
        var n = cc.pAngleSigned(cc.p(0, -1), t._alongVector)
          , n = cc.pRotateByAngle(cc.p(0, -1), cc.p(0, 0), n)
          , r = Math.min(Math.abs(1 / n.x), Math.abs(1 / n.y));
        if (this._startPoint.x = i * -n.x * r + i,
        this._startPoint.y = e * n.y * r - e,
        this._endPoint.x = i * n.x * r + i,
        this._endPoint.y = e * -n.y * r - e,
        i = this._displayedColor,
        e = t._endColor,
        n = t._startOpacity / 255,
        r = t._endOpacity / 255,
        this._startStopStr = "rgba(" + Math.round(i.r) + "," + Math.round(i.g) + "," + Math.round(i.b) + "," + n.toFixed(4) + ")",
        this._endStopStr = "rgba(" + Math.round(e.r) + "," + Math.round(e.g) + "," + Math.round(e.b) + "," + r.toFixed(4) + ")",
        t._colorStops)
            for (this._endOpacity = this._startOpacity = 0,
            this._colorStopsStr = [],
            i = 0; i < t._colorStops.length; i++)
                e = t._colorStops[i].color,
                n = null == e.a ? 1 : e.a / 255,
                this._colorStopsStr.push("rgba(" + Math.round(e.r) + "," + Math.round(e.g) + "," + Math.round(e.b) + "," + n.toFixed(4) + ")")
    }
}(),
function() {
    cc.Layer.WebGLRenderCmd = function(t) {
        cc.Node.WebGLRenderCmd.call(this, t)
    }
    ;
    var t = cc.Layer.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    t.constructor = cc.Layer.WebGLRenderCmd,
    t.bake = function() {}
    ,
    t.unbake = function() {}
    ,
    t._bakeForAddChild = function() {}
}(),
function() {
    cc.LayerColor.WebGLRenderCmd = function(t) {
        cc.Layer.WebGLRenderCmd.call(this, t),
        this._needDraw = !0,
        this._squareVerticesAB = new ArrayBuffer(32),
        this._squareColorsAB = new ArrayBuffer(16),
        t = this._squareVerticesAB;
        var e = this._squareColorsAB
          , i = cc.Vertex2F.BYTES_PER_ELEMENT
          , n = cc.Color.BYTES_PER_ELEMENT;
        this._squareVertices = [new cc.Vertex2F(0,0,t,0), new cc.Vertex2F(0,0,t,i), new cc.Vertex2F(0,0,t,2 * i), new cc.Vertex2F(0,0,t,3 * i)],
        this._squareColors = [cc.color(0, 0, 0, 255, e, 0), cc.color(0, 0, 0, 255, e, n), cc.color(0, 0, 0, 255, e, 2 * n), cc.color(0, 0, 0, 255, e, 3 * n)],
        this._verticesFloat32Buffer = cc._renderContext.createBuffer(),
        this._colorsUint8Buffer = cc._renderContext.createBuffer()
    }
    ;
    var t = cc.LayerColor.WebGLRenderCmd.prototype = Object.create(cc.Layer.WebGLRenderCmd.prototype);
    t.constructor = cc.LayerColor.WebGLRenderCmd,
    t.rendering = function(t) {
        t = t || cc._renderContext;
        var e = this._node;
        this._shaderProgram.use(),
        this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix),
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR),
        cc.glBlendFunc(e._blendFunc.src, e._blendFunc.dst),
        t.bindBuffer(t.ARRAY_BUFFER, this._verticesFloat32Buffer),
        t.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, t.FLOAT, !1, 0, 0),
        t.bindBuffer(t.ARRAY_BUFFER, this._colorsUint8Buffer),
        t.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, t.UNSIGNED_BYTE, !0, 0, 0),
        t.drawArrays(t.TRIANGLE_STRIP, 0, this._squareVertices.length)
    }
    ,
    t._updateSquareVertices = function(t, e) {
        var i = this._squareVertices;
        void 0 === e ? (i[1].x = t.width,
        i[2].y = t.height,
        i[3].x = t.width,
        i[3].y = t.height) : (i[1].x = t,
        i[2].y = e,
        i[3].x = t,
        i[3].y = e),
        this._bindLayerVerticesBufferData()
    }
    ,
    t._updateSquareVerticesWidth = function(t) {
        var e = this._squareVertices;
        e[1].x = t,
        e[3].x = t,
        this._bindLayerVerticesBufferData()
    }
    ,
    t._updateSquareVerticesHeight = function(t) {
        var e = this._squareVertices;
        e[2].y = t,
        e[3].y = t,
        this._bindLayerVerticesBufferData()
    }
    ,
    t._updateColor = function() {
        for (var t = this._displayedColor, e = this._displayedOpacity, i = this._squareColors, n = 0; 4 > n; n++)
            i[n].r = t.r,
            i[n].g = t.g,
            i[n].b = t.b,
            i[n].a = e;
        this._bindLayerColorsBufferData()
    }
    ,
    t._bindLayerVerticesBufferData = function() {
        var t = cc._renderContext;
        t.bindBuffer(t.ARRAY_BUFFER, this._verticesFloat32Buffer),
        t.bufferData(t.ARRAY_BUFFER, this._squareVerticesAB, t.STATIC_DRAW)
    }
    ,
    t._bindLayerColorsBufferData = function() {
        var t = cc._renderContext;
        t.bindBuffer(t.ARRAY_BUFFER, this._colorsUint8Buffer),
        t.bufferData(t.ARRAY_BUFFER, this._squareColorsAB, t.STATIC_DRAW)
    }
    ,
    t.updateBlendFunc = function(t) {}
    ;
}(),
function() {
    cc.LayerGradient.WebGLRenderCmd = function(t) {
        cc.LayerColor.WebGLRenderCmd.call(this, t),
        this._needDraw = !0,
        this._clipRect = new cc.Rect,
        this._clippingRectDirty = !1
    }
    ;
    var t = cc.LayerGradient.WebGLRenderCmd.prototype = Object.create(cc.LayerColor.WebGLRenderCmd.prototype);
    cc.inject(cc.LayerGradient.RenderCmd, t),
    t.constructor = cc.LayerGradient.WebGLRenderCmd,
    t._syncStatus = function(t) {
        var e = cc.Node._dirtyFlags
          , i = this._dirtyFlag
          , n = t ? t._node : null;
        n && n._cascadeColorEnabled && t._dirtyFlag & e.colorDirty && (i |= e.colorDirty),
        n && n._cascadeOpacityEnabled && t._dirtyFlag & e.opacityDirty && (i |= e.opacityDirty),
        t && t._dirtyFlag & e.transformDirty && (i |= e.transformDirty);
        var n = i & e.colorDirty
          , r = i & e.opacityDirty;
        this._dirtyFlag = i,
        n && this._syncDisplayColor(),
        r && this._syncDisplayOpacity(),
        this.transform(t),
        (n || r || i & e.gradientDirty) && this._updateColor()
    }
    ,
    t._updateColor = function() {
        this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.gradientDirty;
        var t = this._node
          , e = t._colorStops;
        if (e && !(2 > e.length)) {
            this._clippingRectDirty = !0;
            var i, n = e.length, r = 2 * n, c = t._contentSize;
            this._squareVerticesAB = new ArrayBuffer(8 * r),
            this._squareColorsAB = new ArrayBuffer(4 * r);
            var s = this._squareVertices
              , o = this._squareColors;
            s.length = 0,
            o.length = 0;
            var a = this._squareVerticesAB
              , h = this._squareColorsAB
              , l = cc.Vertex2F.BYTES_PER_ELEMENT
              , u = cc.Color.BYTES_PER_ELEMENT;
            for (i = 0; i < r; i++)
                s.push(new cc.Vertex2F(0,0,a,l * i)),
                o.push(cc.color(0, 0, 0, 255, h, u * i));
            for (h = Math.PI + cc.pAngleSigned(cc.p(0, -1), t._alongVector),
            t = cc.p(c.width / 2, c.height / 2),
            i = Math.round(cc.radiansToDegrees(h)),
            r = cc.affineTransformMake(1, 0, 0, 1, t.x, t.y),
            r = cc.affineTransformRotate(r, h),
            90 > i ? (l = cc.p(-t.x, t.y),
            i = cc.p(t.x, t.y)) : 180 > i ? (l = cc.p(t.x, t.y),
            i = cc.p(t.x, -t.y)) : 270 > i ? (l = cc.p(t.x, -t.y),
            i = cc.p(-t.x, -t.y)) : (l = cc.p(-t.x, -t.y),
            i = cc.p(-t.x, t.y)),
            a = Math.sin(h),
            h = Math.cos(h),
            l = Math.abs((l.x * h - l.y * a) / t.x),
            i = Math.abs((i.x * a + i.y * h) / t.y),
            r = cc.affineTransformScale(r, l, i),
            i = 0; i < n; i++)
                a = e[i].p * c.height,
                h = cc.pointApplyAffineTransform(-t.x, a - t.y, r),
                s[2 * i].x = h.x,
                s[2 * i].y = h.y,
                a = cc.pointApplyAffineTransform(c.width - t.x, a - t.y, r),
                s[2 * i + 1].x = a.x,
                s[2 * i + 1].y = a.y;
            for (c = this._displayedOpacity / 255,
            i = 0; i < n; i++)
                s = e[i].color,
                t = o[2 * i],
                r = o[2 * i + 1],
                t.r = s.r,
                t.g = s.g,
                t.b = s.b,
                t.a = s.a * c,
                r.r = s.r,
                r.g = s.g,
                r.b = s.b,
                r.a = s.a * c;
            this._bindLayerVerticesBufferData(),
            this._bindLayerColorsBufferData()
        }
    }
    ,
    t.rendering = function(t) {
        t = t || cc._renderContext;
        var e = this._node
          , i = this._getClippingRect();
        t.enable(t.SCISSOR_TEST),
        cc.view.setScissorInPoints(i.x, i.y, i.width, i.height),
        this._shaderProgram.use(),
        this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix),
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR),
        cc.glBlendFunc(e._blendFunc.src, e._blendFunc.dst),
        t.bindBuffer(t.ARRAY_BUFFER, this._verticesFloat32Buffer),
        t.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, t.FLOAT, !1, 0, 0),
        t.bindBuffer(t.ARRAY_BUFFER, this._colorsUint8Buffer),
        t.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, t.UNSIGNED_BYTE, !0, 0, 0),
        t.drawArrays(t.TRIANGLE_STRIP, 0, this._squareVertices.length),
        t.disable(t.SCISSOR_TEST)
    }
    ,
    t._getClippingRect = function() {
        if (this._clippingRectDirty) {
            var t = this._node
              , e = cc.rect(0, 0, t._contentSize.width, t._contentSize.height)
              , t = t.getNodeToWorldTransform();
            this._clipRect = cc._rectApplyAffineTransformIn(e, t)
        }
        return this._clipRect
    }
}(),
cc._tmp.PrototypeSprite = function() {
    var t = cc.Sprite.prototype;
    cc.defineGetterSetter(t, "opacityModifyRGB", t.isOpacityModifyRGB, t.setOpacityModifyRGB),
    cc.defineGetterSetter(t, "opacity", t.getOpacity, t.setOpacity),
    cc.defineGetterSetter(t, "color", t.getColor, t.setColor),
    cc.defineGetterSetter(t, "flippedX", t.isFlippedX, t.setFlippedX),
    cc.defineGetterSetter(t, "flippedY", t.isFlippedY, t.setFlippedY),
    cc.defineGetterSetter(t, "offsetX", t._getOffsetX),
    cc.defineGetterSetter(t, "offsetY", t._getOffsetY),
    cc.defineGetterSetter(t, "texture", t.getTexture, t.setTexture),
    cc.defineGetterSetter(t, "textureRectRotated", t.isTextureRectRotated),
    cc.defineGetterSetter(t, "batchNode", t.getBatchNode, t.setBatchNode),
    cc.defineGetterSetter(t, "quad", t.getQuad)
}
,
cc.Sprite = cc.Node.extend({
    dirty: !1,
    atlasIndex: 0,
    textureAtlas: null,
    _batchNode: null,
    _recursiveDirty: null,
    _hasChildren: null,
    _shouldBeHidden: !1,
    _transformToBatch: null,
    _blendFunc: null,
    _texture: null,
    _rect: null,
    _rectRotated: !1,
    _offsetPosition: null,
    _unflippedOffsetPositionFromCenter: null,
    _opacityModifyRGB: !1,
    _flippedX: !1,
    _flippedY: !1,
    _textureLoaded: !1,
    _className: "Sprite",
    ctor: function(t, e, i) {
        cc.Node.prototype.ctor.call(this),
        this._shouldBeHidden = !1,
        this._offsetPosition = cc.p(0, 0),
        this._unflippedOffsetPositionFromCenter = cc.p(0, 0),
        this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        },
        this._rect = cc.rect(0, 0, 0, 0),
        this._softInit(t, e, i)
    },
    textureLoaded: function() {
        return this._textureLoaded
    },
    addLoadedEventListener: function(t, e) {
        this.addEventListener("load", t, e)
    },
    isDirty: function() {
        return this.dirty
    },
    setDirty: function(t) {
        this.dirty = t
    },
    isTextureRectRotated: function() {
        return this._rectRotated
    },
    getAtlasIndex: function() {
        return this.atlasIndex
    },
    setAtlasIndex: function(t) {
        this.atlasIndex = t
    },
    getTextureRect: function() {
        return cc.rect(this._rect)
    },
    getTextureAtlas: function() {
        return this.textureAtlas
    },
    setTextureAtlas: function(t) {
        this.textureAtlas = t
    },
    getOffsetPosition: function() {
        return cc.p(this._offsetPosition)
    },
    _getOffsetX: function() {
        return this._offsetPosition.x
    },
    _getOffsetY: function() {
        return this._offsetPosition.y
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    initWithSpriteFrame: function(t) {
        cc.assert(t, cc._LogInfos.Sprite_initWithSpriteFrame),
        t.textureLoaded() || (this._textureLoaded = !1,
        t.addEventListener("load", this._renderCmd._spriteFrameLoadedCallback, this));
        var e = cc._renderType !== cc.game.RENDER_TYPE_CANVAS && t._rotated
          , e = this.initWithTexture(t.getTexture(), t.getRect(), e);
        return this.setSpriteFrame(t),
        e
    },
    initWithSpriteFrameName: function(t) {
        cc.assert(t, cc._LogInfos.Sprite_initWithSpriteFrameName);
        var e = cc.spriteFrameCache.getSpriteFrame(t);
        return cc.assert(e, t + cc._LogInfos.Sprite_initWithSpriteFrameName1),
        this.initWithSpriteFrame(e)
    },
    useBatchNode: function(t) {
        this.textureAtlas = t.getTextureAtlas(),
        this._batchNode = t
    },
    setVertexRect: function(t) {
        var e = this._rect;
        e.x = t.x,
        e.y = t.y,
        e.width = t.width,
        e.height = t.height
    },
    sortAllChildren: function() {
        if (this._reorderChildDirty) {
            var t, e, i, n = this._children, r = n.length;
            for (t = 1; t < r; t++) {
                for (i = n[t],
                e = t - 1; 0 <= e; ) {
                    if (i._localZOrder < n[e]._localZOrder)
                        n[e + 1] = n[e];
                    else {
                        if (!(i._localZOrder === n[e]._localZOrder && i.arrivalOrder < n[e].arrivalOrder))
                            break;
                        n[e + 1] = n[e]
                    }
                    e--
                }
                n[e + 1] = i
            }
            this._batchNode && this._arrayMakeObjectsPerformSelector(n, cc.Node._stateCallbackType.sortAllChildren),
            this._reorderChildDirty = !1
        }
    },
    reorderChild: function(t, e) {
        cc.assert(t, cc._LogInfos.Sprite_reorderChild_2),
        -1 === this._children.indexOf(t) ? cc.log(cc._LogInfos.Sprite_reorderChild) : e !== t.zIndex && (this._batchNode && !this._reorderChildDirty && (this._setReorderChildDirtyRecursively(),
        this._batchNode.reorderBatch(!0)),
        cc.Node.prototype.reorderChild.call(this, t, e))
    },
    removeChild: function(t, e) {
        this._batchNode && this._batchNode.removeSpriteFromAtlas(t),
        cc.Node.prototype.removeChild.call(this, t, e)
    },
    setVisible: function(t) {
        cc.Node.prototype.setVisible.call(this, t),
        this._renderCmd.setDirtyRecursively(!0)
    },
    removeAllChildren: function(t) {
        var e = this._children
          , i = this._batchNode;
        if (i && null != e)
            for (var n = 0, r = e.length; n < r; n++)
                i.removeSpriteFromAtlas(e[n]);
        cc.Node.prototype.removeAllChildren.call(this, t),
        this._hasChildren = !1
    },
    ignoreAnchorPointForPosition: function(t) {
        this._batchNode ? cc.log(cc._LogInfos.Sprite_ignoreAnchorPointForPosition) : cc.Node.prototype.ignoreAnchorPointForPosition.call(this, t)
    },
    setFlippedX: function(t) {
        this._flippedX !== t && (this._flippedX = t,
        this.setTextureRect(this._rect, this._rectRotated, this._contentSize),
        this.setNodeDirty(!0))
    },
    setFlippedY: function(t) {
        this._flippedY !== t && (this._flippedY = t,
        this.setTextureRect(this._rect, this._rectRotated, this._contentSize),
        this.setNodeDirty(!0))
    },
    isFlippedX: function() {
        return this._flippedX
    },
    isFlippedY: function() {
        return this._flippedY
    },
    setOpacityModifyRGB: function(t) {
        this._opacityModifyRGB !== t && (this._opacityModifyRGB = t,
        this._renderCmd._setColorDirty())
    },
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB
    },
    setDisplayFrameWithAnimationName: function(t, e) {
        cc.assert(t, cc._LogInfos.Sprite_setDisplayFrameWithAnimationName_3);
        var i = cc.animationCache.getAnimation(t);
        i ? (i = i.getFrames()[e]) ? this.setSpriteFrame(i.getSpriteFrame()) : cc.log(cc._LogInfos.Sprite_setDisplayFrameWithAnimationName_2) : cc.log(cc._LogInfos.Sprite_setDisplayFrameWithAnimationName)
    },
    getBatchNode: function() {
        return this._batchNode
    },
    _setReorderChildDirtyRecursively: function() {
        if (!this._reorderChildDirty) {
            this._reorderChildDirty = !0;
            for (var t = this._parent; t && t !== this._batchNode; )
                t._setReorderChildDirtyRecursively(),
                t = t.parent
        }
    },
    getTexture: function() {
        return this._texture
    },
    _softInit: function(t, e, i) {
        void 0 === t ? cc.Sprite.prototype.init.call(this) : cc.isString(t) ? "#" === t[0] ? (e = t.substr(1, t.length - 1),
        (e = cc.spriteFrameCache.getSpriteFrame(e)) ? this.initWithSpriteFrame(e) : cc.log("%s does not exist", t)) : cc.Sprite.prototype.init.call(this, t, e) : "object" == typeof t && (t instanceof cc.Texture2D ? this.initWithTexture(t, e, i) : t instanceof cc.SpriteFrame ? this.initWithSpriteFrame(t) : (t instanceof HTMLImageElement || t instanceof HTMLCanvasElement) && (e = new cc.Texture2D,
        e.initWithElement(t),
        e.handleLoadedTexture(),
        this.initWithTexture(e)))
    },
    getQuad: function() {
        return this._renderCmd.getQuad()
    },
    setBlendFunc: function(t, e) {
        var i = this._blendFunc;
        void 0 === e ? (i.src = t.src,
        i.dst = t.dst) : (i.src = t,
        i.dst = e),
        this._renderCmd.updateBlendFunc(i)
    },
    init: function() {
        return 0 < arguments.length ? this.initWithFile(arguments[0], arguments[1]) : (cc.Node.prototype.init.call(this),
        this.dirty = this._recursiveDirty = !1,
        this._blendFunc.src = cc.BLEND_SRC,
        this._blendFunc.dst = cc.BLEND_DST,
        this.texture = null,
        this._flippedX = this._flippedY = !1,
        this.anchorY = this.anchorX = .5,
        this._offsetPosition.x = 0,
        this._offsetPosition.y = 0,
        this._hasChildren = !1,
        this._renderCmd._init(),
        this.setTextureRect(cc.rect(0, 0, 0, 0), !1, cc.size(0, 0)),
        !0)
    },
    initWithFile: function(t, e) {
        cc.assert(t, cc._LogInfos.Sprite_initWithFile);
        var i = cc.textureCache.getTextureForKey(t);
        if (i) {
            if (!e) {
                var n = i.getContentSize();
                e = cc.rect(0, 0, n.width, n.height)
            }
            return this.initWithTexture(i, e)
        }
        return i = cc.textureCache.addImage(t),
        this.initWithTexture(i, e || cc.rect(0, 0, i._contentSize.width, i._contentSize.height))
    },
    initWithTexture: function(t, e, i, n) {
        if (cc.assert(0 !== arguments.length, cc._LogInfos.CCSpriteBatchNode_initWithTexture),
        i = i || !1,
        t = this._renderCmd._handleTextureForRotatedTexture(t, e, i, n),
        !cc.Node.prototype.init.call(this))
            return !1;
        this._batchNode = null,
        this.dirty = this._recursiveDirty = !1,
        this._opacityModifyRGB = !0,
        this._blendFunc.src = cc.BLEND_SRC,
        this._blendFunc.dst = cc.BLEND_DST,
        this._flippedX = this._flippedY = !1,
        this.setAnchorPoint(.5, .5),
        this._offsetPosition.x = 0,
        this._offsetPosition.y = 0,
        this._hasChildren = !1,
        this._renderCmd._init();
        var r = t.isLoaded();
        return this._textureLoaded = r,
        r ? (e || (e = cc.rect(0, 0, t.width, t.height)),
        this._renderCmd._checkTextureBoundary(t, e, i),
        this.setTexture(t),
        this.setTextureRect(e, i),
        this.setBatchNode(null),
        !0) : (this._rectRotated = i,
        e && (this._rect.x = e.x,
        this._rect.y = e.y,
        this._rect.width = e.width,
        this._rect.height = e.height),
        this.texture && this.texture.removeEventListener("load", this),
        t.addEventListener("load", this._renderCmd._textureLoadedCallback, this),
        this.texture = t,
        !0)
    },
    setTextureRect: function(t, e, i, n) {
        this._rectRotated = e || !1,
        this.setContentSize(i || t),
        this.setVertexRect(t),
        this._renderCmd._setTextureCoords(t, n),
        t = this._unflippedOffsetPositionFromCenter.x,
        e = this._unflippedOffsetPositionFromCenter.y,
        this._flippedX && (t = -t),
        this._flippedY && (e = -e),
        i = this._rect,
        this._offsetPosition.x = t + (this._contentSize.width - i.width) / 2,
        this._offsetPosition.y = e + (this._contentSize.height - i.height) / 2,
        this._batchNode ? this.dirty = !0 : this._renderCmd._resetForBatchNode()
    },
    updateTransform: function() {
        this._renderCmd.updateTransform()
    },
    addChild: function(t, e, i) {
        cc.assert(t, cc._LogInfos.CCSpriteBatchNode_addChild_2),
        null == e && (e = t._localZOrder),
        null == i && (i = t.tag),
        this._renderCmd._setBatchNodeForAddChild(t) && (cc.Node.prototype.addChild.call(this, t, e, i),
        this._hasChildren = !0)
    },
    setSpriteFrame: function(t) {
        var e = this;
        cc.isString(t) && (t = cc.spriteFrameCache.getSpriteFrame(t),
        cc.assert(t, cc._LogInfos.Sprite_setSpriteFrame)),
        this.setNodeDirty(!0);
        var i = t.getOffset();
        e._unflippedOffsetPositionFromCenter.x = i.x,
        e._unflippedOffsetPositionFromCenter.y = i.y,
        i = t.getTexture(),
        t.textureLoaded() ? (e._textureLoaded = !0,
        i !== e._texture && (e._setTexture(i),
        e.setColor(e._realColor)),
        e.setTextureRect(t.getRect(), t.isRotated(), t.getOriginalSize())) : (e._textureLoaded = !1,
        t.addEventListener("load", function(t) {
            e._textureLoaded = !0;
            var i = t.getTexture();
            i !== e._texture && e._setTexture(i),
            e.setTextureRect(t.getRect(), t.isRotated(), t.getOriginalSize()),
            e.dispatchEvent("load"),
            e.setColor(e._realColor)
        }, e)),
        this._renderCmd._updateForSetSpriteFrame(i)
    },
    setDisplayFrame: function(t) {
        cc.log(cc._LogInfos.Sprite_setDisplayFrame),
        this.setSpriteFrame(t)
    },
    isFrameDisplayed: function(t) {
        return this._renderCmd.isFrameDisplayed(t)
    },
    displayFrame: function() {
        return this.getSpriteFrame()
    },
    getSpriteFrame: function() {
        return new cc.SpriteFrame(this._texture,cc.rectPointsToPixels(this._rect),this._rectRotated,cc.pointPointsToPixels(this._unflippedOffsetPositionFromCenter),cc.sizePointsToPixels(this._contentSize))
    },
    setBatchNode: function(t) {
        (this._batchNode = t) ? (this._transformToBatch = cc.affineTransformIdentity(),
        this.textureAtlas = this._batchNode.getTextureAtlas()) : (this.atlasIndex = cc.Sprite.INDEX_NOT_INITIALIZED,
        this.textureAtlas = null,
        this.dirty = this._recursiveDirty = !1,
        this._renderCmd._resetForBatchNode())
    },
    setTexture: function(t) {
        if (!t)
            return this._renderCmd._setTexture(null);
        var e = cc.isString(t);
        e && (t = cc.textureCache.addImage(t)),
        t._textureLoaded ? (this._setTexture(t, e),
        this.setColor(this._realColor),
        this._textureLoaded = !0) : (this._renderCmd._setTexture(null),
        t.addEventListener("load", function() {
            this._setTexture(t, e),
            this.setColor(this._realColor),
            this._textureLoaded = !0
        }, this))
    },
    _setTexture: function(t, e) {
        this._renderCmd._setTexture(t),
        e && this._changeRectWithTexture(t)
    },
    _changeRectWithTexture: function(t) {
        t = t._contentSize,
        t = cc.rect(0, 0, t.width, t.height),
        this.setTextureRect(t)
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.Sprite.CanvasRenderCmd(this) : new cc.Sprite.WebGLRenderCmd(this)
    }
}),
cc.Sprite.create = function(t, e, i) {
    return new cc.Sprite(t,e,i)
}
,
cc.Sprite.createWithTexture = cc.Sprite.create,
cc.Sprite.createWithSpriteFrameName = cc.Sprite.create,
cc.Sprite.createWithSpriteFrame = cc.Sprite.create,
cc.Sprite.INDEX_NOT_INITIALIZED = -1,
cc.EventHelper.prototype.apply(cc.Sprite.prototype),
cc.assert(cc.isFunction(cc._tmp.PrototypeSprite), cc._LogInfos.MissingFile, "SpritesPropertyDefine.js"),
cc._tmp.PrototypeSprite(),
delete cc._tmp.PrototypeSprite,
function() {
    cc.Sprite.CanvasRenderCmd = function(t) {
        cc.Node.CanvasRenderCmd.call(this, t),
        this._needDraw = !0,
        this._textureCoord = {
            renderX: 0,
            renderY: 0,
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            validRect: !1
        },
        this._blendFuncStr = "source-over",
        this._colorized = !1,
        this._textureToRender = null
    }
    ;
    var t = cc.Sprite.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    t.constructor = cc.Sprite.CanvasRenderCmd,
    t._init = function() {}
    ,
    t.setDirtyRecursively = function(t) {}
    ,
    t._resetForBatchNode = function() {}
    ,
    t._setTexture = function(t) {
        var e = this._node;
        e._texture !== t && (e._textureLoaded = !!t && t._textureLoaded,
        e._texture = t,
        this._updateColor())
    }
    ,
    t._setColorDirty = function() {
        this.setDirtyFlag(cc.Node._dirtyFlags.colorDirty | cc.Node._dirtyFlags.opacityDirty)
    }
    ,
    t.isFrameDisplayed = function(t) {
        var e = this._node;
        return t.getTexture() === e._texture && cc.rectEqualToRect(t.getRect(), e._rect)
    }
    ,
    t.updateBlendFunc = function(t) {
        this._blendFuncStr = cc.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc(t)
    }
    ,
    t._setBatchNodeForAddChild = function(t) {
        return !0
    }
    ,
    t._handleTextureForRotatedTexture = function(t, e, i, n) {
        return i && t.isLoaded() && (t = t.getHtmlElementObj(),
        t = cc.Sprite.CanvasRenderCmd._cutRotateImageToCanvas(t, e, n),
        n = new cc.Texture2D,
        n.initWithElement(t),
        n.handleLoadedTexture(),
        t = n,
        e.x = e.y = 0,
        this._node._rect = cc.rect(0, 0, e.width, e.height)),
        t
    }
    ,
    t._checkTextureBoundary = function(t, e, i) {
        t && t.url && (i = e.y + e.height,
        e.x + e.width > t.width && cc.error(cc._LogInfos.RectWidth, t.url),
        i > t.height && cc.error(cc._LogInfos.RectHeight, t.url))
    }
    ,
    t.rendering = function(t, e, i) {
        var n = this._node
          , r = this._textureCoord
          , c = this._displayedOpacity / 255
          , s = this._textureToRender || n._texture;
        if ((!s || 0 !== r.width && 0 !== r.height && s._textureLoaded) && 0 !== c) {
            t = t || cc._renderContext;
            var o = t.getContext()
              , a = n._offsetPosition.x
              , h = n._rect.height
              , l = n._rect.width
              , u = -n._offsetPosition.y - h;
            t.setTransform(this._worldTransform, e, i),
            t.setCompositeOperation(this._blendFuncStr),
            t.setGlobalAlpha(c),
            (n._flippedX || n._flippedY) && t.save(),
            n._flippedX && (a = -a - l,
            o.scale(-1, 1)),
            n._flippedY && (u = n._offsetPosition.y,
            o.scale(1, -1));
            var d, _, p;
            this._colorized ? d = c = 0 : (c = r.renderX,
            d = r.renderY),
            _ = r.width,
            p = r.height,
            a *= e,
            u *= i,
            l *= e,
            h *= i,
            s ? (e = s._htmlElementObj,
            "" !== s._pattern ? (t.setFillStyle(o.createPattern(e, s._pattern)),
            o.fillRect(a, u, l, h)) : o.drawImage(e, c, d, _, p, a, u, l, h)) : (s = n._contentSize,
            r.validRect && (r = this._displayedColor,
            t.setFillStyle("rgba(" + r.r + "," + r.g + "," + r.b + ",1)"),
            o.fillRect(a, u, s.width * e, s.height * i))),
            (n._flippedX || n._flippedY) && t.restore(),
            cc.g_NumberOfDraws++
        }
    }
    ,
    t._updateColor = function() {
        var t = this._node._texture
          , e = this._textureCoord
          , i = this._displayedColor;
        t && (255 !== i.r || 255 !== i.g || 255 !== i.b ? (this._textureToRender = t._generateColorTexture(i.r, i.g, i.b, e),
        this._colorized = !0) : t && (this._textureToRender = t,
        this._colorized = !1))
    }
    ,
    t.getQuad = function() {
        return null
    }
    ,
    t._updateForSetSpriteFrame = function(t, e) {
        if (this._colorized = !1,
        this._textureCoord.renderX = this._textureCoord.x,
        this._textureCoord.renderY = this._textureCoord.y,
        e = e || t._textureLoaded) {
            var i = this._node.getColor();
            255 === i.r && 255 === i.g && 255 === i.b || this._updateColor()
        }
    }
    ,
    t.updateTransform = function() {
        var t = this._node;
        if (t.dirty) {
            var e = t._parent;
            !t._visible || e && e !== t._batchNode && e._shouldBeHidden ? t._shouldBeHidden = !0 : (t._shouldBeHidden = !1,
            t._transformToBatch = e && e !== t._batchNode ? cc.affineTransformConcat(this.getNodeToParentTransform(), e._transformToBatch) : this.getNodeToParentTransform()),
            t._recursiveDirty = !1,
            t.dirty = !1
        }
        t._hasChildren && t._arrayMakeObjectsPerformSelector(t._children, cc.Node._stateCallbackType.updateTransform)
    }
    ,
    t._spriteFrameLoadedCallback = function(t) {
        this.setTextureRect(t.getRect(), t.isRotated(), t.getOriginalSize()),
        this._renderCmd._updateColor(),
        this.dispatchEvent("load")
    }
    ,
    t._textureLoadedCallback = function(t) {
        if (!this._textureLoaded) {
            this._textureLoaded = !0;
            var e = this._rect
              , i = this._renderCmd;
            e ? cc._rectEqualToZero(e) && (e.width = t.width,
            e.height = t.height) : e = cc.rect(0, 0, t.width, t.height),
            this.texture = t,
            this.setTextureRect(e, this._rectRotated),
            t = i._displayedColor,
            255 === t.r && 255 === t.g && 255 === t.b || i._updateColor(),
            this.setBatchNode(this._batchNode),
            this.dispatchEvent("load")
        }
    }
    ,
    t._setTextureCoords = function(t, e) {
        void 0 === e && (e = !0);
        var i = this._textureCoord
          , n = e ? cc.contentScaleFactor() : 1;
        i.renderX = i.x = 0 | t.x * n,
        i.renderY = i.y = 0 | t.y * n,
        i.width = 0 | t.width * n,
        i.height = 0 | t.height * n,
        i.validRect = !(0 === i.width || 0 === i.height || 0 > i.x || 0 > i.y)
    }
    ,
    cc.Sprite.CanvasRenderCmd._cutRotateImageToCanvas = function(t, e, i) {
        if (!t)
            return null;
        if (!e)
            return t;
        i = null == i || i;
        var n = document.createElement("canvas");
        n.width = e.width,
        n.height = e.height;
        var r = n.getContext("2d");
        return r.translate(n.width / 2, n.height / 2),
        i ? r.rotate(-1.5707963267948966) : r.rotate(1.5707963267948966),
        r.drawImage(t, e.x, e.y, e.height, e.width, -e.height / 2, -e.width / 2, e.height, e.width),
        n
    }
}(),
function() {
    cc.Sprite.WebGLRenderCmd = function(t) {
        cc.Node.WebGLRenderCmd.call(this, t),
        this._needDraw = !0,
        this._quad = new cc.V3F_C4B_T2F_Quad,
        this._quadWebBuffer = cc._renderContext.createBuffer(),
        this._quadDirty = !0,
        this._recursiveDirty = this._dirty = !1
    }
    ;
    var t = cc.Sprite.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    t.constructor = cc.Sprite.WebGLRenderCmd,
    t.updateBlendFunc = function(t) {}
    ,
    t.setDirtyFlag = function(t) {
        cc.Node.WebGLRenderCmd.prototype.setDirtyFlag.call(this, t),
        this._dirty = !0
    }
    ,
    t.setDirtyRecursively = function(t) {
        this._dirty = this._recursiveDirty = t;
        for (var e, i = this._node._children, n = i ? i.length : 0, r = 0; r < n; r++)
            e = i[r],
            e instanceof cc.Sprite && e._renderCmd.setDirtyRecursively(t)
    }
    ,
    t._setBatchNodeForAddChild = function(t) {
        var e = this._node;
        if (e._batchNode) {
            if (!(t instanceof cc.Sprite))
                return cc.log(cc._LogInfos.Sprite_addChild),
                !1;
            t.texture._webTextureObj !== e.textureAtlas.texture._webTextureObj && cc.log(cc._LogInfos.Sprite_addChild_2),
            e._batchNode.appendChild(t),
            e._reorderChildDirty || e._setReorderChildDirtyRecursively()
        }
        return !0
    }
    ,
    t._handleTextureForRotatedTexture = function(t) {
        return t
    }
    ,
    t.isFrameDisplayed = function(t) {
        var e = this._node;
        return cc.rectEqualToRect(t.getRect(), e._rect) && t.getTexture().getName() === e._texture.getName() && cc.pointEqualToPoint(t.getOffset(), e._unflippedOffsetPositionFromCenter)
    }
    ,
    t._init = function() {
        var t = {
            r: 255,
            g: 255,
            b: 255,
            a: 255
        }
          , e = this._quad;
        e.bl.colors = t,
        e.br.colors = t,
        e.tl.colors = t,
        e.tr.colors = t,
        this._quadDirty = !0
    }
    ,
    t._resetForBatchNode = function() {
        var t = this._node
          , e = t._offsetPosition.x
          , i = t._offsetPosition.y
          , n = e + t._rect.width
          , t = i + t._rect.height
          , r = this._quad;
        r.bl.vertices = {
            x: e,
            y: i,
            z: 0
        },
        r.br.vertices = {
            x: n,
            y: i,
            z: 0
        },
        r.tl.vertices = {
            x: e,
            y: t,
            z: 0
        },
        r.tr.vertices = {
            x: n,
            y: t,
            z: 0
        },
        this._quadDirty = !0
    }
    ,
    t.getQuad = function() {
        return this._quad
    }
    ,
    t._updateForSetSpriteFrame = function() {}
    ,
    t._spriteFrameLoadedCallback = function(t) {
        this.setTextureRect(t.getRect(), t.isRotated(), t.getOriginalSize()),
        this.dispatchEvent("load")
    }
    ,
    t._textureLoadedCallback = function(t) {
        var e = this._renderCmd;
        if (!this._textureLoaded) {
            this._textureLoaded = !0;
            var i = this._rect;
            i ? cc._rectEqualToZero(i) && (i.width = t.width,
            i.height = t.height) : i = cc.rect(0, 0, t.width, t.height),
            this.texture = t,
            this.setTextureRect(i, this._rectRotated),
            this.setBatchNode(this._batchNode),
            e._quadDirty = !0,
            this.dispatchEvent("load")
        }
    }
    ,
    t._setTextureCoords = function(t, e) {
        void 0 === e && (e = !0),
        e && (t = cc.rectPointsToPixels(t));
        var i = this._node
          , n = i._batchNode ? i.textureAtlas.texture : i._texture;
        if (n) {
            var r, c, s = n.pixelsWidth, o = n.pixelsHeight, a = this._quad;
            i._rectRotated ? (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (n = (2 * t.x + 1) / (2 * s),
            s = n + (2 * t.height - 2) / (2 * s),
            r = (2 * t.y + 1) / (2 * o),
            o = r + (2 * t.width - 2) / (2 * o)) : (n = t.x / s,
            s = (t.x + t.height) / s,
            r = t.y / o,
            o = (t.y + t.width) / o),
            i._flippedX && (c = r,
            r = o,
            o = c),
            i._flippedY && (c = n,
            n = s,
            s = c),
            a.bl.texCoords.u = n,
            a.bl.texCoords.v = r,
            a.br.texCoords.u = n,
            a.br.texCoords.v = o,
            a.tl.texCoords.u = s,
            a.tl.texCoords.v = r,
            a.tr.texCoords.u = s,
            a.tr.texCoords.v = o) : (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (n = (2 * t.x + 1) / (2 * s),
            s = n + (2 * t.width - 2) / (2 * s),
            r = (2 * t.y + 1) / (2 * o),
            o = r + (2 * t.height - 2) / (2 * o)) : (n = t.x / s,
            s = (t.x + t.width) / s,
            r = t.y / o,
            o = (t.y + t.height) / o),
            i._flippedX && (c = n,
            n = s,
            s = c),
            i._flippedY && (c = r,
            r = o,
            o = c),
            a.bl.texCoords.u = n,
            a.bl.texCoords.v = o,
            a.br.texCoords.u = s,
            a.br.texCoords.v = o,
            a.tl.texCoords.u = n,
            a.tl.texCoords.v = r,
            a.tr.texCoords.u = s,
            a.tr.texCoords.v = r),
            this._quadDirty = !0
        }
    }
    ,
    t.transform = function(t, e) {
        cc.Node.WebGLRenderCmd.prototype.transform.call(this, t, e),
        this._dirty = !0
    }
    ,
    t._setColorDirty = function() {}
    ,
    t._updateColor = function() {
        var t = this._displayedColor
          , e = this._displayedOpacity
          , i = this._node
          , t = {
            r: t.r,
            g: t.g,
            b: t.b,
            a: e
        };
        i._opacityModifyRGB && (t.r *= e / 255,
        t.g *= e / 255,
        t.b *= e / 255),
        e = this._quad,
        e.bl.colors = t,
        e.br.colors = t,
        e.tl.colors = t,
        e.tr.colors = t,
        i._batchNode && (i.atlasIndex !== cc.Sprite.INDEX_NOT_INITIALIZED ? i.textureAtlas.updateQuad(e, i.atlasIndex) : this._dirty = !0),
        this._quadDirty = !0
    }
    ,
    t._updateBlendFunc = function() {
        if (this._batchNode)
            cc.log(cc._LogInfos.Sprite__updateBlendFunc);
        else {
            var t = this._node
              , e = t._blendFunc;
            t._texture && t._texture.hasPremultipliedAlpha() ? (e.src === cc.SRC_ALPHA && e.dst === cc.BLEND_DST && (e.src = cc.ONE),
            t.opacityModifyRGB = !0) : (e.src === cc.ONE && e.dst === cc.BLEND_DST && (e.src = cc.SRC_ALPHA),
            t.opacityModifyRGB = !1)
        }
    }
    ,
    t._setTexture = function(t) {
        var e = this._node;
        if (e._batchNode) {
            if (e._batchNode.texture !== t)
                return void cc.log(cc._LogInfos.Sprite_setTexture)
        } else
            e._texture !== t && (e._textureLoaded = !!t && t._textureLoaded,
            e._texture = t,
            this._updateBlendFunc());
        this._shaderProgram = t ? cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR) : cc.shaderCache.programForKey(cc.SHADER_POSITION_COLOR)
    }
    ,
    t.updateTransform = function() {
        var t = this._node;
        if (this._dirty) {
            var e = this._quad
              , i = t._parent;
            if (!t._visible || i && i !== t._batchNode && i._shouldBeHidden)
                e.br.vertices = e.tl.vertices = e.tr.vertices = e.bl.vertices = {
                    x: 0,
                    y: 0,
                    z: 0
                },
                t._shouldBeHidden = !0;
            else {
                t._shouldBeHidden = !1,
                0 !== this._dirtyFlag && (this.updateStatus(),
                this._dirtyFlag = 0),
                t._transformToBatch = i && i !== t._batchNode ? cc.affineTransformConcat(this.getNodeToParentTransform(), i._transformToBatch) : this.getNodeToParentTransform();
                var n = t._transformToBatch
                  , r = t._rect
                  , i = t._offsetPosition.x
                  , c = t._offsetPosition.y
                  , s = i + r.width
                  , o = c + r.height
                  , a = n.tx
                  , h = n.ty
                  , l = n.a
                  , u = n.b
                  , d = n.d
                  , _ = -n.c
                  , n = i * l - c * _ + a
                  , r = i * u + c * d + h
                  , p = s * l - c * _ + a
                  , c = s * u + c * d + h
                  , f = s * l - o * _ + a
                  , s = s * u + o * d + h
                  , a = i * l - o * _ + a
                  , i = i * u + o * d + h
                  , o = t._vertexZ;
                cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (n |= 0,
                r |= 0,
                p |= 0,
                c |= 0,
                f |= 0,
                s |= 0,
                a |= 0,
                i |= 0),
                e.bl.vertices = {
                    x: n,
                    y: r,
                    z: o
                },
                e.br.vertices = {
                    x: p,
                    y: c,
                    z: o
                },
                e.tl.vertices = {
                    x: a,
                    y: i,
                    z: o
                },
                e.tr.vertices = {
                    x: f,
                    y: s,
                    z: o
                }
            }
            t.textureAtlas.updateQuad(e, t.atlasIndex),
            this._dirty = t._recursiveDirty = !1
        }
        t._hasChildren && t._arrayMakeObjectsPerformSelector(t._children, cc.Node._stateCallbackType.updateTransform)
    }
    ,
    t._checkTextureBoundary = function(t, e, i) {
        t && t.url && (i ? (i = e.x + e.height,
        e = e.y + e.width) : (i = e.x + e.width,
        e = e.y + e.height),
        i > t.width && cc.error(cc._LogInfos.RectWidth, t.url),
        e > t.height && cc.error(cc._LogInfos.RectHeight, t.url))
    }
    ,
    t.rendering = function(t) {
        var e = this._node
          , i = e._texture;
        i && !i._textureLoaded || 0 === this._displayedOpacity || (t = t || cc._renderContext,
        i ? i._textureLoaded && (this._shaderProgram.use(),
        this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix),
        cc.glBlendFunc(e._blendFunc.src, e._blendFunc.dst),
        cc.glBindTexture2DN(0, i),
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX),
        t.bindBuffer(t.ARRAY_BUFFER, this._quadWebBuffer),
        this._quadDirty && (t.bufferData(t.ARRAY_BUFFER, this._quad.arrayBuffer, t.DYNAMIC_DRAW),
        this._quadDirty = !1),
        t.vertexAttribPointer(0, 3, t.FLOAT, !1, 24, 0),
        t.vertexAttribPointer(1, 4, t.UNSIGNED_BYTE, !0, 24, 12),
        t.vertexAttribPointer(2, 2, t.FLOAT, !1, 24, 16),
        t.drawArrays(t.TRIANGLE_STRIP, 0, 4)) : (this._shaderProgram.use(),
        this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix),
        cc.glBlendFunc(e._blendFunc.src, e._blendFunc.dst),
        cc.glBindTexture2D(null),
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR),
        t.bindBuffer(t.ARRAY_BUFFER, this._quadWebBuffer),
        this._quadDirty && (t.bufferData(t.ARRAY_BUFFER, this._quad.arrayBuffer, t.STATIC_DRAW),
        this._quadDirty = !1),
        t.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, t.FLOAT, !1, 24, 0),
        t.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, t.UNSIGNED_BYTE, !0, 24, 12),
        t.drawArrays(t.TRIANGLE_STRIP, 0, 4)),
        cc.g_NumberOfDraws++,
        0 === cc.SPRITE_DEBUG_DRAW && !e._showNode) || (cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW),
        cc.current_stack.stack.push(cc.current_stack.top),
        cc.current_stack.top = this._stackMatrix,
        1 === cc.SPRITE_DEBUG_DRAW || e._showNode ? (e = this._quad,
        e = [cc.p(e.tl.vertices.x, e.tl.vertices.y), cc.p(e.bl.vertices.x, e.bl.vertices.y), cc.p(e.br.vertices.x, e.br.vertices.y), cc.p(e.tr.vertices.x, e.tr.vertices.y)],
        cc._drawingUtil.drawPoly(e, 4, !0)) : 2 === cc.SPRITE_DEBUG_DRAW && (i = e.getTextureRect(),
        e = e.getOffsetPosition(),
        e = [cc.p(e.x, e.y), cc.p(e.x + i.width, e.y), cc.p(e.x + i.width, e.y + i.height), cc.p(e.x, e.y + i.height)],
        cc._drawingUtil.drawPoly(e, 4, !0)),
        cc.current_stack.top = cc.current_stack.stack.pop())
    }
}(),
cc.SpriteBatchNode = cc.Node.extend({
    _blendFunc: null,
    _descendants: null,
    _className: "SpriteBatchNode",
    ctor: function(t, e) {
        cc.Node.prototype.ctor.call(this),
        this._descendants = [],
        this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC,cc.BLEND_DST);
        var i;
        e = e || cc.SpriteBatchNode.DEFAULT_CAPACITY,
        cc.isString(t) ? (i = cc.textureCache.getTextureForKey(t)) || (i = cc.textureCache.addImage(t)) : t instanceof cc.Texture2D && (i = t),
        i && this.initWithTexture(i, e)
    },
    addSpriteWithoutQuad: function(t, e, i) {
        if (cc.assert(t, cc._LogInfos.SpriteBatchNode_addSpriteWithoutQuad_2),
        !(t instanceof cc.Sprite))
            return cc.log(cc._LogInfos.SpriteBatchNode_addSpriteWithoutQuad),
            null;
        t.atlasIndex = e;
        var n, r = 0, c = this._descendants;
        if (c && 0 < c.length)
            for (r = 0,
            n = c.length; r < n; r++) {
                var s = c[r];
                if (s && s.atlasIndex >= e)
                    break
            }
        return c.splice(r, 0, t),
        cc.Node.prototype.addChild.call(this, t, e, i),
        this.reorderBatch(!1),
        this
    },
    getTextureAtlas: function() {
        return this._renderCmd.getTextureAtlas()
    },
    setTextureAtlas: function(t) {
        this._renderCmd.getTextureAtlas(t)
    },
    getDescendants: function() {
        return this._descendants
    },
    initWithFile: function(t, e) {
        var i = cc.textureCache.getTextureForKey(t);
        return i || (i = cc.textureCache.addImage(t)),
        this.initWithTexture(i, e)
    },
    _setNodeDirtyForCache: function() {
        this._renderCmd && this._renderCmd._setNodeDirtyForCache && this._renderCmd._setNodeDirtyForCache()
    },
    init: function(t, e) {
        var i = cc.textureCache.getTextureForKey(t);
        return i || (i = cc.textureCache.addImage(t)),
        this.initWithTexture(i, e)
    },
    increaseAtlasCapacity: function() {
        this._renderCmd.increaseAtlasCapacity()
    },
    removeChildAtIndex: function(t, e) {
        this.removeChild(this._children[t], e)
    },
    rebuildIndexInOrder: function(t, e) {
        var i = t.children;
        if (i && 0 < i.length)
            for (var n = 0; n < i.length; n++) {
                var r = i[n];
                r && 0 > r.zIndex && (e = this.rebuildIndexInOrder(r, e))
            }
        if (!t === this && (t.atlasIndex = e,
        e++),
        i && 0 < i.length)
            for (n = 0; n < i.length; n++)
                (r = i[n]) && 0 <= r.zIndex && (e = this.rebuildIndexInOrder(r, e));
        return e
    },
    highestAtlasIndexInChild: function(t) {
        var e = t.children;
        return e && 0 !== e.length ? this.highestAtlasIndexInChild(e[e.length - 1]) : t.atlasIndex
    },
    lowestAtlasIndexInChild: function(t) {
        var e = t.children;
        return e && 0 !== e.length ? this.lowestAtlasIndexInChild(e[e.length - 1]) : t.atlasIndex
    },
    atlasIndexForChild: function(t, e) {
        var i = t.parent
          , n = i.children
          , r = n.indexOf(t)
          , c = null;
        return 0 < r && r < cc.UINT_MAX && (c = n[r - 1]),
        i === this ? 0 === r ? 0 : this.highestAtlasIndexInChild(c) + 1 : 0 === r ? 0 > e ? i.atlasIndex : i.atlasIndex + 1 : 0 > c.zIndex && 0 > e || 0 <= c.zIndex && 0 <= e ? this.highestAtlasIndexInChild(c) + 1 : i.atlasIndex + 1
    },
    reorderBatch: function(t) {
        this._reorderChildDirty = t
    },
    setBlendFunc: function(t, e) {
        this._blendFunc = void 0 === e ? t : {
            src: t,
            dst: e
        }
    },
    getBlendFunc: function() {
        return new cc.BlendFunc(this._blendFunc.src,this._blendFunc.dst)
    },
    reorderChild: function(t, e) {
        cc.assert(t, cc._LogInfos.SpriteBatchNode_reorderChild_2),
        -1 === this._children.indexOf(t) ? cc.log(cc._LogInfos.SpriteBatchNode_reorderChild) : e !== t.zIndex && cc.Node.prototype.reorderChild.call(this, t, e)
    },
    removeChild: function(t, e) {
        null != t && (-1 === this._children.indexOf(t) ? cc.log(cc._LogInfos.SpriteBatchNode_removeChild) : (this.removeSpriteFromAtlas(t),
        cc.Node.prototype.removeChild.call(this, t, e)))
    },
    updateQuadFromSprite: function(t, e) {
        cc.assert(t, cc._LogInfos.CCSpriteBatchNode_updateQuadFromSprite_2),
        t instanceof cc.Sprite ? (this._renderCmd.checkAtlasCapacity(),
        t.batchNode = this,
        t.atlasIndex = e,
        t.dirty = !0,
        t.updateTransform()) : cc.log(cc._LogInfos.CCSpriteBatchNode_updateQuadFromSprite)
    },
    insertQuadFromSprite: function(t, e) {
        cc.assert(t, cc._LogInfos.CCSpriteBatchNode_insertQuadFromSprite_2),
        t instanceof cc.Sprite ? (this._renderCmd.insertQuad(t, e),
        t.batchNode = this,
        t.atlasIndex = e,
        t.dirty = !0,
        t.updateTransform(),
        this._renderCmd.cutting(t, e)) : cc.log(cc._LogInfos.CCSpriteBatchNode_insertQuadFromSprite)
    },
    initWithTexture: function(t, e) {
        return this._children.length = 0,
        this._descendants.length = 0,
        e = e || cc.SpriteBatchNode.DEFAULT_CAPACITY,
        this._renderCmd.initWithTexture(t, e),
        !0
    },
    insertChild: function(t, e) {
        t.batchNode = this,
        t.atlasIndex = e,
        t.dirty = !0,
        this._renderCmd.insertQuad(t, e),
        this._descendants.splice(e, 0, t);
        var i = e + 1
          , n = this._descendants;
        if (n && 0 < n.length)
            for (; i < n.length; i++)
                n[i].atlasIndex++;
        var r, c, n = t.children;
        if (n)
            for (i = 0,
            c = n.length || 0; i < c; i++)
                if (r = n[i]) {
                    var s = this.atlasIndexForChild(r, r.zIndex);
                    this.insertChild(r, s)
                }
    },
    appendChild: function(t) {
        this._reorderChildDirty = !0,
        t.batchNode = this,
        t.dirty = !0,
        this._descendants.push(t);
        var e = this._descendants.length - 1;
        t.atlasIndex = e,
        this._renderCmd.insertQuad(t, e),
        t = t.children;
        for (var e = 0, i = t.length || 0; e < i; e++)
            this.appendChild(t[e])
    },
    removeSpriteFromAtlas: function(t) {
        this._renderCmd.removeQuadAtIndex(t.atlasIndex),
        t.batchNode = null;
        var e = this._descendants
          , i = e.indexOf(t);
        if (-1 !== i) {
            e.splice(i, 1);
            for (var n = e.length; i < n; ++i)
                e[i].atlasIndex--
        }
        if (t = t.children)
            for (e = 0,
            i = t.length || 0; e < i; e++)
                t[e] && this.removeSpriteFromAtlas(t[e]);
    },
    getTexture: function() {
        return this._renderCmd.getTexture()
    },
    setTexture: function(t) {
        this._renderCmd.setTexture(t)
    },
    addChild: function(t, e, i) {
        cc.assert(null != t, cc._LogInfos.CCSpriteBatchNode_addChild_3),
        this._renderCmd.isValidChild(t) && (e = null == e ? t.zIndex : e,
        i = null == i ? t.tag : i,
        cc.Node.prototype.addChild.call(this, t, e, i),
        this.appendChild(t))
    },
    removeAllChildren: function(t) {
        var e = this._descendants;
        if (e && 0 < e.length)
            for (var i = 0, n = e.length; i < n; i++)
                e[i] && (e[i].batchNode = null);
        cc.Node.prototype.removeAllChildren.call(this, t),
        this._descendants.length = 0,
        this._renderCmd.removeAllQuads()
    },
    sortAllChildren: function() {
        if (this._reorderChildDirty) {
            var t, e, i = this._children, n = 0, r = i.length;
            for (t = 1; t < r; t++) {
                var c = i[t]
                  , n = t - 1;
                for (e = i[n]; 0 <= n && (c._localZOrder < e._localZOrder || c._localZOrder === e._localZOrder && c.arrivalOrder < e.arrivalOrder); )
                    i[n + 1] = e,
                    n -= 1,
                    e = i[n];
                i[n + 1] = c
            }
            0 < i.length && (this._arrayMakeObjectsPerformSelector(i, cc.Node._stateCallbackType.sortAllChildren),
            this._renderCmd.updateChildrenAtlasIndex(i)),
            this._reorderChildDirty = !1
        }
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.SpriteBatchNode.CanvasRenderCmd(this) : new cc.SpriteBatchNode.WebGLRenderCmd(this)
    }
}),
_p = cc.SpriteBatchNode.prototype,
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture),
cc.defineGetterSetter(_p, "textureAtlas", _p.getTextureAtlas, _p.setTextureAtlas),
cc.defineGetterSetter(_p, "descendants", _p.getDescendants),
cc.SpriteBatchNode.DEFAULT_CAPACITY = 29,
cc.SpriteBatchNode.create = function(t, e) {
    return new cc.SpriteBatchNode(t,e)
}
,
cc.SpriteBatchNode.createWithTexture = cc.SpriteBatchNode.create,
function() {
    cc.SpriteBatchNode.CanvasRenderCmd = function(t) {
        cc.Node.CanvasRenderCmd.call(this, t),
        this._textureToRender = this._texture = null
    }
    ;
    var t = cc.SpriteBatchNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    t.constructor = cc.SpriteBatchNode.CanvasRenderCmd,
    t.checkAtlasCapacity = function() {}
    ,
    t.isValidChild = function(t) {
        return t instanceof cc.Sprite || (cc.log(cc._LogInfos.Sprite_addChild_4),
        !1)
    }
    ,
    t.initWithTexture = function(t, e) {
        this._textureToRender = this._texture = t
    }
    ,
    t.insertQuad = function(t, e) {}
    ,
    t.increaseAtlasCapacity = function() {}
    ,
    t.removeQuadAtIndex = function() {}
    ,
    t.removeAllQuads = function() {}
    ,
    t.getTexture = function() {
        return this._texture
    }
    ,
    t.setTexture = function(t) {
        this._texture = t;
        for (var e = this._node._children, i = 0; i < e.length; i++)
            e[i].setTexture(t)
    }
    ,
    t.updateChildrenAtlasIndex = function(t) {
        for (var e = this._node._descendants.length = 0, i = t.length; e < i; e++)
            this._updateAtlasIndex(t[e])
    }
    ,
    t._updateAtlasIndex = function(t) {
        var e, i = this._node._descendants, n = t.children, r = n.length;
        for (e = 0; e < r && 0 > n[e]._localZOrder; e++)
            i.push(n[e]);
        for (i.push(t); e < r; e++)
            i.push(n[e])
    }
    ,
    t.getTextureAtlas = function() {}
    ,
    t.setTextureAtlas = function(t) {}
    ,
    t.cutting = function(t, e) {
        this._node._children.splice(e, 0, t)
    }
}(),
function() {
    cc.SpriteBatchNode.WebGLRenderCmd = function(t) {
        cc.Node.WebGLRenderCmd.call(this, t),
        this._needDraw = !0,
        this._textureAtlas = null
    }
    ;
    var t = cc.SpriteBatchNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    t.constructor = cc.SpriteBatchNode.WebGLRenderCmd,
    t.isValidChild = function(t) {
        return t instanceof cc.Sprite ? t.texture == this.getTexture() || (cc.log(cc._LogInfos.Sprite_addChild_5),
        !1) : (cc.log(cc._LogInfos.Sprite_addChild_4),
        !1)
    }
    ,
    t.rendering = function() {
        var t = this._node;
        0 !== this._textureAtlas.totalQuads && (this._shaderProgram.use(),
        this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix),
        t._arrayMakeObjectsPerformSelector(t._children, cc.Node._stateCallbackType.updateTransform),
        cc.glBlendFunc(t._blendFunc.src, t._blendFunc.dst),
        this._textureAtlas.drawQuads())
    }
    ,
    t.visit = function(t) {
        var e = this._node;
        if (e._visible) {
            e._parent && e._parent._renderCmd && (this._curLevel = e._parent._renderCmd._curLevel + 1);
            var i = cc.current_stack;
            i.stack.push(i.top),
            this._dirtyFlag & cc.Node._dirtyFlags.transformDirty || this.transform(t),
            this.updateStatus(t),
            i.top = this._stackMatrix,
            e.sortAllChildren(),
            cc.renderer.pushRenderCommand(this),
            this._dirtyFlag = 0,
            i.top = i.stack.pop()
        }
    }
    ,
    t.checkAtlasCapacity = function(t) {
        for (var e = this._textureAtlas; t >= e.capacity || e.capacity === e.totalQuads; )
            this.increaseAtlasCapacity()
    }
    ,
    t.increaseAtlasCapacity = function() {
        var t = this._textureAtlas.capacity
          , e = Math.floor(4 * (t + 1) / 3);
        cc.log(cc._LogInfos.SpriteBatchNode_increaseAtlasCapacity, t, e),
        this._textureAtlas.resizeCapacity(e) || cc.log(cc._LogInfos.SpriteBatchNode_increaseAtlasCapacity_2)
    }
    ,
    t.initWithTexture = function(t, e) {
        this._textureAtlas = new cc.TextureAtlas,
        this._textureAtlas.initWithTexture(t, e),
        this._updateBlendFunc(),
        this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)
    }
    ,
    t.insertQuad = function(t, e) {
        var i = this._textureAtlas;
        i.totalQuads >= i.capacity && this.increaseAtlasCapacity(),
        i.insertQuad(t.quad, e)
    }
    ,
    t.removeQuadAtIndex = function(t) {
        this._textureAtlas.removeQuadAtIndex(t)
    }
    ,
    t.getTexture = function() {
        return this._textureAtlas.texture
    }
    ,
    t.setTexture = function(t) {
        this._textureAtlas.setTexture(t),
        t && this._updateBlendFunc()
    }
    ,
    t.removeAllQuads = function() {
        this._textureAtlas.removeAllQuads()
    }
    ,
    t._swap = function(t, e) {
        var i = this._node._descendants
          , n = this._textureAtlas
          , r = n.quads
          , c = i[t]
          , s = cc.V3F_C4B_T2F_QuadCopy(r[t]);
        i[e].atlasIndex = t,
        i[t] = i[e],
        n.updateQuad(r[e], t),
        i[e] = c,
        n.updateQuad(s, e)
    }
    ,
    t._updateAtlasIndex = function(t, e) {
        var i = 0
          , n = t.children;
        n && (i = n.length);
        var r = 0;
        if (0 === i)
            r = t.atlasIndex,
            t.atlasIndex = e,
            t.arrivalOrder = 0,
            r !== e && this._swap(r, e),
            e++;
        else {
            for (r = !0,
            0 <= n[0].zIndex && (r = t.atlasIndex,
            t.atlasIndex = e,
            t.arrivalOrder = 0,
            r !== e && this._swap(r, e),
            e++,
            r = !1),
            i = 0; i < n.length; i++) {
                var c = n[i];
                r && 0 <= c.zIndex && (r = t.atlasIndex,
                t.atlasIndex = e,
                t.arrivalOrder = 0,
                r !== e && this._swap(r, e),
                e++,
                r = !1),
                e = this._updateAtlasIndex(c, e)
            }
            r && (r = t.atlasIndex,
            t.atlasIndex = e,
            t.arrivalOrder = 0,
            r !== e && this._swap(r, e),
            e++)
        }
        return e
    }
    ,
    t.updateChildrenAtlasIndex = function(t) {
        for (var e = 0, i = 0; i < t.length; i++)
            e = this._updateAtlasIndex(t[i], e)
    }
    ,
    t._updateBlendFunc = function() {
        if (!this._textureAtlas.texture.hasPremultipliedAlpha()) {
            var t = this._node._blendFunc;
            t.src = cc.SRC_ALPHA,
            t.dst = cc.ONE_MINUS_SRC_ALPHA
        }
    }
    ,
    t.getTextureAtlas = function() {
        return this._textureAtlas
    }
    ,
    t.setTextureAtlas = function(t) {
        t !== this._textureAtlas && (this._textureAtlas = t)
    }
    ,
    t.cutting = function() {}
}(),
cc.BakeSprite = cc.Sprite.extend({
    _cacheCanvas: null,
    _cacheContext: null,
    ctor: function() {
        cc.Sprite.prototype.ctor.call(this);
        var t = document.createElement("canvas");
        t.width = t.height = 10,
        this._cacheCanvas = t,
        this._cacheContext = new cc.CanvasContextWrapper(t.getContext("2d"));
        var e = new cc.Texture2D;
        e.initWithElement(t),
        e.handleLoadedTexture(),
        this.setTexture(e)
    },
    getCacheContext: function() {
        return this._cacheContext
    },
    getCacheCanvas: function() {
        return this._cacheCanvas
    },
    resetCanvasSize: function(t, e) {
        var i = this._cacheCanvas
          , n = this._cacheContext
          , r = n._context.strokeStyle
          , c = n._context.fillStyle;
        void 0 === e && (e = t.height,
        t = t.width),
        i.width = t,
        i.height = e,
        r !== n._context.strokeStyle && (n._context.strokeStyle = r),
        c !== n._context.fillStyle && (n._context.fillStyle = c),
        this.getTexture().handleLoadedTexture(),
        this.setTextureRect(cc.rect(0, 0, t, e), !1, null, !1)
    }
}),
cc.AnimationFrame = cc.Class.extend({
    _spriteFrame: null,
    _delayPerUnit: 0,
    _userInfo: null,
    ctor: function(t, e, i) {
        this._spriteFrame = t || null,
        this._delayPerUnit = e || 0,
        this._userInfo = i || null
    },
    clone: function() {
        var t = new cc.AnimationFrame;
        return t.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo),
        t
    },
    copyWithZone: function(t) {
        return cc.clone(this)
    },
    copy: function(t) {
        return t = new cc.AnimationFrame,
        t.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo),
        t
    },
    initWithSpriteFrame: function(t, e, i) {
        return this._spriteFrame = t,
        this._delayPerUnit = e,
        this._userInfo = i,
        !0
    },
    getSpriteFrame: function() {
        return this._spriteFrame
    },
    setSpriteFrame: function(t) {
        this._spriteFrame = t
    },
    getDelayUnits: function() {
        return this._delayPerUnit
    },
    setDelayUnits: function(t) {
        this._delayPerUnit = t
    },
    getUserInfo: function() {
        return this._userInfo
    },
    setUserInfo: function(t) {
        this._userInfo = t
    }
}),
cc.AnimationFrame.create = function(t, e, i) {
    return new cc.AnimationFrame(t,e,i)
}
,
cc.Animation = cc.Class.extend({
    _frames: null,
    _loops: 0,
    _restoreOriginalFrame: !1,
    _duration: 0,
    _delayPerUnit: 0,
    _totalDelayUnits: 0,
    ctor: function(t, e, i) {
        if (this._frames = [],
        void 0 === t)
            this.initWithSpriteFrames(null, 0);
        else {
            var n = t[0];
            n && (n instanceof cc.SpriteFrame ? this.initWithSpriteFrames(t, e, i) : n instanceof cc.AnimationFrame && this.initWithAnimationFrames(t, e, i))
        }
    },
    getFrames: function() {
        return this._frames
    },
    setFrames: function(t) {
        this._frames = t
    },
    addSpriteFrame: function(t) {
        var e = new cc.AnimationFrame;
        e.initWithSpriteFrame(t, 1, null),
        this._frames.push(e),
        this._totalDelayUnits++
    },
    addSpriteFrameWithFile: function(t) {
        t = cc.textureCache.addImage(t);
        var e = cc.rect(0, 0, 0, 0);
        e.width = t.width,
        e.height = t.height,
        t = new cc.SpriteFrame(t,e),
        this.addSpriteFrame(t)
    },
    addSpriteFrameWithTexture: function(t, e) {
        var i = new cc.SpriteFrame(t,e);
        this.addSpriteFrame(i)
    },
    initWithAnimationFrames: function(t, e, i) {
        for (cc.arrayVerifyType(t, cc.AnimationFrame),
        this._delayPerUnit = e,
        this._loops = void 0 === i ? 1 : i,
        this._totalDelayUnits = 0,
        e = this._frames,
        i = e.length = 0; i < t.length; i++) {
            var n = t[i];
            e.push(n),
            this._totalDelayUnits += n.getDelayUnits()
        }
        return !0
    },
    clone: function() {
        var t = new cc.Animation;
        return t.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops),
        t.setRestoreOriginalFrame(this._restoreOriginalFrame),
        t
    },
    copyWithZone: function(t) {
        return t = new cc.Animation,
        t.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops),
        t.setRestoreOriginalFrame(this._restoreOriginalFrame),
        t
    },
    _copyFrames: function() {
        for (var t = [], e = 0; e < this._frames.length; e++)
            t.push(this._frames[e].clone());
        return t
    },
    copy: function(t) {
        return this.copyWithZone(null)
    },
    getLoops: function() {
        return this._loops
    },
    setLoops: function(t) {
        this._loops = t
    },
    setRestoreOriginalFrame: function(t) {
        this._restoreOriginalFrame = t
    },
    getRestoreOriginalFrame: function() {
        return this._restoreOriginalFrame
    },
    getDuration: function() {
        return this._totalDelayUnits * this._delayPerUnit
    },
    getDelayPerUnit: function() {
        return this._delayPerUnit
    },
    setDelayPerUnit: function(t) {
        this._delayPerUnit = t
    },
    getTotalDelayUnits: function() {
        return this._totalDelayUnits
    },
    initWithSpriteFrames: function(t, e, i) {
        if (cc.arrayVerifyType(t, cc.SpriteFrame),
        this._loops = void 0 === i ? 1 : i,
        this._delayPerUnit = e || 0,
        this._totalDelayUnits = 0,
        e = this._frames,
        e.length = 0,
        t) {
            for (i = 0; i < t.length; i++) {
                var n = t[i]
                  , r = new cc.AnimationFrame;
                r.initWithSpriteFrame(n, 1, null),
                e.push(r)
            }
            this._totalDelayUnits += t.length
        }
        return !0
    },
    retain: function() {},
    release: function() {}
}),
cc.Animation.create = function(t, e, i) {
    return new cc.Animation(t,e,i)
}
,
cc.Animation.createWithAnimationFrames = cc.Animation.create,
cc.animationCache = {
    _animations: {},
    addAnimation: function(t, e) {
        this._animations[e] = t
    },
    removeAnimation: function(t) {
        t && this._animations[t] && delete this._animations[t]
    },
    getAnimation: function(t) {
        return this._animations[t] ? this._animations[t] : null
    },
    _addAnimationsWithDictionary: function(t, e) {
        var i = t.animations;
        if (i) {
            var n = 1
              , r = t.properties;
            if (r)
                for (var n = null != r.format ? parseInt(r.format) : n, r = r.spritesheets, c = cc.spriteFrameCache, s = cc.path, o = 0; o < r.length; o++)
                    c.addSpriteFrames(s.changeBasename(e, r[o]));
            switch (n) {
            case 1:
                this._parseVersion1(i);
                break;
            case 2:
                this._parseVersion2(i);
                break;
            default:
                cc.log(cc._LogInfos.animationCache__addAnimationsWithDictionary_2)
            }
        } else
            cc.log(cc._LogInfos.animationCache__addAnimationsWithDictionary)
    },
    addAnimations: function(t) {
        cc.assert(t, cc._LogInfos.animationCache_addAnimations_2);
        var e = cc.loader.getRes(t);
        e ? this._addAnimationsWithDictionary(e, t) : cc.log(cc._LogInfos.animationCache_addAnimations)
    },
    _parseVersion1: function(t) {
        var e, i = cc.spriteFrameCache;
        for (e in t) {
            var n = t[e]
              , r = n.frames
              , n = parseFloat(n.delay) || 0
              , c = null;
            if (r) {
                for (var c = [], s = 0; s < r.length; s++) {
                    var o = i.getSpriteFrame(r[s]);
                    if (o) {
                        var a = new cc.AnimationFrame;
                        a.initWithSpriteFrame(o, 1, null),
                        c.push(a)
                    } else
                        cc.log(cc._LogInfos.animationCache__parseVersion1_2, e, r[s])
                }
                0 === c.length ? cc.log(cc._LogInfos.animationCache__parseVersion1_3, e) : (c.length !== r.length && cc.log(cc._LogInfos.animationCache__parseVersion1_4, e),
                c = new cc.Animation(c,n,1),
                cc.animationCache.addAnimation(c, e))
            } else
                cc.log(cc._LogInfos.animationCache__parseVersion1, e)
        }
    },
    _parseVersion2: function(t) {
        var e, i = cc.spriteFrameCache;
        for (e in t) {
            var n = t[e]
              , r = n.loop
              , c = parseInt(n.loops)
              , r = r ? cc.REPEAT_FOREVER : isNaN(c) ? 1 : c
              , c = !(!n.restoreOriginalFrame || 1 != n.restoreOriginalFrame)
              , s = n.frames;
            if (s) {
                for (var o = [], a = 0; a < s.length; a++) {
                    var h = s[a]
                      , l = h.spriteframe
                      , u = i.getSpriteFrame(l);
                    if (u) {
                        var l = parseFloat(h.delayUnits) || 0
                          , h = h.notification
                          , d = new cc.AnimationFrame;
                        d.initWithSpriteFrame(u, l, h),
                        o.push(d)
                    } else
                        cc.log(cc._LogInfos.animationCache__parseVersion2_2, e, l)
                }
                n = parseFloat(n.delayPerUnit) || 0,
                s = new cc.Animation,
                s.initWithAnimationFrames(o, n, r),
                s.setRestoreOriginalFrame(c),
                cc.animationCache.addAnimation(s, e)
            } else
                cc.log(cc._LogInfos.animationCache__parseVersion2, e)
        }
    },
    _clear: function() {
        this._animations = {}
    }
},
cc.SpriteFrame = cc.Class.extend({
    _offset: null,
    _originalSize: null,
    _rectInPixels: null,
    _rotated: !1,
    _rect: null,
    _offsetInPixels: null,
    _originalSizeInPixels: null,
    _texture: null,
    _textureFilename: "",
    _textureLoaded: !1,
    ctor: function(t, e, i, n, r) {
        this._offset = cc.p(0, 0),
        this._offsetInPixels = cc.p(0, 0),
        this._originalSize = cc.size(0, 0),
        this._rotated = !1,
        this._originalSizeInPixels = cc.size(0, 0),
        this._textureFilename = "",
        this._texture = null,
        this._textureLoaded = !1,
        void 0 !== t && void 0 !== e && (void 0 === i || void 0 === n || void 0 === r ? this.initWithTexture(t, e) : this.initWithTexture(t, e, i, n, r))
    },
    textureLoaded: function() {
        return this._textureLoaded
    },
    addLoadedEventListener: function(t, e) {
        this.addEventListener("load", t, e)
    },
    getRectInPixels: function() {
        var t = this._rectInPixels;
        return cc.rect(t.x, t.y, t.width, t.height)
    },
    setRectInPixels: function(t) {
        this._rectInPixels || (this._rectInPixels = cc.rect(0, 0, 0, 0)),
        this._rectInPixels.x = t.x,
        this._rectInPixels.y = t.y,
        this._rectInPixels.width = t.width,
        this._rectInPixels.height = t.height,
        this._rect = cc.rectPixelsToPoints(t)
    },
    isRotated: function() {
        return this._rotated
    },
    setRotated: function(t) {
        this._rotated = t
    },
    getRect: function() {
        var t = this._rect;
        return cc.rect(t.x, t.y, t.width, t.height)
    },
    setRect: function(t) {
        this._rect || (this._rect = cc.rect(0, 0, 0, 0)),
        this._rect.x = t.x,
        this._rect.y = t.y,
        this._rect.width = t.width,
        this._rect.height = t.height,
        this._rectInPixels = cc.rectPointsToPixels(this._rect)
    },
    getOffsetInPixels: function() {
        return cc.p(this._offsetInPixels)
    },
    setOffsetInPixels: function(t) {
        this._offsetInPixels.x = t.x,
        this._offsetInPixels.y = t.y,
        cc._pointPixelsToPointsOut(this._offsetInPixels, this._offset)
    },
    getOriginalSizeInPixels: function() {
        return cc.size(this._originalSizeInPixels)
    },
    setOriginalSizeInPixels: function(t) {
        this._originalSizeInPixels.width = t.width,
        this._originalSizeInPixels.height = t.height
    },
    getOriginalSize: function() {
        return cc.size(this._originalSize)
    },
    setOriginalSize: function(t) {
        this._originalSize.width = t.width,
        this._originalSize.height = t.height
    },
    getTexture: function() {
        if (this._texture)
            return this._texture;
        if ("" !== this._textureFilename) {
            var t = cc.textureCache.addImage(this._textureFilename);
            return t && (this._textureLoaded = t.isLoaded()),
            t
        }
        return null
    },
    setTexture: function(t) {
        if (this._texture !== t) {
            var e = t.isLoaded();
            this._textureLoaded = e,
            this._texture = t,
            e || t.addEventListener("load", function(t) {
                if (this._textureLoaded = !0,
                this._rotated && cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
                    var e = t.getHtmlElementObj()
                      , e = cc.Sprite.CanvasRenderCmd._cutRotateImageToCanvas(e, this.getRect())
                      , i = new cc.Texture2D;
                    i.initWithElement(e),
                    i.handleLoadedTexture(),
                    this.setTexture(i),
                    e = this.getRect(),
                    this.setRect(cc.rect(0, 0, e.width, e.height))
                }
                e = this._rect,
                0 === e.width && 0 === e.height && (e = t.width,
                t = t.height,
                this._rect.width = e,
                this._rect.height = t,
                this._rectInPixels = cc.rectPointsToPixels(this._rect),
                this._originalSizeInPixels.width = this._rectInPixels.width,
                this._originalSizeInPixels.height = this._rectInPixels.height,
                this._originalSize.width = e,
                this._originalSize.height = t),
                this.dispatchEvent("load")
            }, this)
        }
    },
    getOffset: function() {
        return cc.p(this._offset)
    },
    setOffset: function(t) {
        this._offset.x = t.x,
        this._offset.y = t.y
    },
    clone: function() {
        var t = new cc.SpriteFrame;
        return t.initWithTexture(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels),
        t.setTexture(this._texture),
        t
    },
    copyWithZone: function() {
        var t = new cc.SpriteFrame;
        return t.initWithTexture(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels),
        t.setTexture(this._texture),
        t
    },
    copy: function() {
        return this.copyWithZone()
    },
    initWithTexture: function(t, e, i, n, r) {
        if (2 === arguments.length && (e = cc.rectPointsToPixels(e)),
        n = n || cc.p(0, 0),
        r = r || e,
        i = i || !1,
        cc.isString(t) ? (this._texture = null,
        this._textureFilename = t) : t instanceof cc.Texture2D && this.setTexture(t),
        t = this.getTexture(),
        this._rectInPixels = e,
        e = this._rect = cc.rectPixelsToPoints(e),
        t && t.url && t.isLoaded()) {
            var c, s;
            i ? (c = e.x + e.height,
            s = e.y + e.width) : (c = e.x + e.width,
            s = e.y + e.height),
            c > t.getPixelsWide() && cc.error(cc._LogInfos.RectWidth, t.url),
            s > t.getPixelsHigh() && cc.error(cc._LogInfos.RectHeight, t.url)
        }
        return this._offsetInPixels.x = n.x,
        this._offsetInPixels.y = n.y,
        cc._pointPixelsToPointsOut(n, this._offset),
        this._originalSizeInPixels.width = r.width,
        this._originalSizeInPixels.height = r.height,
        cc._sizePixelsToPointsOut(r, this._originalSize),
        this._rotated = i,
        !0
    }
}),
cc.EventHelper.prototype.apply(cc.SpriteFrame.prototype),
cc.SpriteFrame.create = function(t, e, i, n, r) {
    return new cc.SpriteFrame(t,e,i,n,r)
}
,
cc.SpriteFrame.createWithTexture = cc.SpriteFrame.create,
cc.SpriteFrame._frameWithTextureForCanvas = function(t, e, i, n, r) {
    var c = new cc.SpriteFrame;
    return c._texture = t,
    c._rectInPixels = e,
    c._rect = cc.rectPixelsToPoints(e),
    c._offsetInPixels.x = n.x,
    c._offsetInPixels.y = n.y,
    cc._pointPixelsToPointsOut(c._offsetInPixels, c._offset),
    c._originalSizeInPixels.width = r.width,
    c._originalSizeInPixels.height = r.height,
    cc._sizePixelsToPointsOut(c._originalSizeInPixels, c._originalSize),
    c._rotated = i,
    c
}
,
cc.spriteFrameCache = {
    _CCNS_REG1: /^\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*$/,
    _CCNS_REG2: /^\s*\{\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*,\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*\}\s*$/,
    _spriteFrames: {},
    _spriteFramesAliases: {},
    _frameConfigCache: {},
    _rectFromString: function(t) {
        return (t = this._CCNS_REG2.exec(t)) ? cc.rect(parseFloat(t[1]), parseFloat(t[2]), parseFloat(t[3]), parseFloat(t[4])) : cc.rect(0, 0, 0, 0)
    },
    _pointFromString: function(t) {
        return (t = this._CCNS_REG1.exec(t)) ? cc.p(parseFloat(t[1]), parseFloat(t[2])) : cc.p(0, 0)
    },
    _sizeFromString: function(t) {
        return (t = this._CCNS_REG1.exec(t)) ? cc.size(parseFloat(t[1]), parseFloat(t[2])) : cc.size(0, 0)
    },
    _getFrameConfig: function(t) {
        var e = cc.loader.getRes(t);
        return cc.assert(e, cc._LogInfos.spriteFrameCache__getFrameConfig_2, t),
        cc.loader.release(t),
        e._inited ? this._frameConfigCache[t] = e : (this._frameConfigCache[t] = this._parseFrameConfig(e),
        this._frameConfigCache[t])
    },
    _getFrameConfigByJsonObject: function(t, e) {
        return cc.assert(e, cc._LogInfos.spriteFrameCache__getFrameConfig_2, t),
        this._frameConfigCache[t] = this._parseFrameConfig(e),
        this._frameConfigCache[t]
    },
    _parseFrameConfig: function(t) {
        var e = t.frames
          , i = t.metadata || t.meta;
        t = {};
        var n = {}
          , r = 0;
        i && (r = i.format,
        r = 1 >= r.length ? parseInt(r) : r,
        n.image = i.textureFileName || i.textureFileName || i.image);
        for (var c in e) {
            var s = e[c];
            if (s) {
                if (i = {},
                0 == r) {
                    i.rect = cc.rect(s.x, s.y, s.width, s.height),
                    i.rotated = !1,
                    i.offset = cc.p(s.offsetX, s.offsetY);
                    var o = s.originalWidth
                      , s = s.originalHeight;
                    o && s || cc.log(cc._LogInfos.spriteFrameCache__getFrameConfig),
                    o = Math.abs(o),
                    s = Math.abs(s),
                    i.size = cc.size(o, s)
                } else if (1 == r || 2 == r)
                    i.rect = this._rectFromString(s.frame),
                    i.rotated = s.rotated || !1,
                    i.offset = this._pointFromString(s.offset),
                    i.size = this._sizeFromString(s.sourceSize);
                else if (3 == r) {
                    var o = this._sizeFromString(s.spriteSize)
                      , a = this._rectFromString(s.textureRect);
                    o && (a = cc.rect(a.x, a.y, o.width, o.height)),
                    i.rect = a,
                    i.rotated = s.textureRotated || !1,
                    i.offset = this._pointFromString(s.spriteOffset),
                    i.size = this._sizeFromString(s.spriteSourceSize),
                    i.aliases = s.aliases
                } else
                    o = s.frame,
                    a = s.sourceSize,
                    c = s.filename || c,
                    i.rect = cc.rect(o.x, o.y, o.w, o.h),
                    i.rotated = s.rotated || !1,
                    i.offset = cc.p(0, 0),
                    i.size = cc.size(a.w, a.h);
                t[c] = i
            }
        }
        return {
            _inited: !0,
            frames: t,
            meta: n
        }
    },
    _addSpriteFramesByObject: function(t, e, i) {
        cc.assert(t, cc._LogInfos.spriteFrameCache_addSpriteFrames_2),
        e && e.frames && (e = this._frameConfigCache[t] || this._getFrameConfigByJsonObject(t, e),
        this._createSpriteFrames(t, e, i))
    },
    _createSpriteFrames: function(t, e, i) {
        var n = e.frames;
        e = e.meta,
        i ? i instanceof cc.Texture2D || (cc.isString(i) ? i = cc.textureCache.addImage(i) : cc.assert(0, cc._LogInfos.spriteFrameCache_addSpriteFrames_3)) : (i = cc.path.changeBasename(t, e.image || ".png"),
        i = cc.textureCache.addImage(i)),
        t = this._spriteFramesAliases,
        e = this._spriteFrames;
        for (var r in n) {
            var c = n[r]
              , s = e[r];
            if (!s) {
                if (s = new cc.SpriteFrame(i,c.rect,c.rotated,c.offset,c.size),
                c = c.aliases)
                    for (var o = 0, a = c.length; o < a; o++) {
                        var h = c[o];
                        t[h] && cc.log(cc._LogInfos.spriteFrameCache_addSpriteFrames, h),
                        t[h] = r
                    }
                cc._renderType === cc.game.RENDER_TYPE_CANVAS && s.isRotated() && s.getTexture().isLoaded() && (c = s.getTexture().getHtmlElementObj(),
                c = cc.Sprite.CanvasRenderCmd._cutRotateImageToCanvas(c, s.getRectInPixels()),
                o = new cc.Texture2D,
                o.initWithElement(c),
                o.handleLoadedTexture(),
                s.setTexture(o),
                c = s._rect,
                s.setRect(cc.rect(0, 0, c.width, c.height))),
                e[r] = s
            }
        }
    },
    addSpriteFrames: function(t, e) {
        cc.assert(t, cc._LogInfos.spriteFrameCache_addSpriteFrames_2);
        var i = this._frameConfigCache[t] || cc.loader.getRes(t);
        i && i.frames && (i = this._frameConfigCache[t] || this._getFrameConfig(t),
        this._createSpriteFrames(t, i, e))
    },
    _checkConflict: function(t) {
        t = t.frames;
        for (var e in t)
            this._spriteFrames[e] && cc.log(cc._LogInfos.spriteFrameCache__checkConflict, e)
    },
    addSpriteFrame: function(t, e) {
        this._spriteFrames[e] = t
    },
    removeSpriteFrames: function() {
        this._spriteFrames = {},
        this._spriteFramesAliases = {}
    },
    removeSpriteFrameByName: function(t) {
        t && (this._spriteFramesAliases[t] && delete this._spriteFramesAliases[t],
        this._spriteFrames[t] && delete this._spriteFrames[t])
    },
    removeSpriteFramesFromFile: function(t) {
        var e = this._spriteFrames
          , i = this._spriteFramesAliases;
        if (t = this._frameConfigCache[t]) {
            t = t.frames;
            for (var n in t)
                if (e[n]) {
                    delete e[n];
                    for (var r in i)
                        i[r] === n && delete i[r]
                }
        }
    },
    removeSpriteFramesFromTexture: function(t) {
        var e, i = this._spriteFrames, n = this._spriteFramesAliases;
        for (e in i) {
            var r = i[e];
            if (r && r.getTexture() === t) {
                delete i[e];
                for (var c in n)
                    n[c] === e && delete n[c]
            }
        }
    },
    getSpriteFrame: function(t) {
        var e = this._spriteFrames[t];
        if (!e) {
            var i = this._spriteFramesAliases[t];
            i && ((e = this._spriteFrames[i.toString()]) || delete this._spriteFramesAliases[t])
        }
        return e
    },
    _clear: function() {
        this._spriteFrames = {},
        this._spriteFramesAliases = {},
        this._frameConfigCache = {}
    }
},
cc.configuration = {
    ERROR: 0,
    STRING: 1,
    INT: 2,
    DOUBLE: 3,
    BOOLEAN: 4,
    _maxTextureSize: 0,
    _maxModelviewStackDepth: 0,
    _supportsPVRTC: !1,
    _supportsNPOT: !1,
    _supportsBGRA8888: !1,
    _supportsDiscardFramebuffer: !1,
    _supportsShareableVAO: !1,
    _maxSamplesAllowed: 0,
    _maxTextureUnits: 0,
    _GlExtensions: "",
    _valueDict: {},
    _inited: !1,
    _init: function() {
        var t = this._valueDict;
        t["cocos2d.x.version"] = cc.ENGINE_VERSION,
        t["cocos2d.x.compiled_with_profiler"] = !1,
        t["cocos2d.x.compiled_with_gl_state_cache"] = cc.ENABLE_GL_STATE_CACHE,
        this._inited = !0
    },
    getMaxTextureSize: function() {
        return this._maxTextureSize
    },
    getMaxModelviewStackDepth: function() {
        return this._maxModelviewStackDepth
    },
    getMaxTextureUnits: function() {
        return this._maxTextureUnits
    },
    supportsNPOT: function() {
        return this._supportsNPOT
    },
    supportsPVRTC: function() {
        return this._supportsPVRTC
    },
    supportsETC: function() {
        return !1
    },
    supportsS3TC: function() {
        return !1
    },
    supportsATITC: function() {
        return !1
    },
    supportsBGRA8888: function() {
        return this._supportsBGRA8888
    },
    supportsDiscardFramebuffer: function() {
        return this._supportsDiscardFramebuffer
    },
    supportsShareableVAO: function() {
        return this._supportsShareableVAO
    },
    checkForGLExtension: function(t) {
        return -1 < this._GlExtensions.indexOf(t)
    },
    getValue: function(t, e) {
        this._inited || this._init();
        var i = this._valueDict;
        return i[t] ? i[t] : e
    },
    setValue: function(t, e) {
        this._valueDict[t] = e
    },
    dumpInfo: function() {
        0 === cc.ENABLE_GL_STATE_CACHE && (cc.log(""),
        cc.log(cc._LogInfos.configuration_dumpInfo),
        cc.log(""))
    },
    gatherGPUInfo: function() {
        if (cc._renderType !== cc.game.RENDER_TYPE_CANVAS) {
            this._inited || this._init();
            var t = cc._renderContext
              , e = this._valueDict;
            e["gl.vendor"] = t.getParameter(t.VENDOR),
            e["gl.renderer"] = t.getParameter(t.RENDERER),
            e["gl.version"] = t.getParameter(t.VERSION),
            this._GlExtensions = "";
            for (var i = t.getSupportedExtensions(), n = 0; n < i.length; n++)
                this._GlExtensions += i[n] + " ";
            this._maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE),
            e["gl.max_texture_size"] = this._maxTextureSize,
            this._maxTextureUnits = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
            e["gl.max_texture_units"] = this._maxTextureUnits,
            this._supportsPVRTC = this.checkForGLExtension("GL_IMG_texture_compression_pvrtc"),
            e["gl.supports_PVRTC"] = this._supportsPVRTC,
            this._supportsNPOT = !1,
            e["gl.supports_NPOT"] = this._supportsNPOT,
            this._supportsBGRA8888 = this.checkForGLExtension("GL_IMG_texture_format_BGRA888"),
            e["gl.supports_BGRA8888"] = this._supportsBGRA8888,
            this._supportsDiscardFramebuffer = this.checkForGLExtension("GL_EXT_discard_framebuffer"),
            e["gl.supports_discard_framebuffer"] = this._supportsDiscardFramebuffer,
            this._supportsShareableVAO = this.checkForGLExtension("vertex_array_object"),
            e["gl.supports_vertex_array_object"] = this._supportsShareableVAO,
            cc.checkGLErrorDebug()
        }
    },
    loadConfigFile: function(t) {
        this._inited || this._init();
        var e = cc.loader.getRes(t);
        if (!e)
            throw Error("Please load the resource first : " + t);
        if (cc.assert(e, cc._LogInfos.configuration_loadConfigFile_2, t),
        e = e.data)
            for (var i in e)
                this._valueDict[i] = e[i];
        else
            cc.log(cc._LogInfos.configuration_loadConfigFile, t)
    }
},
cc.g_NumberOfDraws = 0,
cc.GLToClipTransform = function(t) {
    cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, t);
    var e = new cc.math.Matrix4;
    cc.kmGLGetMatrix(cc.KM_GL_MODELVIEW, e),
    t.multiply(e)
}
,
cc.Director = cc.Class.extend({
    _landscape: !1,
    _nextDeltaTimeZero: !1,
    _paused: !1,
    _purgeDirectorInNextLoop: !1,
    _sendCleanupToScene: !1,
    _animationInterval: 0,
    _oldAnimationInterval: 0,
    _projection: 0,
    _contentScaleFactor: 1,
    _deltaTime: 0,
    _winSizeInPoints: null,
    _lastUpdate: null,
    _nextScene: null,
    _notificationNode: null,
    _openGLView: null,
    _scenesStack: null,
    _projectionDelegate: null,
    _runningScene: null,
    _totalFrames: 0,
    _secondsPerFrame: 0,
    _dirtyRegion: null,
    _scheduler: null,
    _actionManager: null,
    _eventProjectionChanged: null,
    _eventAfterUpdate: null,
    _eventAfterVisit: null,
    _eventAfterDraw: null,
    ctor: function() {
        var t = this;
        t._lastUpdate = Date.now(),
        cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function() {
            t._lastUpdate = Date.now()
        })
    },
    init: function() {
        return this._oldAnimationInterval = this._animationInterval = 1 / cc.defaultFPS,
        this._scenesStack = [],
        this._projection = cc.Director.PROJECTION_DEFAULT,
        this._projectionDelegate = null,
        this._totalFrames = 0,
        this._lastUpdate = Date.now(),
        this._purgeDirectorInNextLoop = this._paused = !1,
        this._winSizeInPoints = cc.size(0, 0),
        this._openGLView = null,
        this._contentScaleFactor = 1,
        this._scheduler = new cc.Scheduler,
        cc.ActionManager ? (this._actionManager = new cc.ActionManager,
        this._scheduler.scheduleUpdate(this._actionManager, cc.Scheduler.PRIORITY_SYSTEM, !1)) : this._actionManager = null,
        this._eventAfterUpdate = new cc.EventCustom(cc.Director.EVENT_AFTER_UPDATE),
        this._eventAfterUpdate.setUserData(this),
        this._eventAfterVisit = new cc.EventCustom(cc.Director.EVENT_AFTER_VISIT),
        this._eventAfterVisit.setUserData(this),
        this._eventAfterDraw = new cc.EventCustom(cc.Director.EVENT_AFTER_DRAW),
        this._eventAfterDraw.setUserData(this),
        this._eventProjectionChanged = new cc.EventCustom(cc.Director.EVENT_PROJECTION_CHANGED),
        this._eventProjectionChanged.setUserData(this),
        !0
    },
    calculateDeltaTime: function() {
        var t = Date.now();
        this._nextDeltaTimeZero ? (this._deltaTime = 0,
        this._nextDeltaTimeZero = !1) : this._deltaTime = (t - this._lastUpdate) / 1e3,
        0 < cc.game.config[cc.game.CONFIG_KEY.debugMode] && .2 < this._deltaTime && (this._deltaTime = 1 / 60),
        this._lastUpdate = t
    },
    convertToGL: null,
    convertToUI: null,
    drawScene: function() {
        var t = cc.renderer;
        this.calculateDeltaTime(),
        this._paused || (this._scheduler.update(this._deltaTime),
        cc.eventManager.dispatchEvent(this._eventAfterUpdate)),
        t.clear(),
        this._nextScene && this.setNextScene(),
        this._beforeVisitScene && this._beforeVisitScene(),
        this._runningScene && (!0 === t.childrenOrderDirty ? (cc.renderer.clearRenderCommands(),
        this._runningScene._renderCmd._curLevel = 0,
        this._runningScene.visit(),
        t.resetFlag()) : !0 === t.transformDirty() && t.transform()),
        this._notificationNode && this._notificationNode.visit(),
        cc.eventManager.dispatchEvent(this._eventAfterVisit),
        cc.g_NumberOfDraws = 0,
        this._afterVisitScene && this._afterVisitScene(),
        t.rendering(cc._renderContext),
        this._totalFrames++,
        cc.eventManager.dispatchEvent(this._eventAfterDraw),
        this._calculateMPF()
    },
    _beforeVisitScene: null,
    _afterVisitScene: null,
    end: function() {
        this._purgeDirectorInNextLoop = !0
    },
    getContentScaleFactor: function() {
        return this._contentScaleFactor
    },
    getNotificationNode: function() {
        return this._notificationNode
    },
    getWinSize: function() {
        return cc.size(this._winSizeInPoints)
    },
    getWinSizeInPixels: function() {
        return cc.size(this._winSizeInPoints.width * this._contentScaleFactor, this._winSizeInPoints.height * this._contentScaleFactor)
    },
    getVisibleSize: null,
    getVisibleOrigin: null,
    getZEye: null,
    pause: function() {
        this._paused || (this._oldAnimationInterval = this._animationInterval,
        this.setAnimationInterval(.25),
        this._paused = !0)
    },
    popScene: function() {
        cc.assert(this._runningScene, cc._LogInfos.Director_popScene),
        this._scenesStack.pop();
        var t = this._scenesStack.length;
        0 === t ? this.end() : (this._sendCleanupToScene = !0,
        this._nextScene = this._scenesStack[t - 1])
    },
    purgeCachedData: function() {
        cc.animationCache._clear(),
        cc.spriteFrameCache._clear(),
        cc.textureCache._clear()
    },
    purgeDirector: function() {
        this.getScheduler().unscheduleAll(),
        cc.eventManager && cc.eventManager.setEnabled(!1),
        this._runningScene && (this._runningScene.onExitTransitionDidStart(),
        this._runningScene.onExit(),
        this._runningScene.cleanup()),
        this._nextScene = this._runningScene = null,
        this._scenesStack.length = 0,
        this.stopAnimation(),
        this.purgeCachedData(),
        cc.checkGLErrorDebug()
    },
    pushScene: function(t) {
        cc.assert(t, cc._LogInfos.Director_pushScene),
        this._sendCleanupToScene = !1,
        this._scenesStack.push(t),
        this._nextScene = t
    },
    runScene: function(t) {
        if (cc.assert(t, cc._LogInfos.Director_pushScene),
        this._runningScene) {
            var e = this._scenesStack.length;
            0 === e ? (this._sendCleanupToScene = !0,
            this._scenesStack[e] = t) : (this._sendCleanupToScene = !0,
            this._scenesStack[e - 1] = t),
            this._nextScene = t
        } else
            this.pushScene(t),
            this.startAnimation()
    },
    resume: function() {
        this._paused && (this.setAnimationInterval(this._oldAnimationInterval),
        (this._lastUpdate = Date.now()) || cc.log(cc._LogInfos.Director_resume),
        this._paused = !1,
        this._deltaTime = 0)
    },
    setContentScaleFactor: function(t) {
        t !== this._contentScaleFactor && (this._contentScaleFactor = t)
    },
    setDepthTest: null,
    setClearColor: null,
    setDefaultValues: function() {},
    setNextDeltaTimeZero: function(t) {
        this._nextDeltaTimeZero = t
    },
    setNextScene: function() {
        var t = !1
          , e = !1;
        cc.TransitionScene && (t = !!this._runningScene && this._runningScene instanceof cc.TransitionScene,
        e = !!this._nextScene && this._nextScene instanceof cc.TransitionScene),
        e || ((e = this._runningScene) && (e.onExitTransitionDidStart(),
        e.onExit()),
        this._sendCleanupToScene && e && e.cleanup()),
        this._runningScene = this._nextScene,
        cc.renderer.childrenOrderDirty = !0,
        this._nextScene = null,
        t || null === this._runningScene || (this._runningScene.onEnter(),
        this._runningScene.onEnterTransitionDidFinish())
    },
    setNotificationNode: function(t) {
        cc.renderer.childrenOrderDirty = !0,
        this._notificationNode && (this._notificationNode.onExitTransitionDidStart(),
        this._notificationNode.onExit(),
        this._notificationNode.cleanup()),
        (this._notificationNode = t) && (this._notificationNode.onEnter(),
        this._notificationNode.onEnterTransitionDidFinish())
    },
    getDelegate: function() {
        return this._projectionDelegate
    },
    setDelegate: function(t) {
        this._projectionDelegate = t
    },
    setOpenGLView: null,
    setProjection: null,
    setViewport: null,
    getOpenGLView: null,
    getProjection: null,
    setAlphaBlending: null,
    isSendCleanupToScene: function() {
        return this._sendCleanupToScene
    },
    getRunningScene: function() {
        return this._runningScene
    },
    getAnimationInterval: function() {
        return this._animationInterval
    },
    isDisplayStats: function() {
        return !!cc.profiler && cc.profiler.isShowingStats()
    },
    setDisplayStats: function(t) {
        cc.profiler && (t ? cc.profiler.showStats() : cc.profiler.hideStats());
    },
    getSecondsPerFrame: function() {
        return this._secondsPerFrame
    },
    isNextDeltaTimeZero: function() {
        return this._nextDeltaTimeZero
    },
    isPaused: function() {
        return this._paused
    },
    getTotalFrames: function() {
        return this._totalFrames
    },
    popToRootScene: function() {
        this.popToSceneStackLevel(1)
    },
    popToSceneStackLevel: function(t) {
        cc.assert(this._runningScene, cc._LogInfos.Director_popToSceneStackLevel_2);
        var e = this._scenesStack
          , i = e.length;
        if (0 === t)
            this.end();
        else if (!(t >= i)) {
            for (; i > t; ) {
                var n = e.pop();
                n.running && (n.onExitTransitionDidStart(),
                n.onExit()),
                n.cleanup(),
                i--
            }
            this._nextScene = e[e.length - 1],
            this._sendCleanupToScene = !0
        }
    },
    getScheduler: function() {
        return this._scheduler
    },
    setScheduler: function(t) {
        this._scheduler !== t && (this._scheduler = t)
    },
    getActionManager: function() {
        return this._actionManager
    },
    setActionManager: function(t) {
        this._actionManager !== t && (this._actionManager = t)
    },
    getDeltaTime: function() {
        return this._deltaTime
    },
    _calculateMPF: function() {
        this._secondsPerFrame = (Date.now() - this._lastUpdate) / 1e3
    }
}),
cc.Director.EVENT_PROJECTION_CHANGED = "director_projection_changed",
cc.Director.EVENT_AFTER_UPDATE = "director_after_update",
cc.Director.EVENT_AFTER_VISIT = "director_after_visit",
cc.Director.EVENT_AFTER_DRAW = "director_after_draw",
cc.DisplayLinkDirector = cc.Director.extend({
    invalid: !1,
    startAnimation: function() {
        this._nextDeltaTimeZero = !0,
        this.invalid = !1
    },
    mainLoop: function() {
        this._purgeDirectorInNextLoop ? (this._purgeDirectorInNextLoop = !1,
        this.purgeDirector()) : this.invalid || this.drawScene()
    },
    stopAnimation: function() {
        this.invalid = !0
    },
    setAnimationInterval: function(t) {
        this._animationInterval = t,
        this.invalid || (this.stopAnimation(),
        this.startAnimation())
    }
}),
cc.Director.sharedDirector = null,
cc.Director.firstUseDirector = !0,
cc.Director._getInstance = function() {
    return cc.Director.firstUseDirector && (cc.Director.firstUseDirector = !1,
    cc.Director.sharedDirector = new cc.DisplayLinkDirector,
    cc.Director.sharedDirector.init()),
    cc.Director.sharedDirector
}
,
cc.defaultFPS = 60,
cc.Director.PROJECTION_2D = 0,
cc.Director.PROJECTION_3D = 1,
cc.Director.PROJECTION_CUSTOM = 3,
cc.Director.PROJECTION_DEFAULT = cc.Director.PROJECTION_3D,
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function() {
    if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
        var t = cc.Director.prototype;
        t.getProjection = function(t) {
            return this._projection
        }
        ,
        t.setProjection = function(t) {
            this._projection = t,
            cc.eventManager.dispatchEvent(this._eventProjectionChanged)
        }
        ,
        t.setDepthTest = function() {}
        ,
        t.setClearColor = function(t) {
            cc.renderer._clearColor = t,
            cc.renderer._clearFillStyle = "rgb(" + t.r + "," + t.g + "," + t.b + ")"
        }
        ,
        t.setOpenGLView = function(t) {
            this._winSizeInPoints.width = cc._canvas.width,
            this._winSizeInPoints.height = cc._canvas.height,
            this._openGLView = t || cc.view,
            cc.eventManager && cc.eventManager.setEnabled(!0)
        }
        ,
        t.getVisibleSize = function() {
            return this.getWinSize()
        }
        ,
        t.getVisibleOrigin = function() {
            return cc.p(0, 0)
        }
    } else
        cc.Director._fpsImage = new Image,
        cc.Director._fpsImage.addEventListener("load", function() {
            cc.Director._fpsImageLoaded = !0
        }),
        cc._fpsImage && (cc.Director._fpsImage.src = cc._fpsImage)
}),
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function() {
    if (cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
        cc.DirectorDelegate = cc.Class.extend({
            updateProjection: function() {}
        });
        var t = cc.Director.prototype
          , e = function(t) {
            if (t && t._renderCmd) {
                t._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
                var i = t._children;
                for (t = 0; t < i.length; t++)
                    e(i[t])
            }
        };
        cc.eventManager.addCustomListener(cc.Director.EVENT_PROJECTION_CHANGED, function() {
            for (var t = cc.director._scenesStack, i = 0; i < t.length; i++)
                e(t[i])
        }),
        t.setProjection = function(t) {
            var e = this._winSizeInPoints;
            this.setViewport();
            var i = this._openGLView
              , n = i._viewPortRect.x / i._scaleX
              , r = i._viewPortRect.y / i._scaleY;
            switch (t) {
            case cc.Director.PROJECTION_2D:
                cc.kmGLMatrixMode(cc.KM_GL_PROJECTION),
                cc.kmGLLoadIdentity(),
                i = cc.math.Matrix4.createOrthographicProjection(-n, e.width - n, -r, e.height - r, -1024, 1024),
                cc.kmGLMultMatrix(i),
                cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW),
                cc.kmGLLoadIdentity();
                break;
            case cc.Director.PROJECTION_3D:
                var c = this.getZEye()
                  , s = new cc.math.Matrix4
                  , i = new cc.math.Matrix4;
                cc.kmGLMatrixMode(cc.KM_GL_PROJECTION),
                cc.kmGLLoadIdentity(),
                s = cc.math.Matrix4.createPerspectiveProjection(60, e.width / e.height, .1, 2 * c),
                cc.kmGLMultMatrix(s),
                cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW),
                cc.kmGLLoadIdentity(),
                c = new cc.math.Vec3(-n + e.width / 2,-r + e.height / 2,c),
                e = new cc.math.Vec3(-n + e.width / 2,-r + e.height / 2,0),
                n = new cc.math.Vec3(0,1,0),
                i.lookAt(c, e, n),
                cc.kmGLMultMatrix(i);
                break;
            case cc.Director.PROJECTION_CUSTOM:
                this._projectionDelegate && this._projectionDelegate.updateProjection();
                break;
            default:
                cc.log(cc._LogInfos.Director_setProjection)
            }
            this._projection = t,
            cc.eventManager.dispatchEvent(this._eventProjectionChanged),
            cc.setProjectionMatrixDirty(),
            cc.renderer.childrenOrderDirty = !0
        }
        ,
        t.setDepthTest = function(t) {
            cc.renderer.setDepthTest(t)
        }
        ,
        t.setClearColor = function(t) {
            cc.renderer._clearColor = t
        }
        ,
        t.setOpenGLView = function(t) {
            this._winSizeInPoints.width = cc._canvas.width,
            this._winSizeInPoints.height = cc._canvas.height,
            this._openGLView = t || cc.view,
            t = cc.configuration,
            t.gatherGPUInfo(),
            t.dumpInfo(),
            this.setGLDefaultValues(),
            cc.eventManager && cc.eventManager.setEnabled(!0)
        }
        ,
        t._clear = function() {
            var t = cc._renderContext;
            t.clear(t.COLOR_BUFFER_BIT | t.DEPTH_BUFFER_BIT)
        }
        ,
        t._beforeVisitScene = function() {
            cc.kmGLPushMatrix()
        }
        ,
        t._afterVisitScene = function() {
            cc.kmGLPopMatrix()
        }
        ,
        t.convertToGL = function(t) {
            var e = new cc.math.Matrix4;
            cc.GLToClipTransform(e);
            var i = e.inverse()
              , e = e.mat[14] / e.mat[15]
              , n = this._openGLView.getDesignResolutionSize();
            return t = new cc.math.Vec3(2 * t.x / n.width - 1,1 - 2 * t.y / n.height,e),
            t.transformCoord(i),
            cc.p(t.x, t.y)
        }
        ,
        t.convertToUI = function(t) {
            var e = new cc.math.Matrix4;
            return cc.GLToClipTransform(e),
            t = new cc.math.Vec3(t.x,t.y,0),
            t.transformCoord(e),
            e = this._openGLView.getDesignResolutionSize(),
            cc.p(e.width * (.5 * t.x + .5), e.height * (.5 * -t.y + .5))
        }
        ,
        t.getVisibleSize = function() {
            return this._openGLView.getVisibleSize()
        }
        ,
        t.getVisibleOrigin = function() {
            return this._openGLView.getVisibleOrigin()
        }
        ,
        t.getZEye = function() {
            return this._winSizeInPoints.height / 1.1566
        }
        ,
        t.setViewport = function() {
            var t = this._openGLView;
            if (t) {
                var e = this._winSizeInPoints;
                t.setViewPortInPoints(-t._viewPortRect.x / t._scaleX, -t._viewPortRect.y / t._scaleY, e.width, e.height)
            }
        }
        ,
        t.getOpenGLView = function() {
            return this._openGLView
        }
        ,
        t.getProjection = function() {
            return this._projection
        }
        ,
        t.setAlphaBlending = function(t) {
            t ? cc.glBlendFunc(cc.BLEND_SRC, cc.BLEND_DST) : cc.glBlendFunc(cc._renderContext.ONE, cc._renderContext.ZERO)
        }
        ,
        t.setGLDefaultValues = function() {
            this.setAlphaBlending(!0),
            this.setDepthTest(!1),
            this.setProjection(this._projection),
            cc._renderContext.clearColor(0, 0, 0, 0)
        }
    }
}),
cc.Camera = cc.Class.extend({
    _eyeX: null,
    _eyeY: null,
    _eyeZ: null,
    _centerX: null,
    _centerY: null,
    _centerZ: null,
    _upX: null,
    _upY: null,
    _upZ: null,
    _dirty: !1,
    _lookupMatrix: null,
    ctor: function() {
        this._lookupMatrix = new cc.math.Matrix4,
        this.restore()
    },
    description: function() {
        return "<CCCamera | center =(" + this._centerX + "," + this._centerY + "," + this._centerZ + ")>"
    },
    setDirty: function(t) {
        this._dirty = t
    },
    isDirty: function() {
        return this._dirty
    },
    restore: function() {
        this._eyeX = this._eyeY = 0,
        this._eyeZ = cc.Camera.getZEye(),
        this._upX = this._centerX = this._centerY = this._centerZ = 0,
        this._upY = 1,
        this._upZ = 0,
        this._lookupMatrix.identity(),
        this._dirty = !1
    },
    locate: function() {
        if (this._dirty) {
            var t = new cc.math.Vec3(this._eyeX,this._eyeY,this._eyeZ)
              , e = new cc.math.Vec3(this._centerX,this._centerY,this._centerZ)
              , i = new cc.math.Vec3(this._upX,this._upY,this._upZ);
            this._lookupMatrix.lookAt(t, e, i),
            this._dirty = !1
        }
        cc.kmGLMultMatrix(this._lookupMatrix)
    },
    _locateForRenderer: function(t) {
        if (this._dirty) {
            var e = new cc.math.Vec3(this._eyeX,this._eyeY,this._eyeZ)
              , i = new cc.math.Vec3(this._centerX,this._centerY,this._centerZ)
              , n = new cc.math.Vec3(this._upX,this._upY,this._upZ);
            this._lookupMatrix.lookAt(e, i, n),
            this._dirty = !1
        }
        t.multiply(this._lookupMatrix)
    },
    setEyeXYZ: function(t, e, i) {
        this.setEye(t, e, i)
    },
    setEye: function(t, e, i) {
        this._eyeX = t,
        this._eyeY = e,
        this._eyeZ = i,
        this._dirty = !0
    },
    setCenterXYZ: function(t, e, i) {
        this.setCenter(t, e, i)
    },
    setCenter: function(t, e, i) {
        this._centerX = t,
        this._centerY = e,
        this._centerZ = i,
        this._dirty = !0
    },
    setUpXYZ: function(t, e, i) {
        this.setUp(t, e, i)
    },
    setUp: function(t, e, i) {
        this._upX = t,
        this._upY = e,
        this._upZ = i,
        this._dirty = !0
    },
    getEyeXYZ: function(t, e, i) {
        return {
            x: this._eyeX,
            y: this._eyeY,
            z: this._eyeZ
        }
    },
    getEye: function() {
        return {
            x: this._eyeX,
            y: this._eyeY,
            z: this._eyeZ
        }
    },
    getCenterXYZ: function(t, e, i) {
        return {
            x: this._centerX,
            y: this._centerY,
            z: this._centerZ
        }
    },
    getCenter: function() {
        return {
            x: this._centerX,
            y: this._centerY,
            z: this._centerZ
        }
    },
    getUpXYZ: function(t, e, i) {
        return {
            x: this._upX,
            y: this._upY,
            z: this._upZ
        }
    },
    getUp: function() {
        return {
            x: this._upX,
            y: this._upY,
            z: this._upZ
        }
    },
    _DISALLOW_COPY_AND_ASSIGN: function(t) {}
}),
cc.Camera.getZEye = function() {
    return cc.FLT_EPSILON
}
,
cc.PRIORITY_NON_SYSTEM = cc.PRIORITY_SYSTEM + 1,
cc.ListEntry = function(t, e, i, n, r, c, s) {
    this.prev = t,
    this.next = e,
    this.callback = i,
    this.target = n,
    this.priority = r,
    this.paused = c,
    this.markedForDeletion = s
}
,
cc.HashUpdateEntry = function(t, e, i, n, r) {
    this.list = t,
    this.entry = e,
    this.target = i,
    this.callback = n,
    this.hh = r
}
,
cc.HashTimerEntry = cc.hashSelectorEntry = function(t, e, i, n, r, c, s) {
    this.timers = t,
    this.target = e,
    this.timerIndex = i,
    this.currentTimer = n,
    this.currentTimerSalvaged = r,
    this.paused = c,
    this.hh = s
}
,
cc.Timer = cc.Class.extend({
    _scheduler: null,
    _elapsed: 0,
    _runForever: !1,
    _useDelay: !1,
    _timesExecuted: 0,
    _repeat: 0,
    _delay: 0,
    _interval: 0,
    getInterval: function() {
        return this._interval
    },
    setInterval: function(t) {
        this._interval = t
    },
    setupTimerWithInterval: function(t, e, i) {
        this._elapsed = -1,
        this._interval = t,
        this._delay = i,
        this._useDelay = 0 < this._delay,
        this._repeat = e,
        this._runForever = this._repeat === cc.REPEAT_FOREVER
    },
    trigger: function() {
        return 0
    },
    cancel: function() {
        return 0
    },
    ctor: function() {
        this._scheduler = null,
        this._elapsed = -1,
        this._useDelay = this._runForever = !1,
        this._interval = this._delay = this._repeat = this._timesExecuted = 0
    },
    update: function(t) {
        -1 === this._elapsed ? this._timesExecuted = this._elapsed = 0 : (this._elapsed += t,
        this._runForever && !this._useDelay ? this._elapsed >= this._interval && (this.trigger(),
        this._elapsed = 0) : (this._useDelay ? this._elapsed >= this._delay && (this.trigger(),
        this._elapsed -= this._delay,
        this._timesExecuted += 1,
        this._useDelay = !1) : this._elapsed >= this._interval && (this.trigger(),
        this._elapsed = 0,
        this._timesExecuted += 1),
        !this._runForever && this._timesExecuted > this._repeat && this.cancel()))
    }
}),
cc.TimerTargetSelector = cc.Timer.extend({
    _target: null,
    _selector: null,
    ctor: function() {
        this._selector = this._target = null
    },
    initWithSelector: function(t, e, i, n, r, c) {
        return this._scheduler = t,
        this._target = i,
        this._selector = e,
        this.setupTimerWithInterval(n, r, c),
        !0
    },
    getSelector: function() {
        return this._selector
    },
    trigger: function() {
        this._target && this._selector && this._target.call(this._selector, this._elapsed)
    },
    cancel: function() {
        this._scheduler.unschedule(this._selector, this._target)
    }
}),
cc.TimerTargetCallback = cc.Timer.extend({
    _target: null,
    _callback: null,
    _key: null,
    ctor: function() {
        this._callback = this._target = null
    },
    initWithCallback: function(t, e, i, n, r, c, s) {
        return this._scheduler = t,
        this._target = i,
        this._callback = e,
        this._key = n,
        this.setupTimerWithInterval(r, c, s),
        !0
    },
    getCallback: function() {
        return this._callback
    },
    getKey: function() {
        return this._key
    },
    trigger: function() {
        this._callback && this._callback.call(this._target, this._elapsed)
    },
    cancel: function() {
        this._scheduler.unschedule(this._callback, this._target)
    }
}),
cc.Scheduler = cc.Class.extend({
    _timeScale: 1,
    _updatesNegList: null,
    _updates0List: null,
    _updatesPosList: null,
    _hashForTimers: null,
    _arrayForTimers: null,
    _hashForUpdates: null,
    _currentTarget: null,
    _currentTargetSalvaged: !1,
    _updateHashLocked: !1,
    ctor: function() {
        this._timeScale = 1,
        this._updatesNegList = [],
        this._updates0List = [],
        this._updatesPosList = [],
        this._hashForUpdates = {},
        this._hashForTimers = {},
        this._currentTarget = null,
        this._updateHashLocked = this._currentTargetSalvaged = !1,
        this._arrayForTimers = []
    },
    _schedulePerFrame: function(t, e, i, n) {
        var r = this._hashForUpdates[e.__instanceId];
        if (r && r.entry) {
            if (r.entry.priority === i)
                return r.entry.markedForDeletion = !1,
                void (r.entry.paused = n);
            if (this._updateHashLocked)
                return cc.log("warning: you CANNOT change update priority in scheduled function"),
                r.entry.markedForDeletion = !1,
                void (r.entry.paused = n);
            this.unscheduleUpdate(e)
        }
        0 === i ? this._appendIn(this._updates0List, t, e, n) : 0 > i ? this._priorityIn(this._updatesNegList, t, e, i, n) : this._priorityIn(this._updatesPosList, t, e, i, n)
    },
    _removeHashElement: function(t) {
        delete this._hashForTimers[t.target.__instanceId],
        cc.arrayRemoveObject(this._arrayForTimers, t),
        t.Timer = null,
        t.target = null
    },
    _removeUpdateFromHash: function(t) {
        (t = this._hashForUpdates[t.target.__instanceId]) && (cc.arrayRemoveObject(t.list, t.entry),
        delete this._hashForUpdates[t.target.__instanceId],
        t.entry = null,
        t.target = null)
    },
    _priorityIn: function(t, e, i, n, r) {
        if (e = new cc.ListEntry(null,null,e,i,n,r,(!1)),
        t) {
            r = t.length - 1;
            for (var c = 0; c <= r && !(n < t[c].priority); c++)
                ;
            t.splice(c, 0, e)
        } else
            t = [],
            t.push(e);
        return this._hashForUpdates[i.__instanceId] = new cc.HashUpdateEntry(t,e,i,null),
        t
    },
    _appendIn: function(t, e, i, n) {
        e = new cc.ListEntry(null,null,e,i,0,n,(!1)),
        t.push(e),
        this._hashForUpdates[i.__instanceId] = new cc.HashUpdateEntry(t,e,i,null,null)
    },
    setTimeScale: function(t) {
        this._timeScale = t
    },
    getTimeScale: function() {
        return this._timeScale
    },
    update: function(t) {
        this._updateHashLocked = !0,
        1 !== this._timeScale && (t *= this._timeScale);
        var e, i, n, r;
        for (e = 0,
        i = this._updatesNegList,
        n = i.length; e < n; e++)
            r = i[e],
            r.paused || r.markedForDeletion || r.callback(t);
        for (e = 0,
        i = this._updates0List,
        n = i.length; e < n; e++)
            r = i[e],
            r.paused || r.markedForDeletion || r.callback(t);
        for (e = 0,
        i = this._updatesPosList,
        n = i.length; e < n; e++)
            r = i[e],
            r.paused || r.markedForDeletion || r.callback(t);
        for (n = this._arrayForTimers,
        e = 0; e < n.length; e++) {
            if (this._currentTarget = i = n[e],
            this._currentTargetSalvaged = !1,
            !i.paused)
                for (i.timerIndex = 0; i.timerIndex < i.timers.length; ++i.timerIndex)
                    i.currentTimer = i.timers[i.timerIndex],
                    i.currentTimerSalvaged = !1,
                    i.currentTimer.update(t),
                    i.currentTimer = null;
            this._currentTargetSalvaged && 0 === this._currentTarget.timers.length && this._removeHashElement(this._currentTarget)
        }
        for (e = 0,
        i = this._updatesNegList; e < i.length; )
            r = i[e],
            r.markedForDeletion ? this._removeUpdateFromHash(r) : e++;
        for (e = 0,
        i = this._updates0List; e < i.length; )
            r = i[e],
            r.markedForDeletion ? this._removeUpdateFromHash(r) : e++;
        for (e = 0,
        i = this._updatesPosList; e < i.length; )
            r = i[e],
            r.markedForDeletion ? this._removeUpdateFromHash(r) : e++;
        this._updateHashLocked = !1,
        this._currentTarget = null
    },
    scheduleCallbackForTarget: function(t, e, i, n, r, c) {
        this.schedule(e, t, i, n, r, c, t.__instanceId + "")
    },
    schedule: function(t, e, i, n, r, c, s) {
        var o = !1;
        if ("function" != typeof t)
            var a = t
              , o = !0;
        !1 === o ? 4 !== arguments.length && 5 !== arguments.length || (s = r,
        c = n,
        r = 0,
        n = cc.REPEAT_FOREVER) : 4 === arguments.length && (c = n,
        n = cc.REPEAT_FOREVER,
        r = 0),
        void 0 === s && (s = e.__instanceId + ""),
        cc.assert(e, cc._LogInfos.Scheduler_scheduleCallbackForTarget_3);
        var h = this._hashForTimers[e.__instanceId];
        h ? cc.assert(h.paused === c, "") : (h = new cc.HashTimerEntry(null,e,0,null,null,c,null),
        this._arrayForTimers.push(h),
        this._hashForTimers[e.__instanceId] = h);
        var l, u;
        if (null == h.timers)
            h.timers = [];
        else if (!1 === o) {
            for (u = 0; u < h.timers.length; u++)
                if (l = h.timers[u],
                t === l._callback)
                    return cc.log(cc._LogInfos.Scheduler_scheduleCallbackForTarget, l.getInterval().toFixed(4), i.toFixed(4)),
                    void (l._interval = i)
        } else
            for (u = 0; u < h.timers.length; ++u)
                if ((l = h.timers[u]) && a === l.getSelector())
                    return cc.log("CCScheduler#scheduleSelector. Selector already scheduled. Updating interval from: %.4f to %.4f", l.getInterval(), i),
                    void l.setInterval(i);
        !1 === o ? (l = new cc.TimerTargetCallback,
        l.initWithCallback(this, t, e, s, i, n, r)) : (l = new cc.TimerTargetSelector,
        l.initWithSelector(this, a, e, i, n, r)),
        h.timers.push(l)
    },
    scheduleUpdate: function(t, e, i) {
        this._schedulePerFrame(function(e) {
            t.update(e)
        }, t, e, i)
    },
    _getUnscheduleMark: function(t, e) {
        switch (typeof t) {
        case "number":
        case "string":
            return t === e.getKey();
        case "function":
            return t === e._callback;
        default:
            return t === e.getSelector()
        }
    },
    unschedule: function(t, e) {
        if (e && t) {
            var i = this._hashForTimers[e.__instanceId];
            if (i)
                for (var n = i.timers, r = 0, c = n.length; r < c; r++) {
                    var s = n[r];
                    if (this._getUnscheduleMark(t, s)) {
                        s !== i.currentTimer || i.currentTimerSalvaged || (i.currentTimerSalvaged = !0),
                        n.splice(r, 1),
                        i.timerIndex >= r && i.timerIndex--,
                        0 === n.length && (this._currentTarget === i ? this._currentTargetSalvaged = !0 : this._removeHashElement(i));
                        break
                    }
                }
        }
    },
    unscheduleUpdate: function(t) {
        null != t && (t = this._hashForUpdates[t.__instanceId]) && (this._updateHashLocked ? t.entry.markedForDeletion = !0 : this._removeUpdateFromHash(t.entry))
    },
    unscheduleAllForTarget: function(t) {
        if (null != t) {
            var e = this._hashForTimers[t.__instanceId];
            e && (-1 < e.timers.indexOf(e.currentTimer) && !e.currentTimerSalvaged && (e.currentTimerSalvaged = !0),
            e.timers.length = 0,
            this._currentTarget === e ? this._currentTargetSalvaged = !0 : this._removeHashElement(e)),
            this.unscheduleUpdate(t)
        }
    },
    unscheduleAll: function() {
        this.unscheduleAllWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM)
    },
    unscheduleAllWithMinPriority: function(t) {
        var e, i, n = this._arrayForTimers;
        for (e = n.length - 1; 0 <= e; e--)
            i = n[e],
            this.unscheduleAllForTarget(i.target);
        if (n = 0,
        0 > t)
            for (e = 0; e < this._updatesNegList.length; )
                n = this._updatesNegList.length,
                (i = this._updatesNegList[e]) && i.priority >= t && this.unscheduleUpdate(i.target),
                n == this._updatesNegList.length && e++;
        if (0 >= t)
            for (e = 0; e < this._updates0List.length; )
                n = this._updates0List.length,
                (i = this._updates0List[e]) && this.unscheduleUpdate(i.target),
                n == this._updates0List.length && e++;
        for (e = 0; e < this._updatesPosList.length; )
            n = this._updatesPosList.length,
            (i = this._updatesPosList[e]) && i.priority >= t && this.unscheduleUpdate(i.target),
            n == this._updatesPosList.length && e++
    },
    isScheduled: function(t, e) {
        cc.assert(t, "Argument key must not be empty"),
        cc.assert(e, "Argument target must be non-nullptr");
        var i = this._hashForUpdates[e.__instanceId];
        if (!i)
            return !1;
        if (null != i.timers)
            for (var i = i.timers, n = 0; n < i.length; ++n)
                if (t === i[n].getKey())
                    return !0;
        return !1
    },
    pauseAllTargets: function() {
        return this.pauseAllTargetsWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM)
    },
    pauseAllTargetsWithMinPriority: function(t) {
        var e, i, n, r = [], c = this._arrayForTimers;
        for (i = 0,
        n = c.length; i < n; i++)
            (e = c[i]) && (e.paused = !0,
            r.push(e.target));
        if (0 > t)
            for (i = 0; i < this._updatesNegList.length; i++)
                (e = this._updatesNegList[i]) && e.priority >= t && (e.paused = !0,
                r.push(e.target));
        if (0 >= t)
            for (i = 0; i < this._updates0List.length; i++)
                (e = this._updates0List[i]) && (e.paused = !0,
                r.push(e.target));
        for (i = 0; i < this._updatesPosList.length; i++)
            (e = this._updatesPosList[i]) && e.priority >= t && (e.paused = !0,
            r.push(e.target));
        return r
    },
    resumeTargets: function(t) {
        if (t)
            for (var e = 0; e < t.length; e++)
                this.resumeTarget(t[e])
    },
    pauseTarget: function(t) {
        cc.assert(t, cc._LogInfos.Scheduler_pauseTarget);
        var e = this._hashForTimers[t.__instanceId];
        e && (e.paused = !0),
        (t = this._hashForUpdates[t.__instanceId]) && (t.entry.paused = !0)
    },
    resumeTarget: function(t) {
        cc.assert(t, cc._LogInfos.Scheduler_resumeTarget);
        var e = this._hashForTimers[t.__instanceId];
        e && (e.paused = !1),
        (t = this._hashForUpdates[t.__instanceId]) && (t.entry.paused = !1)
    },
    isTargetPaused: function(t) {
        cc.assert(t, cc._LogInfos.Scheduler_isTargetPaused);
        var e = this._hashForTimers[t.__instanceId];
        return e ? e.paused : !!(t = this._hashForUpdates[t.__instanceId]) && t.entry.paused
    },
    scheduleUpdateForTarget: function(t, e, i) {
        this.scheduleUpdate(t, e, i)
    },
    unscheduleCallbackForTarget: function(t, e) {
        this.unschedule(e, t)
    },
    unscheduleUpdateForTarget: function(t) {
        this.unscheduleUpdate(t)
    },
    unscheduleAllCallbacksForTarget: function(t) {
        this.unschedule(t.__instanceId + "", t)
    },
    unscheduleAllCallbacks: function() {
        this.unscheduleAllWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM)
    },
    unscheduleAllCallbacksWithMinPriority: function(t) {
        this.unscheduleAllWithMinPriority(t)
    }
}),
cc.Scheduler.PRIORITY_SYSTEM = -2147483648,
cc.PI2 = 2 * Math.PI,
cc.DrawingPrimitiveCanvas = cc.Class.extend({
    _cacheArray: [],
    _renderContext: null,
    ctor: function(t) {
        this._renderContext = t
    },
    drawPoint: function(t, e) {
        e || (e = 1);
        var i = cc.view.getScaleX()
          , n = cc.view.getScaleY()
          , n = cc.p(t.x * i, t.y * n)
          , r = this._renderContext.getContext();
        r.beginPath(),
        r.arc(n.x, -n.y, e * i, 0, 2 * Math.PI, !1),
        r.closePath(),
        r.fill()
    },
    drawPoints: function(t, e, i) {
        if (null != t) {
            i || (i = 1),
            e = this._renderContext.getContext();
            var n = cc.view.getScaleX()
              , r = cc.view.getScaleY();
            e.beginPath();
            for (var c = 0, s = t.length; c < s; c++)
                e.arc(t[c].x * n, -t[c].y * r, i * n, 0, 2 * Math.PI, !1);
            e.closePath(),
            e.fill()
        }
    },
    drawLine: function(t, e) {
        var i = this._renderContext.getContext()
          , n = cc.view.getScaleX()
          , r = cc.view.getScaleY();
        i.beginPath(),
        i.moveTo(t.x * n, -t.y * r),
        i.lineTo(e.x * n, -e.y * r),
        i.closePath(),
        i.stroke()
    },
    drawRect: function(t, e) {
        this.drawLine(cc.p(t.x, t.y), cc.p(e.x, t.y)),
        this.drawLine(cc.p(e.x, t.y), cc.p(e.x, e.y)),
        this.drawLine(cc.p(e.x, e.y), cc.p(t.x, e.y)),
        this.drawLine(cc.p(t.x, e.y), cc.p(t.x, t.y))
    },
    drawSolidRect: function(t, e, i) {
        t = [t, cc.p(e.x, t.y), e, cc.p(t.x, e.y)],
        this.drawSolidPoly(t, 4, i)
    },
    drawPoly: function(t, e, i, n) {
        if (n = n || !1,
        null != t) {
            if (3 > t.length)
                throw Error("Polygon's point must greater than 2");
            var r = t[0];
            e = this._renderContext.getContext();
            var c = cc.view.getScaleX()
              , s = cc.view.getScaleY();
            e.beginPath(),
            e.moveTo(r.x * c, -r.y * s);
            for (var r = 1, o = t.length; r < o; r++)
                e.lineTo(t[r].x * c, -t[r].y * s);
            i && e.closePath(),
            n ? e.fill() : e.stroke()
        }
    },
    drawSolidPoly: function(t, e, i) {
        this.setDrawColor(i.r, i.g, i.b, i.a),
        this.drawPoly(t, e, !0, !0)
    },
    drawCircle: function(t, e, i, n, r) {
        r = r || !1,
        n = this._renderContext.getContext();
        var c = cc.view.getScaleX()
          , s = cc.view.getScaleY();
        n.beginPath(),
        n.arc(0 | t.x * c, 0 | -(t.y * s), e * c, -i, -(i - 2 * Math.PI), !1),
        r && n.lineTo(0 | t.x * c, 0 | -(t.y * s)),
        n.stroke()
    },
    drawQuadBezier: function(t, e, i, n) {
        for (var r = this._cacheArray, c = r.length = 0, s = 0; s < n; s++) {
            var o = Math.pow(1 - c, 2) * t.x + 2 * (1 - c) * c * e.x + c * c * i.x
              , a = Math.pow(1 - c, 2) * t.y + 2 * (1 - c) * c * e.y + c * c * i.y;
            r.push(cc.p(o, a)),
            c += 1 / n
        }
        r.push(cc.p(i.x, i.y)),
        this.drawPoly(r, n + 1, !1, !1)
    },
    drawCubicBezier: function(t, e, i, n, r) {
        for (var c = this._cacheArray, s = c.length = 0, o = 0; o < r; o++) {
            var a = Math.pow(1 - s, 3) * t.x + 3 * Math.pow(1 - s, 2) * s * e.x + 3 * (1 - s) * s * s * i.x + s * s * s * n.x
              , h = Math.pow(1 - s, 3) * t.y + 3 * Math.pow(1 - s, 2) * s * e.y + 3 * (1 - s) * s * s * i.y + s * s * s * n.y;
            c.push(cc.p(a, h)),
            s += 1 / r
        }
        c.push(cc.p(n.x, n.y)),
        this.drawPoly(c, r + 1, !1, !1)
    },
    drawCatmullRom: function(t, e) {
        this.drawCardinalSpline(t, .5, e)
    },
    drawCardinalSpline: function(t, e, i) {
        cc._renderContext.setStrokeStyle("rgba(255,255,255,1)");
        var n = this._cacheArray;
        n.length = 0;
        for (var r, c, s = 1 / t.length, o = 0; o < i + 1; o++)
            c = o / i,
            1 === c ? (r = t.length - 1,
            c = 1) : (r = 0 | c / s,
            c = (c - s * r) / s),
            r = cc.CardinalSplineAt(cc.getControlPointAt(t, r - 1), cc.getControlPointAt(t, r - 0), cc.getControlPointAt(t, r + 1), cc.getControlPointAt(t, r + 2), e, c),
            n.push(r);
        this.drawPoly(n, i + 1, !1, !1)
    },
    drawImage: function(t, e, i, n, r) {
        var c = arguments.length
          , s = this._renderContext.getContext();
        switch (c) {
        case 2:
            s.drawImage(t, e.x, -(e.y + t.height));
            break;
        case 3:
            s.drawImage(t, e.x, -(e.y + i.height), i.width, i.height);
            break;
        case 5:
            s.drawImage(t, e.x, e.y, i.width, i.height, n.x, -(n.y + r.height), r.width, r.height);
            break;
        default:
            throw Error("Argument must be non-nil")
        }
    },
    drawStar: function(t, e, i) {
        t = t || this._renderContext;
        var n = t.getContext();
        e *= cc.view.getScaleX(),
        i = "rgba(" + (0 | i.r) + "," + (0 | i.g) + "," + (0 | i.b),
        t.setFillStyle(i + ",1)");
        var r = e / 10;
        n.beginPath(),
        n.moveTo(-e, e),
        n.lineTo(0, r),
        n.lineTo(e, e),
        n.lineTo(r, 0),
        n.lineTo(e, -e),
        n.lineTo(0, -r),
        n.lineTo(-e, -e),
        n.lineTo(-r, 0),
        n.lineTo(-e, e),
        n.closePath(),
        n.fill();
        var c = n.createRadialGradient(0, 0, r, 0, 0, e);
        c.addColorStop(0, i + ", 1)"),
        c.addColorStop(.3, i + ", 0.8)"),
        c.addColorStop(1, i + ", 0.0)"),
        t.setFillStyle(c),
        n.beginPath(),
        n.arc(0, 0, e - r, 0, cc.PI2, !1),
        n.closePath(),
        n.fill()
    },
    drawColorBall: function(t, e, i) {
        t = t || this._renderContext;
        var n = t.getContext();
        e *= cc.view.getScaleX(),
        i = "rgba(" + (0 | i.r) + "," + (0 | i.g) + "," + (0 | i.b);
        var r = n.createRadialGradient(0, 0, e / 10, 0, 0, e);
        r.addColorStop(0, i + ", 1)"),
        r.addColorStop(.3, i + ", 0.8)"),
        r.addColorStop(.6, i + ", 0.4)"),
        r.addColorStop(1, i + ", 0.0)"),
        t.setFillStyle(r),
        n.beginPath(),
        n.arc(0, 0, e, 0, cc.PI2, !1),
        n.closePath(),
        n.fill()
    },
    fillText: function(t, e, i) {
        this._renderContext.getContext().fillText(t, e, -i)
    },
    setDrawColor: function(t, e, i, n) {
        this._renderContext.setFillStyle("rgba(" + t + "," + e + "," + i + "," + n / 255 + ")"),
        this._renderContext.setStrokeStyle("rgba(" + t + "," + e + "," + i + "," + n / 255 + ")")
    },
    setPointSize: function(t) {},
    setLineWidth: function(t) {
        this._renderContext.getContext().lineWidth = t * cc.view.getScaleX()
    }
}),
cc.DrawingPrimitiveWebGL = cc.Class.extend({
    _renderContext: null,
    _initialized: !1,
    _shader: null,
    _colorLocation: -1,
    _colorArray: null,
    _pointSizeLocation: -1,
    _pointSize: -1,
    ctor: function(t) {
        if (null == t && (t = cc._renderContext),
        !t instanceof WebGLRenderingContext)
            throw Error("Can't initialise DrawingPrimitiveWebGL. context need is WebGLRenderingContext");
        this._renderContext = t,
        this._colorArray = new Float32Array([1, 1, 1, 1])
    },
    lazy_init: function() {
        this._initialized || (this._shader = cc.shaderCache.programForKey(cc.SHADER_POSITION_UCOLOR),
        this._colorLocation = this._renderContext.getUniformLocation(this._shader.getProgram(), "u_color"),
        this._pointSizeLocation = this._renderContext.getUniformLocation(this._shader.getProgram(), "u_pointSize"),
        this._initialized = !0)
    },
    drawInit: function() {
        this._initialized = !1
    },
    drawPoint: function(t) {
        this.lazy_init();
        var e = this._renderContext;
        this._shader.use(),
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4(),
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION),
        e.uniform4fv(this._colorLocation, this._colorArray),
        this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
        var i = e.createBuffer();
        e.bindBuffer(e.ARRAY_BUFFER, i),
        e.bufferData(e.ARRAY_BUFFER, new Float32Array([t.x, t.y]), e.STATIC_DRAW),
        e.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, e.FLOAT, !1, 0, 0),
        e.drawArrays(e.POINTS, 0, 1),
        e.deleteBuffer(i),
        cc.incrementGLDraws(1)
    },
    drawPoints: function(t, e) {
        if (t && 0 !== t.length) {
            this.lazy_init();
            var i = this._renderContext;
            this._shader.use(),
            this._shader.setUniformForModelViewAndProjectionMatrixWithMat4(),
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION),
            i.uniform4fv(this._colorLocation, this._colorArray),
            this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
            var n = i.createBuffer();
            i.bindBuffer(i.ARRAY_BUFFER, n),
            i.bufferData(i.ARRAY_BUFFER, this._pointsToTypeArray(t), i.STATIC_DRAW),
            i.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, i.FLOAT, !1, 0, 0),
            i.drawArrays(i.POINTS, 0, t.length),
            i.deleteBuffer(n),
            cc.incrementGLDraws(1)
        }
    },
    _pointsToTypeArray: function(t) {
        for (var e = new Float32Array(2 * t.length), i = 0; i < t.length; i++)
            e[2 * i] = t[i].x,
            e[2 * i + 1] = t[i].y;
        return e
    },
    drawLine: function(t, e) {
        this.lazy_init();
        var i = this._renderContext;
        this._shader.use(),
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4(),
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION),
        i.uniform4fv(this._colorLocation, this._colorArray);
        var n = i.createBuffer();
        i.bindBuffer(i.ARRAY_BUFFER, n),
        i.bufferData(i.ARRAY_BUFFER, this._pointsToTypeArray([t, e]), i.STATIC_DRAW),
        i.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, i.FLOAT, !1, 0, 0),
        i.drawArrays(i.LINES, 0, 2),
        i.deleteBuffer(n),
        cc.incrementGLDraws(1)
    },
    drawRect: function(t, e) {
        this.drawLine(cc.p(t.x, t.y), cc.p(e.x, t.y)),
        this.drawLine(cc.p(e.x, t.y), cc.p(e.x, e.y)),
        this.drawLine(cc.p(e.x, e.y), cc.p(t.x, e.y)),
        this.drawLine(cc.p(t.x, e.y), cc.p(t.x, t.y))
    },
    drawSolidRect: function(t, e, i) {
        t = [t, cc.p(e.x, t.y), e, cc.p(t.x, e.y)],
        this.drawSolidPoly(t, 4, i)
    },
    drawPoly: function(t, e, i) {
        this.lazy_init(),
        e = this._renderContext,
        this._shader.use(),
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4(),
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION),
        e.uniform4fv(this._colorLocation, this._colorArray);
        var n = e.createBuffer();
        e.bindBuffer(e.ARRAY_BUFFER, n),
        e.bufferData(e.ARRAY_BUFFER, this._pointsToTypeArray(t), e.STATIC_DRAW),
        e.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, e.FLOAT, !1, 0, 0),
        i ? e.drawArrays(e.LINE_LOOP, 0, t.length) : e.drawArrays(e.LINE_STRIP, 0, t.length),
        e.deleteBuffer(n),
        cc.incrementGLDraws(1)
    },
    drawSolidPoly: function(t, e, i) {
        this.lazy_init(),
        i && this.setDrawColor(i.r, i.g, i.b, i.a),
        e = this._renderContext,
        this._shader.use(),
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4(),
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION),
        e.uniform4fv(this._colorLocation, this._colorArray),
        i = e.createBuffer(),
        e.bindBuffer(e.ARRAY_BUFFER, i),
        e.bufferData(e.ARRAY_BUFFER, this._pointsToTypeArray(t), e.STATIC_DRAW),
        e.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, e.FLOAT, !1, 0, 0),
        e.drawArrays(e.TRIANGLE_FAN, 0, t.length),
        e.deleteBuffer(i),
        cc.incrementGLDraws(1)
    },
    drawCircle: function(t, e, i, n, r) {
        this.lazy_init();
        var c = 1;
        r && c++;
        var s = 2 * Math.PI / n;
        if (r = new Float32Array(2 * (n + 2))) {
            for (var o = 0; o <= n; o++) {
                var a = o * s
                  , h = e * Math.cos(a + i) + t.x
                  , a = e * Math.sin(a + i) + t.y;
                r[2 * o] = h,
                r[2 * o + 1] = a
            }
            r[2 * (n + 1)] = t.x,
            r[2 * (n + 1) + 1] = t.y,
            t = this._renderContext,
            this._shader.use(),
            this._shader.setUniformForModelViewAndProjectionMatrixWithMat4(),
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION),
            t.uniform4fv(this._colorLocation, this._colorArray),
            e = t.createBuffer(),
            t.bindBuffer(t.ARRAY_BUFFER, e),
            t.bufferData(t.ARRAY_BUFFER, r, t.STATIC_DRAW),
            t.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, t.FLOAT, !1, 0, 0),
            t.drawArrays(t.LINE_STRIP, 0, n + c),
            t.deleteBuffer(e),
            cc.incrementGLDraws(1)
        }
    },
    drawQuadBezier: function(t, e, i, n) {
        this.lazy_init();
        for (var r = new Float32Array(2 * (n + 1)), c = 0, s = 0; s < n; s++)
            r[2 * s] = Math.pow(1 - c, 2) * t.x + 2 * (1 - c) * c * e.x + c * c * i.x,
            r[2 * s + 1] = Math.pow(1 - c, 2) * t.y + 2 * (1 - c) * c * e.y + c * c * i.y,
            c += 1 / n;
        r[2 * n] = i.x,
        r[2 * n + 1] = i.y,
        t = this._renderContext,
        this._shader.use(),
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4(),
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION),
        t.uniform4fv(this._colorLocation, this._colorArray),
        e = t.createBuffer(),
        t.bindBuffer(t.ARRAY_BUFFER, e),
        t.bufferData(t.ARRAY_BUFFER, r, t.STATIC_DRAW),
        t.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, t.FLOAT, !1, 0, 0),
        t.drawArrays(t.LINE_STRIP, 0, n + 1),
        t.deleteBuffer(e),
        cc.incrementGLDraws(1)
    },
    drawCubicBezier: function(t, e, i, n, r) {
        this.lazy_init();
        for (var c = new Float32Array(2 * (r + 1)), s = 0, o = 0; o < r; o++)
            c[2 * o] = Math.pow(1 - s, 3) * t.x + 3 * Math.pow(1 - s, 2) * s * e.x + 3 * (1 - s) * s * s * i.x + s * s * s * n.x,
            c[2 * o + 1] = Math.pow(1 - s, 3) * t.y + 3 * Math.pow(1 - s, 2) * s * e.y + 3 * (1 - s) * s * s * i.y + s * s * s * n.y,
            s += 1 / r;
        c[2 * r] = n.x,
        c[2 * r + 1] = n.y,
        t = this._renderContext,
        this._shader.use(),
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4(),
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION),
        t.uniform4fv(this._colorLocation, this._colorArray),
        e = t.createBuffer(),
        t.bindBuffer(t.ARRAY_BUFFER, e),
        t.bufferData(t.ARRAY_BUFFER, c, t.STATIC_DRAW),
        t.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, t.FLOAT, !1, 0, 0),
        t.drawArrays(t.LINE_STRIP, 0, r + 1),
        t.deleteBuffer(e),
        cc.incrementGLDraws(1)
    },
    drawCatmullRom: function(t, e) {
        this.drawCardinalSpline(t, .5, e)
    },
    drawCardinalSpline: function(t, e, i) {
        this.lazy_init();
        for (var n, r, c = new Float32Array(2 * (i + 1)), s = 1 / t.length, o = 0; o < i + 1; o++)
            r = o / i,
            1 === r ? (n = t.length - 1,
            r = 1) : (n = 0 | r / s,
            r = (r - s * n) / s),
            n = cc.cardinalSplineAt(cc.getControlPointAt(t, n - 1), cc.getControlPointAt(t, n), cc.getControlPointAt(t, n + 1), cc.getControlPointAt(t, n + 2), e, r),
            c[2 * o] = n.x,
            c[2 * o + 1] = n.y;
        t = this._renderContext,
        this._shader.use(),
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4(),
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION),
        t.uniform4fv(this._colorLocation, this._colorArray),
        e = t.createBuffer(),
        t.bindBuffer(t.ARRAY_BUFFER, e),
        t.bufferData(t.ARRAY_BUFFER, c, t.STATIC_DRAW),
        t.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, t.FLOAT, !1, 0, 0),
        t.drawArrays(t.LINE_STRIP, 0, i + 1),
        t.deleteBuffer(e),
        cc.incrementGLDraws(1)
    },
    setDrawColor: function(t, e, i, n) {
        this._colorArray[0] = t / 255,
        this._colorArray[1] = e / 255,
        this._colorArray[2] = i / 255,
        this._colorArray[3] = n / 255
    },
    setPointSize: function(t) {
        this._pointSize = t * cc.contentScaleFactor()
    },
    setLineWidth: function(t) {
        this._renderContext.lineWidth && this._renderContext.lineWidth(t)
    }
}),
cc._tmp.PrototypeLabelTTF = function() {
    var t = cc.LabelTTF.prototype;
    cc.defineGetterSetter(t, "color", t.getColor, t.setColor),
    cc.defineGetterSetter(t, "opacity", t.getOpacity, t.setOpacity),
    cc.defineGetterSetter(t, "string", t.getString, t.setString),
    cc.defineGetterSetter(t, "textAlign", t.getHorizontalAlignment, t.setHorizontalAlignment),
    cc.defineGetterSetter(t, "verticalAlign", t.getVerticalAlignment, t.setVerticalAlignment),
    cc.defineGetterSetter(t, "fontSize", t.getFontSize, t.setFontSize),
    cc.defineGetterSetter(t, "fontName", t.getFontName, t.setFontName),
    cc.defineGetterSetter(t, "font", t._getFont, t._setFont),
    cc.defineGetterSetter(t, "boundingWidth", t._getBoundingWidth, t._setBoundingWidth),
    cc.defineGetterSetter(t, "boundingHeight", t._getBoundingHeight, t._setBoundingHeight),
    cc.defineGetterSetter(t, "fillStyle", t._getFillStyle, t.setFontFillColor),
    cc.defineGetterSetter(t, "strokeStyle", t._getStrokeStyle, t._setStrokeStyle),
    cc.defineGetterSetter(t, "lineWidth", t._getLineWidth, t._setLineWidth),
    cc.defineGetterSetter(t, "shadowOffsetX", t._getShadowOffsetX, t._setShadowOffsetX),
    cc.defineGetterSetter(t, "shadowOffsetY", t._getShadowOffsetY, t._setShadowOffsetY),
    cc.defineGetterSetter(t, "shadowOpacity", t._getShadowOpacity, t._setShadowOpacity),
    cc.defineGetterSetter(t, "shadowBlur", t._getShadowBlur, t._setShadowBlur)
}
,
cc.LabelTTF = cc.Sprite.extend({
    _dimensions: null,
    _hAlignment: cc.TEXT_ALIGNMENT_CENTER,
    _vAlignment: cc.VERTICAL_TEXT_ALIGNMENT_TOP,
    _fontName: null,
    _fontSize: 0,
    _string: "",
    _originalText: null,
    _onCacheCanvasMode: !0,
    _shadowEnabled: !1,
    _shadowOffset: null,
    _shadowOpacity: 0,
    _shadowBlur: 0,
    _shadowColor: null,
    _strokeEnabled: !1,
    _strokeColor: null,
    _strokeSize: 0,
    _textFillColor: null,
    _strokeShadowOffsetX: 0,
    _strokeShadowOffsetY: 0,
    _needUpdateTexture: !1,
    _lineWidths: null,
    _className: "LabelTTF",
    _fontStyle: "normal",
    _fontWeight: "normal",
    _lineHeight: "normal",
    initWithString: function(t, e, i, n, r, c) {
        return t = t ? t + "" : "",
        i = i || 16,
        n = n || cc.size(0, 0),
        r = r || cc.TEXT_ALIGNMENT_LEFT,
        c = c || cc.VERTICAL_TEXT_ALIGNMENT_TOP,
        this._opacityModifyRGB = !1,
        this._dimensions = cc.size(n.width, n.height),
        this._fontName = e || "Arial",
        this._hAlignment = r,
        this._vAlignment = c,
        this._fontSize = i,
        this._renderCmd._setFontStyle(this._fontName, i, this._fontStyle, this._fontWeight),
        this.string = t,
        this._renderCmd._setColorsString(),
        this._renderCmd._updateTexture(),
        this._setUpdateTextureDirty(),
        !0
    },
    _setUpdateTextureDirty: function() {
        this._needUpdateTexture = !0,
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.textDirty)
    },
    ctor: function(t, e, i, n, r, c) {
        cc.Sprite.prototype.ctor.call(this),
        this._dimensions = cc.size(0, 0),
        this._hAlignment = cc.TEXT_ALIGNMENT_LEFT,
        this._vAlignment = cc.VERTICAL_TEXT_ALIGNMENT_TOP,
        this._opacityModifyRGB = !1,
        this._fontName = "Arial",
        this._shadowEnabled = !1,
        this._shadowOffset = cc.p(0, 0),
        this._shadowBlur = this._shadowOpacity = 0,
        this._strokeEnabled = !1,
        this._strokeColor = cc.color(255, 255, 255, 255),
        this._strokeSize = 0,
        this._textFillColor = cc.color(255, 255, 255, 255),
        this._strokeShadowOffsetY = this._strokeShadowOffsetX = 0,
        this._needUpdateTexture = !1,
        this._lineWidths = [],
        this._renderCmd._setColorsString(),
        this._textureLoaded = !0,
        e && e instanceof cc.FontDefinition ? this.initWithStringAndTextDefinition(t, e) : cc.LabelTTF.prototype.initWithString.call(this, t, e, i, n, r, c)
    },
    init: function() {
        return this.initWithString(" ", this._fontName, this._fontSize)
    },
    description: function() {
        return "<cc.LabelTTF | FontName =" + this._fontName + " FontSize = " + this._fontSize.toFixed(1) + ">"
    },
    getLineHeight: function() {
        return !this._lineHeight || this._lineHeight.charAt ? this._renderCmd._getFontClientHeight() : this._lineHeight || this._renderCmd._getFontClientHeight()
    },
    setLineHeight: function(t) {
        this._lineHeight = t
    },
    getString: function() {
        return this._string
    },
    getHorizontalAlignment: function() {
        return this._hAlignment
    },
    getVerticalAlignment: function() {
        return this._vAlignment
    },
    getDimensions: function() {
        return cc.size(this._dimensions)
    },
    getFontSize: function() {
        return this._fontSize
    },
    getFontName: function() {
        return this._fontName
    },
    initWithStringAndTextDefinition: function(t, e) {
        return this._updateWithTextDefinition(e, !1),
        this.string = t,
        !0
    },
    setTextDefinition: function(t) {
        t && this._updateWithTextDefinition(t, !0)
    },
    getTextDefinition: function() {
        return this._prepareTextDefinition(!1)
    },
    enableShadow: function(t, e, i, n) {
        null != t.r && null != t.g && null != t.b && null != t.a ? this._enableShadow(t, e, i) : this._enableShadowNoneColor(t, e, i, n)
    },
    _enableShadowNoneColor: function(t, e, i, n) {
        i = i || .5,
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        var r = this._shadowOffset;
        (r && r.x !== t || r._y !== e) && (r.x = t,
        r.y = e),
        this._shadowOpacity !== i && (this._shadowOpacity = i),
        this._renderCmd._setColorsString(),
        this._shadowBlur !== n && (this._shadowBlur = n),
        this._setUpdateTextureDirty()
    },
    _enableShadow: function(t, e, i) {
        this._shadowColor || (this._shadowColor = cc.color(255, 255, 255, 128)),
        this._shadowColor.r = t.r,
        this._shadowColor.g = t.g,
        this._shadowColor.b = t.b,
        this._enableShadowNoneColor(e.width || e.x || 0, e.height || e.y || 0, null != t.a ? t.a / 255 : .5, i)
    },
    _getShadowOffsetX: function() {
        return this._shadowOffset.x
    },
    _setShadowOffsetX: function(t) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0),
        this._shadowOffset.x !== t && (this._shadowOffset.x = t,
        this._setUpdateTextureDirty())
    },
    _getShadowOffsetY: function() {
        return this._shadowOffset._y
    },
    _setShadowOffsetY: function(t) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0),
        this._shadowOffset._y !== t && (this._shadowOffset._y = t,
        this._setUpdateTextureDirty())
    },
    _getShadowOffset: function() {
        return cc.p(this._shadowOffset.x, this._shadowOffset.y)
    },
    _setShadowOffset: function(t) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0),
        this._shadowOffset.x === t.x && this._shadowOffset.y === t.y || (this._shadowOffset.x = t.x,
        this._shadowOffset.y = t.y,
        this._setUpdateTextureDirty())
    },
    _getShadowOpacity: function() {
        return this._shadowOpacity
    },
    _setShadowOpacity: function(t) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0),
        this._shadowOpacity !== t && (this._shadowOpacity = t,
        this._renderCmd._setColorsString(),
        this._setUpdateTextureDirty())
    },
    _getShadowBlur: function() {
        return this._shadowBlur
    },
    _setShadowBlur: function(t) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0),
        this._shadowBlur !== t && (this._shadowBlur = t,
        this._setUpdateTextureDirty())
    },
    disableShadow: function() {
        this._shadowEnabled && (this._shadowEnabled = !1,
        this._setUpdateTextureDirty())
    },
    enableStroke: function(t, e) {
        !1 === this._strokeEnabled && (this._strokeEnabled = !0);
        var i = this._strokeColor;
        i.r === t.r && i.g === t.g && i.b === t.b || (i.r = t.r,
        i.g = t.g,
        i.b = t.b,
        this._renderCmd._setColorsString()),
        this._strokeSize !== e && (this._strokeSize = e || 0),
        this._setUpdateTextureDirty()
    },
    _getStrokeStyle: function() {
        return this._strokeColor
    },
    _setStrokeStyle: function(t) {
        !1 === this._strokeEnabled && (this._strokeEnabled = !0);
        var e = this._strokeColor;
        e.r === t.r && e.g === t.g && e.b === t.b || (e.r = t.r,
        e.g = t.g,
        e.b = t.b,
        this._renderCmd._setColorsString(),
        this._setUpdateTextureDirty())
    },
    _getLineWidth: function() {
        return this._strokeSize
    },
    _setLineWidth: function(t) {
        !1 === this._strokeEnabled && (this._strokeEnabled = !0),
        this._strokeSize !== t && (this._strokeSize = t || 0,
        this._setUpdateTextureDirty())
    },
    disableStroke: function() {
        this._strokeEnabled && (this._strokeEnabled = !1,
        this._setUpdateTextureDirty())
    },
    setFontFillColor: function(t) {
        var e = this._textFillColor;
        e.r === t.r && e.g === t.g && e.b === t.b || (e.r = t.r,
        e.g = t.g,
        e.b = t.b,
        this._renderCmd._setColorsString(),
        this._needUpdateTexture = !0)
    },
    _getFillStyle: function() {
        return this._textFillColor
    },
    _updateWithTextDefinition: function(t, e) {
        t.fontDimensions ? (this._dimensions.width = t.boundingWidth,
        this._dimensions.height = t.boundingHeight) : (this._dimensions.width = 0,
        this._dimensions.height = 0),
        this._hAlignment = t.textAlign,
        this._vAlignment = t.verticalAlign,
        this._fontName = t.fontName,
        this._fontSize = t.fontSize || 12,
        this._lineHeight = t.lineHeight ? t.lineHeight : this._fontSize,
        this._renderCmd._setFontStyle(t),
        t.shadowEnabled && this.enableShadow(t.shadowOffsetX, t.shadowOffsetY, t.shadowOpacity, t.shadowBlur),
        t.strokeEnabled && this.enableStroke(t.strokeStyle, t.lineWidth),
        this.setFontFillColor(t.fillStyle),
        e && this._renderCmd._updateTexture();
        var i = cc.Node._dirtyFlags;
        this._renderCmd.setDirtyFlag(i.colorDirty | i.opacityDirty | i.textDirty)
    },
    _prepareTextDefinition: function(t) {
        var e = new cc.FontDefinition;
        if (t ? (e.fontSize = this._fontSize,
        e.boundingWidth = cc.contentScaleFactor() * this._dimensions.width,
        e.boundingHeight = cc.contentScaleFactor() * this._dimensions.height) : (e.fontSize = this._fontSize,
        e.boundingWidth = this._dimensions.width,
        e.boundingHeight = this._dimensions.height),
        e.fontName = this._fontName,
        e.textAlign = this._hAlignment,
        e.verticalAlign = this._vAlignment,
        this._strokeEnabled) {
            e.strokeEnabled = !0;
            var i = this._strokeColor;
            e.strokeStyle = cc.color(i.r, i.g, i.b),
            e.lineWidth = this._strokeSize
        } else
            e.strokeEnabled = !1;
        return this._shadowEnabled ? (e.shadowEnabled = !0,
        e.shadowBlur = this._shadowBlur,
        e.shadowOpacity = this._shadowOpacity,
        e.shadowOffsetX = (t ? cc.contentScaleFactor() : 1) * this._shadowOffset.x,
        e.shadowOffsetY = (t ? cc.contentScaleFactor() : 1) * this._shadowOffset.y) : e._shadowEnabled = !1,
        t = this._textFillColor,
        e.fillStyle = cc.color(t.r, t.g, t.b),
        e
    },
    setString: function(t) {
        t = String(t),
        this._originalText !== t && (this._originalText = t + "",
        this._updateString(),
        this._setUpdateTextureDirty(),
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty))
    },
    _updateString: function() {
        this._string && "" !== this._string || this._string === this._originalText || (cc.renderer.childrenOrderDirty = !0),
        this._string = this._originalText
    },
    setHorizontalAlignment: function(t) {
        t !== this._hAlignment && (this._hAlignment = t,
        this._setUpdateTextureDirty())
    },
    setVerticalAlignment: function(t) {
        t !== this._vAlignment && (this._vAlignment = t,
        this._setUpdateTextureDirty())
    },
    setDimensions: function(t, e) {
        var i;
        void 0 === e ? (i = t.width,
        e = t.height) : i = t,
        i === this._dimensions.width && e === this._dimensions.height || (this._dimensions.width = i,
        this._dimensions.height = e,
        this._updateString(),
        this._setUpdateTextureDirty())
    },
    _getBoundingWidth: function() {
        return this._dimensions.width
    },
    _setBoundingWidth: function(t) {
        t !== this._dimensions.width && (this._dimensions.width = t,
        this._updateString(),
        this._setUpdateTextureDirty())
    },
    _getBoundingHeight: function() {
        return this._dimensions.height
    },
    _setBoundingHeight: function(t) {
        t !== this._dimensions.height && (this._dimensions.height = t,
        this._updateString(),
        this._setUpdateTextureDirty())
    },
    setFontSize: function(t) {
        this._fontSize !== t && (this._fontSize = t,
        this._renderCmd._setFontStyle(this._fontName, this._fontSize, this._fontStyle, this._fontWeight),
        this._setUpdateTextureDirty())
    },
    setFontName: function(t) {
        this._fontName && this._fontName !== t && (this._fontName = t,
        this._renderCmd._setFontStyle(this._fontName, this._fontSize, this._fontStyle, this._fontWeight),
        this._setUpdateTextureDirty())
    },
    _getFont: function() {
        return this._renderCmd._getFontStyle()
    },
    _setFont: function(t) {
        (t = cc.LabelTTF._fontStyleRE.exec(t)) && (this._fontSize = parseInt(t[1]),
        this._fontName = t[2],
        this._renderCmd._setFontStyle(this._fontName, this._fontSize, this._fontStyle, this._fontWeight),
        this._setUpdateTextureDirty())
    },
    getContentSize: function() {
        return this._needUpdateTexture && this._renderCmd._updateTTF(),
        cc.Sprite.prototype.getContentSize.call(this)
    },
    _getWidth: function() {
        return this._needUpdateTexture && this._renderCmd._updateTTF(),
        cc.Sprite.prototype._getWidth.call(this)
    },
    _getHeight: function() {
        return this._needUpdateTexture && this._renderCmd._updateTTF(),
        cc.Sprite.prototype._getHeight.call(this)
    },
    setTextureRect: function(t, e, i) {
        cc.Sprite.prototype.setTextureRect.call(this, t, e, i, !1)
    },
    setDrawMode: function(t) {
        this._onCacheCanvasMode = t
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_WEBGL ? new cc.LabelTTF.WebGLRenderCmd(this) : this._onCacheCanvasMode ? new cc.LabelTTF.CacheCanvasRenderCmd(this) : new cc.LabelTTF.CanvasRenderCmd(this)
    },
    _setFontStyle: function(t) {
        this._fontStyle !== t && (this._fontStyle = t,
        this._renderCmd._setFontStyle(this._fontName, this._fontSize, this._fontStyle, this._fontWeight),
        this._setUpdateTextureDirty())
    },
    _getFontStyle: function() {
        return this._fontStyle
    },
    _setFontWeight: function(t) {
        this._fontWeight !== t && (this._fontWeight = t,
        this._renderCmd._setFontStyle(this._fontName, this._fontSize, this._fontStyle, this._fontWeight),
        this._setUpdateTextureDirty())
    },
    _getFontWeight: function() {
        return this._fontWeight
    }
}),
cc.assert(cc.isFunction(cc._tmp.PrototypeLabelTTF), cc._LogInfos.MissingFile, "LabelTTFPropertyDefine.js"),
cc._tmp.PrototypeLabelTTF(),
delete cc._tmp.PrototypeLabelTTF,
cc.LabelTTF._fontStyleRE = /^(\d+)px\s+['"]?([\w\s\d]+)['"]?$/,
cc.LabelTTF.create = function(t, e, i, n, r, c) {
    return new cc.LabelTTF(t,e,i,n,r,c)
}
,
cc.LabelTTF.createWithFontDefinition = cc.LabelTTF.create,
cc.LabelTTF._SHADER_PROGRAM = cc.USE_LA88_LABELS ? cc.SHADER_POSITION_TEXTURECOLOR : cc.SHADER_POSITION_TEXTUREA8COLOR,
cc.LabelTTF.__labelHeightDiv = document.createElement("div"),
cc.LabelTTF.__labelHeightDiv.style.fontFamily = "Arial",
cc.LabelTTF.__labelHeightDiv.style.position = "absolute",
cc.LabelTTF.__labelHeightDiv.style.left = "-100px",
cc.LabelTTF.__labelHeightDiv.style.top = "-100px",
cc.LabelTTF.__labelHeightDiv.style.lineHeight = "normal",
document.body ? document.body.appendChild(cc.LabelTTF.__labelHeightDiv) : window.addEventListener("load", function() {
    this.removeEventListener("load", arguments.callee, !1),
    document.body.appendChild(cc.LabelTTF.__labelHeightDiv)
}, !1),
cc.LabelTTF.__getFontHeightByDiv = function(t, e) {
    if (t instanceof cc.FontDefinition) {
        var i = cc.LabelTTF.__fontHeightCache[t._getCanvasFontStr()];
        if (0 < i)
            return i;
        var n = cc.LabelTTF.__labelHeightDiv;
        return n.innerHTML = "ajghl~!",
        n.style.fontFamily = t.fontName,
        n.style.fontSize = t.fontSize + "px",
        n.style.fontStyle = t.fontStyle,
        n.style.fontWeight = t.fontWeight,
        i = n.clientHeight,
        cc.LabelTTF.__fontHeightCache[t._getCanvasFontStr()] = i,
        n.innerHTML = "",
        i
    }
    return i = cc.LabelTTF.__fontHeightCache[t + "." + e],
    0 < i ? i : (n = cc.LabelTTF.__labelHeightDiv,
    n.innerHTML = "ajghl~!",
    n.style.fontFamily = t,
    n.style.fontSize = e + "px",
    i = n.clientHeight,
    cc.LabelTTF.__fontHeightCache[t + "." + e] = i,
    n.innerHTML = "",
    i)
}
,
cc.LabelTTF.__fontHeightCache = {},
cc.LabelTTF._textAlign = ["left", "center", "right"],
cc.LabelTTF._textBaseline = ["top", "middle", "bottom"],
cc.LabelTTF.wrapInspection = !0,
cc.LabelTTF._wordRex = /([a-zA-Z0-9\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00e9\u00e8\u00e7\u00e0\u00f9\u00ea\u00e2\u00ee\u00f4\u00fb]+|\S)/,
cc.LabelTTF._symbolRex = /^[!,.:;}\]%\?>\u3001\u2018\u201c\u300b\uff1f\u3002\uff0c\uff01]/,
cc.LabelTTF._lastWordRex = /([a-zA-Z0-9\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00e9\u00e8\u00e7\u00e0\u00f9\u00ea\u00e2\u00ee\u00f4\u00fb]+|\S)$/,
cc.LabelTTF._lastEnglish = /[a-zA-Z0-9\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00e9\u00e8\u00e7\u00e0\u00f9\u00ea\u00e2\u00ee\u00f4\u00fb]+$/,
cc.LabelTTF._firsrEnglish = /^[a-zA-Z0-9\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00e9\u00e8\u00e7\u00e0\u00f9\u00ea\u00e2\u00ee\u00f4\u00fb]/,
function() {
    cc.LabelTTF.RenderCmd = function() {
        this._fontClientHeight = 18,
        this._fontStyleStr = "",
        this._shadowColorStr = "rgba(128, 128, 128, 0.5)",
        this._strokeColorStr = "",
        this._fillColorStr = "rgba(255,255,255,1)",
        this._labelContext = this._labelCanvas = null,
        this._lineWidths = [],
        this._strings = [],
        this._isMultiLine = !1,
        this._status = [],
        this._renderingIndex = 0
    }
    ;
    var t = cc.LabelTTF.RenderCmd.prototype;
    t.constructor = cc.LabelTTF.RenderCmd,
    t._setFontStyle = function(t, e, i, n) {
        t instanceof cc.FontDefinition ? (this._fontStyleStr = t._getCanvasFontStr(),
        this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(t)) : (this._fontStyleStr = i + " " + n + " " + e + "px '" + t + "'",
        this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(t, e))
    }
    ,
    t._getFontStyle = function() {
        return this._fontStyleStr
    }
    ,
    t._getFontClientHeight = function() {
        return this._fontClientHeight
    }
    ,
    t._updateColor = function() {
        this._setColorsString(),
        this._updateTexture()
    }
    ,
    t._setColorsString = function() {
        var t = this._displayedColor
          , e = this._node
          , i = e._shadowColor || this._displayedColor
          , n = e._strokeColor
          , r = e._textFillColor
          , c = t.r / 255
          , s = t.g / 255
          , t = t.b / 255;
        this._shadowColorStr = "rgba(" + (0 | c * i.r) + "," + (0 | s * i.g) + "," + (0 | t * i.b) + "," + e._shadowOpacity + ")",
        this._fillColorStr = "rgba(" + (0 | c * r.r) + "," + (0 | s * r.g) + "," + (0 | t * r.b) + ", 1)",
        this._strokeColorStr = "rgba(" + (0 | c * n.r) + "," + (0 | s * n.g) + "," + (0 | t * n.b) + ", 1)"
    }
    ,
    t._updateTTF = function() {
        var t, e, i = this._node, n = i._dimensions.width, r = this._lineWidths;
        if (r.length = 0,
        this._isMultiLine = !1,
        this._measureConfig(),
        0 !== n)
            for (this._strings = i._string.split("\n"),
            t = 0; t < this._strings.length; t++)
                this._checkWarp(this._strings, t, n);
        else
            for (this._strings = i._string.split("\n"),
            t = 0,
            e = this._strings.length; t < e; t++)
                r.push(this._measure(this._strings[t]));
        if (1 < this._strings.length && (this._isMultiLine = !0),
        e = t = 0,
        i._strokeEnabled && (t = e = 2 * i._strokeSize),
        i._shadowEnabled) {
            var c = i._shadowOffset;
            t += 2 * Math.abs(c.x),
            e += 2 * Math.abs(c.y)
        }
        n = 0 === n ? this._isMultiLine ? cc.size(Math.ceil(Math.max.apply(Math, r) + t), Math.ceil(this._fontClientHeight * this._strings.length + e)) : cc.size(Math.ceil(this._measure(i._string) + t), Math.ceil(this._fontClientHeight + e)) : 0 === i._dimensions.height ? this._isMultiLine ? cc.size(Math.ceil(n + t), Math.ceil(i.getLineHeight() * this._strings.length + e)) : cc.size(Math.ceil(n + t), Math.ceil(i.getLineHeight() + e)) : cc.size(Math.ceil(n + t), Math.ceil(i._dimensions.height + e)),
        "normal" !== i._getFontStyle() && (n.width = Math.ceil(n.width + .3 * i._fontSize)),
        i.setContentSize(n),
        i._strokeShadowOffsetX = t,
        i._strokeShadowOffsetY = e,
        i = i._anchorPoint,
        this._anchorPointInPoints.x = .5 * t + (n.width - t) * i.x,
        this._anchorPointInPoints.y = .5 * e + (n.height - e) * i.y
    }
    ,
    t._saveStatus = function() {
        var t = this._node
          , e = t._strokeShadowOffsetX
          , i = t._strokeShadowOffsetY
          , n = t._contentSize.height - i
          , r = t._vAlignment
          , c = t._hAlignment
          , s = .5 * e
          , i = n + .5 * i
          , o = 0
          , a = 0
          , h = []
          , l = t._contentSize.width - e
          , t = t.getLineHeight()
          , e = (t - this._fontClientHeight) / 2
          , o = c === cc.TEXT_ALIGNMENT_RIGHT ? o + l : c === cc.TEXT_ALIGNMENT_CENTER ? o + l / 2 : o + 0;
        if (this._isMultiLine)
            for (c = this._strings.length,
            r === cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM ? a = t - 2 * e + n - t * c : r === cc.VERTICAL_TEXT_ALIGNMENT_CENTER && (a = (t - 2 * e) / 2 + (n - t * c) / 2),
            r = 0; r < c; r++)
                h.push(-n + (t * r + e) + a);
        else
            r !== cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM && (a = r === cc.VERTICAL_TEXT_ALIGNMENT_TOP ? a - n : a - .5 * n),
            h.push(a);
        n = {
            contextTransform: cc.p(s, i),
            xOffset: o,
            OffsetYArray: h
        },
        this._status.push(n)
    }
    ,
    t._drawTTFInCanvas = function(t) {
        if (t) {
            var e = this._status.pop();
            t.setTransform(1, 0, 0, 1, e.contextTransform.x, e.contextTransform.y),
            this.drawLabels(t, e.xOffset, e.OffsetYArray)
        }
    }
    ,
    t._checkWarp = function(t, e, i) {
        var n = t[e]
          , r = this._measure(n);
        if (r > i && 1 < n.length) {
            for (var c, s = i / r * n.length | 0, o = n.substr(s), a = r - this._measure(o), h = 0, l = 0; a > i && 100 > l++; )
                s *= i / a,
                s |= 0,
                o = n.substr(s),
                a = r - this._measure(o);
            for (l = 0; a < i && 100 > l++; )
                o && (h = (c = cc.LabelTTF._wordRex.exec(o)) ? c[0].length : 1,
                c = o),
                s += h,
                o = n.substr(s),
                a = r - this._measure(o);
            s -= h,
            0 === s && (s = 1,
            c = c.substr(1)),
            i = n.substr(0, s),
            cc.LabelTTF.wrapInspection && cc.LabelTTF._symbolRex.test(c || o) && (r = cc.LabelTTF._lastWordRex.exec(i),
            s -= r ? r[0].length : 0,
            c = n.substr(s),
            i = n.substr(0, s)),
            cc.LabelTTF._firsrEnglish.test(c) && (r = cc.LabelTTF._lastEnglish.exec(i)) && i !== r[0] && (s -= r[0].length,
            c = n.substr(s),
            i = n.substr(0, s)),
            t[e] = c || o,
            t.splice(e, 0, i)
        }
    }
    ,
    t.updateStatus = function() {
        var t = cc.Node._dirtyFlags
          , e = this._dirtyFlag;
        cc.Node.RenderCmd.prototype.updateStatus.call(this),
        e & t.textDirty && this._updateTexture(),
        this._dirtyFlag & t.transformDirty && (this.transform(this.getParentRenderCmd(), !0),
        this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.transformDirty)
    }
    ,
    t._syncStatus = function(t) {
        var e = cc.Node._dirtyFlags
          , i = this._dirtyFlag;
        cc.Node.RenderCmd.prototype._syncStatus.call(this, t),
        i & e.textDirty && this._updateTexture(),
        (cc._renderType === cc.game.RENDER_TYPE_WEBGL || i & e.transformDirty) && this.transform(t)
    }
    ,
    t.drawLabels = function(t, e, i) {
        var n = this._node;
        if (n._shadowEnabled) {
            var r = n._shadowOffset;
            t.shadowColor = this._shadowColorStr,
            t.shadowOffsetX = r.x,
            t.shadowOffsetY = -r.y,
            t.shadowBlur = n._shadowBlur
        }
        var r = n._hAlignment
          , c = n._vAlignment
          , s = n._strokeSize;
        for (t.font !== this._fontStyleStr && (t.font = this._fontStyleStr),
        t.fillStyle = this._fillColorStr,
        (n = n._strokeEnabled) && (t.lineWidth = 2 * s,
        t.strokeStyle = this._strokeColorStr),
        t.textBaseline = cc.LabelTTF._textBaseline[c],
        t.textAlign = cc.LabelTTF._textAlign[r],
        r = this._strings.length,
        c = 0; c < r; c++)
            s = this._strings[c],
            n && t.strokeText(s, e, i[c]),
            t.fillText(s, e, i[c]);
        cc.g_NumberOfDraws++
    }
}(),
function() {
    cc.LabelTTF.CacheRenderCmd = function(t) {
        cc.LabelTTF.RenderCmd.call(this, t),
        t = this._labelCanvas = document.createElement("canvas"),
        t.width = 1,
        t.height = 1,
        this._labelContext = t.getContext("2d")
    }
    ,
    cc.LabelTTF.CacheRenderCmd.prototype = Object.create(cc.LabelTTF.RenderCmd.prototype),
    cc.inject(cc.LabelTTF.RenderCmd.prototype, cc.LabelTTF.CacheRenderCmd.prototype);
    var t = cc.LabelTTF.CacheRenderCmd.prototype;
    t.constructor = cc.LabelTTF.CacheRenderCmd,
    t._updateTexture = function() {
        this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.textDirty;
        var t = this._node
          , e = t._contentSize;
        this._updateTTF();
        var i = e.width
          , n = e.height
          , r = this._labelContext
          , c = this._labelCanvas;
        if (!t._texture) {
            var s = new cc.Texture2D;
            s.initWithElement(this._labelCanvas),
            t.setTexture(s)
        }
        return 0 === t._string.length ? (c.width = 1,
        c.height = e.height || 1,
        t._texture && t._texture.handleLoadedTexture(),
        t.setTextureRect(cc.rect(0, 0, 1, e.height)),
        !0) : (r.font = this._fontStyleStr,
        e = c.width === i && c.height === n,
        c.width = i,
        c.height = n,
        e && r.clearRect(0, 0, i, n),
        this._saveStatus(),
        this._drawTTFInCanvas(r),
        t._texture && t._texture.handleLoadedTexture(),
        t.setTextureRect(cc.rect(0, 0, i, n)),
        !0)
    }
    ,
    t._measureConfig = function() {
        this._labelContext.font = this._fontStyleStr
    }
    ,
    t._measure = function(t) {
        return this._labelContext.measureText(t).width
    }
}(),
function() {
    cc.LabelTTF.CacheCanvasRenderCmd = function(t) {
        cc.Sprite.CanvasRenderCmd.call(this, t),
        cc.LabelTTF.CacheRenderCmd.call(this)
    }
    ;
    var t = cc.LabelTTF.CacheCanvasRenderCmd.prototype = Object.create(cc.Sprite.CanvasRenderCmd.prototype);
    cc.inject(cc.LabelTTF.CacheRenderCmd.prototype, t),
    t.constructor = cc.LabelTTF.CacheCanvasRenderCmd
}(),
function() {
    cc.LabelTTF.CanvasRenderCmd = function(t) {
        cc.Sprite.CanvasRenderCmd.call(this, t),
        cc.LabelTTF.RenderCmd.call(this)
    }
    ,
    cc.LabelTTF.CanvasRenderCmd.prototype = Object.create(cc.Sprite.CanvasRenderCmd.prototype),
    cc.inject(cc.LabelTTF.RenderCmd.prototype, cc.LabelTTF.CanvasRenderCmd.prototype);
    var t = cc.LabelTTF.CanvasRenderCmd.prototype;
    t.constructor = cc.LabelTTF.CanvasRenderCmd,
    t._measureConfig = function() {}
    ,
    t._measure = function(t) {
        var e = cc._renderContext.getContext();
        return e.font = this._fontStyleStr,
        e.measureText(t).width
    }
    ,
    t._updateTexture = function() {
        this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.textDirty;
        var t = this._node
          , e = t._contentSize;
        this._updateTTF();
        var i = e.width
          , n = e.height;
        return 0 === t._string.length ? (t.setTextureRect(cc.rect(0, 0, 1, e.height)),
        !0) : (this._saveStatus(),
        t.setTextureRect(cc.rect(0, 0, i, n)),
        !0)
    }
    ,
    t.rendering = function(t) {
        var e = cc.view.getScaleX()
          , i = cc.view.getScaleY();
        t = t || cc._renderContext;
        var n = t.getContext();
        if (n) {
            var r = this._node;
            if (t.computeRealOffsetY(),
            !(0 >= this._status.length)) {
                var c = this._renderingIndex >= this._status.length ? this._renderingIndex - this._status.length : this._renderingIndex
                  , s = this._status[c];
                this._renderingIndex = c + 1;
                var o = r._offsetPosition.x
                  , c = -r._offsetPosition.y - r._rect.height
                  , a = this._displayedOpacity / 255;
                for (t.setTransform(this._worldTransform, e, i),
                t.setCompositeOperation(this._blendFuncStr),
                t.setGlobalAlpha(a),
                t.save(),
                r._flippedX && (o = -o - r._rect.width,
                n.scale(-1, 1)),
                r._flippedY && (c = r._offsetPosition.y,
                n.scale(1, -1)),
                e = s.xOffset + s.contextTransform.x + o * e,
                r = [],
                o = this._strings.length,
                a = 0; a < o; a++)
                    r.push(s.OffsetYArray[a] + s.contextTransform.y + c * i);
                this.drawLabels(n, e, r),
                t.restore()
            }
        }
    }
}(),
function() {
    cc.LabelTTF.WebGLRenderCmd = function(t) {
        cc.Sprite.WebGLRenderCmd.call(this, t),
        cc.LabelTTF.CacheRenderCmd.call(this),
        this.setShaderProgram(cc.shaderCache.programForKey(cc.LabelTTF._SHADER_PROGRAM))
    }
    ;
    var t = cc.LabelTTF.WebGLRenderCmd.prototype = Object.create(cc.Sprite.WebGLRenderCmd.prototype);
    cc.inject(cc.LabelTTF.CacheRenderCmd.prototype, t),
    t.constructor = cc.LabelTTF.WebGLRenderCmd,
    t._updateColor = function() {
        this._updateTexture(),
        cc.Sprite.WebGLRenderCmd.prototype._updateColor.call(this)
    }
}(),
cc.HashElement = cc.Class.extend({
    actions: null,
    target: null,
    actionIndex: 0,
    currentAction: null,
    currentActionSalvaged: !1,
    paused: !1,
    hh: null,
    ctor: function() {
        this.actions = [],
        this.target = null,
        this.actionIndex = 0,
        this.currentAction = null,
        this.paused = this.currentActionSalvaged = !1,
        this.hh = null
    }
}),
cc.ActionManager = cc.Class.extend({
    _hashTargets: null,
    _arrayTargets: null,
    _currentTarget: null,
    _currentTargetSalvaged: !1,
    _searchElementByTarget: function(t, e) {
        for (var i = 0; i < t.length; i++)
            if (e === t[i].target)
                return t[i];
        return null
    },
    ctor: function() {
        this._hashTargets = {},
        this._arrayTargets = [],
        this._currentTarget = null,
        this._currentTargetSalvaged = !1
    },
    addAction: function(t, e, i) {
        if (!t)
            throw Error("cc.ActionManager.addAction(): action must be non-null");
        if (!e)
            throw Error("cc.ActionManager.addAction(): action must be non-null");
        var n = this._hashTargets[e.__instanceId];
        n || (n = new cc.HashElement,
        n.paused = i,
        n.target = e,
        this._hashTargets[e.__instanceId] = n,
        this._arrayTargets.push(n)),
        this._actionAllocWithHashElement(n),
        n.actions.push(t),
        t.startWithTarget(e)
    },
    removeAllActions: function() {
        for (var t = this._arrayTargets, e = 0; e < t.length; e++) {
            var i = t[e];
            i && this.removeAllActionsFromTarget(i.target, !0)
        }
    },
    removeAllActionsFromTarget: function(t, e) {
        if (null != t) {
            var i = this._hashTargets[t.__instanceId];
            i && (-1 === i.actions.indexOf(i.currentAction) || i.currentActionSalvaged || (i.currentActionSalvaged = !0),
            i.actions.length = 0,
            this._currentTarget !== i || e ? this._deleteHashElement(i) : this._currentTargetSalvaged = !0)
        }
    },
    removeAction: function(t) {
        if (null != t) {
            var e = t.getOriginalTarget();
            if (e = this._hashTargets[e.__instanceId]) {
                for (var i = 0; i < e.actions.length; i++)
                    if (e.actions[i] === t) {
                        e.actions.splice(i, 1);
                        break
                    }
            } else
                cc.log(cc._LogInfos.ActionManager_removeAction)
        }
    },
    removeActionByTag: function(t, e) {
        t === cc.ACTION_TAG_INVALID && cc.log(cc._LogInfos.ActionManager_addAction),
        cc.assert(e, cc._LogInfos.ActionManager_addAction);
        var i = this._hashTargets[e.__instanceId];
        if (i)
            for (var n = i.actions.length, r = 0; r < n; ++r) {
                var c = i.actions[r];
                if (c && c.getTag() === t && c.getOriginalTarget() === e) {
                    this._removeActionAtIndex(r, i);
                    break
                }
            }
    },
    getActionByTag: function(t, e) {
        t === cc.ACTION_TAG_INVALID && cc.log(cc._LogInfos.ActionManager_getActionByTag);
        var i = this._hashTargets[e.__instanceId];
        if (i) {
            if (null != i.actions)
                for (var n = 0; n < i.actions.length; ++n) {
                    var r = i.actions[n];
                    if (r && r.getTag() === t)
                        return r
                }
            cc.log(cc._LogInfos.ActionManager_getActionByTag_2, t)
        }
        return null
    },
    numberOfRunningActionsInTarget: function(t) {
        return (t = this._hashTargets[t.__instanceId]) && t.actions ? t.actions.length : 0
    },
    pauseTarget: function(t) {
        (t = this._hashTargets[t.__instanceId]) && (t.paused = !0)
    },
    resumeTarget: function(t) {
        (t = this._hashTargets[t.__instanceId]) && (t.paused = !1)
    },
    pauseAllRunningActions: function() {
        for (var t = [], e = this._arrayTargets, i = 0; i < e.length; i++) {
            var n = e[i];
            n && !n.paused && (n.paused = !0,
            t.push(n.target))
        }
        return t
    },
    resumeTargets: function(t) {
        if (t)
            for (var e = 0; e < t.length; e++)
                t[e] && this.resumeTarget(t[e])
    },
    purgeSharedManager: function() {
        cc.director.getScheduler().unscheduleUpdate(this)
    },
    _removeActionAtIndex: function(t, e) {
        e.actions[t] !== e.currentAction || e.currentActionSalvaged || (e.currentActionSalvaged = !0),
        e.actions.splice(t, 1),
        e.actionIndex >= t && e.actionIndex--,
        0 === e.actions.length && (this._currentTarget === e ? this._currentTargetSalvaged = !0 : this._deleteHashElement(e))
    },
    _deleteHashElement: function(t) {
        var e = !1;
        return t && (this._hashTargets[t.target.__instanceId] && (delete this._hashTargets[t.target.__instanceId],
        cc.arrayRemoveObject(this._arrayTargets, t),
        e = !0),
        t.actions = null,
        t.target = null),
        e
    },
    _actionAllocWithHashElement: function(t) {
        null == t.actions && (t.actions = [])
    },
    update: function(t) {
        for (var e, i = this._arrayTargets, n = 0; n < i.length; n++) {
            if (e = this._currentTarget = i[n],
            !e.paused)
                for (e.actionIndex = 0; e.actionIndex < (e.actions ? e.actions.length : 0); e.actionIndex++)
                    if (e.currentAction = e.actions[e.actionIndex],
                    e.currentAction) {
                        if (e.currentActionSalvaged = !1,
                        e.currentAction.step(t * (e.currentAction._speedMethod ? e.currentAction._speed : 1)),
                        e.currentActionSalvaged)
                            e.currentAction = null;
                        else if (e.currentAction.isDone()) {
                            e.currentAction.stop();
                            var r = e.currentAction;
                            e.currentAction = null,
                            this.removeAction(r)
                        }
                        e.currentAction = null
                    }
            this._currentTargetSalvaged && 0 === e.actions.length && this._deleteHashElement(e) && n--
        }
    }
}),
cc.profiler = function() {
    var t = _showFPS = !1
      , e = _frameRate = _lastSPF = _accumDt = 0;
    _afterVisitListener = _FPSLabel = _SPFLabel = _drawsLabel = null;
    var n = 10
      , r = [0, 10, 20, 30]
      , c = [0, 0, 0, 0]
      , s = 3
      , o = 0
      , a = 0
      , h = function() {
        if (_lastSPF = cc.director.getSecondsPerFrame(),
        e++,
        _accumDt += cc.director.getDeltaTime(),
        _accumDt > cc.DIRECTOR_FPS_INTERVAL) {
            if (_frameRate = e / _accumDt,
            _accumDt = e = 0,
            u.onFrameRateChange) {
                var t = _frameRate
                  , h = i = r.length - 1
                  , l = 0;
                for (o++,
                a += t; 0 <= i; i--)
                    if (t >= r[i]) {
                        c[i]++;
                        break
                    }
                if (o >= n) {
                    for (l = a / n,
                    i = h; 0 < i; i--)
                        if (t = c[i] / n,
                        .6 <= t && l >= r[i]) {
                            i != s && (s = i,
                            u.onFrameRateChange && u.onFrameRateChange(l.toFixed(2)));
                            break
                        }
                    for (a = o = _changeCount = 0,
                    i = h; 0 < i; i--)
                        c[i] = 0
                }
            }
            _showFPS && (_SPFLabel.string = _lastSPF.toFixed(3),
            _FPSLabel.string = _frameRate.toFixed(1),
            _drawsLabel.string = (0 | cc.g_NumberOfDraws).toString())
        }
        _showFPS && (_FPSLabel.visit(),
        _SPFLabel.visit(),
        _drawsLabel.visit())
    }
      , l = function() {
        _FPSLabel._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty),
        _SPFLabel._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty),
        _drawsLabel._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    }
      , u = {
        onFrameRateChange: null,
        getSecondsPerFrame: function() {
            return _lastSPF
        },
        getFrameRate: function() {
            return _frameRate
        },
        setProfileDuration: function(t) {
            !isNaN(t) && 0 < t && (n = t / cc.DIRECTOR_FPS_INTERVAL)
        },
        resumeProfiling: function() {
            cc.eventManager.addListener(_afterVisitListener, 1)
        },
        stopProfiling: function() {
            cc.eventManager.removeListener(_afterVisitListener)
        },
        isShowingStats: function() {
            return _showFPS
        },
        showStats: function() {
            if (t || this.init(),
            cc.LabelTTF && !_FPSLabel) {
                var e = 0
                  , e = cc.winSize.width
                  , i = cc.winSize.height
                  , n = cc.DIRECTOR_STATS_POSITION
                  , e = e > i ? 0 | i / 320 * 24 : 0 | e / 320 * 24;
                _FPSLabel = new cc.LabelTTF("000.0","Arial",e),
                _SPFLabel = new cc.LabelTTF("0.000","Arial",e),
                _drawsLabel = new cc.LabelTTF("0000","Arial",e),
                _drawsLabel.setPosition(_drawsLabel.width / 2 + n.x, 5 * _drawsLabel.height / 2 + n.y),
                _SPFLabel.setPosition(_SPFLabel.width / 2 + n.x, 3 * _SPFLabel.height / 2 + n.y),
                _FPSLabel.setPosition(_FPSLabel.width / 2 + n.x, _FPSLabel.height / 2 + n.y)
            }
            _FPSLabel && (_showFPS = !0)
        },
        hideStats: function() {
            _showFPS = !1
        },
        init: function() {
            t || (_afterVisitListener = cc.eventManager.addCustomListener(cc.Director.EVENT_AFTER_VISIT, h),
            cc.eventManager.addCustomListener(cc.Director.EVENT_PROJECTION_CHANGED, l),
            t = !0)
        }
    };
    return u
}(),
cc.math = cc.math || {},
cc.math.EPSILON = .015625,
cc.math.square = function(t) {
    return t * t
}
,
cc.math.almostEqual = function(t, e) {
    return t + cc.math.EPSILON > e && t - cc.math.EPSILON < e
}
,
function(t) {
    t.math.Vec2 = function(t, e) {
        void 0 === e ? (this.x = t.x,
        this.y = t.y) : (this.x = t || 0,
        this.y = e || 0)
    }
    ;
    var e = t.math.Vec2.prototype;
    e.fill = function(t, e) {
        this.x = t,
        this.y = e
    }
    ,
    e.length = function() {
        return Math.sqrt(t.math.square(this.x) + t.math.square(this.y))
    }
    ,
    e.lengthSq = function() {
        return t.math.square(this.x) + t.math.square(this.y)
    }
    ,
    e.normalize = function() {
        var t = 1 / this.length();
        return this.x *= t,
        this.y *= t,
        this
    }
    ,
    t.math.Vec2.add = function(t, e, i) {
        return t.x = e.x + i.x,
        t.y = e.y + i.y,
        t
    }
    ,
    e.add = function(t) {
        return this.x += t.x,
        this.y += t.y,
        this
    }
    ,
    e.dot = function(t) {
        return this.x * t.x + this.y * t.y
    }
    ,
    t.math.Vec2.subtract = function(t, e, i) {
        return t.x = e.x - i.x,
        t.y = e.y - i.y,
        t
    }
    ,
    e.subtract = function(t) {
        return this.x -= t.x,
        this.y -= t.y,
        this
    }
    ,
    e.transform = function(t) {
        var e = this.x
          , i = this.y;
        return this.x = e * t.mat[0] + i * t.mat[3] + t.mat[6],
        this.y = e * t.mat[1] + i * t.mat[4] + t.mat[7],
        this
    }
    ,
    t.math.Vec2.scale = function(t, e, i) {
        return t.x = e.x * i,
        t.y = e.y * i,
        t
    }
    ,
    e.scale = function(t) {
        return this.x *= t,
        this.y *= t,
        this
    }
    ,
    e.equals = function(e) {
        return this.x < e.x + t.math.EPSILON && this.x > e.x - t.math.EPSILON && this.y < e.y + t.math.EPSILON && this.y > e.y - t.math.EPSILON
    }
}(cc),
function(t) {
    t.kmVec3 = t.math.Vec3 = function(t, e, i) {
        t && void 0 === e ? (this.x = t.x,
        this.y = t.y,
        this.z = t.z) : (this.x = t || 0,
        this.y = e || 0,
        this.z = i || 0)
    }
    ,
    t.math.vec3 = function(e, i, n) {
        return new t.math.Vec3(e,i,n)
    }
    ;
    var e = t.math.Vec3.prototype;
    e.fill = function(t, e, i) {
        return t && void 0 === e ? (this.x = t.x,
        this.y = t.y,
        this.z = t.z) : (this.x = t,
        this.y = e,
        this.z = i),
        this
    }
    ,
    e.length = function() {
        return Math.sqrt(t.math.square(this.x) + t.math.square(this.y) + t.math.square(this.z))
    }
    ,
    e.lengthSq = function() {
        return t.math.square(this.x) + t.math.square(this.y) + t.math.square(this.z)
    }
    ,
    e.normalize = function() {
        var t = 1 / this.length();
        return this.x *= t,
        this.y *= t,
        this.z *= t,
        this
    }
    ,
    e.cross = function(t) {
        var e = this.x
          , i = this.y
          , n = this.z;
        return this.x = i * t.z - n * t.y,
        this.y = n * t.x - e * t.z,
        this.z = e * t.y - i * t.x,
        this
    }
    ,
    e.dot = function(t) {
        return this.x * t.x + this.y * t.y + this.z * t.z
    }
    ,
    e.add = function(t) {
        return this.x += t.x,
        this.y += t.y,
        this.z += t.z,
        this
    }
    ,
    e.subtract = function(t) {
        return this.x -= t.x,
        this.y -= t.y,
        this.z -= t.z,
        this
    }
    ,
    e.transform = function(t) {
        var e = this.x
          , i = this.y
          , n = this.z;
        return t = t.mat,
        this.x = e * t[0] + i * t[4] + n * t[8] + t[12],
        this.y = e * t[1] + i * t[5] + n * t[9] + t[13],
        this.z = e * t[2] + i * t[6] + n * t[10] + t[14],
        this
    }
    ,
    e.transformNormal = function(t) {
        var e = this.x
          , i = this.y
          , n = this.z;
        return t = t.mat,
        this.x = e * t[0] + i * t[4] + n * t[8],
        this.y = e * t[1] + i * t[5] + n * t[9],
        this.z = e * t[2] + i * t[6] + n * t[10],
        this
    }
    ,
    e.transformCoord = function(e) {
        var i = new t.math.Vec4(this.x,this.y,this.z,1);
        return i.transform(e),
        this.x = i.x / i.w,
        this.y = i.y / i.w,
        this.z = i.z / i.w,
        this
    }
    ,
    e.scale = function(t) {
        return this.x *= t,
        this.y *= t,
        this.z *= t,
        this
    }
    ,
    e.equals = function(e) {
        var i = t.math.EPSILON;
        return this.x < e.x + i && this.x > e.x - i && this.y < e.y + i && this.y > e.y - i && this.z < e.z + i && this.z > e.z - i
    }
    ,
    e.inverseTransform = function(e) {
        e = e.mat;
        var i = new t.math.Vec3(this.x - e[12],this.y - e[13],this.z - e[14]);
        return this.x = i.x * e[0] + i.y * e[1] + i.z * e[2],
        this.y = i.x * e[4] + i.y * e[5] + i.z * e[6],
        this.z = i.x * e[8] + i.y * e[9] + i.z * e[10],
        this
    }
    ,
    e.inverseTransformNormal = function(t) {
        var e = this.x
          , i = this.y
          , n = this.z;
        return t = t.mat,
        this.x = e * t[0] + i * t[1] + n * t[2],
        this.y = e * t[4] + i * t[5] + n * t[6],
        this.z = e * t[8] + i * t[9] + n * t[10],
        this
    }
    ,
    e.assignFrom = function(t) {
        return t ? (this.x = t.x,
        this.y = t.y,
        this.z = t.z,
        this) : this
    }
    ,
    t.math.Vec3.zero = function(t) {
        return t.x = t.y = t.z = 0,
        t
    }
    ,
    e.toTypeArray = function() {
        var t = new Float32Array(3);
        return t[0] = this.x,
        t[1] = this.y,
        t[2] = this.z,
        t
    }
}(cc),
function(t) {
    t.math.Vec4 = function(t, e, i, n) {
        t && void 0 === e ? (this.x = t.x,
        this.y = t.y,
        this.z = t.z,
        this.w = t.w) : (this.x = t || 0,
        this.y = e || 0,
        this.z = i || 0,
        this.w = n || 0)
    }
    ,
    t.kmVec4 = t.math.Vec4;
    var e = t.math.Vec4.prototype;
    e.fill = function(t, e, i, n) {
        t && void 0 === e ? (this.x = t.x,
        this.y = t.y,
        this.z = t.z,
        this.w = t.w) : (this.x = t,
        this.y = e,
        this.z = i,
        this.w = n)
    }
    ,
    e.add = function(t) {
        return t ? (this.x += t.x,
        this.y += t.y,
        this.z += t.z,
        this.w += t.w,
        this) : this
    }
    ,
    e.dot = function(t) {
        return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
    }
    ,
    e.length = function() {
        return Math.sqrt(t.math.square(this.x) + t.math.square(this.y) + t.math.square(this.z) + t.math.square(this.w))
    }
    ,
    e.lengthSq = function() {
        return t.math.square(this.x) + t.math.square(this.y) + t.math.square(this.z) + t.math.square(this.w)
    }
    ,
    e.lerp = function(t, e) {
        return this
    }
    ,
    e.normalize = function() {
        var t = 1 / this.length();
        return this.x *= t,
        this.y *= t,
        this.z *= t,
        this.w *= t,
        this
    }
    ,
    e.scale = function(t) {
        return this.normalize(),
        this.x *= t,
        this.y *= t,
        this.z *= t,
        this.w *= t,
        this
    }
    ,
    e.subtract = function(t) {
        this.x -= t.x,
        this.y -= t.y,
        this.z -= t.z,
        this.w -= t.w
    }
    ,
    e.transform = function(t) {
        var e = this.x
          , i = this.y
          , n = this.z
          , r = this.w;
        return t = t.mat,
        this.x = e * t[0] + i * t[4] + n * t[8] + r * t[12],
        this.y = e * t[1] + i * t[5] + n * t[9] + r * t[13],
        this.z = e * t[2] + i * t[6] + n * t[10] + r * t[14],
        this.w = e * t[3] + i * t[7] + n * t[11] + r * t[15],
        this
    }
    ,
    t.math.Vec4.transformArray = function(e, i) {
        for (var n = [], r = 0; r < e.length; r++) {
            var c = new t.math.Vec4(e[r]);
            c.transform(i),
            n.push(c)
        }
        return n
    }
    ,
    e.equals = function(e) {
        var i = t.math.EPSILON;
        return this.x < e.x + i && this.x > e.x - i && this.y < e.y + i && this.y > e.y - i && this.z < e.z + i && this.z > e.z - i && this.w < e.w + i && this.w > e.w - i
    }
    ,
    e.assignFrom = function(t) {
        return this.x = t.x,
        this.y = t.y,
        this.z = t.z,
        this.w = t.w,
        this
    }
    ,
    e.toTypeArray = function() {
        var t = new Float32Array(4);
        return t[0] = this.x,
        t[1] = this.y,
        t[2] = this.z,
        t[3] = this.w,
        t
    }
}(cc),
function(t) {
    function e(e, i, n) {
        i = new t.math.Vec2(i),
        i.subtract(e),
        n.x = -i.y,
        n.y = i.x,
        n.normalize()
    }
    t.math.Ray2 = function(e, i) {
        this.start = e || new t.math.Vec2,
        this.dir = i || new t.math.Vec2
    }
    ,
    t.math.Ray2.prototype.fill = function(t, e, i, n) {
        this.start.x = t,
        this.start.y = e,
        this.dir.x = i,
        this.dir.y = n
    }
    ,
    t.math.Ray2.prototype.intersectLineSegment = function(e, i, n) {
        var r = this.start.x
          , c = this.start.y
          , s = this.start.x + this.dir.x
          , o = this.start.y + this.dir.y
          , a = e.x
          , h = e.y
          , l = i.x
          , u = i.y
          , d = (u - h) * (s - r) - (l - a) * (o - c);
        return !(d > -t.math.EPSILON && d < t.math.EPSILON) && (h = ((l - a) * (c - h) - (u - h) * (r - a)) / d,
        a = r + h * (s - r),
        h = c + h * (o - c),
        !(a < Math.min(e.x, i.x) - t.math.EPSILON || a > Math.max(e.x, i.x) + t.math.EPSILON || h < Math.min(e.y, i.y) - t.math.EPSILON || h > Math.max(e.y, i.y) + t.math.EPSILON || a < Math.min(r, s) - t.math.EPSILON || a > Math.max(r, s) + t.math.EPSILON || h < Math.min(c, o) - t.math.EPSILON || h > Math.max(c, o) + t.math.EPSILON) && (n.x = a,
        n.y = h,
        !0))
    }
    ,
    t.math.Ray2.prototype.intersectTriangle = function(i, n, r, c, s) {
        var o, a = new t.math.Vec2, h = new t.math.Vec2, l = new t.math.Vec2, u = 1e4, d = !1;
        return this.intersectLineSegment(i, n, a) && (d = !0,
        o = a.subtract(this.start).length(),
        o < u && (h.x = a.x,
        h.y = a.y,
        u = o,
        e(i, n, l))),
        this.intersectLineSegment(n, r, a) && (d = !0,
        o = a.subtract(this.start).length(),
        o < u && (h.x = a.x,
        h.y = a.y,
        u = o,
        e(n, r, l))),
        this.intersectLineSegment(r, i, a) && (d = !0,
        o = a.subtract(this.start).length(),
        o < u && (h.x = a.x,
        h.y = a.y,
        e(r, i, l))),
        d && (c.x = h.x,
        c.y = h.y,
        s && (s.x = l.x,
        s.y = l.y)),
        d
    }
}(cc),
window.Uint16Array = window.Uint16Array || window.Array,
window.Float32Array = window.Float32Array || window.Array,
function(t) {
    t.math.Matrix3 = function(t) {
        this.mat = t && t.mat ? new Float32Array(t.mat) : new Float32Array(9)
    }
    ,
    t.kmMat3 = t.math.Matrix3;
    var e = t.math.Matrix3.prototype;
    e.fill = function(t) {
        var e = this.mat;
        return t = t.mat,
        e[0] = t[0],
        e[1] = t[1],
        e[2] = t[2],
        e[3] = t[3],
        e[4] = t[4],
        e[5] = t[5],
        e[6] = t[6],
        e[7] = t[7],
        e[8] = t[8],
        this
    }
    ,
    e.adjugate = function() {
        var t = this.mat
          , e = t[0]
          , i = t[1]
          , n = t[2]
          , r = t[3]
          , c = t[4]
          , s = t[5]
          , o = t[6]
          , a = t[7]
          , h = t[8];
        return t[0] = c * h - s * a,
        t[1] = n * a - i * h,
        t[2] = i * s - n * c,
        t[3] = s * o - r * h,
        t[4] = e * h - n * o,
        t[5] = n * r - e * s,
        t[6] = r * a - c * o,
        t[8] = e * c - i * r,
        this
    }
    ,
    e.identity = function() {
        var t = this.mat;
        return t[1] = t[2] = t[3] = t[5] = t[6] = t[7] = 0,
        t[0] = t[4] = t[8] = 1,
        this
    }
    ;
    var i = new t.math.Matrix3;
    e.inverse = function(t) {
        return 0 === t ? this : (i.assignFrom(this),
        t = 1 / t,
        this.adjugate(),
        this.multiplyScalar(t),
        this)
    }
    ,
    e.isIdentity = function() {
        var t = this.mat;
        return 1 === t[0] && 0 === t[1] && 0 === t[2] && 0 === t[3] && 1 === t[4] && 0 === t[5] && 0 === t[6] && 0 === t[7] && 1 === t[8]
    }
    ,
    e.transpose = function() {
        var t = this.mat
          , e = t[1]
          , i = t[2]
          , n = t[5]
          , r = t[6]
          , c = t[7];
        return t[1] = t[3],
        t[2] = r,
        t[3] = e,
        t[5] = c,
        t[6] = i,
        t[7] = n,
        this
    }
    ,
    e.determinant = function() {
        var t = this.mat
          , e = t[0] * t[4] * t[8] + t[1] * t[5] * t[6] + t[2] * t[3] * t[7];
        return e -= t[2] * t[4] * t[6] + t[0] * t[5] * t[7] + t[1] * t[3] * t[8]
    }
    ,
    e.multiply = function(t) {
        var e = this.mat
          , i = t.mat;
        t = e[0];
        var n = e[1]
          , r = e[2]
          , c = e[3]
          , s = e[4]
          , o = e[5]
          , a = e[6]
          , h = e[7]
          , l = e[8]
          , u = i[0]
          , d = i[1]
          , _ = i[2]
          , p = i[3]
          , f = i[4]
          , g = i[5]
          , m = i[6]
          , y = i[7]
          , i = i[8];
        return e[0] = t * u + c * d + a * _,
        e[1] = n * u + s * d + h * _,
        e[2] = r * u + o * d + l * _,
        e[3] = r * u + o * d + l * _,
        e[4] = n * p + s * f + h * g,
        e[5] = r * p + o * f + l * g,
        e[6] = t * m + c * y + a * i,
        e[7] = n * m + s * y + h * i,
        e[8] = r * m + o * y + l * i,
        this
    }
    ,
    e.multiplyScalar = function(t) {
        var e = this.mat;
        return e[0] *= t,
        e[1] *= t,
        e[2] *= t,
        e[3] *= t,
        e[4] *= t,
        e[5] *= t,
        e[6] *= t,
        e[7] *= t,
        e[8] *= t,
        this
    }
    ,
    t.math.Matrix3.rotationAxisAngle = function(e, i) {
        var n = Math.cos(i)
          , r = Math.sin(i)
          , c = new t.math.Matrix3
          , s = c.mat;
        return s[0] = n + e.x * e.x * (1 - n),
        s[1] = e.z * r + e.y * e.x * (1 - n),
        s[2] = -e.y * r + e.z * e.x * (1 - n),
        s[3] = -e.z * r + e.x * e.y * (1 - n),
        s[4] = n + e.y * e.y * (1 - n),
        s[5] = e.x * r + e.z * e.y * (1 - n),
        s[6] = e.y * r + e.x * e.z * (1 - n),
        s[7] = -e.x * r + e.y * e.z * (1 - n),
        s[8] = n + e.z * e.z * (1 - n),
        c
    }
    ,
    e.assignFrom = function(e) {
        if (this === e)
            return t.log("cc.math.Matrix3.assign(): current matrix equals matIn"),
            this;
        var i = this.mat;
        return e = e.mat,
        i[0] = e[0],
        i[1] = e[1],
        i[2] = e[2],
        i[3] = e[3],
        i[4] = e[4],
        i[5] = e[5],
        i[6] = e[6],
        i[7] = e[7],
        i[8] = e[8],
        this
    }
    ,
    e.equals = function(e) {
        if (this === e)
            return !0;
        var i = t.math.EPSILON
          , n = this.mat;
        e = e.mat;
        for (var r = 0; 9 > r; ++r)
            if (!(n[r] + i > e[r] && n[r] - i < e[r]))
                return !1;
        return !0
    }
    ,
    t.math.Matrix3.createByRotationX = function(e) {
        var i = new t.math.Matrix3
          , n = i.mat;
        return n[0] = 1,
        n[1] = 0,
        n[2] = 0,
        n[3] = 0,
        n[4] = Math.cos(e),
        n[5] = Math.sin(e),
        n[6] = 0,
        n[7] = -Math.sin(e),
        n[8] = Math.cos(e),
        i
    }
    ,
    t.math.Matrix3.createByRotationY = function(e) {
        var i = new t.math.Matrix3
          , n = i.mat;
        return n[0] = Math.cos(e),
        n[1] = 0,
        n[2] = -Math.sin(e),
        n[3] = 0,
        n[4] = 1,
        n[5] = 0,
        n[6] = Math.sin(e),
        n[7] = 0,
        n[8] = Math.cos(e),
        i
    }
    ,
    t.math.Matrix3.createByRotationZ = function(e) {
        var i = new t.math.Matrix3
          , n = i.mat;
        return n[0] = Math.cos(e),
        n[1] = -Math.sin(e),
        n[2] = 0,
        n[3] = Math.sin(e),
        n[4] = Math.cos(e),
        n[5] = 0,
        n[6] = 0,
        n[7] = 0,
        n[8] = 1,
        i
    }
    ,
    t.math.Matrix3.createByRotation = function(e) {
        var i = new t.math.Matrix3
          , n = i.mat;
        return n[0] = Math.cos(e),
        n[1] = Math.sin(e),
        n[2] = 0,
        n[3] = -Math.sin(e),
        n[4] = Math.cos(e),
        n[5] = 0,
        n[6] = 0,
        n[7] = 0,
        n[8] = 1,
        i
    }
    ,
    t.math.Matrix3.createByScale = function(e, i) {
        var n = new t.math.Matrix3;
        return n.identity(),
        n.mat[0] = e,
        n.mat[4] = i,
        n
    }
    ,
    t.math.Matrix3.createByTranslation = function(e, i) {
        var n = new t.math.Matrix3;
        return n.identity(),
        n.mat[6] = e,
        n.mat[7] = i,
        n
    }
    ,
    t.math.Matrix3.createByQuaternion = function(e) {
        if (!e)
            return null;
        var i = new t.math.Matrix3
          , n = i.mat;
        return n[0] = 1 - 2 * (e.y * e.y + e.z * e.z),
        n[1] = 2 * (e.x * e.y - e.w * e.z),
        n[2] = 2 * (e.x * e.z + e.w * e.y),
        n[3] = 2 * (e.x * e.y + e.w * e.z),
        n[4] = 1 - 2 * (e.x * e.x + e.z * e.z),
        n[5] = 2 * (e.y * e.z - e.w * e.x),
        n[6] = 2 * (e.x * e.z - e.w * e.y),
        n[7] = 2 * (e.y * e.z + e.w * e.x),
        n[8] = 1 - 2 * (e.x * e.x + e.y * e.y),
        i
    }
    ,
    e.rotationToAxisAngle = function() {
        return t.math.Quaternion.rotationMatrix(this).toAxisAndAngle()
    }
}(cc),
function(t) {
    t.math.Matrix4 = function(t) {
        this.mat = t && t.mat ? new Float32Array(t.mat) : new Float32Array(16)
    }
    ,
    t.kmMat4 = t.math.Matrix4;
    var e = t.math.Matrix4.prototype;
    e.fill = function(t) {
        for (var e = this.mat, i = 0; 16 > i; i++)
            e[i] = t[i];
        return this
    }
    ,
    t.kmMat4Identity = function(t) {
        var e = t.mat;
        return e[1] = e[2] = e[3] = e[4] = e[6] = e[7] = e[8] = e[9] = e[11] = e[12] = e[13] = e[14] = 0,
        e[0] = e[5] = e[10] = e[15] = 1,
        t
    }
    ,
    e.identity = function() {
        var t = this.mat;
        return t[1] = t[2] = t[3] = t[4] = t[6] = t[7] = t[8] = t[9] = t[11] = t[12] = t[13] = t[14] = 0,
        t[0] = t[5] = t[10] = t[15] = 1,
        this
    }
    ,
    e.get = function(t, e) {
        return this.mat[t + 4 * e]
    }
    ,
    e.set = function(t, e, i) {
        this.mat[t + 4 * e] = i
    }
    ,
    e.swap = function(t, e, i, n) {
        var r = this.mat
          , c = r[t + 4 * e];
        r[t + 4 * e] = r[i + 4 * n],
        r[i + 4 * n] = c
    }
    ,
    t.math.Matrix4._gaussj = function(t, e) {
        var i, n, r, c, s, o = 0, a = 0, h = [0, 0, 0, 0], l = [0, 0, 0, 0], u = [0, 0, 0, 0];
        for (i = 0; 4 > i; i++) {
            for (n = s = 0; 4 > n; n++)
                if (1 !== u[n])
                    for (r = 0; 4 > r; r++)
                        0 === u[r] && (c = Math.abs(t.get(n, r)),
                        c >= s && (s = c,
                        a = n,
                        o = r));
            if (++u[o],
            a !== o) {
                for (n = 0; 4 > n; n++)
                    t.swap(a, n, o, n);
                for (n = 0; 4 > n; n++)
                    e.swap(a, n, o, n)
            }
            if (l[i] = a,
            h[i] = o,
            0 === t.get(o, o))
                return !1;
            for (r = 1 / t.get(o, o),
            t.set(o, o, 1),
            n = 0; 4 > n; n++)
                t.set(o, n, t.get(o, n) * r);
            for (n = 0; 4 > n; n++)
                e.set(o, n, e.get(o, n) * r);
            for (r = 0; 4 > r; r++)
                if (r !== o) {
                    for (c = t.get(r, o),
                    t.set(r, o, 0),
                    n = 0; 4 > n; n++)
                        t.set(r, n, t.get(r, n) - t.get(o, n) * c);
                    for (n = 0; 4 > n; n++)
                        e.set(r, n, t.get(r, n) - e.get(o, n) * c)
                }
        }
        for (n = 3; 0 <= n; n--)
            if (l[n] !== h[n])
                for (r = 0; 4 > r; r++)
                    t.swap(r, l[n], r, h[n]);
        return !0
    }
    ;
    var i = (new t.math.Matrix4).identity();
    t.kmMat4Inverse = function(e, n) {
        var r = new t.math.Matrix4(n)
          , c = new t.math.Matrix4(i);
        return !1 === t.math.Matrix4._gaussj(r, c) ? null : (e.assignFrom(r),
        e)
    }
    ,
    e.inverse = function() {
        var e = new t.math.Matrix4(this)
          , n = new t.math.Matrix4(i);
        return !1 === t.math.Matrix4._gaussj(e, n) ? null : e
    }
    ,
    e.isIdentity = function() {
        var t = this.mat;
        return 1 === t[0] && 0 === t[1] && 0 === t[2] && 0 === t[3] && 0 === t[4] && 1 === t[5] && 0 === t[6] && 0 === t[7] && 0 === t[8] && 0 === t[9] && 1 === t[10] && 0 === t[11] && 0 === t[12] && 0 === t[13] && 0 === t[14] && 1 === t[15]
    }
    ,
    e.transpose = function() {
        var t = this.mat
          , e = t[1]
          , i = t[2]
          , n = t[3]
          , r = t[6]
          , c = t[7]
          , s = t[8]
          , o = t[9]
          , a = t[11]
          , h = t[12]
          , l = t[13]
          , u = t[14];
        return t[1] = t[4],
        t[2] = s,
        t[3] = h,
        t[4] = e,
        t[6] = o,
        t[7] = l,
        t[8] = i,
        t[9] = r,
        t[11] = u,
        t[12] = n,
        t[13] = c,
        t[14] = a,
        this
    }
    ,
    t.kmMat4Multiply = function(t, e, i) {
        var n = t.mat
          , r = e.mat
          , c = i.mat;
        i = r[0],
        e = r[1];
        var s = r[2]
          , o = r[3]
          , a = r[4]
          , h = r[5]
          , l = r[6]
          , u = r[7]
          , d = r[8]
          , _ = r[9]
          , p = r[10]
          , f = r[11]
          , g = r[12]
          , m = r[13]
          , y = r[14]
          , r = r[15]
          , T = c[0]
          , v = c[1]
          , A = c[2]
          , S = c[3]
          , E = c[4]
          , x = c[5]
          , C = c[6]
          , I = c[7]
          , b = c[8]
          , R = c[9]
          , w = c[10]
          , P = c[11]
          , L = c[12]
          , F = c[13]
          , O = c[14]
          , c = c[15];
        return n[0] = T * i + v * a + A * d + S * g,
        n[1] = T * e + v * h + A * _ + S * m,
        n[2] = T * s + v * l + A * p + S * y,
        n[3] = T * o + v * u + A * f + S * r,
        n[4] = E * i + x * a + C * d + I * g,
        n[5] = E * e + x * h + C * _ + I * m,
        n[6] = E * s + x * l + C * p + I * y,
        n[7] = E * o + x * u + C * f + I * r,
        n[8] = b * i + R * a + w * d + P * g,
        n[9] = b * e + R * h + w * _ + P * m,
        n[10] = b * s + R * l + w * p + P * y,
        n[11] = b * o + R * u + w * f + P * r,
        n[12] = L * i + F * a + O * d + c * g,
        n[13] = L * e + F * h + O * _ + c * m,
        n[14] = L * s + F * l + O * p + c * y,
        n[15] = L * o + F * u + O * f + c * r,
        t
    }
    ,
    e.multiply = function(t) {
        var e = this.mat
          , i = t.mat;
        t = e[0];
        var n = e[1]
          , r = e[2]
          , c = e[3]
          , s = e[4]
          , o = e[5]
          , a = e[6]
          , h = e[7]
          , l = e[8]
          , u = e[9]
          , d = e[10]
          , _ = e[11]
          , p = e[12]
          , f = e[13]
          , g = e[14]
          , m = e[15]
          , y = i[0]
          , T = i[1]
          , v = i[2]
          , A = i[3]
          , S = i[4]
          , E = i[5]
          , x = i[6]
          , C = i[7]
          , I = i[8]
          , b = i[9]
          , R = i[10]
          , w = i[11]
          , P = i[12]
          , L = i[13]
          , F = i[14]
          , i = i[15];
        return e[0] = y * t + T * s + v * l + A * p,
        e[1] = y * n + T * o + v * u + A * f,
        e[2] = y * r + T * a + v * d + A * g,
        e[3] = y * c + T * h + v * _ + A * m,
        e[4] = S * t + E * s + x * l + C * p,
        e[5] = S * n + E * o + x * u + C * f,
        e[6] = S * r + E * a + x * d + C * g,
        e[7] = S * c + E * h + x * _ + C * m,
        e[8] = I * t + b * s + R * l + w * p,
        e[9] = I * n + b * o + R * u + w * f,
        e[10] = I * r + b * a + R * d + w * g,
        e[11] = I * c + b * h + R * _ + w * m,
        e[12] = P * t + L * s + F * l + i * p,
        e[13] = P * n + L * o + F * u + i * f,
        e[14] = P * r + L * a + F * d + i * g,
        e[15] = P * c + L * h + F * _ + i * m,
        this
    }
    ,
    t.getMat4MultiplyValue = function(t, e) {
        var i = t.mat
          , n = e.mat
          , r = new Float32Array(16);
        return r[0] = i[0] * n[0] + i[4] * n[1] + i[8] * n[2] + i[12] * n[3],
        r[1] = i[1] * n[0] + i[5] * n[1] + i[9] * n[2] + i[13] * n[3],
        r[2] = i[2] * n[0] + i[6] * n[1] + i[10] * n[2] + i[14] * n[3],
        r[3] = i[3] * n[0] + i[7] * n[1] + i[11] * n[2] + i[15] * n[3],
        r[4] = i[0] * n[4] + i[4] * n[5] + i[8] * n[6] + i[12] * n[7],
        r[5] = i[1] * n[4] + i[5] * n[5] + i[9] * n[6] + i[13] * n[7],
        r[6] = i[2] * n[4] + i[6] * n[5] + i[10] * n[6] + i[14] * n[7],
        r[7] = i[3] * n[4] + i[7] * n[5] + i[11] * n[6] + i[15] * n[7],
        r[8] = i[0] * n[8] + i[4] * n[9] + i[8] * n[10] + i[12] * n[11],
        r[9] = i[1] * n[8] + i[5] * n[9] + i[9] * n[10] + i[13] * n[11],
        r[10] = i[2] * n[8] + i[6] * n[9] + i[10] * n[10] + i[14] * n[11],
        r[11] = i[3] * n[8] + i[7] * n[9] + i[11] * n[10] + i[15] * n[11],
        r[12] = i[0] * n[12] + i[4] * n[13] + i[8] * n[14] + i[12] * n[15],
        r[13] = i[1] * n[12] + i[5] * n[13] + i[9] * n[14] + i[13] * n[15],
        r[14] = i[2] * n[12] + i[6] * n[13] + i[10] * n[14] + i[14] * n[15],
        r[15] = i[3] * n[12] + i[7] * n[13] + i[11] * n[14] + i[15] * n[15],
        r
    }
    ,
    t.kmMat4Assign = function(e, i) {
        if (e === i)
            return t.log("cc.kmMat4Assign(): pOut equals pIn"),
            e;
        var n = e.mat
          , r = i.mat;
        return n[0] = r[0],
        n[1] = r[1],
        n[2] = r[2],
        n[3] = r[3],
        n[4] = r[4],
        n[5] = r[5],
        n[6] = r[6],
        n[7] = r[7],
        n[8] = r[8],
        n[9] = r[9],
        n[10] = r[10],
        n[11] = r[11],
        n[12] = r[12],
        n[13] = r[13],
        n[14] = r[14],
        n[15] = r[15],
        e
    }
    ,
    e.assignFrom = function(e) {
        if (this === e)
            return t.log("cc.mat.Matrix4.assignFrom(): mat4 equals current matrix"),
            this;
        var i = this.mat;
        return e = e.mat,
        i[0] = e[0],
        i[1] = e[1],
        i[2] = e[2],
        i[3] = e[3],
        i[4] = e[4],
        i[5] = e[5],
        i[6] = e[6],
        i[7] = e[7],
        i[8] = e[8],
        i[9] = e[9],
        i[10] = e[10],
        i[11] = e[11],
        i[12] = e[12],
        i[13] = e[13],
        i[14] = e[14],
        i[15] = e[15],
        this
    }
    ,
    e.equals = function(e) {
        if (this === e)
            return t.log("cc.kmMat4AreEqual(): pMat1 and pMat2 are same object."),
            !0;
        var i = this.mat;
        e = e.mat;
        for (var n = t.math.EPSILON, r = 0; 16 > r; r++)
            if (!(i[r] + n > e[r] && i[r] - n < e[r]))
                return !1;
        return !0
    }
    ,
    t.math.Matrix4.createByRotationX = function(e, i) {
        i = i || new t.math.Matrix4;
        var n = i.mat;
        return n[0] = 1,
        n[3] = n[2] = n[1] = 0,
        n[4] = 0,
        n[5] = Math.cos(e),
        n[6] = Math.sin(e),
        n[7] = 0,
        n[8] = 0,
        n[9] = -Math.sin(e),
        n[10] = Math.cos(e),
        n[11] = 0,
        n[14] = n[13] = n[12] = 0,
        n[15] = 1,
        i
    }
    ,
    t.math.Matrix4.createByRotationY = function(e, i) {
        i = i || new t.math.Matrix4;
        var n = i.mat;
        return n[0] = Math.cos(e),
        n[1] = 0,
        n[2] = -Math.sin(e),
        n[3] = 0,
        n[7] = n[6] = n[4] = 0,
        n[5] = 1,
        n[8] = Math.sin(e),
        n[9] = 0,
        n[10] = Math.cos(e),
        n[11] = 0,
        n[14] = n[13] = n[12] = 0,
        n[15] = 1,
        i
    }
    ,
    t.math.Matrix4.createByRotationZ = function(e, i) {
        i = i || new t.math.Matrix4;
        var n = i.mat;
        return n[0] = Math.cos(e),
        n[1] = Math.sin(e),
        n[3] = n[2] = 0,
        n[4] = -Math.sin(e),
        n[5] = Math.cos(e),
        n[7] = n[6] = 0,
        n[11] = n[9] = n[8] = 0,
        n[10] = 1,
        n[14] = n[13] = n[12] = 0,
        n[15] = 1,
        i
    }
    ,
    t.math.Matrix4.createByPitchYawRoll = function(e, i, n, r) {
        r = r || new t.math.Matrix4;
        var c = Math.cos(e);
        e = Math.sin(e);
        var s = Math.cos(i);
        i = Math.sin(i);
        var o = Math.cos(n);
        n = Math.sin(n);
        var a = e * i
          , h = c * i
          , l = r.mat;
        return l[0] = s * o,
        l[4] = s * n,
        l[8] = -i,
        l[1] = a * o - c * n,
        l[5] = a * n + c * o,
        l[9] = e * s,
        l[2] = h * o + e * n,
        l[6] = h * n - e * o,
        l[10] = c * s,
        l[3] = l[7] = l[11] = 0,
        l[15] = 1,
        r
    }
    ,
    t.math.Matrix4.createByQuaternion = function(e, i) {
        i = i || new t.math.Matrix4;
        var n = i.mat;
        return n[0] = 1 - 2 * (e.y * e.y + e.z * e.z),
        n[1] = 2 * (e.x * e.y + e.z * e.w),
        n[2] = 2 * (e.x * e.z - e.y * e.w),
        n[3] = 0,
        n[4] = 2 * (e.x * e.y - e.z * e.w),
        n[5] = 1 - 2 * (e.x * e.x + e.z * e.z),
        n[6] = 2 * (e.z * e.y + e.x * e.w),
        n[7] = 0,
        n[8] = 2 * (e.x * e.z + e.y * e.w),
        n[9] = 2 * (e.y * e.z - e.x * e.w),
        n[10] = 1 - 2 * (e.x * e.x + e.y * e.y),
        n[11] = 0,
        n[14] = n[13] = n[12] = 0,
        n[15] = 1,
        i
    }
    ,
    t.math.Matrix4.createByRotationTranslation = function(e, i, n) {
        n = n || new t.math.Matrix4;
        var r = n.mat;
        return e = e.mat,
        r[0] = e[0],
        r[1] = e[1],
        r[2] = e[2],
        r[3] = 0,
        r[4] = e[3],
        r[5] = e[4],
        r[6] = e[5],
        r[7] = 0,
        r[8] = e[6],
        r[9] = e[7],
        r[10] = e[8],
        r[11] = 0,
        r[12] = i.x,
        r[13] = i.y,
        r[14] = i.z,
        r[15] = 1,
        n
    }
    ,
    t.math.Matrix4.createByScale = function(e, i, n, r) {
        r = r || new t.math.Matrix4;
        var c = r.mat;
        return c[0] = e,
        c[5] = i,
        c[10] = n,
        c[15] = 1,
        c[1] = c[2] = c[3] = c[4] = c[6] = c[7] = c[8] = c[9] = c[11] = c[12] = c[13] = c[14] = 0,
        r
    }
    ,
    t.kmMat4Translation = function(t, e, i, n) {
        return t.mat[0] = t.mat[5] = t.mat[10] = t.mat[15] = 1,
        t.mat[1] = t.mat[2] = t.mat[3] = t.mat[4] = t.mat[6] = t.mat[7] = t.mat[8] = t.mat[9] = t.mat[11] = 0,
        t.mat[12] = e,
        t.mat[13] = i,
        t.mat[14] = n,
        t
    }
    ,
    t.math.Matrix4.createByTranslation = function(e, i, n, r) {
        return r = r || new t.math.Matrix4,
        r.identity(),
        r.mat[12] = e,
        r.mat[13] = i,
        r.mat[14] = n,
        r
    }
    ,
    e.getUpVec3 = function() {
        var e = this.mat;
        return new t.math.Vec3(e[4],e[5],e[6]).normalize()
    }
    ,
    e.getRightVec3 = function() {
        var e = this.mat;
        return new t.math.Vec3(e[0],e[1],e[2]).normalize()
    }
    ,
    e.getForwardVec3 = function() {
        var e = this.mat;
        return new t.math.Vec3(e[8],e[9],e[10]).normalize()
    }
    ,
    t.kmMat4PerspectiveProjection = function(e, i, n, r, c) {
        var s = t.degreesToRadians(i / 2);
        i = c - r;
        var o = Math.sin(s);
        return 0 === i || 0 === o || 0 === n ? null : (s = Math.cos(s) / o,
        e.identity(),
        e.mat[0] = s / n,
        e.mat[5] = s,
        e.mat[10] = -(c + r) / i,
        e.mat[11] = -1,
        e.mat[14] = -2 * r * c / i,
        e.mat[15] = 0,
        e)
    }
    ,
    t.math.Matrix4.createPerspectiveProjection = function(e, i, n, r) {
        var c = t.degreesToRadians(e / 2);
        e = r - n;
        var s = Math.sin(c);
        if (0 === e || 0 === s || 0 === i)
            return null;
        var c = Math.cos(c) / s
          , s = new t.math.Matrix4
          , o = s.mat;
        return s.identity(),
        o[0] = c / i,
        o[5] = c,
        o[10] = -(r + n) / e,
        o[11] = -1,
        o[14] = -2 * n * r / e,
        o[15] = 0,
        s
    }
    ,
    t.kmMat4OrthographicProjection = function(t, e, i, n, r, c, s) {
        return t.identity(),
        t.mat[0] = 2 / (i - e),
        t.mat[5] = 2 / (r - n),
        t.mat[10] = -2 / (s - c),
        t.mat[12] = -((i + e) / (i - e)),
        t.mat[13] = -((r + n) / (r - n)),
        t.mat[14] = -((s + c) / (s - c)),
        t
    }
    ,
    t.math.Matrix4.createOrthographicProjection = function(e, i, n, r, c, s) {
        var o = new t.math.Matrix4
          , a = o.mat;
        return o.identity(),
        a[0] = 2 / (i - e),
        a[5] = 2 / (r - n),
        a[10] = -2 / (s - c),
        a[12] = -((i + e) / (i - e)),
        a[13] = -((r + n) / (r - n)),
        a[14] = -((s + c) / (s - c)),
        o
    }
    ,
    t.kmMat4LookAt = function(e, i, n, r) {
        n = new t.math.Vec3(n);
        var c = new t.math.Vec3(r);
        return n.subtract(i),
        n.normalize(),
        c.normalize(),
        r = new t.math.Vec3(n),
        r.cross(c),
        r.normalize(),
        c = new t.math.Vec3(r),
        c.cross(n),
        r.normalize(),
        e.identity(),
        e.mat[0] = r.x,
        e.mat[4] = r.y,
        e.mat[8] = r.z,
        e.mat[1] = c.x,
        e.mat[5] = c.y,
        e.mat[9] = c.z,
        e.mat[2] = -n.x,
        e.mat[6] = -n.y,
        e.mat[10] = -n.z,
        i = t.math.Matrix4.createByTranslation(-i.x, -i.y, -i.z),
        e.multiply(i),
        e
    }
    ;
    var n = new t.math.Matrix4;
    e.lookAt = function(e, i, r) {
        i = new t.math.Vec3(i);
        var c = new t.math.Vec3(r);
        r = this.mat,
        i.subtract(e),
        i.normalize(),
        c.normalize();
        var s = new t.math.Vec3(i);
        return s.cross(c),
        s.normalize(),
        c = new t.math.Vec3(s),
        c.cross(i),
        s.normalize(),
        this.identity(),
        r[0] = s.x,
        r[4] = s.y,
        r[8] = s.z,
        r[1] = c.x,
        r[5] = c.y,
        r[9] = c.z,
        r[2] = -i.x,
        r[6] = -i.y,
        r[10] = -i.z,
        n = t.math.Matrix4.createByTranslation(-e.x, -e.y, -e.z, n),
        this.multiply(n),
        this
    }
    ,
    t.kmMat4RotationAxisAngle = function(e, i, n) {
        var r = Math.cos(n);
        return n = Math.sin(n),
        i = new t.math.Vec3(i),
        i.normalize(),
        e.mat[0] = r + i.x * i.x * (1 - r),
        e.mat[1] = i.z * n + i.y * i.x * (1 - r),
        e.mat[2] = -i.y * n + i.z * i.x * (1 - r),
        e.mat[3] = 0,
        e.mat[4] = -i.z * n + i.x * i.y * (1 - r),
        e.mat[5] = r + i.y * i.y * (1 - r),
        e.mat[6] = i.x * n + i.z * i.y * (1 - r),
        e.mat[7] = 0,
        e.mat[8] = i.y * n + i.x * i.z * (1 - r),
        e.mat[9] = -i.x * n + i.y * i.z * (1 - r),
        e.mat[10] = r + i.z * i.z * (1 - r),
        e.mat[11] = 0,
        e.mat[12] = 0,
        e.mat[13] = 0,
        e.mat[14] = 0,
        e.mat[15] = 1,
        e
    }
    ,
    t.math.Matrix4.createByAxisAndAngle = function(e, i, n) {
        n = n || new t.math.Matrix4;
        var r = this.mat
          , c = Math.cos(i);
        return i = Math.sin(i),
        e = new t.math.Vec3(e),
        e.normalize(),
        r[0] = c + e.x * e.x * (1 - c),
        r[1] = e.z * i + e.y * e.x * (1 - c),
        r[2] = -e.y * i + e.z * e.x * (1 - c),
        r[3] = 0,
        r[4] = -e.z * i + e.x * e.y * (1 - c),
        r[5] = c + e.y * e.y * (1 - c),
        r[6] = e.x * i + e.z * e.y * (1 - c),
        r[7] = 0,
        r[8] = e.y * i + e.x * e.z * (1 - c),
        r[9] = -e.x * i + e.y * e.z * (1 - c),
        r[10] = c + e.z * e.z * (1 - c),
        r[11] = 0,
        r[12] = r[13] = r[14] = 0,
        r[15] = 1,
        n
    }
    ,
    e.extractRotation = function() {
        var e = new t.math.Matrix3
          , i = this.mat
          , n = e.mat;
        return n[0] = i[0],
        n[1] = i[1],
        n[2] = i[2],
        n[3] = i[4],
        n[4] = i[5],
        n[5] = i[6],
        n[6] = i[8],
        n[7] = i[9],
        n[8] = i[10],
        e
    }
    ,
    e.extractPlane = function(e) {
        var i = new t.math.Plane
          , n = this.mat;
        switch (e) {
        case t.math.Plane.RIGHT:
            i.a = n[3] - n[0],
            i.b = n[7] - n[4],
            i.c = n[11] - n[8],
            i.d = n[15] - n[12];
            break;
        case t.math.Plane.LEFT:
            i.a = n[3] + n[0],
            i.b = n[7] + n[4],
            i.c = n[11] + n[8],
            i.d = n[15] + n[12];
            break;
        case t.math.Plane.BOTTOM:
            i.a = n[3] + n[1],
            i.b = n[7] + n[5],
            i.c = n[11] + n[9],
            i.d = n[15] + n[13];
            break;
        case t.math.Plane.TOP:
            i.a = n[3] - n[1],
            i.b = n[7] - n[5],
            i.c = n[11] - n[9],
            i.d = n[15] - n[13];
            break;
        case t.math.Plane.FAR:
            i.a = n[3] - n[2],
            i.b = n[7] - n[6],
            i.c = n[11] - n[10],
            i.d = n[15] - n[14];
            break;
        case t.math.Plane.NEAR:
            i.a = n[3] + n[2],
            i.b = n[7] + n[6],
            i.c = n[11] + n[10],
            i.d = n[15] + n[14];
            break;
        default:
            t.log("cc.math.Matrix4.extractPlane: Invalid plane index")
        }
        return e = Math.sqrt(i.a * i.a + i.b * i.b + i.c * i.c),
        i.a /= e,
        i.b /= e,
        i.c /= e,
        i.d /= e,
        i
    }
    ,
    e.toAxisAndAngle = function() {
        var e = this.extractRotation();
        return t.math.Quaternion.rotationMatrix(e).toAxisAndAngle()
    }
}(cc),
function(t) {
    t.math.Plane = function(t, e, i, n) {
        t && void 0 === e ? (this.a = t.a,
        this.b = t.b,
        this.c = t.c,
        this.d = t.d) : (this.a = t || 0,
        this.b = e || 0,
        this.c = i || 0,
        this.d = n || 0)
    }
    ,
    t.kmPlane = t.math.Plane;
    var e = t.math.Plane.prototype;
    t.math.Plane.LEFT = 0,
    t.math.Plane.RIGHT = 1,
    t.math.Plane.BOTTOM = 2,
    t.math.Plane.TOP = 3,
    t.math.Plane.NEAR = 4,
    t.math.Plane.FAR = 5,
    t.math.Plane.POINT_INFRONT_OF_PLANE = 0,
    t.math.Plane.POINT_BEHIND_PLANE = 1,
    t.math.Plane.POINT_ON_PLANE = 2,
    e.dot = function(t) {
        return this.a * t.x + this.b * t.y + this.c * t.z + this.d * t.w
    }
    ,
    e.dotCoord = function(t) {
        return this.a * t.x + this.b * t.y + this.c * t.z + this.d
    }
    ,
    e.dotNormal = function(t) {
        return this.a * t.x + this.b * t.y + this.c * t.z
    }
    ,
    t.math.Plane.fromPointNormal = function(e, i) {
        return new t.math.Plane(i.x,i.y,i.z,(-i.dot(e)))
    }
    ,
    t.math.Plane.fromPoints = function(e, i, n) {
        i = new t.math.Vec3(i),
        n = new t.math.Vec3(n);
        var r = new t.math.Plane;
        return i.subtract(e),
        n.subtract(e),
        i.cross(n),
        i.normalize(),
        r.a = i.x,
        r.b = i.y,
        r.c = i.z,
        r.d = i.scale(-1).dot(e),
        r
    }
    ,
    e.normalize = function() {
        var e = new t.math.Vec3(this.a,this.b,this.c)
          , i = 1 / e.length();
        return e.normalize(),
        this.a = e.x,
        this.b = e.y,
        this.c = e.z,
        this.d *= i,
        this
    }
    ,
    e.classifyPoint = function(e) {
        return e = this.a * e.x + this.b * e.y + this.c * e.z + this.d,
        .001 < e ? t.math.Plane.POINT_INFRONT_OF_PLANE : -.001 > e ? t.math.Plane.POINT_BEHIND_PLANE : t.math.Plane.POINT_ON_PLANE
    }
}(cc),
function(t) {
    t.math.Quaternion = function(t, e, i, n) {
        t && void 0 === e ? (this.x = t.x,
        this.y = t.y,
        this.z = t.z,
        this.w = t.w) : (this.x = t || 0,
        this.y = e || 0,
        this.z = i || 0,
        this.w = n || 0)
    }
    ,
    t.kmQuaternion = t.math.Quaternion;
    var e = t.math.Quaternion.prototype;
    e.conjugate = function(t) {
        return this.x = -t.x,
        this.y = -t.y,
        this.z = -t.z,
        this.w = t.w,
        this
    }
    ,
    e.dot = function(t) {
        return this.w * t.w + this.x * t.x + this.y * t.y + this.z * t.z
    }
    ,
    e.exponential = function() {
        return this
    }
    ,
    e.identity = function() {
        return this.z = this.y = this.x = 0,
        this.w = 1,
        this
    }
    ,
    e.inverse = function() {
        var e = this.length();
        return Math.abs(e) > t.math.EPSILON ? (this.w = this.z = this.y = this.x = 0,
        this) : (this.conjugate(this).scale(1 / e),
        this)
    }
    ,
    e.isIdentity = function() {
        return 0 === this.x && 0 === this.y && 0 === this.z && 1 === this.w
    }
    ,
    e.length = function() {
        return Math.sqrt(this.lengthSq())
    }
    ,
    e.lengthSq = function() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    ,
    e.multiply = function(t) {
        var e = this.x
          , i = this.y
          , n = this.z
          , r = this.w;
        return this.w = r * t.w - e * t.x - i * t.y - n * t.z,
        this.x = r * t.x + e * t.w + i * t.z - n * t.y,
        this.y = r * t.y + i * t.w + n * t.x - e * t.z,
        this.z = r * t.z + n * t.w + e * t.y - i * t.x,
        this
    }
    ,
    e.normalize = function() {
        var e = this.length();
        if (Math.abs(e) <= t.math.EPSILON)
            throw Error("current quaternion is an invalid value");
        return this.scale(1 / e),
        this
    }
    ,
    e.rotationAxis = function(t, e) {
        var i = .5 * e
          , n = Math.sin(i);
        return this.w = Math.cos(i),
        this.x = t.x * n,
        this.y = t.y * n,
        this.z = t.z * n,
        this
    }
    ,
    t.math.Quaternion.rotationMatrix = function(e) {
        if (!e)
            return null;
        var i, n, r;
        i = [],
        n = e.mat,
        e = 0,
        i[0] = n[0],
        i[1] = n[3],
        i[2] = n[6],
        i[4] = n[1],
        i[5] = n[4],
        i[6] = n[7],
        i[8] = n[2],
        i[9] = n[5],
        i[10] = n[8],
        i[15] = 1;
        var c = i[0];
        return e = c[0] + c[5] + c[10] + 1,
        e > t.math.EPSILON ? (e = 2 * Math.sqrt(e),
        i = (c[9] - c[6]) / e,
        n = (c[2] - c[8]) / e,
        r = (c[4] - c[1]) / e,
        e *= .25) : c[0] > c[5] && c[0] > c[10] ? (e = 2 * Math.sqrt(1 + c[0] - c[5] - c[10]),
        i = .25 * e,
        n = (c[4] + c[1]) / e,
        r = (c[2] + c[8]) / e,
        e = (c[9] - c[6]) / e) : c[5] > c[10] ? (e = 2 * Math.sqrt(1 + c[5] - c[0] - c[10]),
        i = (c[4] + c[1]) / e,
        n = .25 * e,
        r = (c[9] + c[6]) / e,
        e = (c[2] - c[8]) / e) : (e = 2 * Math.sqrt(1 + c[10] - c[0] - c[5]),
        i = (c[2] + c[8]) / e,
        n = (c[9] + c[6]) / e,
        r = .25 * e,
        e = (c[4] - c[1]) / e),
        new t.math.Quaternion(i,n,r,e)
    }
    ,
    t.math.Quaternion.rotationYawPitchRoll = function(e, i, n) {
        var r, c, s, o, a;
        r = t.degreesToRadians(i) / 2,
        c = t.degreesToRadians(e) / 2,
        s = t.degreesToRadians(n) / 2,
        n = Math.cos(r),
        e = Math.cos(c),
        i = Math.cos(s),
        r = Math.sin(r),
        c = Math.sin(c),
        s = Math.sin(s),
        o = e * i,
        a = c * s;
        var h = new t.math.Quaternion;
        return h.w = n * o + r * a,
        h.x = r * o - n * a,
        h.y = n * c * i + r * e * s,
        h.z = n * e * s - r * c * i,
        h.normalize(),
        h
    }
    ,
    e.slerp = function(e, i) {
        if (this.x === e.x && this.y === e.y && this.z === e.z && this.w === e.w)
            return this;
        var n = this.dot(e)
          , r = Math.acos(n)
          , c = Math.sqrt(1 - t.math.square(n))
          , n = Math.sin(i * r) / c
          , r = Math.sin((1 - i) * r) / c
          , c = new t.math.Quaternion(e);
        return this.scale(r),
        c.scale(n),
        this.add(c),
        this
    }
    ,
    e.toAxisAndAngle = function() {
        var e, i, n = new t.math.Vec3;
        return e = Math.acos(this.w),
        i = Math.sqrt(t.math.square(this.x) + t.math.square(this.y) + t.math.square(this.z)),
        i > -t.math.EPSILON && i < t.math.EPSILON || i < 2 * Math.PI + t.math.EPSILON && i > 2 * Math.PI - t.math.EPSILON ? (e = 0,
        n.x = 0,
        n.y = 0,
        n.z = 1) : (e *= 2,
        n.x = this.x / i,
        n.y = this.y / i,
        n.z = this.z / i,
        n.normalize()),
        {
            axis: n,
            angle: e
        }
    }
    ,
    e.scale = function(t) {
        return this.x *= t,
        this.y *= t,
        this.z *= t,
        this.w *= t,
        this
    }
    ,
    e.assignFrom = function(t) {
        return this.x = t.x,
        this.y = t.y,
        this.z = t.z,
        this.w = t.w,
        this
    }
    ,
    e.add = function(t) {
        return this.x += t.x,
        this.y += t.y,
        this.z += t.z,
        this.w += t.w,
        this
    }
    ,
    t.math.Quaternion.rotationBetweenVec3 = function(e, i, n) {
        var r = new t.math.Vec3(e)
          , c = new t.math.Vec3(i);
        r.normalize(),
        c.normalize();
        var s = r.dot(c);
        return i = new t.math.Quaternion,
        1 <= s ? (i.identity(),
        i) : (-.999999 > s ? Math.abs(n.lengthSq()) < t.math.EPSILON ? i.rotationAxis(n, Math.PI) : (r = new t.math.Vec3(1,0,0),
        r.cross(e),
        Math.abs(r.lengthSq()) < t.math.EPSILON && (r.fill(0, 1, 0),
        r.cross(e)),
        r.normalize(),
        i.rotationAxis(r, Math.PI)) : (e = Math.sqrt(2 * (1 + s)),
        n = 1 / e,
        r.cross(c),
        i.x = r.x * n,
        i.y = r.y * n,
        i.z = r.z * n,
        i.w = .5 * e,
        i.normalize()),
        i)
    }
    ,
    e.multiplyVec3 = function(e) {
        var i = this.x
          , n = this.y
          , r = this.z
          , c = new t.math.Vec3(e)
          , s = new t.math.Vec3(i,n,r)
          , i = new t.math.Vec3(i,n,r);
        return s.cross(e),
        i.cross(s),
        s.scale(2 * q.w),
        i.scale(2),
        c.add(s),
        c.add(i),
        c
    }
}(cc),
cc.math.AABB = function(t, e) {
    this.min = t || new cc.math.Vec3,
    this.max = e || new cc.math.Vec3
}
,
cc.math.AABB.prototype.containsPoint = function(t) {
    return t.x >= this.min.x && t.x <= this.max.x && t.y >= this.min.y && t.y <= this.max.y && t.z >= this.min.z && t.z <= this.max.z
}
,
cc.math.AABB.containsPoint = function(t, e) {
    return t.x >= e.min.x && t.x <= e.max.x && t.y >= e.min.y && t.y <= e.max.y && t.z >= e.min.z && t.z <= e.max.z
}
,
cc.math.AABB.prototype.assignFrom = function(t) {
    this.min.assignFrom(t.min),
    this.max.assignFrom(t.max)
}
,
cc.math.AABB.assign = function(t, e) {
    return t.min.assignFrom(e.min),
    t.max.assignFrom(e.max),
    t
}
,
function(t) {
    t.math.Matrix4Stack = function(t, e) {
        this.top = t,
        this.stack = e || []
    }
    ,
    t.km_mat4_stack = t.math.Matrix4Stack;
    var e = t.math.Matrix4Stack.prototype;
    e.initialize = function() {
        this.stack.length = 0,
        this.top = null
    }
    ,
    t.km_mat4_stack_push = function(e, i) {
        e.stack.push(e.top),
        e.top = new t.math.Matrix4(i)
    }
    ,
    t.km_mat4_stack_pop = function(t, e) {
        t.top = t.stack.pop()
    }
    ,
    t.km_mat4_stack_release = function(t) {
        t.stack = null,
        t.top = null
    }
    ,
    e.push = function(e) {
        e = e || this.top,
        this.stack.push(this.top),
        this.top = new t.math.Matrix4(e)
    }
    ,
    e.pop = function() {
        this.top = this.stack.pop()
    }
    ,
    e.release = function() {
        this._matrixPool = this.top = this.stack = null
    }
    ,
    e._getFromPool = function(e) {
        var i = this._matrixPool;
        return 0 === i.length ? new t.math.Matrix4(e) : (i = i.pop(),
        i.assignFrom(e),
        i)
    }
    ,
    e._putInPool = function(t) {
        this._matrixPool.push(t)
    }
}(cc),
function(t) {
    t.KM_GL_MODELVIEW = 5888,
    t.KM_GL_PROJECTION = 5889,
    t.KM_GL_TEXTURE = 5890,
    t.modelview_matrix_stack = new t.math.Matrix4Stack,
    t.projection_matrix_stack = new t.math.Matrix4Stack,
    t.texture_matrix_stack = new t.math.Matrix4Stack,
    t.current_stack = null,
    t.lazyInitialize = function() {
        var e = new t.math.Matrix4;
        t.modelview_matrix_stack.initialize(),
        t.projection_matrix_stack.initialize(),
        t.texture_matrix_stack.initialize(),
        t.current_stack = t.modelview_matrix_stack,
        t.initialized = !0,
        e.identity(),
        t.modelview_matrix_stack.push(e),
        t.projection_matrix_stack.push(e),
        t.texture_matrix_stack.push(e)
    }
    ,
    t.lazyInitialize(),
    t.kmGLFreeAll = function() {
        t.modelview_matrix_stack.release(),
        t.modelview_matrix_stack = null,
        t.projection_matrix_stack.release(),
        t.projection_matrix_stack = null,
        t.texture_matrix_stack.release(),
        t.texture_matrix_stack = null,
        t.initialized = !1,
        t.current_stack = null
    }
    ,
    t.kmGLPushMatrix = function() {
        t.current_stack.push(t.current_stack.top)
    }
    ,
    t.kmGLPushMatrixWitMat4 = function(e) {
        t.current_stack.stack.push(t.current_stack.top),
        e.assignFrom(t.current_stack.top),
        t.current_stack.top = e
    }
    ,
    t.kmGLPopMatrix = function() {
        t.current_stack.top = t.current_stack.stack.pop()
    }
    ,
    t.kmGLMatrixMode = function(e) {
        switch (e) {
        case t.KM_GL_MODELVIEW:
            t.current_stack = t.modelview_matrix_stack;
            break;
        case t.KM_GL_PROJECTION:
            t.current_stack = t.projection_matrix_stack;
            break;
        case t.KM_GL_TEXTURE:
            t.current_stack = t.texture_matrix_stack;
            break;
        default:
            throw Error("Invalid matrix mode specified")
        }
    }
    ,
    t.kmGLLoadIdentity = function() {
        t.current_stack.top.identity()
    }
    ,
    t.kmGLLoadMatrix = function(e) {
        t.current_stack.top.assignFrom(e)
    }
    ,
    t.kmGLMultMatrix = function(e) {
        t.current_stack.top.multiply(e)
    }
    ;
    var e = new t.math.Matrix4;
    t.kmGLTranslatef = function(i, n, r) {
        i = t.math.Matrix4.createByTranslation(i, n, r, e),
        t.current_stack.top.multiply(i)
    }
    ;
    var i = new t.math.Vec3;
    t.kmGLRotatef = function(n, r, c, s) {
        i.fill(r, c, s),
        n = t.math.Matrix4.createByAxisAndAngle(i, t.degreesToRadians(n), e),
        t.current_stack.top.multiply(n)
    }
    ,
    t.kmGLScalef = function(i, n, r) {
        i = t.math.Matrix4.createByScale(i, n, r, e),
        t.current_stack.top.multiply(i)
    }
    ,
    t.kmGLGetMatrix = function(e, i) {
        switch (e) {
        case t.KM_GL_MODELVIEW:
            i.assignFrom(t.modelview_matrix_stack.top);
            break;
        case t.KM_GL_PROJECTION:
            i.assignFrom(t.projection_matrix_stack.top);
            break;
        case t.KM_GL_TEXTURE:
            i.assignFrom(t.texture_matrix_stack.top);
            break;
        default:
            throw Error("Invalid matrix mode specified")
        }
    }
}(cc),
cc.SHADER_POSITION_UCOLOR_FRAG = "precision lowp float;\nvarying vec4 v_fragmentColor;\nvoid main()                              \n{ \n    gl_FragColor = v_fragmentColor;      \n}\n",
cc.SHADER_POSITION_UCOLOR_VERT = "attribute vec4 a_position;\nuniform    vec4 u_color;\nuniform float u_pointSize;\nvarying lowp vec4 v_fragmentColor; \nvoid main(void)   \n{\n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n    gl_PointSize = u_pointSize;          \n    v_fragmentColor = u_color;           \n}",
cc.SHADER_POSITION_COLOR_FRAG = "precision lowp float; \nvarying vec4 v_fragmentColor; \nvoid main() \n{ \n     gl_FragColor = v_fragmentColor; \n} ",
cc.SHADER_POSITION_COLOR_VERT = "attribute vec4 a_position;\nattribute vec4 a_color;\nvarying lowp vec4 v_fragmentColor;\nvoid main()\n{\n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor = a_color;             \n}",
cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_FRAG = "// #extension GL_OES_standard_derivatives : enable\nvarying mediump vec4 v_color;\nvarying mediump vec2 v_texcoord;\nvoid main()\t\n{ \n// #if defined GL_OES_standard_derivatives\t\n// gl_FragColor = v_color*smoothstep(0.0, length(fwidth(v_texcoord)), 1.0 - length(v_texcoord)); \n// #else\t\ngl_FragColor = v_color * step(0.0, 1.0 - length(v_texcoord)); \n// #endif \n}",
cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_VERT = "attribute mediump vec4 a_position; \nattribute mediump vec2 a_texcoord; \nattribute mediump vec4 a_color;\t\nvarying mediump vec4 v_color; \nvarying mediump vec2 v_texcoord;\t\nvoid main() \n{ \n     v_color = a_color;//vec4(a_color.rgb * a_color.a, a_color.a); \n     v_texcoord = a_texcoord; \n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n}",
cc.SHADER_POSITION_TEXTURE_FRAG = "precision lowp float;   \nvarying vec2 v_texCoord;  \nvoid main() \n{  \n    gl_FragColor =  texture2D(CC_Texture0, v_texCoord);   \n}",
cc.SHADER_POSITION_TEXTURE_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_texCoord = a_texCoord;               \n}",
cc.SHADER_POSITION_TEXTURE_UCOLOR_FRAG = "precision lowp float;  \nuniform vec4 u_color; \nvarying vec2 v_texCoord; \nvoid main() \n{  \n    gl_FragColor =  texture2D(CC_Texture0, v_texCoord) * u_color;    \n}",
cc.SHADER_POSITION_TEXTURE_UCOLOR_VERT = "attribute vec4 a_position;\nattribute vec2 a_texCoord; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_texCoord = a_texCoord;                 \n}",
cc.SHADER_POSITION_TEXTURE_A8COLOR_FRAG = "precision lowp float;  \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nvoid main() \n{ \n    gl_FragColor = vec4( v_fragmentColor.rgb,         \n        v_fragmentColor.a * texture2D(CC_Texture0, v_texCoord).a   \n    ); \n}",
cc.SHADER_POSITION_TEXTURE_A8COLOR_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nattribute vec4 a_color;  \nvarying lowp vec4 v_fragmentColor; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor = a_color; \n    v_texCoord = a_texCoord; \n}",
cc.SHADER_POSITION_TEXTURE_COLOR_FRAG = "precision lowp float;\nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nvoid main() \n{ \n    gl_FragColor = v_fragmentColor * texture2D(CC_Texture0, v_texCoord); \n}",
cc.SHADER_POSITION_TEXTURE_COLOR_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nattribute vec4 a_color;  \nvarying lowp vec4 v_fragmentColor; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor = a_color; \n    v_texCoord = a_texCoord; \n}",
cc.SHADER_POSITION_TEXTURE_COLOR_ALPHATEST_FRAG = "precision lowp float;   \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord;   \nuniform float CC_alpha_value; \nvoid main() \n{  \n    vec4 texColor = texture2D(CC_Texture0, v_texCoord);  \n    if ( texColor.a <= CC_alpha_value )          \n        discard; \n    gl_FragColor = texColor * v_fragmentColor;  \n}",
cc.SHADEREX_SWITCHMASK_FRAG = "precision lowp float; \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nuniform sampler2D u_texture;  \nuniform sampler2D   u_mask;   \nvoid main()  \n{  \n    vec4 texColor   = texture2D(u_texture, v_texCoord);  \n    vec4 maskColor  = texture2D(u_mask, v_texCoord); \n    vec4 finalColor = vec4(texColor.r, texColor.g, texColor.b, maskColor.a * texColor.a);        \n    gl_FragColor    = v_fragmentColor * finalColor; \n}",
cc.shaderCache = {
    TYPE_POSITION_TEXTURECOLOR: 0,
    TYPE_POSITION_TEXTURECOLOR_ALPHATEST: 1,
    TYPE_POSITION_COLOR: 2,
    TYPE_POSITION_TEXTURE: 3,
    TYPE_POSITION_TEXTURE_UCOLOR: 4,
    TYPE_POSITION_TEXTURE_A8COLOR: 5,
    TYPE_POSITION_UCOLOR: 6,
    TYPE_POSITION_LENGTH_TEXTURECOLOR: 7,
    TYPE_MAX: 8,
    _programs: {},
    _init: function() {
        return this.loadDefaultShaders(),
        !0
    },
    _loadDefaultShader: function(t, e) {
        switch (e) {
        case this.TYPE_POSITION_TEXTURECOLOR:
            t.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_COLOR_VERT, cc.SHADER_POSITION_TEXTURE_COLOR_FRAG),
            t.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION),
            t.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR),
            t.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
            break;
        case this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST:
            t.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_COLOR_VERT, cc.SHADER_POSITION_TEXTURE_COLOR_ALPHATEST_FRAG),
            t.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION),
            t.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR),
            t.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
            break;
        case this.TYPE_POSITION_COLOR:
            t.initWithVertexShaderByteArray(cc.SHADER_POSITION_COLOR_VERT, cc.SHADER_POSITION_COLOR_FRAG),
            t.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION),
            t.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
            break;
        case this.TYPE_POSITION_TEXTURE:
            t.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_VERT, cc.SHADER_POSITION_TEXTURE_FRAG),
            t.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION),
            t.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
            break;
        case this.TYPE_POSITION_TEXTURE_UCOLOR:
            t.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_UCOLOR_VERT, cc.SHADER_POSITION_TEXTURE_UCOLOR_FRAG),
            t.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION),
            t.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
            break;
        case this.TYPE_POSITION_TEXTURE_A8COLOR:
            t.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_A8COLOR_VERT, cc.SHADER_POSITION_TEXTURE_A8COLOR_FRAG),
            t.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION),
            t.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR),
            t.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
            break;
        case this.TYPE_POSITION_UCOLOR:
            t.initWithVertexShaderByteArray(cc.SHADER_POSITION_UCOLOR_VERT, cc.SHADER_POSITION_UCOLOR_FRAG),
            t.addAttribute("aVertex", cc.VERTEX_ATTRIB_POSITION);
            break;
        case this.TYPE_POSITION_LENGTH_TEXTURECOLOR:
            t.initWithVertexShaderByteArray(cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_VERT, cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_FRAG),
            t.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION),
            t.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS),
            t.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
            break;
        default:
            return void cc.log("cocos2d: cc.shaderCache._loadDefaultShader, error shader type")
        }
        t.link(),
        t.updateUniforms()
    },
    loadDefaultShaders: function() {
        var t = new cc.GLProgram;
        this._loadDefaultShader(t, this.TYPE_POSITION_TEXTURECOLOR),
        this._programs[cc.SHADER_POSITION_TEXTURECOLOR] = t,
        this._programs.ShaderPositionTextureColor = t,
        t = new cc.GLProgram,
        this._loadDefaultShader(t, this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST),
        this._programs[cc.SHADER_POSITION_TEXTURECOLORALPHATEST] = t,
        this._programs.ShaderPositionTextureColorAlphaTest = t,
        t = new cc.GLProgram,
        this._loadDefaultShader(t, this.TYPE_POSITION_COLOR),
        this._programs[cc.SHADER_POSITION_COLOR] = t,
        this._programs.ShaderPositionColor = t,
        t = new cc.GLProgram,
        this._loadDefaultShader(t, this.TYPE_POSITION_TEXTURE),
        this._programs[cc.SHADER_POSITION_TEXTURE] = t,
        this._programs.ShaderPositionTexture = t,
        t = new cc.GLProgram,
        this._loadDefaultShader(t, this.TYPE_POSITION_TEXTURE_UCOLOR),
        this._programs[cc.SHADER_POSITION_TEXTURE_UCOLOR] = t,
        this._programs.ShaderPositionTextureUColor = t,
        t = new cc.GLProgram,
        this._loadDefaultShader(t, this.TYPE_POSITION_TEXTURE_A8COLOR),
        this._programs[cc.SHADER_POSITION_TEXTUREA8COLOR] = t,
        this._programs.ShaderPositionTextureA8Color = t,
        t = new cc.GLProgram,
        this._loadDefaultShader(t, this.TYPE_POSITION_UCOLOR),
        this._programs[cc.SHADER_POSITION_UCOLOR] = t,
        this._programs.ShaderPositionUColor = t,
        t = new cc.GLProgram,
        this._loadDefaultShader(t, this.TYPE_POSITION_LENGTH_TEXTURECOLOR),
        this._programs[cc.SHADER_POSITION_LENGTHTEXTURECOLOR] = t,
        this._programs.ShaderPositionLengthTextureColor = t
    },
    reloadDefaultShaders: function() {
        var t = this.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
        t.reset(),
        this._loadDefaultShader(t, this.TYPE_POSITION_TEXTURECOLOR),
        t = this.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST),
        t.reset(),
        this._loadDefaultShader(t, this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST),
        t = this.programForKey(cc.SHADER_POSITION_COLOR),
        t.reset(),
        this._loadDefaultShader(t, this.TYPE_POSITION_COLOR),
        t = this.programForKey(cc.SHADER_POSITION_TEXTURE),
        t.reset(),
        this._loadDefaultShader(t, this.TYPE_POSITION_TEXTURE),
        t = this.programForKey(cc.SHADER_POSITION_TEXTURE_UCOLOR),
        t.reset(),
        this._loadDefaultShader(t, this.TYPE_POSITION_TEXTURE_UCOLOR),
        t = this.programForKey(cc.SHADER_POSITION_TEXTUREA8COLOR),
        t.reset(),
        this._loadDefaultShader(t, this.TYPE_POSITION_TEXTURE_A8COLOR),
        t = this.programForKey(cc.SHADER_POSITION_UCOLOR),
        t.reset(),
        this._loadDefaultShader(t, this.TYPE_POSITION_UCOLOR)
    },
    programForKey: function(t) {
        return this._programs[t]
    },
    getProgram: function(t) {
        return this._programs[t]
    },
    addProgram: function(t, e) {
        this._programs[e] = t
    }
},
cc.HashUniformEntry = function(t, e, i) {
    this.value = t,
    this.location = e,
    this.hh = i || {}
}
,
cc.GLProgram = cc.Class.extend({
    _glContext: null,
    _programObj: null,
    _vertShader: null,
    _fragShader: null,
    _uniforms: null,
    _hashForUniforms: null,
    _usesTime: !1,
    _updateUniformLocation: function(t, e, i) {
        if (null == t)
            return !1;
        i = !0;
        for (var n = null, r = 0; r < this._hashForUniforms.length; r++)
            this._hashForUniforms[r].location == t && (n = this._hashForUniforms[r]);
        return n ? n.value == e ? i = !1 : n.value = e : (n = new cc.HashUniformEntry,
        n.location = t,
        n.value = e,
        this._hashForUniforms.push(n)),
        i
    },
    _description: function() {
        return "<CCGLProgram = " + this.toString() + " | Program = " + this._programObj.toString() + ", VertexShader = " + this._vertShader.toString() + ", FragmentShader = " + this._fragShader.toString() + ">"
    },
    _compileShader: function(t, e, i) {
        return !(!i || !t) && (i = (cc.GLProgram._isHighpSupported() ? "precision highp float;\n" : "precision mediump float;\n") + "uniform mat4 CC_PMatrix;         \nuniform mat4 CC_MVMatrix;        \nuniform mat4 CC_MVPMatrix;       \nuniform vec4 CC_Time;            \nuniform vec4 CC_SinTime;         \nuniform vec4 CC_CosTime;         \nuniform vec4 CC_Random01;        \nuniform sampler2D CC_Texture0;   \n//CC INCLUDES END                \n" + i,
        this._glContext.shaderSource(t, i),
        this._glContext.compileShader(t),
        i = this._glContext.getShaderParameter(t, this._glContext.COMPILE_STATUS),
        i || (cc.log("cocos2d: ERROR: Failed to compile shader:\n" + this._glContext.getShaderSource(t)),
        e === this._glContext.VERTEX_SHADER ? cc.log("cocos2d: \n" + this.vertexShaderLog()) : cc.log("cocos2d: \n" + this.fragmentShaderLog())),
        !0 === i)
    },
    ctor: function(t, e, i) {
        this._uniforms = [],
        this._hashForUniforms = [],
        this._glContext = i || cc._renderContext,
        t && e && this.init(t, e)
    },
    destroyProgram: function() {
        this._hashForUniforms = this._uniforms = this._fragShader = this._vertShader = null,
        this._glContext.deleteProgram(this._programObj)
    },
    initWithVertexShaderByteArray: function(t, e) {
        var i = this._glContext;
        return this._programObj = i.createProgram(),
        this._fragShader = this._vertShader = null,
        t && (this._vertShader = i.createShader(i.VERTEX_SHADER),
        this._compileShader(this._vertShader, i.VERTEX_SHADER, t) || cc.log("cocos2d: ERROR: Failed to compile vertex shader")),
        e && (this._fragShader = i.createShader(i.FRAGMENT_SHADER),
        this._compileShader(this._fragShader, i.FRAGMENT_SHADER, e) || cc.log("cocos2d: ERROR: Failed to compile fragment shader")),
        this._vertShader && i.attachShader(this._programObj, this._vertShader),
        cc.checkGLErrorDebug(),
        this._fragShader && i.attachShader(this._programObj, this._fragShader),
        this._hashForUniforms.length = 0,
        cc.checkGLErrorDebug(),
        !0
    },
    initWithString: function(t, e) {
        return this.initWithVertexShaderByteArray(t, e)
    },
    initWithVertexShaderFilename: function(t, e) {
        var i = cc.loader.getRes(t);
        if (!i)
            throw Error("Please load the resource firset : " + t);
        var n = cc.loader.getRes(e);
        if (!n)
            throw Error("Please load the resource firset : " + e);
        return this.initWithVertexShaderByteArray(i, n)
    },
    init: function(t, e) {
        return this.initWithVertexShaderFilename(t, e)
    },
    addAttribute: function(t, e) {
        this._glContext.bindAttribLocation(this._programObj, e, t)
    },
    link: function() {
        return this._programObj ? (this._glContext.linkProgram(this._programObj),
        this._vertShader && this._glContext.deleteShader(this._vertShader),
        this._fragShader && this._glContext.deleteShader(this._fragShader),
        this._fragShader = this._vertShader = null,
        !(cc.game.config[cc.game.CONFIG_KEY.debugMode] && !this._glContext.getProgramParameter(this._programObj, this._glContext.LINK_STATUS)) || (cc.log("cocos2d: ERROR: Failed to link program: " + this._glContext.getProgramInfoLog(this._programObj)),
        cc.glDeleteProgram(this._programObj),
        this._programObj = null,
        !1)) : (cc.log("cc.GLProgram.link(): Cannot link invalid program"),
        !1)
    },
    use: function() {
        cc.glUseProgram(this._programObj)
    },
    updateUniforms: function() {
        this._uniforms[cc.UNIFORM_PMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_PMATRIX_S),
        this._uniforms[cc.UNIFORM_MVMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_MVMATRIX_S),
        this._uniforms[cc.UNIFORM_MVPMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_MVPMATRIX_S),
        this._uniforms[cc.UNIFORM_TIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_TIME_S),
        this._uniforms[cc.UNIFORM_SINTIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_SINTIME_S),
        this._uniforms[cc.UNIFORM_COSTIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_COSTIME_S),
        this._usesTime = null != this._uniforms[cc.UNIFORM_TIME] || null != this._uniforms[cc.UNIFORM_SINTIME] || null != this._uniforms[cc.UNIFORM_COSTIME],
        this._uniforms[cc.UNIFORM_RANDOM01] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_RANDOM01_S),
        this._uniforms[cc.UNIFORM_SAMPLER] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_SAMPLER_S),
        this.use(),
        this.setUniformLocationWith1i(this._uniforms[cc.UNIFORM_SAMPLER], 0)
    },
    getUniformLocationForName: function(t) {
        if (!t)
            throw Error("cc.GLProgram.getUniformLocationForName(): uniform name should be non-null");
        if (!this._programObj)
            throw Error("cc.GLProgram.getUniformLocationForName(): Invalid operation. Cannot get uniform location when program is not initialized");
        return this._glContext.getUniformLocation(this._programObj, t)
    },
    getUniformMVPMatrix: function() {
        return this._uniforms[cc.UNIFORM_MVPMATRIX]
    },
    getUniformSampler: function() {
        return this._uniforms[cc.UNIFORM_SAMPLER]
    },
    setUniformLocationWith1i: function(t, e) {
        this._updateUniformLocation(t, e) && this._glContext.uniform1i(t, e)
    },
    setUniformLocationWith2i: function(t, e, i) {
        this._updateUniformLocation(t, [e, i]) && this._glContext.uniform2i(t, e, i)
    },
    setUniformLocationWith3i: function(t, e, i, n) {
        this._updateUniformLocation(t, [e, i, n]) && this._glContext.uniform3i(t, e, i, n)
    },
    setUniformLocationWith4i: function(t, e, i, n, r) {
        this._updateUniformLocation(t, [e, i, n, r]) && this._glContext.uniform4i(t, e, i, n, r)
    },
    setUniformLocationWith2iv: function(t, e, i) {
        this._updateUniformLocation(t, e) && this._glContext.uniform2iv(t, e)
    },
    setUniformLocationWith3iv: function(t, e, i) {
        this._updateUniformLocation(t, e) && this._glContext.uniform3iv(t, e)
    },
    setUniformLocationWith4iv: function(t, e, i) {
        this._updateUniformLocation(t, e) && this._glContext.uniform4iv(t, e)
    },
    setUniformLocationI32: function(t, e) {
        this.setUniformLocationWith1i(t, e)
    },
    setUniformLocationWith1f: function(t, e) {
        this._updateUniformLocation(t, e) && this._glContext.uniform1f(t, e)
    },
    setUniformLocationWith2f: function(t, e, i) {
        this._updateUniformLocation(t, [e, i]) && this._glContext.uniform2f(t, e, i)
    },
    setUniformLocationWith3f: function(t, e, i, n) {
        this._updateUniformLocation(t, [e, i, n]) && this._glContext.uniform3f(t, e, i, n)
    },
    setUniformLocationWith4f: function(t, e, i, n, r) {
        this._updateUniformLocation(t, [e, i, n, r]) && this._glContext.uniform4f(t, e, i, n, r)
    },
    setUniformLocationWith2fv: function(t, e, i) {
        this._updateUniformLocation(t, e) && this._glContext.uniform2fv(t, e)
    },
    setUniformLocationWith3fv: function(t, e, i) {
        this._updateUniformLocation(t, e) && this._glContext.uniform3fv(t, e)
    },
    setUniformLocationWith4fv: function(t, e, i) {
        this._updateUniformLocation(t, e) && this._glContext.uniform4fv(t, e)
    },
    setUniformLocationWithMatrix4fv: function(t, e, i) {
        this._updateUniformLocation(t, e) && this._glContext.uniformMatrix4fv(t, !1, e)
    },
    setUniformLocationF32: function() {
        if (!(2 > arguments.length))
            switch (arguments.length) {
            case 2:
                this.setUniformLocationWith1f(arguments[0], arguments[1]);
                break;
            case 3:
                this.setUniformLocationWith2f(arguments[0], arguments[1], arguments[2]);
                break;
            case 4:
                this.setUniformLocationWith3f(arguments[0], arguments[1], arguments[2], arguments[3]);
                break;
            case 5:
                this.setUniformLocationWith4f(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4])
            }
    },
    setUniformsForBuiltins: function() {
        var t = new cc.math.Matrix4
          , e = new cc.math.Matrix4
          , i = new cc.math.Matrix4;
        cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, t),
        cc.kmGLGetMatrix(cc.KM_GL_MODELVIEW, e),
        cc.kmMat4Multiply(i, t, e),
        this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], t.mat, 1),
        this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], e.mat, 1),
        this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], i.mat, 1),
        this._usesTime && (t = cc.director,
        t = t.getTotalFrames() * t.getAnimationInterval(),
        this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_TIME], t / 10, t, 2 * t, 4 * t),
        this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_SINTIME], t / 8, t / 4, t / 2, Math.sin(t)),
        this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_COSTIME], t / 8, t / 4, t / 2, Math.cos(t))),
        -1 !== this._uniforms[cc.UNIFORM_RANDOM01] && this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_RANDOM01], Math.random(), Math.random(), Math.random(), Math.random())
    },
    _setUniformsForBuiltinsForRenderer: function(t) {
        if (t && t._renderCmd) {
            var e = new cc.math.Matrix4
              , i = new cc.math.Matrix4;
            cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, e),
            cc.kmMat4Multiply(i, e, t._renderCmd._stackMatrix),
            this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], e.mat, 1),
            this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], t._renderCmd._stackMatrix.mat, 1),
            this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], i.mat, 1),
            this._usesTime && (t = cc.director,
            t = t.getTotalFrames() * t.getAnimationInterval(),
            this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_TIME], t / 10, t, 2 * t, 4 * t),
            this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_SINTIME], t / 8, t / 4, t / 2, Math.sin(t)),
            this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_COSTIME], t / 8, t / 4, t / 2, Math.cos(t))),
            -1 !== this._uniforms[cc.UNIFORM_RANDOM01] && this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_RANDOM01], Math.random(), Math.random(), Math.random(), Math.random())
        }
    },
    setUniformForModelViewProjectionMatrix: function() {
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], !1, cc.getMat4MultiplyValue(cc.projection_matrix_stack.top, cc.modelview_matrix_stack.top))
    },
    setUniformForModelViewProjectionMatrixWithMat4: function(t) {
        cc.kmMat4Multiply(t, cc.projection_matrix_stack.top, cc.modelview_matrix_stack.top),
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], !1, t.mat)
    },
    setUniformForModelViewAndProjectionMatrixWithMat4: function() {
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], !1, cc.modelview_matrix_stack.top.mat),
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], !1, cc.projection_matrix_stack.top.mat)
    },
    _setUniformForMVPMatrixWithMat4: function(t) {
        if (!t)
            throw Error("modelView matrix is undefined.");
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], !1, t.mat),
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], !1, cc.projection_matrix_stack.top.mat)
    },
    vertexShaderLog: function() {
        return this._glContext.getShaderInfoLog(this._vertShader)
    },
    getVertexShaderLog: function() {
        return this._glContext.getShaderInfoLog(this._vertShader)
    },
    getFragmentShaderLog: function() {
        return this._glContext.getShaderInfoLog(this._vertShader)
    },
    fragmentShaderLog: function() {
        return this._glContext.getShaderInfoLog(this._fragShader)
    },
    programLog: function() {
        return this._glContext.getProgramInfoLog(this._programObj)
    },
    getProgramLog: function() {
        return this._glContext.getProgramInfoLog(this._programObj)
    },
    reset: function() {
        this._fragShader = this._vertShader = null,
        this._uniforms.length = 0,
        this._glContext.deleteProgram(this._programObj),
        this._programObj = null;
        for (var t = 0; t < this._hashForUniforms.length; t++)
            this._hashForUniforms[t].value = null,
            this._hashForUniforms[t] = null;
        this._hashForUniforms.length = 0
    },
    getProgram: function() {
        return this._programObj
    },
    retain: function() {},
    release: function() {}
}),
cc.GLProgram.create = function(t, e) {
    return new cc.GLProgram(t,e)
}
,
cc.GLProgram._highpSupported = null,
cc.GLProgram._isHighpSupported = function() {
    if (null == cc.GLProgram._highpSupported) {
        var t = cc._renderContext
          , t = t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT);
        cc.GLProgram._highpSupported = 0 !== t.precision
    }
    return cc.GLProgram._highpSupported
}
,
cc.setProgram = function(t, e) {
    t.shaderProgram = e;
    var i = t.children;
    if (i)
        for (var n = 0; n < i.length; n++)
            cc.setProgram(i[n], e)
}
,
cc._currentProjectionMatrix = -1,
cc._vertexAttribPosition = !1,
cc._vertexAttribColor = !1,
cc._vertexAttribTexCoords = !1,
cc.ENABLE_GL_STATE_CACHE && (cc.MAX_ACTIVETEXTURE = 16,
cc._currentShaderProgram = -1,
cc._currentBoundTexture = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
cc._blendingSource = -1,
cc._blendingDest = -1,
cc._GLServerState = 0,
cc.TEXTURE_ATLAS_USE_VAO && (cc._uVAO = 0)),
cc.glInvalidateStateCache = function() {
    if (cc.kmGLFreeAll(),
    cc._currentProjectionMatrix = -1,
    cc._vertexAttribPosition = !1,
    cc._vertexAttribColor = !1,
    cc._vertexAttribTexCoords = !1,
    cc.ENABLE_GL_STATE_CACHE) {
        cc._currentShaderProgram = -1;
        for (var t = 0; t < cc.MAX_ACTIVETEXTURE; t++)
            cc._currentBoundTexture[t] = -1;
        cc._blendingSource = -1,
        cc._blendingDest = -1,
        cc._GLServerState = 0
    }
}
,
cc.glUseProgram = function(t) {
    t !== cc._currentShaderProgram && (cc._currentShaderProgram = t,
    cc._renderContext.useProgram(t))
}
,
cc.ENABLE_GL_STATE_CACHE || (cc.glUseProgram = function(t) {
    cc._renderContext.useProgram(t)
}
),
cc.glDeleteProgram = function(t) {
    cc.ENABLE_GL_STATE_CACHE && t === cc._currentShaderProgram && (cc._currentShaderProgram = -1),
    gl.deleteProgram(t)
}
,
cc.glBlendFunc = function(t, e) {
    t === cc._blendingSource && e === cc._blendingDest || (cc._blendingSource = t,
    cc._blendingDest = e,
    cc.setBlending(t, e))
}
,
cc.setBlending = function(t, e) {
    var i = cc._renderContext;
    t === i.ONE && e === i.ZERO ? i.disable(i.BLEND) : (i.enable(i.BLEND),
    cc._renderContext.blendFunc(t, e))
}
,
cc.glBlendFuncForParticle = function(t, e) {
    if (t !== cc._blendingSource || e !== cc._blendingDest) {
        cc._blendingSource = t,
        cc._blendingDest = e;
        var i = cc._renderContext;
        t === i.ONE && e === i.ZERO ? i.disable(i.BLEND) : (i.enable(i.BLEND),
        i.blendFuncSeparate(i.SRC_ALPHA, e, t, e))
    }
}
,
cc.ENABLE_GL_STATE_CACHE || (cc.glBlendFunc = cc.setBlending),
cc.glBlendResetToCache = function() {
    var t = cc._renderContext;
    t.blendEquation(t.FUNC_ADD),
    cc.ENABLE_GL_STATE_CACHE ? cc.setBlending(cc._blendingSource, cc._blendingDest) : cc.setBlending(t.BLEND_SRC, t.BLEND_DST)
}
,
cc.setProjectionMatrixDirty = function() {
    cc._currentProjectionMatrix = -1
}
,
cc.glEnableVertexAttribs = function(t) {
    var e = cc._renderContext
      , i = t & cc.VERTEX_ATTRIB_FLAG_POSITION;
    i !== cc._vertexAttribPosition && (i ? e.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION) : e.disableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION),
    cc._vertexAttribPosition = i),
    i = t & cc.VERTEX_ATTRIB_FLAG_COLOR,
    i !== cc._vertexAttribColor && (i ? e.enableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR) : e.disableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR),
    cc._vertexAttribColor = i),
    t &= cc.VERTEX_ATTRIB_FLAG_TEX_COORDS,
    t !== cc._vertexAttribTexCoords && (t ? e.enableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS) : e.disableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS),
    cc._vertexAttribTexCoords = t)
}
,
cc.glBindTexture2D = function(t) {
    cc.glBindTexture2DN(0, t)
}
,
cc.glBindTexture2DN = function(t, e) {
    if (cc._currentBoundTexture[t] !== e) {
        cc._currentBoundTexture[t] = e;
        var i = cc._renderContext;
        i.activeTexture(i.TEXTURE0 + t),
        e ? i.bindTexture(i.TEXTURE_2D, e._webTextureObj) : i.bindTexture(i.TEXTURE_2D, null)
    }
}
,
cc.ENABLE_GL_STATE_CACHE || (cc.glBindTexture2DN = function(t, e) {
    var i = cc._renderContext;
    i.activeTexture(i.TEXTURE0 + t),
    e ? i.bindTexture(i.TEXTURE_2D, e._webTextureObj) : i.bindTexture(i.TEXTURE_2D, null)
}
),
cc.glDeleteTexture = function(t) {
    cc.glDeleteTextureN(0, t)
}
,
cc.glDeleteTextureN = function(t, e) {
    cc.ENABLE_GL_STATE_CACHE && e === cc._currentBoundTexture[t] && (cc._currentBoundTexture[t] = -1),
    cc._renderContext.deleteTexture(e)
}
,
cc.glBindVAO = function(t) {
    cc.TEXTURE_ATLAS_USE_VAO && cc.ENABLE_GL_STATE_CACHE && cc._uVAO !== t && (cc._uVAO = t)
}
,
cc.glEnable = function(t) {}
,
cc.IMAGE_FORMAT_JPEG = 0,
cc.IMAGE_FORMAT_PNG = 1,
cc.IMAGE_FORMAT_RAWDATA = 9,
cc.NextPOT = function(t) {
    return t -= 1,
    t |= t >> 1,
    t |= t >> 2,
    t |= t >> 4,
    t |= t >> 8,
    (t | t >> 16) + 1
}
,
cc.RenderTexture = cc.Node.extend({
    sprite: null,
    clearFlags: 0,
    clearDepthVal: 0,
    autoDraw: !1,
    _texture: null,
    _pixelFormat: 0,
    clearStencilVal: 0,
    _clearColor: null,
    _className: "RenderTexture",
    ctor: function(t, e, i, n) {
        cc.Node.prototype.ctor.call(this),
        this._cascadeOpacityEnabled = this._cascadeColorEnabled = !0,
        this._pixelFormat = cc.Texture2D.PIXEL_FORMAT_RGBA8888,
        this._clearColor = new cc.Color(0,0,0,255),
        void 0 !== t && void 0 !== e && (i = i || cc.Texture2D.PIXEL_FORMAT_RGBA8888,
        this.initWithWidthAndHeight(t, e, i, n || 0)),
        this.setAnchorPoint(0, 0)
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.RenderTexture.CanvasRenderCmd(this) : new cc.RenderTexture.WebGLRenderCmd(this)
    },
    cleanup: function() {
        cc.Node.prototype.onExit.call(this),
        this._renderCmd.cleanup()
    },
    getSprite: function() {
        return this.sprite
    },
    setSprite: function(t) {
        this.sprite = t
    },
    setVirtualViewport: function(t, e, i) {
        this._renderCmd.setVirtualViewport(t, e, i)
    },
    initWithWidthAndHeight: function(t, e, i, n) {
        return this._renderCmd.initWithWidthAndHeight(t, e, i, n)
    },
    begin: function() {
        cc.renderer._turnToCacheMode(this.__instanceId),
        this._renderCmd.begin()
    },
    beginWithClear: function(t, e, i, n, r, c) {
        var s = cc._renderContext;
        r = r || s.COLOR_BUFFER_BIT,
        c = c || s.COLOR_BUFFER_BIT | s.DEPTH_BUFFER_BIT,
        this._beginWithClear(t, e, i, n, r, c, s.COLOR_BUFFER_BIT | s.DEPTH_BUFFER_BIT | s.STENCIL_BUFFER_BIT)
    },
    _beginWithClear: function(t, e, i, n, r, c, s) {
        this.begin(),
        this._renderCmd._beginWithClear(t, e, i, n, r, c, s)
    },
    end: function() {
        this._renderCmd.end()
    },
    clear: function(t, e, i, n) {
        this.beginWithClear(t, e, i, n),
        this.end()
    },
    clearRect: function(t, e, i, n) {
        this._renderCmd.clearRect(t, e, i, n)
    },
    clearDepth: function(t) {
        this._renderCmd.clearDepth(t)
    },
    clearStencil: function(t) {
        this._renderCmd.clearStencil(t)
    },
    getClearFlags: function() {
        return this.clearFlags
    },
    setClearFlags: function(t) {
        this.clearFlags = t
    },
    getClearColor: function() {
        return this._clearColor
    },
    setClearColor: function(t) {
        var e = this._clearColor;
        e.r = t.r,
        e.g = t.g,
        e.b = t.b,
        e.a = t.a,
        this._renderCmd.updateClearColor(t)
    },
    getClearDepth: function() {
        return this.clearDepthVal
    },
    setClearDepth: function(t) {
        this.clearDepthVal = t
    },
    getClearStencil: function() {
        return this.clearStencilVal
    },
    setClearStencil: function(t) {
        this.clearStencilVal = t
    },
    isAutoDraw: function() {
        return this.autoDraw
    },
    setAutoDraw: function(t) {
        this.autoDraw = t
    },
    saveToFile: function(t, e) {
        cc.log("saveToFile isn't supported on Cocos2d-Html5")
    },
    newCCImage: function(t) {
        return cc.log("saveToFile isn't supported on cocos2d-html5"),
        null
    },
    listenToBackground: function(t) {},
    listenToForeground: function(t) {}
}),
_p = cc.RenderTexture.prototype,
cc.defineGetterSetter(_p, "clearColorVal", _p.getClearColor, _p.setClearColor),
cc.RenderTexture.create = function(t, e, i, n) {
    return new cc.RenderTexture(t,e,i,n)
}
,
function() {
    cc.RenderTexture.CanvasRenderCmd = function(t) {
        cc.Node.CanvasRenderCmd.call(this, t),
        this._needDraw = !0,
        this._clearColorStr = "rgba(255,255,255,1)",
        this._cacheCanvas = document.createElement("canvas"),
        this._cacheContext = new cc.CanvasContextWrapper(this._cacheCanvas.getContext("2d"))
    }
    ;
    var t = cc.RenderTexture.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    t.constructor = cc.RenderTexture.CanvasRenderCmd,
    t.cleanup = function() {
        this._cacheCanvas = this._cacheContext = null
    }
    ,
    t.clearStencil = function(t) {}
    ,
    t.setVirtualViewport = function(t, e, i) {}
    ,
    t.updateClearColor = function(t) {
        this._clearColorStr = "rgba(" + (0 | t.r) + "," + (0 | t.g) + "," + (0 | t.b) + "," + t.a / 255 + ")"
    }
    ,
    t.initWithWidthAndHeight = function(t, e, i, n) {
        i = this._node,
        n = this._cacheCanvas;
        var r = cc.contentScaleFactor();
        return n.width = 0 | t * r,
        n.height = 0 | e * r,
        t = new cc.Texture2D,
        t.initWithElement(n),
        t.handleLoadedTexture(),
        t = i.sprite = new cc.Sprite(t),
        t.setBlendFunc(cc.ONE, cc.ONE_MINUS_SRC_ALPHA),
        i.autoDraw = !1,
        i.addChild(t),
        !0
    }
    ,
    t.begin = function() {}
    ,
    t._beginWithClear = function(t, e, i, n, r, c, s) {
        t = t || 0,
        e = e || 0,
        i = i || 0,
        n = isNaN(n) ? 255 : n,
        r = this._cacheContext.getContext(),
        c = this._cacheCanvas,
        r.setTransform(1, 0, 0, 1, 0, 0),
        this._cacheContext.setFillStyle("rgba(" + (0 | t) + "," + (0 | e) + "," + (0 | i) + "," + n / 255 + ")"),
        r.clearRect(0, 0, c.width, c.height),
        r.fillRect(0, 0, c.width, c.height)
    }
    ,
    t.end = function() {
        var t = this._node
          , e = cc.contentScaleFactor();
        cc.renderer._renderingToCacheCanvas(this._cacheContext, t.__instanceId, e, e)
    }
    ,
    t.clearRect = function(t, e, i, n) {
        this._cacheContext.clearRect(t, e, i, -n)
    }
    ,
    t.clearDepth = function(t) {
        cc.log("clearDepth isn't supported on Cocos2d-Html5")
    }
    ,
    t.visit = function(t) {
        var e = this._node;
        this._syncStatus(t),
        e.sprite.visit(this),
        this._dirtyFlag = 0
    }
}(),
function() {
    cc.RenderTexture.WebGLRenderCmd = function(t) {
        cc.Node.WebGLRenderCmd.call(this, t),
        this._needDraw = !0,
        this._depthRenderBuffer = this._textureCopy = this._oldFBO = this._fBO = null,
        this._rtTextureRect = new cc.Rect,
        this._fullRect = new cc.Rect,
        this._fullViewport = new cc.Rect
    }
    ;
    var t = cc.RenderTexture.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    t.constructor = cc.RenderTexture.WebGLRenderCmd,
    t.setVirtualViewport = function(t, e, i) {
        this._rtTextureRect.x = t.x,
        this._rtTextureRect.y = t.y,
        this._fullRect = e,
        this._fullViewport = i
    }
    ,
    t.rendering = function(t) {
        var e = t || cc._renderContext;
        if (t = this._node,
        t.autoDraw) {
            t.begin();
            var i = t.clearFlags;
            if (i) {
                var n = [0, 0, 0, 0]
                  , r = 0
                  , c = 0;
                i & e.COLOR_BUFFER_BIT && (n = e.getParameter(e.COLOR_CLEAR_VALUE),
                e.clearColor(t._clearColor.r / 255, t._clearColor.g / 255, t._clearColor.b / 255, t._clearColor.a / 255)),
                i & e.DEPTH_BUFFER_BIT && (r = e.getParameter(e.DEPTH_CLEAR_VALUE),
                e.clearDepth(t.clearDepthVal)),
                i & e.STENCIL_BUFFER_BIT && (c = e.getParameter(e.STENCIL_CLEAR_VALUE),
                e.clearStencil(t.clearStencilVal)),
                e.clear(i),
                i & e.COLOR_BUFFER_BIT && e.clearColor(n[0], n[1], n[2], n[3]),
                i & e.DEPTH_BUFFER_BIT && e.clearDepth(r),
                i & e.STENCIL_BUFFER_BIT && e.clearStencil(c)
            }
            for (t.sortAllChildren(),
            e = t._children,
            i = 0; i < e.length; i++)
                n = e[i],
                n !== t.sprite && n._renderCmd.visit(t.sprite._renderCmd);
            t.end()
        }
    }
    ,
    t.clearStencil = function(t) {
        var e = cc._renderContext
          , i = e.getParameter(e.STENCIL_CLEAR_VALUE);
        e.clearStencil(t),
        e.clear(e.STENCIL_BUFFER_BIT),
        e.clearStencil(i)
    }
    ,
    t.cleanup = function() {
        this._textureCopy = null;
        var t = cc._renderContext;
        t.deleteFramebuffer(this._fBO),
        this._depthRenderBuffer && t.deleteRenderbuffer(this._depthRenderBuffer)
    }
    ,
    t.updateClearColor = function(t) {}
    ,
    t.initWithWidthAndHeight = function(t, e, i, n) {
        var r = this._node;
        i === cc.Texture2D.PIXEL_FORMAT_A8 && cc.log("cc.RenderTexture._initWithWidthAndHeightForWebGL() : only RGB and RGBA formats are valid for a render texture;");
        var c = cc._renderContext
          , s = cc.contentScaleFactor();
        this._fullRect = new cc.Rect(0,0,t,e),
        this._fullViewport = new cc.Rect(0,0,t,e),
        t = 0 | t * s,
        e = 0 | e * s,
        this._oldFBO = c.getParameter(c.FRAMEBUFFER_BINDING);
        var o;
        cc.configuration.supportsNPOT() ? (s = t,
        o = e) : (s = cc.NextPOT(t),
        o = cc.NextPOT(e));
        for (var a = new Uint8Array(s * o * 4), h = 0; h < s * o * 4; h++)
            a[h] = 0;
        if (this._pixelFormat = i,
        h = r._texture = new cc.Texture2D,
        !r._texture)
            return !1;
        if (h.initWithData(a, r._pixelFormat, s, o, cc.size(t, e)),
        i = c.getParameter(c.RENDERBUFFER_BINDING),
        cc.configuration.checkForGLExtension("GL_QCOM")) {
            if (this._textureCopy = new cc.Texture2D,
            !this._textureCopy)
                return !1;
            this._textureCopy.initWithData(a, r._pixelFormat, s, o, cc.size(t, e))
        }
        return this._fBO = c.createFramebuffer(),
        c.bindFramebuffer(c.FRAMEBUFFER, this._fBO),
        c.framebufferTexture2D(c.FRAMEBUFFER, c.COLOR_ATTACHMENT0, c.TEXTURE_2D, h._webTextureObj, 0),
        0 !== n && (this._depthRenderBuffer = c.createRenderbuffer(),
        c.bindRenderbuffer(c.RENDERBUFFER, this._depthRenderBuffer),
        c.renderbufferStorage(c.RENDERBUFFER, n, s, o),
        n === c.DEPTH_STENCIL ? c.framebufferRenderbuffer(c.FRAMEBUFFER, c.DEPTH_STENCIL_ATTACHMENT, c.RENDERBUFFER, this._depthRenderBuffer) : n === c.STENCIL_INDEX || n === c.STENCIL_INDEX8 ? c.framebufferRenderbuffer(c.FRAMEBUFFER, c.STENCIL_ATTACHMENT, c.RENDERBUFFER, this._depthRenderBuffer) : n === c.DEPTH_COMPONENT16 && c.framebufferRenderbuffer(c.FRAMEBUFFER, c.DEPTH_ATTACHMENT, c.RENDERBUFFER, this._depthRenderBuffer)),
        c.checkFramebufferStatus(c.FRAMEBUFFER) !== c.FRAMEBUFFER_COMPLETE && cc.log("Could not attach texture to the framebuffer"),
        h.setAliasTexParameters(),
        t = r.sprite = new cc.Sprite(h),
        t.scaleY = -1,
        t.setBlendFunc(c.ONE, c.ONE_MINUS_SRC_ALPHA),
        c.bindRenderbuffer(c.RENDERBUFFER, i),
        c.bindFramebuffer(c.FRAMEBUFFER, this._oldFBO),
        r.autoDraw = !1,
        r.addChild(t),
        !0
    }
    ,
    t.begin = function() {
        var t = this._node;
        cc.kmGLMatrixMode(cc.KM_GL_PROJECTION),
        cc.kmGLPushMatrix(),
        cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW),
        cc.kmGLPushMatrix();
        var e = cc._renderContext
          , i = cc.director;
        i.setProjection(i.getProjection());
        var n = t._texture.getContentSizeInPixels()
          , r = cc.director.getWinSizeInPixels()
          , i = r.width / n.width
          , n = r.height / n.height
          , i = cc.math.Matrix4.createOrthographicProjection(-1 / i, 1 / i, -1 / n, 1 / n, -1, 1);
        cc.kmGLMultMatrix(i),
        i = new cc.Rect(0,0,0,0),
        i.width = this._fullViewport.width,
        i.height = this._fullViewport.height,
        n = i.height / this._fullRect.height,
        i.x = i.width / this._fullRect.width * (this._fullRect.x - this._rtTextureRect.x),
        i.y = (this._fullRect.y - this._rtTextureRect.y) * n,
        e.viewport(i.x, i.y, i.width, i.height),
        this._oldFBO = e.getParameter(e.FRAMEBUFFER_BINDING),
        e.bindFramebuffer(e.FRAMEBUFFER, this._fBO),
        cc.configuration.checkForGLExtension("GL_QCOM") && (e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, this._textureCopy._webTextureObj, 0),
        e.clear(e.COLOR_BUFFER_BIT | e.DEPTH_BUFFER_BIT),
        e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t._texture._webTextureObj, 0))
    }
    ,
    t._beginWithClear = function(t, e, i, n, r, c, s) {
        t /= 255,
        e /= 255,
        i /= 255,
        n /= 255;
        var o = cc._renderContext
          , a = [0, 0, 0, 0]
          , h = 0
          , l = 0;
        s & o.COLOR_BUFFER_BIT && (a = o.getParameter(o.COLOR_CLEAR_VALUE),
        o.clearColor(t, e, i, n)),
        s & o.DEPTH_BUFFER_BIT && (h = o.getParameter(o.DEPTH_CLEAR_VALUE),
        o.clearDepth(r)),
        s & o.STENCIL_BUFFER_BIT && (l = o.getParameter(o.STENCIL_CLEAR_VALUE),
        o.clearStencil(c)),
        o.clear(s),
        s & o.COLOR_BUFFER_BIT && o.clearColor(a[0], a[1], a[2], a[3]),
        s & o.DEPTH_BUFFER_BIT && o.clearDepth(h),
        s & o.STENCIL_BUFFER_BIT && o.clearStencil(l)
    }
    ,
    t.end = function() {
        cc.renderer._renderingToBuffer(this._node.__instanceId);
        var t = cc._renderContext
          , e = cc.director;
        t.bindFramebuffer(t.FRAMEBUFFER, this._oldFBO),
        e.setViewport(),
        cc.kmGLMatrixMode(cc.KM_GL_PROJECTION),
        cc.kmGLPopMatrix(),
        cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW),
        cc.kmGLPopMatrix()
    }
    ,
    t.clearRect = function(t, e, i, n) {}
    ,
    t.clearDepth = function(t) {
        var e = this._node;
        e.begin();
        var i = cc._renderContext
          , n = i.getParameter(i.DEPTH_CLEAR_VALUE);
        i.clearDepth(t),
        i.clear(i.DEPTH_BUFFER_BIT),
        i.clearDepth(n),
        e.end()
    }
    ,
    t.visit = function(t) {
        var e = this._node;
        e._visible && (cc.kmGLPushMatrix(),
        this._syncStatus(t),
        cc.renderer.pushRenderCommand(this),
        e.sprite.visit(this),
        this._dirtyFlag = 0,
        cc.kmGLPopMatrix())
    }
}(),
cc.LabelAtlas = cc.AtlasNode.extend({
    _string: null,
    _mapStartChar: null,
    _textureLoaded: !1,
    _className: "LabelAtlas",
    ctor: function(t, e, i, n, r) {
        cc.AtlasNode.prototype.ctor.call(this),
        this._renderCmd.setCascade(),
        e && cc.LabelAtlas.prototype.initWithString.call(this, t, e, i, n, r)
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_WEBGL ? new cc.LabelAtlas.WebGLRenderCmd(this) : new cc.LabelAtlas.CanvasRenderCmd(this);
    },
    textureLoaded: function() {
        return this._textureLoaded
    },
    addLoadedEventListener: function(t, e) {
        this.addEventListener("load", t, e)
    },
    initWithString: function(t, e, i, n, r) {
        var c, s, o = t + "";
        if (void 0 === i) {
            if (i = cc.loader.getRes(e),
            1 !== parseInt(i.version, 10))
                return cc.log("cc.LabelAtlas.initWithString(): Unsupported version. Upgrade cocos2d version"),
                !1;
            e = cc.path.changeBasename(e, i.textureFilename),
            n = cc.contentScaleFactor(),
            c = parseInt(i.itemWidth, 10) / n,
            s = parseInt(i.itemHeight, 10) / n,
            i = String.fromCharCode(parseInt(i.firstChar, 10))
        } else
            c = i || 0,
            s = n || 0,
            i = r || " ";
        var a = null
          , a = e instanceof cc.Texture2D ? e : cc.textureCache.addImage(e);
        return this._textureLoaded = e = a.isLoaded(),
        e || (this._string = o,
        a.addEventListener("load", function(t) {
            this.initWithTexture(a, c, s, o.length),
            this.string = this._string,
            this.setColor(this._renderCmd._displayedColor),
            this.dispatchEvent("load")
        }, this)),
        !!this.initWithTexture(a, c, s, o.length) && (this._mapStartChar = i,
        this.string = o,
        !0)
    },
    setColor: function(t) {
        cc.AtlasNode.prototype.setColor.call(this, t),
        this._renderCmd.updateAtlasValues()
    },
    getString: function() {
        return this._string
    },
    addChild: function(t, e, i) {
        this._renderCmd._addChild(t),
        cc.Node.prototype.addChild.call(this, t, e, i)
    },
    updateAtlasValues: function() {
        this._renderCmd.updateAtlasValues()
    },
    setString: function(t) {
        t = String(t);
        var e = t.length;
        this._string = t,
        this.setContentSize(e * this._itemWidth, this._itemHeight),
        this._renderCmd.setString(t),
        this._renderCmd.updateAtlasValues(),
        this.quadsToDraw = e
    }
}),
function() {
    var t = cc.LabelAtlas.prototype;
    cc.defineGetterSetter(t, "opacity", t.getOpacity, t.setOpacity),
    cc.defineGetterSetter(t, "color", t.getColor, t.setColor),
    cc.defineGetterSetter(t, "string", t.getString, t.setString)
}(),
cc.LabelAtlas.create = function(t, e, i, n, r) {
    return new cc.LabelAtlas(t,e,i,n,r)
}
,
function() {
    cc.LabelAtlas.CanvasRenderCmd = function(t) {
        cc.AtlasNode.CanvasRenderCmd.call(this, t),
        this._needDraw = !1
    }
    ;
    var t = cc.LabelAtlas.CanvasRenderCmd.prototype = Object.create(cc.AtlasNode.CanvasRenderCmd.prototype);
    t.constructor = cc.LabelAtlas.CanvasRenderCmd,
    t.setCascade = function() {
        var t = this._node;
        t._cascadeOpacityEnabled = !0,
        t._cascadeColorEnabled = !1
    }
    ,
    t.updateAtlasValues = function() {
        for (var t = this._node, e = t._string || "", i = e.length, n = this._textureToRender, r = t._itemWidth, c = t._itemHeight, s = 0, o = -1; s < i; s++) {
            var a = e.charCodeAt(s) - t._mapStartChar.charCodeAt(0)
              , h = parseInt(a % t._itemsPerRow, 10)
              , a = parseInt(a / t._itemsPerRow, 10);
            if (!(0 > h || 0 > a || (h = cc.rect(h * r, a * c, r, c),
            a = n._contentSize,
            0 > h.x || 0 > h.y || h.x + h.width > a.width || h.y + h.height > a.height))) {
                o++;
                var a = e.charCodeAt(s)
                  , l = t.getChildByTag(s);
                l ? 32 === a ? (l.init(),
                l.setTextureRect(cc.rect(0, 0, 10, 10), !1, cc.size(0, 0))) : (l.initWithTexture(n, h),
                l.visible = !0) : (l = new cc.Sprite,
                32 === a ? (l.init(),
                l.setTextureRect(cc.rect(0, 0, 10, 10), !1, cc.size(0, 0))) : l.initWithTexture(n, h),
                cc.Node.prototype.addChild.call(t, l, 0, s)),
                l.setPosition(o * r + r / 2, c / 2)
            }
        }
        this.updateContentSize(s, o + 1)
    }
    ,
    t.updateContentSize = function(t, e) {
        var i = this._node
          , n = i._contentSize;
        t !== e && t * i._itemWidth === n.width && i._itemHeight === n.height && i.setContentSize(e * i._itemWidth, i._itemHeight)
    }
    ,
    t.setString = function(t) {
        if (t = this._node,
        t._children) {
            t = t._children;
            for (var e = t.length, i = 0; i < e; i++) {
                var n = t[i];
                n && !n._lateChild && (n.visible = !1)
            }
        }
    }
    ,
    t._addChild = function() {
        child._lateChild = !0
    }
}(),
function() {
    cc.LabelAtlas.WebGLRenderCmd = function(t) {
        cc.AtlasNode.WebGLRenderCmd.call(this, t),
        this._needDraw = !0
    }
    ;
    var t = cc.LabelAtlas.WebGLRenderCmd.prototype = Object.create(cc.AtlasNode.WebGLRenderCmd.prototype);
    t.constructor = cc.LabelAtlas.WebGLRenderCmd,
    t.setCascade = function() {
        var t = this._node;
        t._cascadeOpacityEnabled = !0,
        t._cascadeColorEnabled = !0
    }
    ,
    t.rendering = function(t) {
        if (cc.AtlasNode.WebGLRenderCmd.prototype.rendering.call(this, t),
        cc.LABELATLAS_DEBUG_DRAW) {
            var e = this._node;
            t = e.getContentSize();
            var e = e.getBoundingBoxToWorld()
              , i = e.x
              , n = e.y;
            t.width = e.width,
            t.height = e.height,
            t = [cc.p(i, n), cc.p(i + t.width, n), cc.p(t.width + i, t.height + n), cc.p(i, n + t.height)],
            cc._drawingUtil.drawPoly(t, 4, !0)
        }
    }
    ,
    t.updateAtlasValues = function() {
        var t = this._node
          , e = t._string
          , i = e.length
          , n = this._textureAtlas
          , r = n.texture
          , c = r.pixelsWidth
          , r = r.pixelsHeight
          , s = t._itemWidth
          , o = t._itemHeight;
        t._ignoreContentScaleFactor || (s = t._itemWidth * cc.contentScaleFactor(),
        o = t._itemHeight * cc.contentScaleFactor()),
        i > n.getCapacity() && cc.log("cc.LabelAtlas._updateAtlasValues(): Invalid String length");
        for (var a = n.quads, h = this._displayedColor, h = {
            r: h.r,
            g: h.g,
            b: h.b,
            a: t._displayedOpacity
        }, l = t._itemWidth, u = t._itemHeight, d = 0, _ = -1; d < i; d++) {
            var p = e.charCodeAt(d) - t._mapStartChar.charCodeAt(0)
              , f = p % t._itemsPerRow
              , g = 0 | p / t._itemsPerRow;
            if (!(0 > f || 0 > g || f * l + l > c || g * u + u > r)) {
                _++;
                var m;
                cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (f = (2 * f * s + 1) / (2 * c),
                p = f + (2 * s - 2) / (2 * c),
                g = (2 * g * o + 1) / (2 * r),
                m = g + (2 * o - 2) / (2 * r)) : (f = f * s / c,
                p = f + s / c,
                g = g * o / r,
                m = g + o / r);
                var y = a[d]
                  , T = y.tl
                  , v = y.tr
                  , A = y.bl
                  , y = y.br;
                T.texCoords.u = f,
                T.texCoords.v = g,
                v.texCoords.u = p,
                v.texCoords.v = g,
                A.texCoords.u = f,
                A.texCoords.v = m,
                y.texCoords.u = p,
                y.texCoords.v = m,
                A.vertices.x = _ * l,
                A.vertices.y = 0,
                A.vertices.z = 0,
                y.vertices.x = _ * l + l,
                y.vertices.y = 0,
                y.vertices.z = 0,
                T.vertices.x = _ * l,
                T.vertices.y = t._itemHeight,
                T.vertices.z = 0,
                v.vertices.x = _ * l + l,
                v.vertices.y = t._itemHeight,
                v.vertices.z = 0,
                T.colors = h,
                v.colors = h,
                A.colors = h,
                y.colors = h
            }
        }
        this.updateContentSize(d, _ + 1),
        0 < i && (n.dirty = !0,
        t = n.totalQuads,
        i > t && n.increaseTotalQuadsWith(i - t))
    }
    ,
    t.updateContentSize = function(t, e) {
        var i = this._node
          , n = i._contentSize;
        t !== e && t * i._itemWidth === n.width && i._itemHeight === n.height && i.setContentSize(e * i._itemWidth, i._itemHeight)
    }
    ,
    t.setString = function(t) {
        t = t.length,
        t > this._textureAtlas.totalQuads && this._textureAtlas.resizeCapacity(t)
    }
    ,
    t._addChild = function() {}
}(),
cc.LABEL_AUTOMATIC_WIDTH = -1,
cc.LabelBMFont = cc.SpriteBatchNode.extend({
    _opacityModifyRGB: !1,
    _string: "",
    _config: null,
    _fntFile: "",
    _initialString: "",
    _alignment: cc.TEXT_ALIGNMENT_CENTER,
    _width: -1,
    _lineBreakWithoutSpaces: !1,
    _imageOffset: null,
    _reusedChar: null,
    _textureLoaded: !1,
    _className: "LabelBMFont",
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_WEBGL ? new cc.LabelBMFont.WebGLRenderCmd(this) : new cc.LabelBMFont.CanvasRenderCmd(this)
    },
    _setString: function(t, e) {
        e ? this._initialString = t : this._string = t;
        var i = this._children;
        if (i)
            for (var n = 0; n < i.length; n++) {
                var r = i[n];
                r && r.setVisible(!1)
            }
        this._textureLoaded && (this.createFontChars(),
        e && this.updateLabel())
    },
    ctor: function(t, e, i, n, r) {
        cc.SpriteBatchNode.prototype.ctor.call(this),
        this._imageOffset = cc.p(0, 0),
        this._reusedChar = [],
        this._cascadeOpacityEnabled = this._cascadeColorEnabled = !0,
        this.initWithString(t, e, i, n, r)
    },
    textureLoaded: function() {
        return this._textureLoaded
    },
    addLoadedEventListener: function(t, e) {
        this.addEventListener("load", t, e)
    },
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB
    },
    setOpacityModifyRGB: function(t) {
        if (this._opacityModifyRGB = t,
        t = this._children)
            for (var e = 0; e < t.length; e++) {
                var i = t[e];
                i && (i.opacityModifyRGB = this._opacityModifyRGB)
            }
    },
    _changeTextureColor: function() {
        this._renderCmd._changeTextureColor()
    },
    init: function() {
        return this.initWithString(null, null, null, null, null)
    },
    initWithString: function(t, e, i, n, r) {
        if (t = t || "",
        this._config && cc.log("cc.LabelBMFont.initWithString(): re-init is no longer supported"),
        e) {
            var c = cc.loader.getRes(e);
            if (!c)
                return cc.log("cc.LabelBMFont.initWithString(): Impossible to create font. Please check file"),
                !1;
            this._config = c,
            this._fntFile = e,
            e = cc.textureCache.addImage(c.atlasName),
            (this._textureLoaded = c = e.isLoaded()) || e.addEventListener("load", function(t) {
                this._textureLoaded = !0,
                this.initWithTexture(t, this._initialString.length),
                this.setString(this._initialString, !0),
                this.dispatchEvent("load")
            }, this)
        } else
            e = new cc.Texture2D,
            c = new Image,
            e.initWithElement(c),
            this._textureLoaded = !1;
        return !!this.initWithTexture(e, t.length) && (this._alignment = n || cc.TEXT_ALIGNMENT_LEFT,
        this._imageOffset = r || cc.p(0, 0),
        this._width = null == i ? -1 : i,
        this._realOpacity = 255,
        this._realColor = cc.color(255, 255, 255, 255),
        this._contentSize.width = 0,
        this._contentSize.height = 0,
        this.setAnchorPoint(.5, .5),
        this._renderCmd._initBatchTexture(),
        this.setString(t, !0),
        !0)
    },
    createFontChars: function() {
        var t = this._renderCmd._texture || this.textureAtlas.texture
          , e = 0
          , i = cc.size(0, 0)
          , n = 0
          , r = 1
          , c = this._string
          , s = c ? c.length : 0;
        if (0 !== s) {
            var o, a = this._config, h = a.kerningDict, l = a.commonHeight, u = a.fontDefDictionary;
            for (o = 0; o < s - 1; o++)
                10 === c.charCodeAt(o) && r++;
            var d = l * r
              , r = -(l - l * r)
              , _ = -1;
            for (o = 0; o < s; o++)
                if (l = c.charCodeAt(o),
                0 !== l)
                    if (10 === l)
                        e = 0,
                        r -= a.commonHeight;
                    else {
                        var _ = h[_ << 16 | 65535 & l] || 0
                          , p = u[l];
                        p || (cc.log("cocos2d: LabelBMFont: character not found " + c[o]),
                        p = {
                            rect: {
                                x: 0,
                                y: 0,
                                width: 0,
                                height: 0
                            },
                            xOffset: 0,
                            yOffset: 0,
                            xAdvance: 0
                        });
                        var f = cc.rect(p.rect.x, p.rect.y, p.rect.width, p.rect.height)
                          , f = cc.rectPixelsToPoints(f);
                        f.x += this._imageOffset.x,
                        f.y += this._imageOffset.y;
                        var g = this.getChildByTag(o);
                        g ? this._renderCmd._updateCharTexture(g, f, l) : (g = new cc.Sprite,
                        g.initWithTexture(t, f, !1),
                        g._newTextureWhenChangeColor = !0,
                        this.addChild(g, 0, o)),
                        g.opacityModifyRGB = this._opacityModifyRGB,
                        this._renderCmd._updateCharColorAndOpacity(g),
                        f = cc.p(e + p.xOffset + .5 * p.rect.width + _, r + (a.commonHeight - p.yOffset) - .5 * f.height * cc.contentScaleFactor()),
                        g.setPosition(cc.pointPixelsToPoints(f)),
                        e += p.xAdvance + _,
                        _ = l,
                        n < e && (n = e)
                    }
            i.width = p && p.xAdvance < p.rect.width ? n - p.xAdvance + p.rect.width : n,
            i.height = d,
            this.setContentSize(cc.sizePixelsToPoints(i))
        }
    },
    updateString: function(t) {
        var e = this._children;
        if (e)
            for (var i = 0, n = e.length; i < n; i++) {
                var r = e[i];
                r && (r.visible = !1)
            }
        this._config && this.createFontChars(),
        t || this.updateLabel()
    },
    getString: function() {
        return this._initialString
    },
    setString: function(t, e) {
        t = String(t),
        null == e && (e = !0),
        null != t && cc.isString(t) || (t += ""),
        this._initialString = t,
        this._setString(t, e)
    },
    _setStringForSetter: function(t) {
        this.setString(t, !1)
    },
    setCString: function(t) {
        this.setString(t, !0)
    },
    _getCharsWidth: function(t, e) {
        if (0 >= e)
            return 0;
        var i = this.getChildByTag(t)
          , n = this.getChildByTag(t + e);
        return this._getLetterPosXLeft(n) - this._getLetterPosXLeft(i)
    },
    _checkWarp: function(t, e, i, n) {
        for (var r = t[e], c = 0, s = 0; s < e; s++)
            c += t[s].length;
        var c = c + e - n
          , o = this._getCharsWidth(c, t[e].length - 1);
        if (o > i && 1 < r.length) {
            n = i / o * r.length | 0;
            for (var a, s = r.substr(n), h = o - this._getCharsWidth(c + n, s.length - 1), l = 0, u = 0; h > i && 100 > u++; )
                n *= i / h,
                n |= 0,
                s = r.substr(n),
                h = o - this._getCharsWidth(c + n, s.length - 1);
            for (u = 0; h < i && 100 > u++; )
                s && (l = (a = cc.LabelTTF._wordRex.exec(s)) ? a[0].length : 1,
                a = s),
                this._lineBreakWithoutSpaces && (l = 0),
                n += l,
                s = r.substr(n),
                h = o - this._getCharsWidth(c + n, s.length - 1);
            n -= l,
            0 === n && (n = 1,
            a = a.substr(1)),
            i = r.substr(0, n),
            cc.LabelTTF.wrapInspection && cc.LabelTTF._symbolRex.test(a || s) && (l = (c = cc.LabelTTF._lastWordRex.exec(i)) ? c[0].length : 0,
            this._lineBreakWithoutSpaces && (l = 0),
            n -= l,
            a = r.substr(n),
            i = r.substr(0, n)),
            cc.LabelTTF._firsrEnglish.test(a) && (c = cc.LabelTTF._lastEnglish.exec(i)) && i !== c[0] && (l = c[0].length,
            this._lineBreakWithoutSpaces && (l = 0),
            n -= l,
            a = r.substr(n),
            i = r.substr(0, n)),
            t[e] = a || s,
            t.splice(e, 0, i)
        }
    },
    updateLabel: function() {
        this.string = this._initialString;
        var t, e, i;
        if (0 < this._width) {
            var n = this.string.split("\n")
              , r = ""
              , c = 0
              , s = 0;
            for (t = 0; t < n.length; t++)
                s = n.length,
                this._checkWarp(n, t, this._width * this._scaleX, c),
                s < n.length && c++,
                0 < t && (r += "\n"),
                r += n[t];
            r += String.fromCharCode(0),
            this._setString(r, !1)
        }
        if (this._alignment !== cc.TEXT_ALIGNMENT_LEFT)
            for (n = t = 0,
            r = this._string.length,
            c = [],
            s = 0; s < r; s++)
                if (10 === this._string[s].charCodeAt(0) || 0 === this._string[s].charCodeAt(0)) {
                    e = 0;
                    var o = c.length;
                    if (0 === o)
                        n++;
                    else if (i = t + o - 1 + n,
                    !(0 > i)) {
                        var a = this.getChildByTag(i);
                        if (null != a) {
                            switch (e = a.getPositionX() + a._getWidth() / 2,
                            a = 0,
                            this._alignment) {
                            case cc.TEXT_ALIGNMENT_CENTER:
                                a = this.width / 2 - e / 2;
                                break;
                            case cc.TEXT_ALIGNMENT_RIGHT:
                                a = this.width - e
                            }
                            if (0 !== a)
                                for (e = 0; e < o; e++)
                                    i = t + e + n,
                                    0 > i || (i = this.getChildByTag(i)) && (i.x += a);
                            t += o,
                            n++,
                            c.length = 0
                        }
                    }
                } else
                    c.push(this._string[t])
    },
    setAlignment: function(t) {
        this._alignment = t,
        this.updateLabel()
    },
    _getAlignment: function() {
        return this._alignment
    },
    setBoundingWidth: function(t) {
        this._width = t,
        this.updateLabel()
    },
    _getBoundingWidth: function() {
        return this._width
    },
    setLineBreakWithoutSpace: function(t) {
        this._lineBreakWithoutSpaces = t,
        this.updateLabel()
    },
    setScale: function(t, e) {
        cc.Node.prototype.setScale.call(this, t, e),
        this.updateLabel()
    },
    setScaleX: function(t) {
        cc.Node.prototype.setScaleX.call(this, t),
        this.updateLabel()
    },
    setScaleY: function(t) {
        cc.Node.prototype.setScaleY.call(this, t),
        this.updateLabel()
    },
    setFntFile: function(t) {
        if (null != t && t !== this._fntFile) {
            var e = cc.loader.getRes(t);
            e ? (this._fntFile = t,
            this._config = e,
            t = cc.textureCache.addImage(e.atlasName),
            this._textureLoaded = e = t.isLoaded(),
            this.texture = t,
            e ? this.createFontChars() : t.addEventListener("load", function(t) {
                this._textureLoaded = !0,
                this.texture = t,
                this.createFontChars(),
                this._changeTextureColor(),
                this.updateLabel(),
                this.dispatchEvent("load")
            }, this)) : cc.log("cc.LabelBMFont.setFntFile() : Impossible to create font. Please check file")
        }
    },
    getFntFile: function() {
        return this._fntFile
    },
    setTexture: function(t) {
        this._renderCmd.setTexture(t)
    },
    setAnchorPoint: function(t, e) {
        cc.Node.prototype.setAnchorPoint.call(this, t, e),
        this.updateLabel()
    },
    _setAnchorX: function(t) {
        cc.Node.prototype._setAnchorX.call(this, t),
        this.updateLabel()
    },
    _setAnchorY: function(t) {
        cc.Node.prototype._setAnchorY.call(this, t),
        this.updateLabel()
    },
    _atlasNameFromFntFile: function(t) {},
    _kerningAmountForFirst: function(t, e) {
        var i = 0;
        if (this._configuration.kerningDictionary) {
            var n = this._configuration.kerningDictionary[(t << 16 | 65535 & e).toString()];
            n && (i = n.amount)
        }
        return i
    },
    _getLetterPosXLeft: function(t) {
        return t.getPositionX() * this._scaleX - t._getWidth() * this._scaleX * t._getAnchorX()
    },
    _getLetterPosXRight: function(t) {
        return t.getPositionX() * this._scaleX + t._getWidth() * this._scaleX * t._getAnchorX()
    },
    _isspace_unicode: function(t) {
        return t = t.charCodeAt(0),
        9 <= t && 13 >= t || 32 === t || 133 === t || 160 === t || 5760 === t || 8192 <= t && 8202 >= t || 8232 === t || 8233 === t || 8239 === t || 8287 === t || 12288 === t
    },
    _utf8_trim_ws: function(t) {
        var e = t.length;
        if (!(0 >= e) && (e -= 1,
        this._isspace_unicode(t[e]))) {
            for (var i = e - 1; 0 <= i && this._isspace_unicode(t[i]); --i)
                e = i;
            this._utf8_trim_from(t, e)
        }
    },
    _utf8_trim_from: function(t, e) {
        var i = t.length;
        e >= i || 0 > e || t.splice(e, i)
    }
}),
function() {
    var t = cc.LabelBMFont.prototype;
    cc.EventHelper.prototype.apply(t),
    cc.defineGetterSetter(t, "string", t.getString, t._setStringForSetter),
    cc.defineGetterSetter(t, "boundingWidth", t._getBoundingWidth, t.setBoundingWidth),
    cc.defineGetterSetter(t, "textAlign", t._getAlignment, t.setAlignment)
}(),
cc.LabelBMFont.create = function(t, e, i, n, r) {
    return new cc.LabelBMFont(t,e,i,n,r)
}
,
cc._fntLoader = {
    INFO_EXP: /info [^\n]*(\n|$)/gi,
    COMMON_EXP: /common [^\n]*(\n|$)/gi,
    PAGE_EXP: /page [^\n]*(\n|$)/gi,
    CHAR_EXP: /char [^\n]*(\n|$)/gi,
    KERNING_EXP: /kerning [^\n]*(\n|$)/gi,
    ITEM_EXP: /\w+=[^ \r\n]+/gi,
    INT_EXP: /^[\-]?\d+$/,
    _parseStrToObj: function(t) {
        t = t.match(this.ITEM_EXP);
        var e = {};
        if (t)
            for (var i = 0, n = t.length; i < n; i++) {
                var r = t[i]
                  , c = r.indexOf("=")
                  , s = r.substring(0, c)
                  , r = r.substring(c + 1);
                r.match(this.INT_EXP) ? r = parseInt(r) : '"' === r[0] && (r = r.substring(1, r.length - 1)),
                e[s] = r
            }
        return e
    },
    parseFnt: function(t, e) {
        var i = {}
          , n = this._parseStrToObj(t.match(this.INFO_EXP)[0]).padding.split(",");
        if (parseInt(n[0]),
        parseInt(n[1]),
        parseInt(n[2]),
        parseInt(n[3]),
        n = this._parseStrToObj(t.match(this.COMMON_EXP)[0]),
        i.commonHeight = n.lineHeight,
        cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
            var r = cc.configuration.getMaxTextureSize();
            (n.scaleW > r.width || n.scaleH > r.height) && cc.log("cc.LabelBMFont._parseCommonArguments(): page can't be larger than supported")
        }
        1 !== n.pages && cc.log("cc.LabelBMFont._parseCommonArguments(): only supports 1 page"),
        n = this._parseStrToObj(t.match(this.PAGE_EXP)[0]),
        0 !== n.id && cc.log("cc.LabelBMFont._parseImageFileName() : file could not be found"),
        i.atlasName = cc.path.changeBasename(e, n.file);
        for (var c = t.match(this.CHAR_EXP), s = i.fontDefDictionary = {}, n = 0, r = c.length; n < r; n++) {
            var o = this._parseStrToObj(c[n]);
            s[o.id] = {
                rect: {
                    x: o.x,
                    y: o.y,
                    width: o.width,
                    height: o.height
                },
                xOffset: o.xoffset,
                yOffset: o.yoffset,
                xAdvance: o.xadvance
            }
        }
        if (c = i.kerningDict = {},
        s = t.match(this.KERNING_EXP))
            for (n = 0,
            r = s.length; n < r; n++)
                o = this._parseStrToObj(s[n]),
                c[o.first << 16 | 65535 & o.second] = o.amount;
        return i
    },
    load: function(t, e, i, n) {
        var r = this;
        cc.loader.loadTxt(t, function(t, i) {
            return t ? n(t) : void n(null, r.parseFnt(i, e))
        })
    }
},
cc.loader.register(["fnt"], cc._fntLoader),
function() {
    cc.LabelBMFont.CanvasRenderCmd = function(t) {
        cc.SpriteBatchNode.CanvasRenderCmd.call(this, t),
        this._needDraw = !0
    }
    ;
    var t = cc.LabelBMFont.CanvasRenderCmd.prototype = Object.create(cc.SpriteBatchNode.CanvasRenderCmd.prototype);
    t.constructor = cc.LabelBMFont.CanvasRenderCmd,
    t.rendering = function() {}
    ,
    t._updateCharTexture = function(t, e, i) {
        32 === i ? t.setTextureRect(e, !1, cc.size(0, 0)) : (t.setTextureRect(e, !1),
        t.visible = !0)
    }
    ,
    t._updateCharColorAndOpacity = function(t) {
        t._displayedColor = this._displayedColor,
        t._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty),
        t._displayedOpacity = this._displayedOpacity,
        t._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
    }
    ,
    t.setTexture = function(t) {
        for (var e = this._node._children, i = this._displayedColor, n = 0; n < e.length; n++) {
            var r = e[n]
              , c = r._renderCmd
              , s = c._displayedColor;
            (this._texture === c._texture || s.r === i.r && s.g === i.g && s.b === i.b) && (r.texture = t)
        }
        this._texture = t
    }
    ,
    t._changeTextureColor = function() {
        var t = this._node
          , e = this._textureToRender
          , i = e.getContentSize()
          , t = t._texture
          , n = t.getHtmlElementObj()
          , r = this._displayedColor
          , c = cc.rect(0, 0, n.width, n.height);
        e && 0 < i.width && n && (this._textureToRender = t._generateColorTexture(r.r, r.g, r.b, c))
    }
    ,
    t._updateChildrenDisplayedOpacity = function(t) {
        cc.Node.prototype.updateDisplayedOpacity.call(t, this._displayedOpacity)
    }
    ,
    t._updateChildrenDisplayedColor = function(t) {
        cc.Node.prototype.updateDisplayedColor.call(t, this._displayedColor)
    }
    ,
    t._initBatchTexture = function() {}
}(),
function() {
    cc.LabelBMFont.WebGLRenderCmd = function(t) {
        cc.SpriteBatchNode.WebGLRenderCmd.call(this, t),
        this._needDraw = !0
    }
    ;
    var t = cc.LabelBMFont.WebGLRenderCmd.prototype = Object.create(cc.SpriteBatchNode.WebGLRenderCmd.prototype);
    t.constructor = cc.LabelBMFont.WebGLRenderCmd,
    t._updateCharTexture = function(t, e, i) {
        t.setTextureRect(e, !1),
        t.visible = !0
    }
    ,
    t._changeTextureColor = function() {}
    ,
    t._updateChildrenDisplayedOpacity = function(t) {
        t.updateDisplayedOpacity(this._displayedOpacity)
    }
    ,
    t._updateChildrenDisplayedColor = function(t) {
        t.updateDisplayedColor(this._displayedColor)
    }
    ,
    t._initBatchTexture = function() {
        var t = this._node
          , e = t.textureAtlas.texture;
        t._opacityModifyRGB = e.hasPremultipliedAlpha();
        var i = t._reusedChar = new cc.Sprite;
        i.initWithTexture(e, cc.rect(0, 0, 0, 0), !1),
        i.batchNode = t
    }
    ,
    t.rendering = function(t) {
        if (cc.SpriteBatchNode.WebGLRenderCmd.prototype.rendering.call(this, t),
        t = this._node,
        cc.LABELBMFONT_DEBUG_DRAW) {
            t = t.getContentSize();
            var e = cc.p(0 | -this._anchorPointInPoints.x, 0 | -this._anchorPointInPoints.y);
            t = [cc.p(e.x, e.y), cc.p(e.x + t.width, e.y), cc.p(e.x + t.width, e.y + t.height), cc.p(e.x, e.y + t.height)],
            cc._drawingUtil.setDrawColor(0, 255, 0, 255),
            cc._drawingUtil.drawPoly(t, 4, !0)
        }
    }
    ,
    t._updateCharColorAndOpacity = function() {}
}(),
cc.MotionStreak = cc.Node.extend({
    texture: null,
    fastMode: !1,
    startingPositionInitialized: !1,
    _blendFunc: null,
    _stroke: 0,
    _fadeDelta: 0,
    _minSeg: 0,
    _maxPoints: 0,
    _nuPoints: 0,
    _previousNuPoints: 0,
    _pointVertexes: null,
    _pointState: null,
    _vertices: null,
    _colorPointer: null,
    _texCoords: null,
    _verticesBuffer: null,
    _colorPointerBuffer: null,
    _texCoordsBuffer: null,
    _className: "MotionStreak",
    ctor: function(t, e, i, n, r) {
        cc.Node.prototype.ctor.call(this),
        this._positionR = cc.p(0, 0),
        this._blendFunc = new cc.BlendFunc(cc.SRC_ALPHA,cc.ONE_MINUS_SRC_ALPHA),
        this.startingPositionInitialized = this.fastMode = !1,
        this.texture = null,
        this._previousNuPoints = this._nuPoints = this._maxPoints = this._minSeg = this._fadeDelta = this._stroke = 0,
        this._texCoordsBuffer = this._colorPointerBuffer = this._verticesBuffer = this._texCoords = this._colorPointer = this._vertices = this._pointState = this._pointVertexes = null,
        void 0 !== r && this.initWithFade(t, e, i, n, r)
    },
    getTexture: function() {
        return this.texture
    },
    setTexture: function(t) {
        this.texture !== t && (this.texture = t)
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    setBlendFunc: function(t, e) {
        void 0 === e ? this._blendFunc = t : (this._blendFunc.src = t,
        this._blendFunc.dst = e)
    },
    getOpacity: function() {
        return cc.log("cc.MotionStreak.getOpacity has not been supported."),
        0
    },
    setOpacity: function(t) {
        cc.log("cc.MotionStreak.setOpacity has not been supported.")
    },
    setOpacityModifyRGB: function(t) {},
    isOpacityModifyRGB: function() {
        return !1
    },
    isFastMode: function() {
        return this.fastMode
    },
    setFastMode: function(t) {
        this.fastMode = t
    },
    isStartingPositionInitialized: function() {
        return this.startingPositionInitialized
    },
    setStartingPositionInitialized: function(t) {
        this.startingPositionInitialized = t
    },
    getStroke: function() {
        return this._stroke
    },
    setStroke: function(t) {
        this._stroke = t
    },
    initWithFade: function(t, e, i, n, r) {
        if (!r)
            throw Error("cc.MotionStreak.initWithFade(): Invalid filename or texture");
        return cc.isString(r) && (r = cc.textureCache.addImage(r)),
        cc.Node.prototype.setPosition.call(this, cc.p(0, 0)),
        this.anchorY = this.anchorX = 0,
        this.ignoreAnchor = !0,
        this.startingPositionInitialized = !1,
        this.fastMode = !0,
        this._minSeg = -1 === e ? i / 5 : e,
        this._minSeg *= this._minSeg,
        this._stroke = i,
        this._fadeDelta = 1 / t,
        this._maxPoints = t = (0 | 60 * t) + 2,
        this._nuPoints = 0,
        this._pointState = new Float32Array(t),
        this._pointVertexes = new Float32Array(2 * t),
        this._vertices = new Float32Array(4 * t),
        this._texCoords = new Float32Array(4 * t),
        this._colorPointer = new Uint8Array(8 * t),
        this._verticesBuffer = gl.createBuffer(),
        this._texCoordsBuffer = gl.createBuffer(),
        this._colorPointerBuffer = gl.createBuffer(),
        this._blendFunc.src = gl.SRC_ALPHA,
        this._blendFunc.dst = gl.ONE_MINUS_SRC_ALPHA,
        this.texture = r,
        this.color = n,
        this.scheduleUpdate(),
        gl.bindBuffer(gl.ARRAY_BUFFER, this._verticesBuffer),
        gl.bufferData(gl.ARRAY_BUFFER, this._vertices, gl.DYNAMIC_DRAW),
        gl.bindBuffer(gl.ARRAY_BUFFER, this._texCoordsBuffer),
        gl.bufferData(gl.ARRAY_BUFFER, this._texCoords, gl.DYNAMIC_DRAW),
        gl.bindBuffer(gl.ARRAY_BUFFER, this._colorPointerBuffer),
        gl.bufferData(gl.ARRAY_BUFFER, this._colorPointer, gl.DYNAMIC_DRAW),
        !0
    },
    tintWithColor: function(t) {
        this.color = t;
        for (var e = this._colorPointer, i = 0, n = 2 * this._nuPoints; i < n; i++)
            e[4 * i] = t.r,
            e[4 * i + 1] = t.g,
            e[4 * i + 2] = t.b
    },
    reset: function() {
        this._nuPoints = 0
    },
    setPosition: function(t, e) {
        this.startingPositionInitialized = !0,
        void 0 === e ? (this._positionR.x = t.x,
        this._positionR.y = t.y) : (this._positionR.x = t,
        this._positionR.y = e)
    },
    getPositionX: function() {
        return this._positionR.x
    },
    setPositionX: function(t) {
        this._positionR.x = t,
        this.startingPositionInitialized || (this.startingPositionInitialized = !0)
    },
    getPositionY: function() {
        return this._positionR.y
    },
    setPositionY: function(t) {
        this._positionR.y = t,
        this.startingPositionInitialized || (this.startingPositionInitialized = !0)
    },
    update: function(t) {
        if (this.startingPositionInitialized) {
            this._renderCmd._updateDisplayColor(),
            t *= this._fadeDelta;
            var e, i, n, r, c = 0, s = this._nuPoints, o = this._pointState, a = this._pointVertexes, h = this._vertices, l = this._colorPointer;
            for (n = 0; n < s; n++)
                o[n] -= t,
                0 >= o[n] ? c++ : (e = n - c,
                0 < c ? (o[e] = o[n],
                a[2 * e] = a[2 * n],
                a[2 * e + 1] = a[2 * n + 1],
                r = 2 * n,
                i = 2 * e,
                h[2 * i] = h[2 * r],
                h[2 * i + 1] = h[2 * r + 1],
                h[2 * (i + 1)] = h[2 * (r + 1)],
                h[2 * (i + 1) + 1] = h[2 * (r + 1) + 1],
                r *= 4,
                i *= 4,
                l[i + 0] = l[r + 0],
                l[i + 1] = l[r + 1],
                l[i + 2] = l[r + 2],
                l[i + 4] = l[r + 4],
                l[i + 5] = l[r + 5],
                l[i + 6] = l[r + 6]) : i = 8 * e,
                e = 255 * o[e],
                l[i + 3] = e,
                l[i + 7] = e);
            if (s -= c,
            n = !0,
            s >= this._maxPoints ? n = !1 : 0 < s && (t = cc.pDistanceSQ(cc.p(a[2 * (s - 1)], a[2 * (s - 1) + 1]), this._positionR) < this._minSeg,
            i = 1 !== s && cc.pDistanceSQ(cc.p(a[2 * (s - 2)], a[2 * (s - 2) + 1]), this._positionR) < 2 * this._minSeg,
            t || i) && (n = !1),
            n && (a[2 * s] = this._positionR.x,
            a[2 * s + 1] = this._positionR.y,
            o[s] = 1,
            o = 8 * s,
            n = this.getDisplayedColor(),
            l[o] = n.r,
            l[o + 1] = n.g,
            l[o + 2] = n.b,
            l[o + 4] = n.r,
            l[o + 5] = n.g,
            l[o + 6] = n.b,
            l[o + 3] = 255,
            l[o + 7] = 255,
            0 < s && this.fastMode && (1 < s ? cc.vertexLineToPolygon(a, this._stroke, this._vertices, s, 1) : cc.vertexLineToPolygon(a, this._stroke, this._vertices, 0, 2)),
            s++),
            this.fastMode || cc.vertexLineToPolygon(a, this._stroke, this._vertices, 0, s),
            s && this._previousNuPoints !== s) {
                for (a = 1 / s,
                l = this._texCoords,
                n = 0; n < s; n++)
                    l[4 * n] = 0,
                    l[4 * n + 1] = a * n,
                    l[2 * (2 * n + 1)] = 1,
                    l[2 * (2 * n + 1) + 1] = a * n;
                this._previousNuPoints = s
            }
            this._nuPoints = s
        }
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_WEBGL ? new cc.MotionStreak.WebGLRenderCmd(this) : null
    }
}),
cc.MotionStreak.create = function(t, e, i, n, r) {
    return new cc.MotionStreak(t,e,i,n,r)
}
,
cc.MotionStreak.WebGLRenderCmd = function(t) {
    cc.Node.WebGLRenderCmd.call(this, t),
    this._needDraw = !0,
    this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)
}
,
cc.MotionStreak.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype),
cc.MotionStreak.WebGLRenderCmd.prototype.constructor = cc.Sprite.WebGLRenderCmd,
cc.MotionStreak.WebGLRenderCmd.prototype.rendering = function(t) {
    var e = this._node;
    1 >= e._nuPoints || !e.texture || !e.texture.isLoaded() || (t = t || cc._renderContext,
    this._shaderProgram.use(),
    this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix),
    cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX),
    cc.glBlendFunc(e._blendFunc.src, e._blendFunc.dst),
    cc.glBindTexture2D(e.texture),
    t.bindBuffer(t.ARRAY_BUFFER, e._verticesBuffer),
    t.bufferData(t.ARRAY_BUFFER, e._vertices, t.DYNAMIC_DRAW),
    t.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, t.FLOAT, !1, 0, 0),
    t.bindBuffer(t.ARRAY_BUFFER, e._texCoordsBuffer),
    t.bufferData(t.ARRAY_BUFFER, e._texCoords, t.DYNAMIC_DRAW),
    t.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, t.FLOAT, !1, 0, 0),
    t.bindBuffer(t.ARRAY_BUFFER, e._colorPointerBuffer),
    t.bufferData(t.ARRAY_BUFFER, e._colorPointer, t.DYNAMIC_DRAW),
    t.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, t.UNSIGNED_BYTE, !0, 0, 0),
    t.drawArrays(t.TRIANGLE_STRIP, 0, 2 * e._nuPoints),
    cc.g_NumberOfDraws++)
}
,
cc.NodeGrid = cc.Node.extend({
    grid: null,
    _target: null,
    _gridRect: null,
    ctor: function(t) {
        cc.Node.prototype.ctor.call(this),
        void 0 === t && (t = cc.rect()),
        this._gridRect = t
    },
    getGrid: function() {
        return this.grid
    },
    setGrid: function(t) {
        this.grid = t
    },
    setGridRect: function(t) {
        this._gridRect = t
    },
    getGridRect: function() {
        return this._gridRect
    },
    setTarget: function(t) {
        this._target = t
    },
    _transformForWebGL: function() {
        var t = this._transform4x4
          , e = cc.current_stack.top
          , i = this.getNodeToParentTransform()
          , n = t.mat;
        n[0] = i.a,
        n[4] = i.c,
        n[12] = i.tx,
        n[1] = i.b,
        n[5] = i.d,
        n[13] = i.ty,
        n[14] = this._vertexZ,
        e.multiply(t),
        null === this._camera || this.grid && this.grid.isActive() || (e = this._renderCmd._anchorPointInPoints,
        t = e.x,
        e = e.y,
        0 !== t || 0 !== e ? (cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (t |= 0,
        e |= 0),
        cc.kmGLTranslatef(t, e, 0),
        this._camera.locate(),
        cc.kmGLTranslatef(-t, -e, 0)) : this._camera.locate())
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_WEBGL ? new cc.NodeGrid.WebGLRenderCmd(this) : new cc.Node.CanvasRenderCmd(this)
    }
}),
_p = cc.NodeGrid.prototype,
cc.defineGetterSetter(_p, "target", null, _p.setTarget),
cc.NodeGrid.create = function() {
    return new cc.NodeGrid
}
,
function() {
    cc.NodeGrid.WebGLRenderCmd = function(t) {
        cc.Node.WebGLRenderCmd.call(this, t),
        this._needDraw = !1,
        this._gridBeginCommand = new cc.CustomRenderCmd(this,this.onGridBeginDraw),
        this._gridEndCommand = new cc.CustomRenderCmd(this,this.onGridEndDraw)
    }
    ;
    var t = cc.NodeGrid.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    t.constructor = cc.NodeGrid.WebGLRenderCmd,
    t.visit = function(t) {
        var e = this._node;
        if (e._visible) {
            t = t || this.getParentRenderCmd(),
            e._parent && e._parent._renderCmd && (this._curLevel = e._parent._renderCmd._curLevel + 1);
            var i = cc.current_stack;
            if (i.stack.push(i.top),
            this._syncStatus(t),
            i.top = this._stackMatrix,
            cc.renderer.pushRenderCommand(this._gridBeginCommand),
            e._target && e._target.visit(),
            (t = e._children) && 0 < t.length) {
                var n = t.length;
                for (e.sortAllChildren(),
                e = 0; e < n; e++) {
                    var r = t[e];
                    r && r.visit()
                }
            }
            cc.renderer.pushRenderCommand(this._gridEndCommand),
            this._dirtyFlag = 0,
            i.top = i.stack.pop()
        }
    }
    ,
    t.onGridBeginDraw = function() {
        var t = this._node.grid;
        t && t._active && t.beforeDraw()
    }
    ,
    t.onGridEndDraw = function() {
        var t = this._node.grid;
        t && t._active && t.afterDraw(this._node)
    }
}(),
cc.v2fzero = function() {
    return {
        x: 0,
        y: 0
    }
}
,
cc.v2f = function(t, e) {
    return {
        x: t,
        y: e
    }
}
,
cc.v2fadd = function(t, e) {
    return cc.v2f(t.x + e.x, t.y + e.y)
}
,
cc.v2fsub = function(t, e) {
    return cc.v2f(t.x - e.x, t.y - e.y)
}
,
cc.v2fmult = function(t, e) {
    return cc.v2f(t.x * e, t.y * e)
}
,
cc.v2fperp = function(t) {
    return cc.v2f(-t.y, t.x)
}
,
cc.v2fneg = function(t) {
    return cc.v2f(-t.x, -t.y)
}
,
cc.v2fdot = function(t, e) {
    return t.x * e.x + t.y * e.y
}
,
cc.v2fforangle = function(t) {
    return cc.v2f(Math.cos(t), Math.sin(t))
}
,
cc.v2fnormalize = function(t) {
    return t = cc.pNormalize(cc.p(t.x, t.y)),
    cc.v2f(t.x, t.y)
}
,
cc.__v2f = function(t) {
    return cc.v2f(t.x, t.y)
}
,
cc.__t = function(t) {
    return {
        u: t.x,
        v: t.y
    }
}
,
cc.DrawNode = cc.Node.extend({
    _buffer: null,
    _blendFunc: null,
    _lineWidth: 1,
    _drawColor: null,
    getBlendFunc: function() {
        return this._blendFunc
    },
    setBlendFunc: function(t, e) {
        void 0 === e ? (this._blendFunc.src = t.src,
        this._blendFunc.dst = t.dst) : (this._blendFunc.src = t,
        this._blendFunc.dst = e)
    },
    setLineWidth: function(t) {
        this._lineWidth = t
    },
    getLineWidth: function() {
        return this._lineWidth
    },
    setDrawColor: function(t) {
        var e = this._drawColor;
        e.r = t.r,
        e.g = t.g,
        e.b = t.b,
        e.a = null == t.a ? 255 : t.a
    },
    getDrawColor: function() {
        return cc.color(this._drawColor.r, this._drawColor.g, this._drawColor.b, this._drawColor.a)
    }
}),
cc.DrawNode.create = function() {
    return new cc.DrawNode
}
,
cc.DrawNode.TYPE_DOT = 0,
cc.DrawNode.TYPE_SEGMENT = 1,
cc.DrawNode.TYPE_POLY = 2,
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function() {
    cc._renderType === cc.game.RENDER_TYPE_CANVAS ? (cc._DrawNodeElement = function(t, e, i, n, r, c, s, o, a) {
        this.type = t,
        this.verts = e || null,
        this.fillColor = i || null,
        this.lineWidth = n || 0,
        this.lineColor = r || null,
        this.lineCap = c || "butt",
        this.isClosePolygon = s || !1,
        this.isFill = o || !1,
        this.isStroke = a || !1
    }
    ,
    cc.extend(cc.DrawNode.prototype, {
        _className: "DrawNodeCanvas",
        ctor: function() {
            cc.Node.prototype.ctor.call(this);
            var t = this._renderCmd;
            t._buffer = this._buffer = [],
            t._drawColor = this._drawColor = cc.color(255, 255, 255, 255),
            t._blendFunc = this._blendFunc = new cc.BlendFunc(cc.SRC_ALPHA,cc.ONE_MINUS_SRC_ALPHA),
            this.init()
        },
        drawRect: function(t, e, i, n, r) {
            n = null == n ? this._lineWidth : n,
            r = r || this.getDrawColor(),
            null == r.a && (r.a = 255),
            t = [t, cc.p(e.x, t.y), e, cc.p(t.x, e.y)],
            e = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY),
            e.verts = t,
            e.lineWidth = n,
            e.lineColor = r,
            e.isClosePolygon = !0,
            e.isStroke = !0,
            e.lineCap = "butt",
            (e.fillColor = i) && (null == i.a && (i.a = 255),
            e.isFill = !0),
            this._buffer.push(e)
        },
        drawCircle: function(t, e, i, n, r, c, s) {
            c = c || this._lineWidth,
            s = s || this.getDrawColor(),
            null == s.a && (s.a = 255);
            for (var o = 2 * Math.PI / n, a = [], h = 0; h <= n; h++) {
                var l = h * o
                  , u = e * Math.cos(l + i) + t.x
                  , l = e * Math.sin(l + i) + t.y;
                a.push(cc.p(u, l))
            }
            r && a.push(cc.p(t.x, t.y)),
            t = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY),
            t.verts = a,
            t.lineWidth = c,
            t.lineColor = s,
            t.isClosePolygon = !0,
            t.isStroke = !0,
            this._buffer.push(t)
        },
        drawQuadBezier: function(t, e, i, n, r, c) {
            r = r || this._lineWidth,
            c = c || this.getDrawColor(),
            null == c.a && (c.a = 255);
            for (var s = [], o = 0, a = 0; a < n; a++) {
                var h = Math.pow(1 - o, 2) * t.x + 2 * (1 - o) * o * e.x + o * o * i.x
                  , l = Math.pow(1 - o, 2) * t.y + 2 * (1 - o) * o * e.y + o * o * i.y;
                s.push(cc.p(h, l)),
                o += 1 / n
            }
            s.push(cc.p(i.x, i.y)),
            t = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY),
            t.verts = s,
            t.lineWidth = r,
            t.lineColor = c,
            t.isStroke = !0,
            t.lineCap = "round",
            this._buffer.push(t)
        },
        drawCubicBezier: function(t, e, i, n, r, c, s) {
            c = c || this._lineWidth,
            s = s || this.getDrawColor(),
            null == s.a && (s.a = 255);
            for (var o = [], a = 0, h = 0; h < r; h++) {
                var l = Math.pow(1 - a, 3) * t.x + 3 * Math.pow(1 - a, 2) * a * e.x + 3 * (1 - a) * a * a * i.x + a * a * a * n.x
                  , u = Math.pow(1 - a, 3) * t.y + 3 * Math.pow(1 - a, 2) * a * e.y + 3 * (1 - a) * a * a * i.y + a * a * a * n.y;
                o.push(cc.p(l, u)),
                a += 1 / r
            }
            o.push(cc.p(n.x, n.y)),
            t = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY),
            t.verts = o,
            t.lineWidth = c,
            t.lineColor = s,
            t.isStroke = !0,
            t.lineCap = "round",
            this._buffer.push(t)
        },
        drawCatmullRom: function(t, e, i, n) {
            this.drawCardinalSpline(t, .5, e, i, n)
        },
        drawCardinalSpline: function(t, e, i, n, r) {
            n = n || this._lineWidth,
            r = r || this.getDrawColor(),
            null == r.a && (r.a = 255);
            for (var c, s, o = [], a = 1 / t.length, h = 0; h < i + 1; h++)
                s = h / i,
                1 === s ? (c = t.length - 1,
                s = 1) : (c = 0 | s / a,
                s = (s - a * c) / a),
                c = cc.cardinalSplineAt(cc.getControlPointAt(t, c - 1), cc.getControlPointAt(t, c - 0), cc.getControlPointAt(t, c + 1), cc.getControlPointAt(t, c + 2), e, s),
                o.push(c);
            t = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY),
            t.verts = o,
            t.lineWidth = n,
            t.lineColor = r,
            t.isStroke = !0,
            t.lineCap = "round",
            this._buffer.push(t)
        },
        drawDot: function(t, e, i) {
            i = i || this.getDrawColor(),
            null == i.a && (i.a = 255);
            var n = new cc._DrawNodeElement(cc.DrawNode.TYPE_DOT);
            n.verts = [t],
            n.lineWidth = e,
            n.fillColor = i,
            this._buffer.push(n)
        },
        drawDots: function(t, e, i) {
            if (t && 0 != t.length) {
                i = i || this.getDrawColor(),
                null == i.a && (i.a = 255);
                for (var n = 0, r = t.length; n < r; n++)
                    this.drawDot(t[n], e, i)
            }
        },
        drawSegment: function(t, e, i, n) {
            i = i || this._lineWidth,
            n = n || this.getDrawColor(),
            null == n.a && (n.a = 255);
            var r = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
            r.verts = [t, e],
            r.lineWidth = 2 * i,
            r.lineColor = n,
            r.isStroke = !0,
            r.lineCap = "round",
            this._buffer.push(r)
        },
        drawPoly_: function(t, e, i, n) {
            i = null == i ? this._lineWidth : i,
            n = n || this.getDrawColor(),
            null == n.a && (n.a = 255);
            var r = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
            r.verts = t,
            r.fillColor = e,
            r.lineWidth = i,
            r.lineColor = n,
            r.isClosePolygon = !0,
            r.isStroke = !0,
            r.lineCap = "round",
            e && (r.isFill = !0),
            this._buffer.push(r)
        },
        drawPoly: function(t, e, i, n) {
            for (var r = [], c = 0; c < t.length; c++)
                r.push(cc.p(t[c].x, t[c].y));
            return this.drawPoly_(r, e, i, n)
        },
        clear: function() {
            this._buffer.length = 0
        },
        _createRenderCmd: function() {
            return new cc.DrawNode.CanvasRenderCmd(this)
        }
    })) : cc._renderType === cc.game.RENDER_TYPE_WEBGL && cc.extend(cc.DrawNode.prototype, {
        _bufferCapacity: 0,
        _trianglesArrayBuffer: null,
        _trianglesWebBuffer: null,
        _trianglesReader: null,
        _dirty: !1,
        _className: "DrawNodeWebGL",
        ctor: function() {
            cc.Node.prototype.ctor.call(this),
            this._buffer = [],
            this._blendFunc = new cc.BlendFunc(cc.SRC_ALPHA,cc.ONE_MINUS_SRC_ALPHA),
            this._drawColor = cc.color(255, 255, 255, 255),
            this.init()
        },
        init: function() {
            return !!cc.Node.prototype.init.call(this) && (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_LENGTHTEXTURECOLOR),
            this._ensureCapacity(64),
            this._trianglesWebBuffer = cc._renderContext.createBuffer(),
            this._dirty = !0)
        },
        drawRect: function(t, e, i, n, r) {
            n = null == n ? this._lineWidth : n,
            r = r || this.getDrawColor(),
            null == r.a && (r.a = 255),
            t = [t, cc.p(e.x, t.y), e, cc.p(t.x, e.y)],
            null == i ? this._drawSegments(t, n, r, !0) : this.drawPoly(t, i, n, r)
        },
        drawCircle: function(t, e, i, n, r, c, s) {
            c = c || this._lineWidth,
            s = s || this.getDrawColor(),
            null == s.a && (s.a = 255);
            var o, a = 2 * Math.PI / n, h = [];
            for (o = 0; o <= n; o++) {
                var l = o * a
                  , u = e * Math.cos(l + i) + t.x
                  , l = e * Math.sin(l + i) + t.y;
                h.push(cc.p(u, l))
            }
            for (r && h.push(cc.p(t.x, t.y)),
            c *= .5,
            o = 0,
            t = h.length; o < t - 1; o++)
                this.drawSegment(h[o], h[o + 1], c, s)
        },
        drawQuadBezier: function(t, e, i, n, r, c) {
            r = r || this._lineWidth,
            c = c || this.getDrawColor(),
            null == c.a && (c.a = 255);
            for (var s = [], o = 0, a = 0; a < n; a++) {
                var h = Math.pow(1 - o, 2) * t.x + 2 * (1 - o) * o * e.x + o * o * i.x
                  , l = Math.pow(1 - o, 2) * t.y + 2 * (1 - o) * o * e.y + o * o * i.y;
                s.push(cc.p(h, l)),
                o += 1 / n
            }
            s.push(cc.p(i.x, i.y)),
            this._drawSegments(s, r, c, !1)
        },
        drawCubicBezier: function(t, e, i, n, r, c, s) {
            c = c || this._lineWidth,
            s = s || this.getDrawColor(),
            null == s.a && (s.a = 255);
            for (var o = [], a = 0, h = 0; h < r; h++) {
                var l = Math.pow(1 - a, 3) * t.x + 3 * Math.pow(1 - a, 2) * a * e.x + 3 * (1 - a) * a * a * i.x + a * a * a * n.x
                  , u = Math.pow(1 - a, 3) * t.y + 3 * Math.pow(1 - a, 2) * a * e.y + 3 * (1 - a) * a * a * i.y + a * a * a * n.y;
                o.push(cc.p(l, u)),
                a += 1 / r
            }
            o.push(cc.p(n.x, n.y)),
            this._drawSegments(o, c, s, !1)
        },
        drawCatmullRom: function(t, e, i, n) {
            this.drawCardinalSpline(t, .5, e, i, n)
        },
        drawCardinalSpline: function(t, e, i, n, r) {
            n = n || this._lineWidth,
            r = r || this.getDrawColor(),
            null == r.a && (r.a = 255);
            for (var c, s, o = [], a = 1 / t.length, h = 0; h < i + 1; h++)
                s = h / i,
                1 === s ? (c = t.length - 1,
                s = 1) : (c = 0 | s / a,
                s = (s - a * c) / a),
                c = cc.cardinalSplineAt(cc.getControlPointAt(t, c - 1), cc.getControlPointAt(t, c - 0), cc.getControlPointAt(t, c + 1), cc.getControlPointAt(t, c + 2), e, s),
                o.push(c);
            for (n *= .5,
            t = 0,
            e = o.length; t < e - 1; t++)
                this.drawSegment(o[t], o[t + 1], n, r)
        },
        _render: function() {
            var t = cc._renderContext;
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX),
            t.bindBuffer(t.ARRAY_BUFFER, this._trianglesWebBuffer),
            this._dirty && (t.bufferData(t.ARRAY_BUFFER, this._trianglesArrayBuffer, t.STREAM_DRAW),
            this._dirty = !1);
            var e = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
            t.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, t.FLOAT, !1, e, 0),
            t.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, t.UNSIGNED_BYTE, !0, e, 8),
            t.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, t.FLOAT, !1, e, 12),
            t.drawArrays(t.TRIANGLES, 0, 3 * this._buffer.length),
            cc.incrementGLDraws(1)
        },
        _ensureCapacity: function(t) {
            var e = this._buffer;
            if (e.length + t > this._bufferCapacity) {
                var i = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT;
                if (this._bufferCapacity += Math.max(this._bufferCapacity, t),
                null == e || 0 === e.length)
                    this._buffer = [],
                    this._trianglesArrayBuffer = new ArrayBuffer(i * this._bufferCapacity),
                    this._trianglesReader = new Uint8Array(this._trianglesArrayBuffer);
                else {
                    t = [];
                    for (var n = new ArrayBuffer(i * this._bufferCapacity), r = 0; r < e.length; r++)
                        t[r] = new cc.V2F_C4B_T2F_Triangle(e[r].a,e[r].b,e[r].c,n,r * i);
                    this._trianglesReader = new Uint8Array(n),
                    this._trianglesArrayBuffer = n,
                    this._buffer = t
                }
            }
        },
        drawDot: function(t, e, i) {
            i = i || this.getDrawColor(),
            null == i.a && (i.a = 255);
            var n = {
                r: 0 | i.r,
                g: 0 | i.g,
                b: 0 | i.b,
                a: 0 | i.a
            };
            i = {
                vertices: {
                    x: t.x - e,
                    y: t.y - e
                },
                colors: n,
                texCoords: {
                    u: -1,
                    v: -1
                }
            };
            var r = {
                vertices: {
                    x: t.x - e,
                    y: t.y + e
                },
                colors: n,
                texCoords: {
                    u: -1,
                    v: 1
                }
            }
              , c = {
                vertices: {
                    x: t.x + e,
                    y: t.y + e
                },
                colors: n,
                texCoords: {
                    u: 1,
                    v: 1
                }
            };
            t = {
                vertices: {
                    x: t.x + e,
                    y: t.y - e
                },
                colors: n,
                texCoords: {
                    u: 1,
                    v: -1
                }
            },
            this._ensureCapacity(6),
            this._buffer.push(new cc.V2F_C4B_T2F_Triangle(i,r,c,this._trianglesArrayBuffer,this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT)),
            this._buffer.push(new cc.V2F_C4B_T2F_Triangle(i,c,t,this._trianglesArrayBuffer,this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT)),
            this._dirty = !0
        },
        drawDots: function(t, e, i) {
            if (t && 0 !== t.length) {
                i = i || this.getDrawColor(),
                null == i.a && (i.a = 255);
                for (var n = 0, r = t.length; n < r; n++)
                    this.drawDot(t[n], e, i)
            }
        },
        drawSegment: function(t, e, i, n) {
            n = n || this.getDrawColor(),
            null == n.a && (n.a = 255),
            i = i || .5 * this._lineWidth,
            this._ensureCapacity(18),
            n = {
                r: 0 | n.r,
                g: 0 | n.g,
                b: 0 | n.b,
                a: 0 | n.a
            };
            var r = cc.__v2f(t)
              , c = cc.__v2f(e);
            e = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(c, r))),
            t = cc.v2fperp(e);
            var s = cc.v2fmult(e, i)
              , o = cc.v2fmult(t, i);
            i = cc.v2fsub(c, cc.v2fadd(s, o));
            var a = cc.v2fadd(c, cc.v2fsub(s, o))
              , h = cc.v2fsub(c, s)
              , c = cc.v2fadd(c, s)
              , l = cc.v2fsub(r, s)
              , u = cc.v2fadd(r, s)
              , d = cc.v2fsub(r, cc.v2fsub(s, o))
              , r = cc.v2fadd(r, cc.v2fadd(s, o))
              , s = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT
              , o = this._trianglesArrayBuffer
              , _ = this._buffer;
            _.push(new cc.V2F_C4B_T2F_Triangle({
                vertices: i,
                colors: n,
                texCoords: cc.__t(cc.v2fneg(cc.v2fadd(e, t)))
            },{
                vertices: a,
                colors: n,
                texCoords: cc.__t(cc.v2fsub(e, t))
            },{
                vertices: h,
                colors: n,
                texCoords: cc.__t(cc.v2fneg(e))
            },o,_.length * s)),
            _.push(new cc.V2F_C4B_T2F_Triangle({
                vertices: c,
                colors: n,
                texCoords: cc.__t(e)
            },{
                vertices: a,
                colors: n,
                texCoords: cc.__t(cc.v2fsub(e, t))
            },{
                vertices: h,
                colors: n,
                texCoords: cc.__t(cc.v2fneg(e))
            },o,_.length * s)),
            _.push(new cc.V2F_C4B_T2F_Triangle({
                vertices: c,
                colors: n,
                texCoords: cc.__t(e)
            },{
                vertices: l,
                colors: n,
                texCoords: cc.__t(cc.v2fneg(e))
            },{
                vertices: h,
                colors: n,
                texCoords: cc.__t(cc.v2fneg(e))
            },o,_.length * s)),
            _.push(new cc.V2F_C4B_T2F_Triangle({
                vertices: c,
                colors: n,
                texCoords: cc.__t(e)
            },{
                vertices: l,
                colors: n,
                texCoords: cc.__t(cc.v2fneg(e))
            },{
                vertices: u,
                colors: n,
                texCoords: cc.__t(e)
            },o,_.length * s)),
            _.push(new cc.V2F_C4B_T2F_Triangle({
                vertices: d,
                colors: n,
                texCoords: cc.__t(cc.v2fsub(t, e))
            },{
                vertices: l,
                colors: n,
                texCoords: cc.__t(cc.v2fneg(e))
            },{
                vertices: u,
                colors: n,
                texCoords: cc.__t(e)
            },o,_.length * s)),
            _.push(new cc.V2F_C4B_T2F_Triangle({
                vertices: d,
                colors: n,
                texCoords: cc.__t(cc.v2fsub(t, e))
            },{
                vertices: r,
                colors: n,
                texCoords: cc.__t(cc.v2fadd(e, t))
            },{
                vertices: u,
                colors: n,
                texCoords: cc.__t(e)
            },o,_.length * s)),
            this._dirty = !0
        },
        drawPoly: function(t, e, i, n) {
            if (null == e)
                this._drawSegments(t, i, n, !0);
            else {
                null == e.a && (e.a = 255),
                null == n.a && (n.a = 255),
                i = null == i ? this._lineWidth : i,
                i *= .5,
                e = {
                    r: 0 | e.r,
                    g: 0 | e.g,
                    b: 0 | e.b,
                    a: 0 | e.a
                },
                n = {
                    r: 0 | n.r,
                    g: 0 | n.g,
                    b: 0 | n.b,
                    a: 0 | n.a
                };
                var r, c, s, o, a = [], h = t.length;
                for (r = 0; r < h; r++) {
                    c = cc.__v2f(t[(r - 1 + h) % h]),
                    s = cc.__v2f(t[r]),
                    o = cc.__v2f(t[(r + 1) % h]);
                    var l = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(s, c)));
                    s = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(o, s))),
                    l = cc.v2fmult(cc.v2fadd(l, s), 1 / (cc.v2fdot(l, s) + 1)),
                    a[r] = {
                        offset: l,
                        n: s
                    }
                }
                l = 0 < i,
                this._ensureCapacity(3 * (3 * h - 2));
                var u = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT
                  , d = this._trianglesArrayBuffer
                  , _ = this._buffer
                  , p = 0 == l ? .5 : 0;
                for (r = 0; r < h - 2; r++)
                    c = cc.v2fsub(cc.__v2f(t[0]), cc.v2fmult(a[0].offset, p)),
                    s = cc.v2fsub(cc.__v2f(t[r + 1]), cc.v2fmult(a[r + 1].offset, p)),
                    o = cc.v2fsub(cc.__v2f(t[r + 2]), cc.v2fmult(a[r + 2].offset, p)),
                    _.push(new cc.V2F_C4B_T2F_Triangle({
                        vertices: c,
                        colors: e,
                        texCoords: cc.__t(cc.v2fzero())
                    },{
                        vertices: s,
                        colors: e,
                        texCoords: cc.__t(cc.v2fzero())
                    },{
                        vertices: o,
                        colors: e,
                        texCoords: cc.__t(cc.v2fzero())
                    },d,_.length * u));
                for (r = 0; r < h; r++) {
                    p = (r + 1) % h,
                    c = cc.__v2f(t[r]),
                    s = cc.__v2f(t[p]),
                    o = a[r].n;
                    var f = a[r].offset
                      , g = a[p].offset
                      , p = l ? cc.v2fsub(c, cc.v2fmult(f, i)) : cc.v2fsub(c, cc.v2fmult(f, .5))
                      , m = l ? cc.v2fsub(s, cc.v2fmult(g, i)) : cc.v2fsub(s, cc.v2fmult(g, .5));
                    c = l ? cc.v2fadd(c, cc.v2fmult(f, i)) : cc.v2fadd(c, cc.v2fmult(f, .5)),
                    s = l ? cc.v2fadd(s, cc.v2fmult(g, i)) : cc.v2fadd(s, cc.v2fmult(g, .5)),
                    l ? (_.push(new cc.V2F_C4B_T2F_Triangle({
                        vertices: p,
                        colors: n,
                        texCoords: cc.__t(cc.v2fneg(o))
                    },{
                        vertices: m,
                        colors: n,
                        texCoords: cc.__t(cc.v2fneg(o))
                    },{
                        vertices: s,
                        colors: n,
                        texCoords: cc.__t(o)
                    },d,_.length * u)),
                    _.push(new cc.V2F_C4B_T2F_Triangle({
                        vertices: p,
                        colors: n,
                        texCoords: cc.__t(cc.v2fneg(o))
                    },{
                        vertices: c,
                        colors: n,
                        texCoords: cc.__t(o)
                    },{
                        vertices: s,
                        colors: n,
                        texCoords: cc.__t(o)
                    },d,_.length * u))) : (_.push(new cc.V2F_C4B_T2F_Triangle({
                        vertices: p,
                        colors: e,
                        texCoords: cc.__t(cc.v2fzero())
                    },{
                        vertices: m,
                        colors: e,
                        texCoords: cc.__t(cc.v2fzero())
                    },{
                        vertices: s,
                        colors: e,
                        texCoords: cc.__t(o)
                    },d,_.length * u)),
                    _.push(new cc.V2F_C4B_T2F_Triangle({
                        vertices: p,
                        colors: e,
                        texCoords: cc.__t(cc.v2fzero())
                    },{
                        vertices: c,
                        colors: e,
                        texCoords: cc.__t(o)
                    },{
                        vertices: s,
                        colors: e,
                        texCoords: cc.__t(o)
                    },d,_.length * u)))
                }
                this._dirty = !0
            }
        },
        _drawSegments: function(t, e, i, n) {
            if (e = null == e ? this._lineWidth : e,
            i = i || this._drawColor,
            null == i.a && (i.a = 255),
            e *= .5,
            !(0 >= e)) {
                i = {
                    r: 0 | i.r,
                    g: 0 | i.g,
                    b: 0 | i.b,
                    a: 0 | i.a
                };
                var r, c, s, o, a = [], h = t.length;
                for (r = 0; r < h; r++) {
                    c = cc.__v2f(t[(r - 1 + h) % h]),
                    s = cc.__v2f(t[r]),
                    o = cc.__v2f(t[(r + 1) % h]);
                    var l = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(s, c)));
                    s = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(o, s))),
                    o = cc.v2fmult(cc.v2fadd(l, s), 1 / (cc.v2fdot(l, s) + 1)),
                    a[r] = {
                        offset: o,
                        n: s
                    }
                }
                this._ensureCapacity(3 * (3 * h - 2)),
                o = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT;
                var l = this._trianglesArrayBuffer
                  , u = this._buffer;
                for (n = n ? h : h - 1,
                r = 0; r < n; r++) {
                    var d = (r + 1) % h;
                    c = cc.__v2f(t[r]),
                    s = cc.__v2f(t[d]);
                    var _ = a[r].n
                      , p = a[r].offset
                      , f = a[d].offset
                      , d = cc.v2fsub(c, cc.v2fmult(p, e))
                      , g = cc.v2fsub(s, cc.v2fmult(f, e));
                    c = cc.v2fadd(c, cc.v2fmult(p, e)),
                    s = cc.v2fadd(s, cc.v2fmult(f, e)),
                    u.push(new cc.V2F_C4B_T2F_Triangle({
                        vertices: d,
                        colors: i,
                        texCoords: cc.__t(cc.v2fneg(_))
                    },{
                        vertices: g,
                        colors: i,
                        texCoords: cc.__t(cc.v2fneg(_))
                    },{
                        vertices: s,
                        colors: i,
                        texCoords: cc.__t(_)
                    },l,u.length * o)),
                    u.push(new cc.V2F_C4B_T2F_Triangle({
                        vertices: d,
                        colors: i,
                        texCoords: cc.__t(cc.v2fneg(_))
                    },{
                        vertices: c,
                        colors: i,
                        texCoords: cc.__t(_)
                    },{
                        vertices: s,
                        colors: i,
                        texCoords: cc.__t(_)
                    },l,u.length * o))
                }
                this._dirty = !0
            }
        },
        clear: function() {
            this._buffer.length = 0,
            this._dirty = !0
        },
        _createRenderCmd: function() {
            return new cc.DrawNode.WebGLRenderCmd(this)
        }
    })
}),
function() {
    cc.DrawNode.CanvasRenderCmd = function(t) {
        cc.Node.CanvasRenderCmd.call(this, t),
        this._needDraw = !0,
        this._blendFunc = this._drawColor = this._buffer = null
    }
    ,
    cc.DrawNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype),
    cc.DrawNode.CanvasRenderCmd.prototype.constructor = cc.DrawNode.CanvasRenderCmd,
    cc.extend(cc.DrawNode.CanvasRenderCmd.prototype, {
        rendering: function(t, e, i) {
            t = t || cc._renderContext,
            t.getContext();
            var n = this._node._displayedOpacity / 255;
            if (0 !== n) {
                t.setTransform(this._worldTransform, e, i),
                t.setGlobalAlpha(n),
                this._blendFunc && this._blendFunc.src === cc.SRC_ALPHA && this._blendFunc.dst === cc.ONE && t.setCompositeOperation("lighter");
                for (var n = this._buffer, r = 0, c = n.length; r < c; r++) {
                    var s = n[r];
                    switch (s.type) {
                    case cc.DrawNode.TYPE_DOT:
                        this._drawDot(t, s, e, i);
                        break;
                    case cc.DrawNode.TYPE_SEGMENT:
                        this._drawSegment(t, s, e, i);
                        break;
                    case cc.DrawNode.TYPE_POLY:
                        this._drawPoly(t, s, e, i)
                    }
                }
            }
        },
        _drawDot: function(t, e, i, n) {
            var r = e.fillColor
              , c = e.verts[0];
            e = e.lineWidth;
            var s = t.getContext();
            t.setFillStyle("rgba(" + (0 | r.r) + "," + (0 | r.g) + "," + (0 | r.b) + "," + r.a / 255 + ")"),
            s.beginPath(),
            s.arc(c.x * i, -c.y * n, e * i, 0, 2 * Math.PI, !1),
            s.closePath(),
            s.fill()
        },
        _drawSegment: function(t, e, i, n) {
            var r = e.lineColor
              , c = e.verts[0]
              , s = e.verts[1]
              , o = e.lineWidth;
            e = e.lineCap;
            var a = t.getContext();
            t.setStrokeStyle("rgba(" + (0 | r.r) + "," + (0 | r.g) + "," + (0 | r.b) + "," + r.a / 255 + ")"),
            a.lineWidth = o * i,
            a.beginPath(),
            a.lineCap = e,
            a.moveTo(c.x * i, -c.y * n),
            a.lineTo(s.x * i, -s.y * n),
            a.stroke()
        },
        _drawPoly: function(t, e, i, n) {
            var r = e.verts
              , c = e.lineCap;
            if (null != r) {
                var s = e.fillColor
                  , o = e.lineWidth
                  , a = e.lineColor
                  , h = e.isClosePolygon
                  , l = e.isFill;
                e = e.isStroke;
                var u = t.getContext()
                  , d = r[0];
                for (u.lineCap = c,
                s && t.setFillStyle("rgba(" + (0 | s.r) + "," + (0 | s.g) + "," + (0 | s.b) + "," + s.a / 255 + ")"),
                o && (u.lineWidth = o * i),
                a && t.setStrokeStyle("rgba(" + (0 | a.r) + "," + (0 | a.g) + "," + (0 | a.b) + "," + a.a / 255 + ")"),
                u.beginPath(),
                u.moveTo(d.x * i, -d.y * n),
                t = 1,
                c = r.length; t < c; t++)
                    u.lineTo(r[t].x * i, -r[t].y * n);
                h && u.closePath(),
                l && u.fill(),
                e && u.stroke()
            }
        }
    })
}(),
function() {
    cc.DrawNode.WebGLRenderCmd = function(t) {
        cc.Node.WebGLRenderCmd.call(this, t),
        this._needDraw = !0
    }
    ,
    cc.DrawNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype),
    cc.DrawNode.WebGLRenderCmd.prototype.constructor = cc.DrawNode.WebGLRenderCmd,
    cc.DrawNode.WebGLRenderCmd.prototype.rendering = function(t) {
        t = this._node,
        cc.glBlendFunc(t._blendFunc.src, t._blendFunc.dst),
        this._shaderProgram.use(),
        this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix),
        t._render()
    }
}(),
cc.stencilBits = -1,
cc.ClippingNode = cc.Node.extend({
    alphaThreshold: 0,
    inverted: !1,
    _stencil: null,
    _className: "ClippingNode",
    ctor: function(t) {
        t = t || null,
        cc.Node.prototype.ctor.call(this),
        this._stencil = t,
        this.alphaThreshold = 1,
        this.inverted = !1,
        this._renderCmd.initStencilBits()
    },
    init: function(t) {
        return this._stencil = t,
        this.alphaThreshold = 1,
        this.inverted = !1,
        this._renderCmd.initStencilBits(),
        !0
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this),
        this._stencil.onEnter()
    },
    onEnterTransitionDidFinish: function() {
        cc.Node.prototype.onEnterTransitionDidFinish.call(this),
        this._stencil.onEnterTransitionDidFinish()
    },
    onExitTransitionDidStart: function() {
        this._stencil.onExitTransitionDidStart(),
        cc.Node.prototype.onExitTransitionDidStart.call(this)
    },
    onExit: function() {
        this._stencil.onExit(),
        cc.Node.prototype.onExit.call(this)
    },
    getAlphaThreshold: function() {
        return this.alphaThreshold
    },
    setAlphaThreshold: function(t) {
        this.alphaThreshold = t
    },
    isInverted: function() {
        return this.inverted
    },
    setInverted: function(t) {
        this.inverted = t
    },
    getStencil: function() {
        return this._stencil
    },
    setStencil: function(t) {
        this._stencil !== t && this._renderCmd.setStencil(t)
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.ClippingNode.CanvasRenderCmd(this) : new cc.ClippingNode.WebGLRenderCmd(this)
    }
}),
_p = cc.ClippingNode.prototype,
cc.defineGetterSetter(_p, "stencil", _p.getStencil, _p.setStencil),
cc.ClippingNode.create = function(t) {
    return new cc.ClippingNode(t)
}
,
function() {
    cc.ClippingNode.CanvasRenderCmd = function(t) {
        cc.Node.CanvasRenderCmd.call(this, t),
        this._clipElemType = this._godhelpme = this._needDraw = !1,
        this._rendererSaveCmd = new cc.CustomRenderCmd(this,this._saveCmdCallback),
        this._rendererClipCmd = new cc.CustomRenderCmd(this,this._clipCmdCallback),
        this._rendererRestoreCmd = new cc.CustomRenderCmd(this,this._restoreCmdCallback)
    }
    ;
    var t = cc.ClippingNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    t.constructor = cc.ClippingNode.CanvasRenderCmd,
    t.initStencilBits = function() {}
    ,
    t.setStencil = function(t) {
        if (null != t)
            if (this._node._stencil = t,
            t instanceof cc.DrawNode) {
                if (t._buffer)
                    for (var e = 0; e < t._buffer.length; e++)
                        t._buffer[e].isFill = !1,
                        t._buffer[e].isStroke = !1;
                t._renderCmd.rendering = function(e, i, n) {
                    i = i || cc.view.getScaleX(),
                    n = n || cc.view.getScaleY(),
                    e = (e || cc._renderContext).getContext();
                    var r = this._transform;
                    for (e.transform(r.a, r.b, r.c, r.d, r.tx * i, -r.ty * n),
                    r = 0; r < t._buffer.length; r++) {
                        var c = t._buffer[r].verts
                          , s = c[0];
                        for (e.moveTo(s.x * i, -s.y * n),
                        s = c.length - 1; 0 < s; s--)
                            e.lineTo(c[s].x * i, -c[s].y * n)
                    }
                }
            } else
                t._parent = this._node
    }
    ,
    t._saveCmdCallback = function(t, e, i) {
        var n = t || cc._renderContext;
        t = n.getContext(),
        this._clipElemType ? (e = cc.ClippingNode.CanvasRenderCmd._getSharedCache(),
        i = t.canvas,
        e.width = i.width,
        e.height = i.height,
        e.getContext("2d").drawImage(i, 0, 0)) : (n.save(),
        t.beginPath(),
        n.setTransform(this._worldTransform, e, i),
        this._node.inverted && (t.rect(0, 0, t.canvas.width, -t.canvas.height),
        t.clip()))
    }
    ,
    t._setStencilCompositionOperation = function(t) {
        if (t) {
            var e = this._node;
            if (t._renderCmd && t._renderCmd._blendFuncStr && (t._renderCmd._blendFuncStr = e.inverted ? "destination-out" : "destination-in"),
            t._children) {
                t = t._children;
                for (var e = 0, i = t.length; e < i; e++)
                    this._setStencilCompositionOperation(t[e])
            }
        }
    }
    ,
    t._clipCmdCallback = function(t) {
        var e = this._node;
        t = (t || cc._renderContext).getContext(),
        this._clipElemType ? this._setStencilCompositionOperation(e._stencil) : t.clip()
    }
    ,
    t._restoreCmdCallback = function(t) {
        var e = cc.ClippingNode.CanvasRenderCmd._getSharedCache();
        t = t || cc._renderContext;
        var i = t.getContext();
        this._clipElemType ? (i.save(),
        i.setTransform(1, 0, 0, 1, 0, 0),
        i.globalCompositeOperation = "destination-over",
        i.drawImage(e, 0, 0),
        i.restore(),
        this._dirtyFlag = 0) : t.restore()
    }
    ,
    t.transform = function(t, e) {
        cc.Node.CanvasRenderCmd.prototype.transform.call(this, t, e);
        var i = this._node;
        i._stencil && i._stencil._renderCmd && i._stencil._renderCmd.transform(this, e)
    }
    ,
    t._cangodhelpme = function(t) {
        return !0 !== t && !1 !== t || (cc.ClippingNode.CanvasRenderCmd.prototype._godhelpme = t),
        cc.ClippingNode.CanvasRenderCmd.prototype._godhelpme
    }
    ,
    t.visit = function(t) {
        var e = this._node;
        if (e._visible)
            if ((t = t || this.getParentRenderCmd()) && (this._curLevel = t._curLevel + 1),
            this._clipElemType = !(!this._cangodhelpme() && e._stencil instanceof cc.DrawNode),
            e._stencil && e._stencil.visible) {
                if (this._syncStatus(t),
                cc.renderer.pushRenderCommand(this._rendererSaveCmd),
                this._clipElemType ? cc.Node.CanvasRenderCmd.prototype.visit.call(this, t) : e._stencil.visit(this),
                cc.renderer.pushRenderCommand(this._rendererClipCmd),
                this._clipElemType)
                    e._stencil.visit(this);
                else {
                    t = e._children,
                    this._cangodhelpme(!0);
                    var i = t.length;
                    if (0 < i)
                        for (e.sortAllChildren(),
                        e = 0; e < i; e++)
                            t[e]._renderCmd.visit(this);
                    this._cangodhelpme(!1)
                }
                cc.renderer.pushRenderCommand(this._rendererRestoreCmd),
                this._dirtyFlag = 0
            } else
                this.inverted && cc.Node.CanvasRenderCmd.prototype.visit.call(this, t)
    }
    ,
    cc.ClippingNode.CanvasRenderCmd._sharedCache = null,
    cc.ClippingNode.CanvasRenderCmd._getSharedCache = function() {
        return cc.ClippingNode.CanvasRenderCmd._sharedCache || (cc.ClippingNode.CanvasRenderCmd._sharedCache = document.createElement("canvas"))
    }
}(),
function() {
    cc.ClippingNode.WebGLRenderCmd = function(t) {
        cc.Node.WebGLRenderCmd.call(this, t),
        this._needDraw = !1,
        this._beforeVisitCmd = new cc.CustomRenderCmd(this,this._onBeforeVisit),
        this._afterDrawStencilCmd = new cc.CustomRenderCmd(this,this._onAfterDrawStencil),
        this._afterVisitCmd = new cc.CustomRenderCmd(this,this._onAfterVisit),
        this._mask_layer_le = this._currentDepthWriteMask = this._currentStencilEnabled = this._currentStencilWriteMask = this._currentStencilPassDepthPass = this._currentStencilPassDepthFail = this._currentStencilFail = this._currentStencilValueMask = this._currentStencilRef = this._currentStencilFunc = null
    }
    ;
    var t = cc.ClippingNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    t.constructor = cc.ClippingNode.WebGLRenderCmd,
    cc.ClippingNode.WebGLRenderCmd._init_once = null,
    cc.ClippingNode.WebGLRenderCmd._visit_once = null,
    cc.ClippingNode.WebGLRenderCmd._layer = -1,
    t.initStencilBits = function() {
        cc.ClippingNode.WebGLRenderCmd._init_once = !0,
        cc.ClippingNode.WebGLRenderCmd._init_once && (cc.stencilBits = cc._renderContext.getParameter(cc._renderContext.STENCIL_BITS),
        0 >= cc.stencilBits && cc.log("Stencil buffer is not enabled."),
        cc.ClippingNode.WebGLRenderCmd._init_once = !1)
    }
    ,
    t.transform = function(t, e) {
        var i = this._node;
        cc.Node.WebGLRenderCmd.prototype.transform.call(this, t, e),
        i._stencil && i._stencil._renderCmd.transform(this, e)
    }
    ,
    t.visit = function(t) {
        var e = this._node;
        if (e._visible)
            if (e._parent && e._parent._renderCmd && (this._curLevel = e._parent._renderCmd._curLevel + 1),
            1 > cc.stencilBits)
                cc.Node.WebGLRenderCmd.prototype.visit.call(this, t);
            else if (e._stencil && e._stencil.visible)
                if (cc.ClippingNode.WebGLRenderCmd._layer + 1 === cc.stencilBits)
                    cc.ClippingNode.WebGLRenderCmd._visit_once = !0,
                    cc.ClippingNode.WebGLRenderCmd._visit_once && (cc.log("Nesting more than " + cc.stencilBits + "stencils is not supported. Everything will be drawn without stencil for this node and its children."),
                    cc.ClippingNode.WebGLRenderCmd._visit_once = !1),
                    cc.Node.WebGLRenderCmd.prototype.visit.call(this, t);
                else {
                    cc.renderer.pushRenderCommand(this._beforeVisitCmd);
                    var i = cc.current_stack;
                    if (i.stack.push(i.top),
                    this._syncStatus(t),
                    i.top = this._stackMatrix,
                    e._stencil._renderCmd.visit(this),
                    cc.renderer.pushRenderCommand(this._afterDrawStencilCmd),
                    (t = e._children) && 0 < t.length) {
                        var n = t.length;
                        for (e.sortAllChildren(),
                        e = 0; e < n; e++)
                            t[e]._renderCmd.visit(this)
                    }
                    cc.renderer.pushRenderCommand(this._afterVisitCmd),
                    this._dirtyFlag = 0,
                    i.top = i.stack.pop()
                }
            else
                e.inverted && cc.Node.WebGLRenderCmd.prototype.visit.call(this, t)
    }
    ,
    t.setStencil = function(t) {
        var e = this._node;
        e._stencil && (e._stencil._parent = null),
        e._stencil = t,
        e._stencil && (e._stencil._parent = e)
    }
    ,
    t._drawFullScreenQuadClearStencil = function() {
        var t = cc.projection_matrix_stack;
        t.push(),
        t.top.identity();
        var e = cc.modelview_matrix_stack;
        e.push(),
        e.top.identity(),
        cc._drawingUtil.drawSolidRect(cc.p(-1, -1), cc.p(1, 1), cc.color(255, 255, 255, 255)),
        t.pop(),
        e.pop()
    }
    ,
    t._onBeforeVisit = function(t) {
        var e = t || cc._renderContext;
        t = this._node,
        cc.ClippingNode.WebGLRenderCmd._layer++;
        var i = 1 << cc.ClippingNode.WebGLRenderCmd._layer;
        this._mask_layer_le = i | i - 1,
        this._currentStencilEnabled = e.isEnabled(e.STENCIL_TEST),
        this._currentStencilWriteMask = e.getParameter(e.STENCIL_WRITEMASK),
        this._currentStencilFunc = e.getParameter(e.STENCIL_FUNC),
        this._currentStencilRef = e.getParameter(e.STENCIL_REF),
        this._currentStencilValueMask = e.getParameter(e.STENCIL_VALUE_MASK),
        this._currentStencilFail = e.getParameter(e.STENCIL_FAIL),
        this._currentStencilPassDepthFail = e.getParameter(e.STENCIL_PASS_DEPTH_FAIL),
        this._currentStencilPassDepthPass = e.getParameter(e.STENCIL_PASS_DEPTH_PASS),
        e.enable(e.STENCIL_TEST),
        e.stencilMask(i),
        this._currentDepthWriteMask = e.getParameter(e.DEPTH_WRITEMASK),
        e.depthMask(!1),
        e.stencilFunc(e.NEVER, i, i),
        e.stencilOp(t.inverted ? e.REPLACE : e.ZERO, e.KEEP, e.KEEP),
        this._drawFullScreenQuadClearStencil(),
        e.stencilFunc(e.NEVER, i, i),
        e.stencilOp(t.inverted ? e.ZERO : e.REPLACE, e.KEEP, e.KEEP),
        1 > t.alphaThreshold && (i = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST),
        e = e.getUniformLocation(i.getProgram(), cc.UNIFORM_ALPHA_TEST_VALUE_S),
        cc.glUseProgram(i.getProgram()),
        i.setUniformLocationWith1f(e, t.alphaThreshold),
        cc.setProgram(t._stencil, i))
    }
    ,
    t._onAfterDrawStencil = function(t) {
        t = t || cc._renderContext,
        t.depthMask(this._currentDepthWriteMask),
        t.stencilFunc(t.EQUAL, this._mask_layer_le, this._mask_layer_le),
        t.stencilOp(t.KEEP, t.KEEP, t.KEEP)
    }
    ,
    t._onAfterVisit = function(t) {
        t = t || cc._renderContext,
        t.stencilFunc(this._currentStencilFunc, this._currentStencilRef, this._currentStencilValueMask),
        t.stencilOp(this._currentStencilFail, this._currentStencilPassDepthFail, this._currentStencilPassDepthPass),
        t.stencilMask(this._currentStencilWriteMask),
        this._currentStencilEnabled || t.disable(t.STENCIL_TEST),
        cc.ClippingNode.WebGLRenderCmd._layer--
    }
}(),
cc.GridBase = cc.Class.extend({
    _active: !1,
    _reuseGrid: 0,
    _gridSize: null,
    _gridRect: null,
    _texture: null,
    _step: null,
    _grabber: null,
    _isTextureFlipped: !1,
    _shaderProgram: null,
    _directorProjection: 0,
    _dirty: !1,
    ctor: function(t, e, i, n) {
        cc.sys._checkWebGLRenderMode(),
        this._active = !1,
        this._reuseGrid = 0,
        this._gridSize = null,
        this._gridRect = new cc.rect,
        this._texture = null,
        this._step = cc.p(0, 0),
        this._grabber = null,
        this._isTextureFlipped = !1,
        this._shaderProgram = null,
        this._directorProjection = 0,
        this._dirty = !1,
        void 0 !== t && this.initWithSize(t, e, i, n)
    },
    isActive: function() {
        return this._active
    },
    setActive: function(t) {
        if (this._active = t,
        !t) {
            t = cc.director;
            var e = t.getProjection();
            t.setProjection(e)
        }
    },
    getReuseGrid: function() {
        return this._reuseGrid
    },
    setReuseGrid: function(t) {
        this._reuseGrid = t
    },
    getGridSize: function() {
        return cc.size(this._gridSize.width, this._gridSize.height)
    },
    setGridSize: function(t) {
        this._gridSize.width = parseInt(t.width),
        this._gridSize.height = parseInt(t.height)
    },
    setGridRect: function(t) {
        this._gridRect = t
    },
    getGridRect: function() {
        return this._gridRect
    },
    getStep: function() {
        return cc.p(this._step.x, this._step.y)
    },
    setStep: function(t) {
        this._step.x = t.x,
        this._step.y = t.y
    },
    isTextureFlipped: function() {
        return this._isTextureFlipped
    },
    setTextureFlipped: function(t) {
        this._isTextureFlipped !== t && (this._isTextureFlipped = t,
        this.calculateVertexPoints())
    },
    initWithSize: function(t, e, i, n) {
        if (!e) {
            var r = cc.director.getWinSizeInPixels()
              , c = cc.NextPOT(r.width)
              , s = cc.NextPOT(r.height)
              , o = new Uint8Array(c * s * 4);
            if (!o)
                return cc.log("cocos2d: CCGrid: not enough memory."),
                !1;
            if (e = new cc.Texture2D,
            e.initWithData(o, cc.Texture2D.PIXEL_FORMAT_RGBA8888, c, s, r),
            !e)
                return cc.log("cocos2d: CCGrid: error creating texture"),
                !1
        }
        return this._active = !1,
        this._reuseGrid = 0,
        this._gridSize = t,
        this._texture = e,
        this._isTextureFlipped = i || !1,
        (void 0 === n || cc._rectEqualToZero(n)) && (e = this._texture.getContentSize(),
        n = new cc.rect(0,0,e.width,e.height)),
        this._gridRect = n,
        this._step.x = this._gridRect.width / t.width,
        this._step.y = this._gridRect.height / t.height,
        this._grabber = new cc.Grabber,
        !!this._grabber && (this._grabber.grab(this._texture),
        this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE),
        this.calculateVertexPoints(),
        !0)
    },
    beforeDraw: function() {
        this._directorProjection = cc.director.getProjection();
        var t = cc.director.getWinSizeInPixels();
        gl.viewport(0, 0, t.width, t.height),
        this._grabber.beforeRender(this._texture)
    },
    afterDraw: function(t) {
        if (this._grabber.afterRender(this._texture),
        cc.director.setViewport(),
        t && t.getCamera().isDirty()) {
            var e = t.getAnchorPointInPoints()
              , i = t._renderCmd._stackMatrix
              , n = cc.math.Matrix4.createByTranslation(e.x, e.y, 0);
            i.multiply(n),
            t._camera._locateForRenderer(i),
            n = cc.math.Matrix4.createByTranslation(-e.x, -e.y, 0, n),
            i.multiply(n)
        }
        cc.glBindTexture2D(this._texture),
        this.beforeBlit(),
        this.blit(t),
        this.afterBlit()
    },
    beforeBlit: function() {},
    afterBlit: function() {},
    blit: function() {
        cc.log("cc.GridBase.blit(): Shall be overridden in subclass.")
    },
    reuse: function() {
        cc.log("cc.GridBase.reuse(): Shall be overridden in subclass.")
    },
    calculateVertexPoints: function() {
        cc.log("cc.GridBase.calculateVertexPoints(): Shall be overridden in subclass.")
    },
    set2DProjection: function() {
        var t = cc.director.getWinSizeInPixels();
        cc._renderContext.viewport(0, 0, t.width, t.height),
        cc.kmGLMatrixMode(cc.KM_GL_PROJECTION),
        cc.kmGLLoadIdentity(),
        t = cc.math.Matrix4.createOrthographicProjection(0, t.width, 0, t.height, -1, 1),
        cc.kmGLMultMatrix(t),
        cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW),
        cc.kmGLLoadIdentity(),
        cc.setProjectionMatrixDirty()
    }
}),
cc.GridBase.create = function(t, e, i, n) {
    return new cc.GridBase(t,e,i,n)
}
,
cc.Grid3D = cc.GridBase.extend({
    _texCoordinates: null,
    _vertices: null,
    _originalVertices: null,
    _indices: null,
    _texCoordinateBuffer: null,
    _verticesBuffer: null,
    _indicesBuffer: null,
    _needDepthTestForBlit: !1,
    _oldDepthTestValue: !1,
    _oldDepthWriteValue: !1,
    ctor: function(t, e, i, n) {
        cc.GridBase.prototype.ctor.call(this),
        this._indicesBuffer = this._verticesBuffer = this._texCoordinateBuffer = this._indices = this._originalVertices = this._vertices = this._texCoordinates = null,
        void 0 !== t && this.initWithSize(t, e, i, n)
    },
    vertex: function(t) {
        return this.getVertex(t)
    },
    getVertex: function(t) {
        t.x === (0 | t.x) && t.y === (0 | t.y) || cc.log("cc.Grid3D.vertex() : Numbers must be integers"),
        t = 0 | 3 * (t.x * (this._gridSize.height + 1) + t.y);
        var e = this._vertices;
        return new cc.Vertex3F(e[t],e[t + 1],e[t + 2])
    },
    originalVertex: function(t) {
        return this.getOriginalVertex(t)
    },
    getOriginalVertex: function(t) {
        t.x === (0 | t.x) && t.y === (0 | t.y) || cc.log("cc.Grid3D.originalVertex() : Numbers must be integers"),
        t = 0 | 3 * (t.x * (this._gridSize.height + 1) + t.y);
        var e = this._originalVertices;
        return new cc.Vertex3F(e[t],e[t + 1],e[t + 2])
    },
    setVertex: function(t, e) {
        t.x === (0 | t.x) && t.y === (0 | t.y) || cc.log("cc.Grid3D.setVertex() : Numbers must be integers");
        var i = 0 | 3 * (t.x * (this._gridSize.height + 1) + t.y)
          , n = this._vertices;
        n[i] = e.x,
        n[i + 1] = e.y,
        n[i + 2] = e.z,
        this._dirty = !0
    },
    beforeBlit: function() {
        if (this._needDepthTestForBlit) {
            var t = cc._renderContext;
            this._oldDepthTestValue = t.isEnabled(t.DEPTH_TEST),
            this._oldDepthWriteValue = t.getParameter(t.DEPTH_WRITEMASK),
            t.enable(t.DEPTH_TEST),
            t.depthMask(!0)
        }
    },
    afterBlit: function() {
        if (this._needDepthTestForBlit) {
            var t = cc._renderContext;
            this._oldDepthTestValue ? t.enable(t.DEPTH_TEST) : t.disable(t.DEPTH_TEST),
            t.depthMask(this._oldDepthWriteValue)
        }
    },
    blit: function(t) {
        var e = this._gridSize.width * this._gridSize.height;
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS),
        this._shaderProgram.use(),
        this._shaderProgram._setUniformForMVPMatrixWithMat4(t._renderCmd._stackMatrix),
        t = cc._renderContext;
        var i = this._dirty;
        t.bindBuffer(t.ARRAY_BUFFER, this._verticesBuffer),
        i && t.bufferData(t.ARRAY_BUFFER, this._vertices, t.DYNAMIC_DRAW),
        t.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, t.FLOAT, !1, 0, 0),
        t.bindBuffer(t.ARRAY_BUFFER, this._texCoordinateBuffer),
        i && t.bufferData(t.ARRAY_BUFFER, this._texCoordinates, t.DYNAMIC_DRAW),
        t.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, t.FLOAT, !1, 0, 0),
        t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this._indicesBuffer),
        i && t.bufferData(t.ELEMENT_ARRAY_BUFFER, this._indices, t.STATIC_DRAW),
        t.drawElements(t.TRIANGLES, 6 * e, t.UNSIGNED_SHORT, 0),
        i && (this._dirty = !1),
        cc.incrementGLDraws(1)
    },
    reuse: function() {
        if (0 < this._reuseGrid) {
            for (var t = this._originalVertices, e = this._vertices, i = 0, n = this._vertices.length; i < n; i++)
                t[i] = e[i];
            --this._reuseGrid
        }
    },
    calculateVertexPoints: function() {
        var t = cc._renderContext
          , e = this._texture.pixelsWidth
          , i = this._texture.pixelsHeight
          , n = this._texture.getContentSizeInPixels().height
          , r = this._gridSize
          , c = (r.width + 1) * (r.height + 1);
        this._vertices = new Float32Array(3 * c),
        this._texCoordinates = new Float32Array(2 * c),
        this._indices = new Uint16Array(r.width * r.height * 6),
        this._verticesBuffer && t.deleteBuffer(this._verticesBuffer),
        this._verticesBuffer = t.createBuffer(),
        this._texCoordinateBuffer && t.deleteBuffer(this._texCoordinateBuffer),
        this._texCoordinateBuffer = t.createBuffer(),
        this._indicesBuffer && t.deleteBuffer(this._indicesBuffer),
        this._indicesBuffer = t.createBuffer();
        for (var s, o, a = this._indices, h = this._texCoordinates, l = this._isTextureFlipped, u = this._vertices, c = 0; c < r.width; ++c)
            for (s = 0; s < r.height; ++s) {
                var d = s * r.width + c;
                o = c * this._step.x + this._gridRect.x;
                var _ = o + this._step.x
                  , p = s * this._step.y + this._gridRect.y
                  , f = p + this._step.y
                  , g = c * (r.height + 1) + s
                  , m = (c + 1) * (r.height + 1) + s
                  , y = (c + 1) * (r.height + 1) + (s + 1)
                  , T = c * (r.height + 1) + (s + 1);
                a[6 * d] = g,
                a[6 * d + 1] = m,
                a[6 * d + 2] = T,
                a[6 * d + 3] = m,
                a[6 * d + 4] = y,
                a[6 * d + 5] = T;
                var d = [3 * g, 3 * m, 3 * y, 3 * T]
                  , v = [{
                    x: o,
                    y: p,
                    z: 0
                }, {
                    x: _,
                    y: p,
                    z: 0
                }, {
                    x: _,
                    y: f,
                    z: 0
                }, {
                    x: o,
                    y: f,
                    z: 0
                }]
                  , g = [2 * g, 2 * m, 2 * y, 2 * T]
                  , _ = [cc.p(o, p), cc.p(_, p), cc.p(_, f), cc.p(o, f)];
                for (o = 0; 4 > o; ++o)
                    u[d[o]] = v[o].x,
                    u[d[o] + 1] = v[o].y,
                    u[d[o] + 2] = v[o].z,
                    h[g[o]] = _[o].x / e,
                    h[g[o] + 1] = l ? (n - _[o].y) / i : _[o].y / i
            }
        this._originalVertices = new Float32Array(this._vertices),
        t.bindBuffer(t.ARRAY_BUFFER, this._verticesBuffer),
        t.bufferData(t.ARRAY_BUFFER, this._vertices, t.DYNAMIC_DRAW),
        t.bindBuffer(t.ARRAY_BUFFER, this._texCoordinateBuffer),
        t.bufferData(t.ARRAY_BUFFER, this._texCoordinates, t.DYNAMIC_DRAW),
        t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this._indicesBuffer),
        t.bufferData(t.ELEMENT_ARRAY_BUFFER, this._indices, t.STATIC_DRAW),
        this._dirty = !0
    },
    setNeedDepthTestForBlit: function(t) {
        this._needDepthTestForBlit = t
    },
    getNeedDepthTestForBlit: function() {
        return this._needDepthTestForBlit
    }
}),
cc.Grid3D.create = function(t, e, i) {
    return new cc.Grid3D(t,e,i)
}
,
cc.TiledGrid3D = cc.GridBase.extend({
    _texCoordinates: null,
    _vertices: null,
    _originalVertices: null,
    _indices: null,
    _texCoordinateBuffer: null,
    _verticesBuffer: null,
    _indicesBuffer: null,
    ctor: function(t, e, i, n) {
        cc.GridBase.prototype.ctor.call(this),
        this._indicesBuffer = this._verticesBuffer = this._texCoordinateBuffer = this._indices = this._originalVertices = this._vertices = this._texCoordinates = null,
        void 0 !== t && this.initWithSize(t, e, i, n)
    },
    tile: function(t) {
        return this.getTile(t)
    },
    getTile: function(t) {
        t.x === (0 | t.x) && t.y === (0 | t.y) || cc.log("cc.TiledGrid3D.tile() : Numbers must be integers"),
        t = 12 * (this._gridSize.height * t.x + t.y);
        var e = this._vertices;
        return new cc.Quad3(new cc.Vertex3F(e[t],e[t + 1],e[t + 2]),new cc.Vertex3F(e[t + 3],e[t + 4],e[t + 5]),new cc.Vertex3F(e[t + 6],e[t + 7],e[t + 8]),new cc.Vertex3F(e[t + 9],e[t + 10],e[t + 11]))
    },
    getOriginalTile: function(t) {
        t.x === (0 | t.x) && t.y === (0 | t.y) || cc.log("cc.TiledGrid3D.originalTile() : Numbers must be integers"),
        t = 12 * (this._gridSize.height * t.x + t.y);
        var e = this._originalVertices;
        return new cc.Quad3(new cc.Vertex3F(e[t],e[t + 1],e[t + 2]),new cc.Vertex3F(e[t + 3],e[t + 4],e[t + 5]),new cc.Vertex3F(e[t + 6],e[t + 7],e[t + 8]),new cc.Vertex3F(e[t + 9],e[t + 10],e[t + 11]))
    },
    originalTile: function(t) {
        return this.getOriginalTile(t)
    },
    setTile: function(t, e) {
        t.x === (0 | t.x) && t.y === (0 | t.y) || cc.log("cc.TiledGrid3D.setTile() : Numbers must be integers");
        var i = 12 * (this._gridSize.height * t.x + t.y)
          , n = this._vertices;
        n[i] = e.bl.x,
        n[i + 1] = e.bl.y,
        n[i + 2] = e.bl.z,
        n[i + 3] = e.br.x,
        n[i + 4] = e.br.y,
        n[i + 5] = e.br.z,
        n[i + 6] = e.tl.x,
        n[i + 7] = e.tl.y,
        n[i + 8] = e.tl.z,
        n[i + 9] = e.tr.x,
        n[i + 10] = e.tr.y,
        n[i + 11] = e.tr.z,
        this._dirty = !0
    },
    blit: function(t) {
        var e = this._gridSize.width * this._gridSize.height;
        this._shaderProgram.use(),
        this._shaderProgram._setUniformForMVPMatrixWithMat4(t._renderCmd._stackMatrix),
        t = cc._renderContext;
        var i = this._dirty;
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS),
        t.bindBuffer(t.ARRAY_BUFFER, this._verticesBuffer),
        i && t.bufferData(t.ARRAY_BUFFER, this._vertices, t.DYNAMIC_DRAW),
        t.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, t.FLOAT, !1, 0, this._vertices),
        t.bindBuffer(t.ARRAY_BUFFER, this._texCoordinateBuffer),
        i && t.bufferData(t.ARRAY_BUFFER, this._texCoordinates, t.DYNAMIC_DRAW),
        t.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, t.FLOAT, !1, 0, this._texCoordinates),
        t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this._indicesBuffer),
        i && t.bufferData(t.ELEMENT_ARRAY_BUFFER, this._indices, t.STATIC_DRAW),
        t.drawElements(t.TRIANGLES, 6 * e, t.UNSIGNED_SHORT, 0),
        i && (this._dirty = !1),
        cc.incrementGLDraws(1)
    },
    reuse: function() {
        if (0 < this._reuseGrid) {
            for (var t = this._vertices, e = this._originalVertices, i = 0; i < t.length; i++)
                e[i] = t[i];
            --this._reuseGrid
        }
    },
    calculateVertexPoints: function() {
        var t = this._texture.pixelsWidth
          , e = this._texture.pixelsHeight
          , i = this._texture.getContentSizeInPixels().height
          , n = this._gridSize
          , r = n.width * n.height;
        this._vertices = new Float32Array(12 * r),
        this._texCoordinates = new Float32Array(8 * r),
        this._indices = new Uint16Array(6 * r);
        var c = cc._renderContext;
        this._verticesBuffer && c.deleteBuffer(this._verticesBuffer),
        this._verticesBuffer = c.createBuffer(),
        this._texCoordinateBuffer && c.deleteBuffer(this._texCoordinateBuffer),
        this._texCoordinateBuffer = c.createBuffer(),
        this._indicesBuffer && c.deleteBuffer(this._indicesBuffer),
        this._indicesBuffer = c.createBuffer();
        var s, o, a = 0, h = this._step, l = this._vertices, u = this._texCoordinates, d = this._isTextureFlipped;
        for (s = 0; s < n.width; s++)
            for (o = 0; o < n.height; o++) {
                var _ = s * h.x
                  , p = _ + h.x
                  , f = o * h.y
                  , g = f + h.y;
                l[12 * a] = _,
                l[12 * a + 1] = f,
                l[12 * a + 2] = 0,
                l[12 * a + 3] = p,
                l[12 * a + 4] = f,
                l[12 * a + 5] = 0,
                l[12 * a + 6] = _,
                l[12 * a + 7] = g,
                l[12 * a + 8] = 0,
                l[12 * a + 9] = p,
                l[12 * a + 10] = g,
                l[12 * a + 11] = 0;
                var m = f
                  , y = g;
                d && (m = i - f,
                y = i - g),
                u[8 * a] = _ / t,
                u[8 * a + 1] = m / e,
                u[8 * a + 2] = p / t,
                u[8 * a + 3] = m / e,
                u[8 * a + 4] = _ / t,
                u[8 * a + 5] = y / e,
                u[8 * a + 6] = p / t,
                u[8 * a + 7] = y / e,
                a++
            }
        for (t = this._indices,
        s = 0; s < r; s++)
            t[6 * s + 0] = 4 * s + 0,
            t[6 * s + 1] = 4 * s + 1,
            t[6 * s + 2] = 4 * s + 2,
            t[6 * s + 3] = 4 * s + 1,
            t[6 * s + 4] = 4 * s + 2,
            t[6 * s + 5] = 4 * s + 3;
        this._originalVertices = new Float32Array(this._vertices),
        c.bindBuffer(c.ARRAY_BUFFER, this._verticesBuffer),
        c.bufferData(c.ARRAY_BUFFER, this._vertices, c.DYNAMIC_DRAW),
        c.bindBuffer(c.ARRAY_BUFFER, this._texCoordinateBuffer),
        c.bufferData(c.ARRAY_BUFFER, this._texCoordinates, c.DYNAMIC_DRAW),
        c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, this._indicesBuffer),
        c.bufferData(c.ELEMENT_ARRAY_BUFFER, this._indices, c.DYNAMIC_DRAW),
        this._dirty = !0
    }
}),
cc.TiledGrid3D.create = function(t, e, i) {
    return new cc.TiledGrid3D(t,e,i)
}
,
cc.Grabber = cc.Class.extend({
    _FBO: null,
    _oldFBO: null,
    _oldClearColor: null,
    _gl: null,
    ctor: function() {
        cc.sys._checkWebGLRenderMode(),
        this._gl = cc._renderContext,
        this._oldClearColor = [0, 0, 0, 0],
        this._oldFBO = null,
        this._FBO = this._gl.createFramebuffer()
    },
    grab: function(t) {
        var e = this._gl;
        this._oldFBO = e.getParameter(e.FRAMEBUFFER_BINDING),
        e.bindFramebuffer(e.FRAMEBUFFER, this._FBO),
        e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t._webTextureObj, 0),
        e.checkFramebufferStatus(e.FRAMEBUFFER) !== e.FRAMEBUFFER_COMPLETE && cc.log("Frame Grabber: could not attach texture to frmaebuffer"),
        e.bindFramebuffer(e.FRAMEBUFFER, this._oldFBO)
    },
    beforeRender: function(t) {
        t = this._gl,
        this._oldFBO = t.getParameter(t.FRAMEBUFFER_BINDING),
        t.bindFramebuffer(t.FRAMEBUFFER, this._FBO),
        this._oldClearColor = t.getParameter(t.COLOR_CLEAR_VALUE),
        t.clearColor(0, 0, 0, 0),
        t.clear(t.COLOR_BUFFER_BIT | t.DEPTH_BUFFER_BIT)
    },
    afterRender: function(t) {
        t = this._gl,
        t.bindFramebuffer(t.FRAMEBUFFER, this._oldFBO),
        t.colorMask(!0, !0, !0, !0)
    },
    destroy: function() {
        this._gl.deleteFramebuffer(this._FBO)
    }
}),
cc.ACTION_TAG_INVALID = -1,
cc.Action = cc.Class.extend({
    originalTarget: null,
    target: null,
    tag: cc.ACTION_TAG_INVALID,
    ctor: function() {
        this.target = this.originalTarget = null,
        this.tag = cc.ACTION_TAG_INVALID
    },
    copy: function() {
        return cc.log("copy is deprecated. Please use clone instead."),
        this.clone()
    },
    clone: function() {
        var t = new cc.Action;
        return t.originalTarget = null,
        t.target = null,
        t.tag = this.tag,
        t
    },
    isDone: function() {
        return !0
    },
    startWithTarget: function(t) {
        this.target = this.originalTarget = t
    },
    stop: function() {
        this.target = null
    },
    step: function(t) {
        cc.log("[Action step]. override me")
    },
    update: function(t) {
        cc.log("[Action update]. override me")
    },
    getTarget: function() {
        return this.target
    },
    setTarget: function(t) {
        this.target = t
    },
    getOriginalTarget: function() {
        return this.originalTarget
    },
    setOriginalTarget: function(t) {
        this.originalTarget = t
    },
    getTag: function() {
        return this.tag
    },
    setTag: function(t) {
        this.tag = t
    },
    retain: function() {},
    release: function() {}
}),
cc.action = function() {
    return new cc.Action
}
,
cc.Action.create = cc.action,
cc.FiniteTimeAction = cc.Action.extend({
    _duration: 0,
    ctor: function() {
        cc.Action.prototype.ctor.call(this),
        this._duration = 0
    },
    getDuration: function() {
        return this._duration * (this._timesForRepeat || 1)
    },
    setDuration: function(t) {
        this._duration = t
    },
    reverse: function() {
        return cc.log("cocos2d: FiniteTimeAction#reverse: Implement me"),
        null
    },
    clone: function() {
        return new cc.FiniteTimeAction
    }
}),
cc.Speed = cc.Action.extend({
    _speed: 0,
    _innerAction: null,
    ctor: function(t, e) {
        cc.Action.prototype.ctor.call(this),
        this._speed = 0,
        this._innerAction = null,
        t && this.initWithAction(t, e)
    },
    getSpeed: function() {
        return this._speed
    },
    setSpeed: function(t) {
        this._speed = t
    },
    initWithAction: function(t, e) {
        if (!t)
            throw Error("cc.Speed.initWithAction(): action must be non nil");
        return this._innerAction = t,
        this._speed = e,
        !0
    },
    clone: function() {
        var t = new cc.Speed;
        return t.initWithAction(this._innerAction.clone(), this._speed),
        t
    },
    startWithTarget: function(t) {
        cc.Action.prototype.startWithTarget.call(this, t),
        this._innerAction.startWithTarget(t)
    },
    stop: function() {
        this._innerAction.stop(),
        cc.Action.prototype.stop.call(this)
    },
    step: function(t) {
        this._innerAction.step(t * this._speed)
    },
    isDone: function() {
        return this._innerAction.isDone()
    },
    reverse: function() {
        return new cc.Speed(this._innerAction.reverse(),this._speed)
    },
    setInnerAction: function(t) {
        this._innerAction !== t && (this._innerAction = t)
    },
    getInnerAction: function() {
        return this._innerAction
    }
}),
cc.speed = function(t, e) {
    return new cc.Speed(t,e)
}
,
cc.Speed.create = cc.speed,
cc.Follow = cc.Action.extend({
    _followedNode: null,
    _boundarySet: !1,
    _boundaryFullyCovered: !1,
    _halfScreenSize: null,
    _fullScreenSize: null,
    _worldRect: null,
    leftBoundary: 0,
    rightBoundary: 0,
    topBoundary: 0,
    bottomBoundary: 0,
    ctor: function(t, e) {
        cc.Action.prototype.ctor.call(this),
        this._followedNode = null,
        this._boundaryFullyCovered = this._boundarySet = !1,
        this._fullScreenSize = this._halfScreenSize = null,
        this.bottomBoundary = this.topBoundary = this.rightBoundary = this.leftBoundary = 0,
        this._worldRect = cc.rect(0, 0, 0, 0),
        t && (e ? this.initWithTarget(t, e) : this.initWithTarget(t))
    },
    clone: function() {
        var t = new cc.Follow
          , e = this._worldRect
          , e = new cc.Rect(e.x,e.y,e.width,e.height);
        return t.initWithTarget(this._followedNode, e),
        t
    },
    isBoundarySet: function() {
        return this._boundarySet
    },
    setBoudarySet: function(t) {
        this._boundarySet = t
    },
    initWithTarget: function(t, e) {
        if (!t)
            throw Error("cc.Follow.initWithAction(): followedNode must be non nil");
        e = e || cc.rect(0, 0, 0, 0),
        this._followedNode = t,
        this._worldRect = e,
        this._boundarySet = !cc._rectEqualToZero(e),
        this._boundaryFullyCovered = !1;
        var i = cc.director.getWinSize();
        return this._fullScreenSize = cc.p(i.width, i.height),
        this._halfScreenSize = cc.pMult(this._fullScreenSize, .5),
        this._boundarySet && (this.leftBoundary = -(e.x + e.width - this._fullScreenSize.x),
        this.rightBoundary = -e.x,
        this.topBoundary = -e.y,
        this.bottomBoundary = -(e.y + e.height - this._fullScreenSize.y),
        this.rightBoundary < this.leftBoundary && (this.rightBoundary = this.leftBoundary = (this.leftBoundary + this.rightBoundary) / 2),
        this.topBoundary < this.bottomBoundary && (this.topBoundary = this.bottomBoundary = (this.topBoundary + this.bottomBoundary) / 2),
        this.topBoundary === this.bottomBoundary && this.leftBoundary === this.rightBoundary && (this._boundaryFullyCovered = !0)),
        !0
    },
    step: function(t) {
        t = this._followedNode.x;
        var e = this._followedNode.y;
        t = this._halfScreenSize.x - t,
        e = this._halfScreenSize.y - e,
        this.target._renderCmd._dirtyFlag = 0,
        this._boundarySet ? this._boundaryFullyCovered || this.target.setPosition(cc.clampf(t, this.leftBoundary, this.rightBoundary), cc.clampf(e, this.bottomBoundary, this.topBoundary)) : this.target.setPosition(t, e)
    },
    isDone: function() {
        return !this._followedNode.running
    },
    stop: function() {
        this.target = null,
        cc.Action.prototype.stop.call(this)
    }
}),
cc.follow = function(t, e) {
    return new cc.Follow(t,e)
}
,
cc.Follow.create = cc.follow,
cc.ActionInterval = cc.FiniteTimeAction.extend({
    _elapsed: 0,
    _firstTick: !1,
    _easeList: null,
    _timesForRepeat: 1,
    _repeatForever: !1,
    _repeatMethod: !1,
    _speed: 1,
    _speedMethod: !1,
    ctor: function(t) {
        this._timesForRepeat = this._speed = 1,
        this._repeatForever = !1,
        this.MAX_VALUE = 2,
        this._speedMethod = this._repeatMethod = !1,
        cc.FiniteTimeAction.prototype.ctor.call(this),
        void 0 !== t && this.initWithDuration(t)
    },
    getElapsed: function() {
        return this._elapsed
    },
    initWithDuration: function(t) {
        return this._duration = 0 === t ? cc.FLT_EPSILON : t,
        this._elapsed = 0,
        this._firstTick = !0
    },
    isDone: function() {
        return this._elapsed >= this._duration
    },
    _cloneDecoration: function(t) {
        t._repeatForever = this._repeatForever,
        t._speed = this._speed,
        t._timesForRepeat = this._timesForRepeat,
        t._easeList = this._easeList,
        t._speedMethod = this._speedMethod,
        t._repeatMethod = this._repeatMethod
    },
    _reverseEaseList: function(t) {
        if (this._easeList) {
            t._easeList = [];
            for (var e = 0; e < this._easeList.length; e++)
                t._easeList.push(this._easeList[e].reverse())
        }
    },
    clone: function() {
        var t = new cc.ActionInterval(this._duration);
        return this._cloneDecoration(t),
        t
    },
    easing: function(t) {
        this._easeList ? this._easeList.length = 0 : this._easeList = [];
        for (var e = 0; e < arguments.length; e++)
            this._easeList.push(arguments[e]);
        return this
    },
    _computeEaseTime: function(t) {
        var e = this._easeList;
        if (!e || 0 === e.length)
            return t;
        for (var i = 0, n = e.length; i < n; i++)
            t = e[i].easing(t);
        return t
    },
    step: function(t) {
        this._firstTick ? (this._firstTick = !1,
        this._elapsed = 0) : this._elapsed += t,
        t = this._elapsed / (1.192092896e-7 < this._duration ? this._duration : 1.192092896e-7),
        t = 1 > t ? t : 1,
        this.update(0 < t ? t : 0),
        this._repeatMethod && 1 < this._timesForRepeat && this.isDone() && (this._repeatForever || this._timesForRepeat--,
        this.startWithTarget(this.target),
        this.step(this._elapsed - this._duration))
    },
    startWithTarget: function(t) {
        cc.Action.prototype.startWithTarget.call(this, t),
        this._elapsed = 0,
        this._firstTick = !0
    },
    reverse: function() {
        return cc.log("cc.IntervalAction: reverse not implemented."),
        null
    },
    setAmplitudeRate: function(t) {
        cc.log("cc.ActionInterval.setAmplitudeRate(): it should be overridden in subclass.")
    },
    getAmplitudeRate: function() {
        return cc.log("cc.ActionInterval.getAmplitudeRate(): it should be overridden in subclass."),
        0
    },
    speed: function(t) {
        return 0 >= t ? (cc.log("The speed parameter error"),
        this) : (this._speedMethod = !0,
        this._speed *= t,
        this)
    },
    getSpeed: function() {
        return this._speed
    },
    setSpeed: function(t) {
        return this._speed = t,
        this
    },
    repeat: function(t) {
        return t = Math.round(t),
        isNaN(t) || 1 > t ? (cc.log("The repeat parameter error"),
        this) : (this._repeatMethod = !0,
        this._timesForRepeat *= t,
        this)
    },
    repeatForever: function() {
        return this._repeatMethod = !0,
        this._timesForRepeat = this.MAX_VALUE,
        this._repeatForever = !0,
        this
    }
}),
cc.actionInterval = function(t) {
    return new cc.ActionInterval(t)
}
,
cc.ActionInterval.create = cc.actionInterval,
cc.Sequence = cc.ActionInterval.extend({
    _actions: null,
    _split: null,
    _last: 0,
    ctor: function(t) {
        cc.ActionInterval.prototype.ctor.call(this),
        this._actions = [];
        var e = t instanceof Array ? t : arguments
          , i = e.length - 1;
        if (0 <= i && null == e[i] && cc.log("parameters should not be ending with null in Javascript"),
        0 <= i) {
            for (var n = e[0], r = 1; r < i; r++)
                e[r] && (n = cc.Sequence._actionOneTwo(n, e[r]));
            this.initWithTwoActions(n, e[i])
        }
    },
    initWithTwoActions: function(t, e) {
        if (!t || !e)
            throw Error("cc.Sequence.initWithTwoActions(): arguments must all be non nil");
        return this.initWithDuration(t._duration + e._duration),
        this._actions[0] = t,
        this._actions[1] = e,
        !0
    },
    clone: function() {
        var t = new cc.Sequence;
        return this._cloneDecoration(t),
        t.initWithTwoActions(this._actions[0].clone(), this._actions[1].clone()),
        t
    },
    startWithTarget: function(t) {
        cc.ActionInterval.prototype.startWithTarget.call(this, t),
        this._split = this._actions[0]._duration / this._duration,
        this._last = -1
    },
    stop: function() {
        -1 !== this._last && this._actions[this._last].stop(),
        cc.Action.prototype.stop.call(this)
    },
    update: function(t) {
        var e = 0
          , i = this._split
          , n = this._actions
          , r = this._last;
        t = this._computeEaseTime(t),
        t < i ? (t = 0 !== i ? t / i : 1,
        0 === e && 1 === r && (n[1].update(0),
        n[1].stop())) : (e = 1,
        t = 1 === i ? 1 : (t - i) / (1 - i),
        -1 === r && (n[0].startWithTarget(this.target),
        n[0].update(1),
        n[0].stop()),
        r || (n[0].update(1),
        n[0].stop())),
        n = n[e],
        r === e && n.isDone() || (r !== e && n.startWithTarget(this.target),
        t *= n._timesForRepeat,
        n.update(1 < t ? t % 1 : t),
        this._last = e)
    },
    reverse: function() {
        var t = cc.Sequence._actionOneTwo(this._actions[1].reverse(), this._actions[0].reverse());
        return this._cloneDecoration(t),
        this._reverseEaseList(t),
        t
    }
}),
cc.sequence = function(t) {
    var e = t instanceof Array ? t : arguments;
    0 < e.length && null == e[e.length - 1] && cc.log("parameters should not be ending with null in Javascript");
    for (var i, n, r, c; e && 0 < e.length; )
        for (n = Array.prototype.shift.call(e),
        c = n._timesForRepeat || 1,
        n._repeatMethod = !1,
        n._timesForRepeat = 1,
        r = 0,
        i || (i = n,
        r = 1),
        r; r < c; r++)
            i = cc.Sequence._actionOneTwo(i, n);
    return i
}
,
cc.Sequence.create = cc.sequence,
cc.Sequence._actionOneTwo = function(t, e) {
    var i = new cc.Sequence;
    return i.initWithTwoActions(t, e),
    i
}
,
cc.Repeat = cc.ActionInterval.extend({
    _times: 0,
    _total: 0,
    _nextDt: 0,
    _actionInstant: !1,
    _innerAction: null,
    ctor: function(t, e) {
        cc.ActionInterval.prototype.ctor.call(this),
        void 0 !== e && this.initWithAction(t, e)
    },
    initWithAction: function(t, e) {
        return !!this.initWithDuration(t._duration * e) && (this._times = e,
        this._innerAction = t,
        t instanceof cc.ActionInstant && (this._actionInstant = !0,
        this._times -= 1),
        this._total = 0,
        !0)
    },
    clone: function() {
        var t = new cc.Repeat;
        return this._cloneDecoration(t),
        t.initWithAction(this._innerAction.clone(), this._times),
        t
    },
    startWithTarget: function(t) {
        this._total = 0,
        this._nextDt = this._innerAction._duration / this._duration,
        cc.ActionInterval.prototype.startWithTarget.call(this, t),
        this._innerAction.startWithTarget(t)
    },
    stop: function() {
        this._innerAction.stop(),
        cc.Action.prototype.stop.call(this)
    },
    update: function(t) {
        t = this._computeEaseTime(t);
        var e = this._innerAction
          , i = this._duration
          , n = this._times
          , r = this._nextDt;
        if (t >= r) {
            for (; t > r && this._total < n; )
                e.update(1),
                this._total++,
                e.stop(),
                e.startWithTarget(this.target),
                this._nextDt = r += e._duration / i;
            1 <= t && this._total < n && this._total++,
            this._actionInstant || (this._total === n ? (e.update(1),
            e.stop()) : e.update(t - (r - e._duration / i)))
        } else
            e.update(t * n % 1)
    },
    isDone: function() {
        return this._total === this._times
    },
    reverse: function() {
        var t = new cc.Repeat(this._innerAction.reverse(),this._times);
        return this._cloneDecoration(t),
        this._reverseEaseList(t),
        t
    },
    setInnerAction: function(t) {
        this._innerAction !== t && (this._innerAction = t)
    },
    getInnerAction: function() {
        return this._innerAction
    }
}),
cc.repeat = function(t, e) {
    return new cc.Repeat(t,e)
}
,
cc.Repeat.create = cc.repeat,
cc.RepeatForever = cc.ActionInterval.extend({
    _innerAction: null,
    ctor: function(t) {
        cc.ActionInterval.prototype.ctor.call(this),
        this._innerAction = null,
        t && this.initWithAction(t)
    },
    initWithAction: function(t) {
        if (!t)
            throw Error("cc.RepeatForever.initWithAction(): action must be non null");
        return this._innerAction = t,
        !0
    },
    clone: function() {
        var t = new cc.RepeatForever;
        return this._cloneDecoration(t),
        t.initWithAction(this._innerAction.clone()),
        t
    },
    startWithTarget: function(t) {
        cc.ActionInterval.prototype.startWithTarget.call(this, t),
        this._innerAction.startWithTarget(t)
    },
    step: function(t) {
        var e = this._innerAction;
        e.step(t),
        e.isDone() && (e.startWithTarget(this.target),
        e.step(e.getElapsed() - e._duration))
    },
    isDone: function() {
        return !1
    },
    reverse: function() {
        var t = new cc.RepeatForever(this._innerAction.reverse());
        return this._cloneDecoration(t),
        this._reverseEaseList(t),
        t
    },
    setInnerAction: function(t) {
        this._innerAction !== t && (this._innerAction = t)
    },
    getInnerAction: function() {
        return this._innerAction
    }
}),
cc.repeatForever = function(t) {
    return new cc.RepeatForever(t)
}
,
cc.RepeatForever.create = cc.repeatForever,
cc.Spawn = cc.ActionInterval.extend({
    _one: null,
    _two: null,
    ctor: function(t) {
        cc.ActionInterval.prototype.ctor.call(this),
        this._two = this._one = null;
        var e = t instanceof Array ? t : arguments
          , i = e.length - 1;
        if (0 <= i && null == e[i] && cc.log("parameters should not be ending with null in Javascript"),
        0 <= i) {
            for (var n = e[0], r = 1; r < i; r++)
                e[r] && (n = cc.Spawn._actionOneTwo(n, e[r]));
            this.initWithTwoActions(n, e[i])
        }
    },
    initWithTwoActions: function(t, e) {
        if (!t || !e)
            throw Error("cc.Spawn.initWithTwoActions(): arguments must all be non null");
        var i = !1
          , n = t._duration
          , r = e._duration;
        return this.initWithDuration(Math.max(n, r)) && (this._one = t,
        this._two = e,
        n > r ? this._two = cc.Sequence._actionOneTwo(e, cc.delayTime(n - r)) : n < r && (this._one = cc.Sequence._actionOneTwo(t, cc.delayTime(r - n))),
        i = !0),
        i
    },
    clone: function() {
        var t = new cc.Spawn;
        return this._cloneDecoration(t),
        t.initWithTwoActions(this._one.clone(), this._two.clone()),
        t
    },
    startWithTarget: function(t) {
        cc.ActionInterval.prototype.startWithTarget.call(this, t),
        this._one.startWithTarget(t),
        this._two.startWithTarget(t)
    },
    stop: function() {
        this._one.stop(),
        this._two.stop(),
        cc.Action.prototype.stop.call(this)
    },
    update: function(t) {
        t = this._computeEaseTime(t),
        this._one && this._one.update(t),
        this._two && this._two.update(t)
    },
    reverse: function() {
        var t = cc.Spawn._actionOneTwo(this._one.reverse(), this._two.reverse());
        return this._cloneDecoration(t),
        this._reverseEaseList(t),
        t
    }
}),
cc.spawn = function(t) {
    var e = t instanceof Array ? t : arguments;
    0 < e.length && null == e[e.length - 1] && cc.log("parameters should not be ending with null in Javascript");
    for (var i = e[0], n = 1; n < e.length; n++)
        null != e[n] && (i = cc.Spawn._actionOneTwo(i, e[n]));
    return i
}
,
cc.Spawn.create = cc.spawn,
cc.Spawn._actionOneTwo = function(t, e) {
    var i = new cc.Spawn;
    return i.initWithTwoActions(t, e),
    i
}
,
cc.RotateTo = cc.ActionInterval.extend({
    _dstAngleX: 0,
    _startAngleX: 0,
    _diffAngleX: 0,
    _dstAngleY: 0,
    _startAngleY: 0,
    _diffAngleY: 0,
    ctor: function(t, e, i) {
        cc.ActionInterval.prototype.ctor.call(this),
        void 0 !== e && this.initWithDuration(t, e, i)
    },
    initWithDuration: function(t, e, i) {
        return !!cc.ActionInterval.prototype.initWithDuration.call(this, t) && (this._dstAngleX = e || 0,
        this._dstAngleY = i || this._dstAngleX,
        !0)
    },
    clone: function() {
        var t = new cc.RotateTo;
        return this._cloneDecoration(t),
        t.initWithDuration(this._duration, this._dstAngleX, this._dstAngleY),
        t
    },
    startWithTarget: function(t) {
        cc.ActionInterval.prototype.startWithTarget.call(this, t);
        var e = t.rotationX % 360
          , i = this._dstAngleX - e;
        180 < i && (i -= 360),
        -180 > i && (i += 360),
        this._startAngleX = e,
        this._diffAngleX = i,
        this._startAngleY = t.rotationY % 360,
        t = this._dstAngleY - this._startAngleY,
        180 < t && (t -= 360),
        -180 > t && (t += 360),
        this._diffAngleY = t
    },
    reverse: function() {
        cc.log("cc.RotateTo.reverse(): it should be overridden in subclass.")
    },
    update: function(t) {
        t = this._computeEaseTime(t),
        this.target && (this.target.rotationX = this._startAngleX + this._diffAngleX * t,
        this.target.rotationY = this._startAngleY + this._diffAngleY * t)
    }
}),
cc.rotateTo = function(t, e, i) {
    return new cc.RotateTo(t,e,i)
}
,
cc.RotateTo.create = cc.rotateTo,
cc.RotateBy = cc.ActionInterval.extend({
    _angleX: 0,
    _startAngleX: 0,
    _angleY: 0,
    _startAngleY: 0,
    ctor: function(t, e, i) {
        cc.ActionInterval.prototype.ctor.call(this),
        void 0 !== e && this.initWithDuration(t, e, i)
    },
    initWithDuration: function(t, e, i) {
        return !!cc.ActionInterval.prototype.initWithDuration.call(this, t) && (this._angleX = e || 0,
        this._angleY = i || this._angleX,
        !0)
    },
    clone: function() {
        var t = new cc.RotateBy;
        return this._cloneDecoration(t),
        t.initWithDuration(this._duration, this._angleX, this._angleY),
        t
    },
    startWithTarget: function(t) {
        cc.ActionInterval.prototype.startWithTarget.call(this, t),
        this._startAngleX = t.rotationX,
        this._startAngleY = t.rotationY
    },
    update: function(t) {
        t = this._computeEaseTime(t),
        this.target && (this.target.rotationX = this._startAngleX + this._angleX * t,
        this.target.rotationY = this._startAngleY + this._angleY * t)
    },
    reverse: function() {
        var t = new cc.RotateBy(this._duration,(-this._angleX),(-this._angleY));
        return this._cloneDecoration(t),
        this._reverseEaseList(t),
        t
    }
}),
cc.rotateBy = function(t, e, i) {
    return new cc.RotateBy(t,e,i)
}
,
cc.RotateBy.create = cc.rotateBy,
cc.MoveBy = cc.ActionInterval.extend({
    _positionDelta: null,
    _startPosition: null,
    _previousPosition: null,
    ctor: function(t, e, i) {
        cc.ActionInterval.prototype.ctor.call(this),
        this._positionDelta = cc.p(0, 0),
        this._startPosition = cc.p(0, 0),
        this._previousPosition = cc.p(0, 0),
        void 0 !== e && this.initWithDuration(t, e, i)
    },
    initWithDuration: function(t, e, i) {
        return !!cc.ActionInterval.prototype.initWithDuration.call(this, t) && (void 0 !== e.x && (i = e.y,
        e = e.x),
        this._positionDelta.x = e,
        this._positionDelta.y = i,
        !0)
    },
    clone: function() {
        var t = new cc.MoveBy;
        return this._cloneDecoration(t),
        t.initWithDuration(this._duration, this._positionDelta),
        t
    },
    startWithTarget: function(t) {
        cc.ActionInterval.prototype.startWithTarget.call(this, t);
        var e = t.getPositionX();
        t = t.getPositionY(),
        this._previousPosition.x = e,
        this._previousPosition.y = t,
        this._startPosition.x = e,
        this._startPosition.y = t
    },
    update: function(t) {
        if (t = this._computeEaseTime(t),
        this.target) {
            var e = this._positionDelta.x * t;
            t *= this._positionDelta.y;
            var i = this._startPosition;
            if (cc.ENABLE_STACKABLE_ACTIONS) {
                var n = this.target.getPositionX()
                  , r = this.target.getPositionY()
                  , c = this._previousPosition;
                i.x = i.x + n - c.x,
                i.y = i.y + r - c.y,
                e += i.x,
                t += i.y,
                c.x = e,
                c.y = t,
                this.target.setPosition(e, t)
            } else
                this.target.setPosition(i.x + e, i.y + t)
        }
    },
    reverse: function() {
        var t = new cc.MoveBy(this._duration,cc.p(-this._positionDelta.x, -this._positionDelta.y));
        return this._cloneDecoration(t),
        this._reverseEaseList(t),
        t
    }
}),
cc.moveBy = function(t, e, i) {
    return new cc.MoveBy(t,e,i)
}
,
cc.MoveBy.create = cc.moveBy,
cc.MoveTo = cc.MoveBy.extend({
    _endPosition: null,
    ctor: function(t, e, i) {
        cc.MoveBy.prototype.ctor.call(this),
        this._endPosition = cc.p(0, 0),
        void 0 !== e && this.initWithDuration(t, e, i)
    },
    initWithDuration: function(t, e, i) {
        return !!cc.MoveBy.prototype.initWithDuration.call(this, t, e, i) && (void 0 !== e.x && (i = e.y,
        e = e.x),
        this._endPosition.x = e,
        this._endPosition.y = i,
        !0)
    },
    clone: function() {
        var t = new cc.MoveTo;
        return this._cloneDecoration(t),
        t.initWithDuration(this._duration, this._endPosition),
        t
    },
    startWithTarget: function(t) {
        cc.MoveBy.prototype.startWithTarget.call(this, t),
        this._positionDelta.x = this._endPosition.x - t.getPositionX(),
        this._positionDelta.y = this._endPosition.y - t.getPositionY()
    }
}),
cc.moveTo = function(t, e, i) {
    return new cc.MoveTo(t,e,i)
}
,
cc.MoveTo.create = cc.moveTo,
cc.SkewTo = cc.ActionInterval.extend({
    _skewX: 0,
    _skewY: 0,
    _startSkewX: 0,
    _startSkewY: 0,
    _endSkewX: 0,
    _endSkewY: 0,
    _deltaX: 0,
    _deltaY: 0,
    ctor: function(t, e, i) {
        cc.ActionInterval.prototype.ctor.call(this),
        void 0 !== i && this.initWithDuration(t, e, i)
    },
    initWithDuration: function(t, e, i) {
        var n = !1;
        return cc.ActionInterval.prototype.initWithDuration.call(this, t) && (this._endSkewX = e,
        this._endSkewY = i,
        n = !0),
        n
    },
    clone: function() {
        var t = new cc.SkewTo;
        return this._cloneDecoration(t),
        t.initWithDuration(this._duration, this._endSkewX, this._endSkewY),
        t
    },
    startWithTarget: function(t) {
        cc.ActionInterval.prototype.startWithTarget.call(this, t),
        this._startSkewX = t.skewX % 180,
        this._deltaX = this._endSkewX - this._startSkewX,
        180 < this._deltaX && (this._deltaX -= 360),
        -180 > this._deltaX && (this._deltaX += 360),
        this._startSkewY = t.skewY % 360,
        this._deltaY = this._endSkewY - this._startSkewY,
        180 < this._deltaY && (this._deltaY -= 360),
        -180 > this._deltaY && (this._deltaY += 360)
    },
    update: function(t) {
        t = this._computeEaseTime(t),
        this.target.skewX = this._startSkewX + this._deltaX * t,
        this.target.skewY = this._startSkewY + this._deltaY * t
    }
}),
cc.skewTo = function(t, e, i) {
    return new cc.SkewTo(t,e,i)
}
,
cc.SkewTo.create = cc.skewTo,
cc.SkewBy = cc.SkewTo.extend({
    ctor: function(t, e, i) {
        cc.SkewTo.prototype.ctor.call(this),
        void 0 !== i && this.initWithDuration(t, e, i)
    },
    initWithDuration: function(t, e, i) {
        var n = !1;
        return cc.SkewTo.prototype.initWithDuration.call(this, t, e, i) && (this._skewX = e,
        this._skewY = i,
        n = !0),
        n
    },
    clone: function() {
        var t = new cc.SkewBy;
        return this._cloneDecoration(t),
        t.initWithDuration(this._duration, this._skewX, this._skewY),
        t
    },
    startWithTarget: function(t) {
        cc.SkewTo.prototype.startWithTarget.call(this, t),
        this._deltaX = this._skewX,
        this._deltaY = this._skewY,
        this._endSkewX = this._startSkewX + this._deltaX,
        this._endSkewY = this._startSkewY + this._deltaY
    },
    reverse: function() {
        var t = new cc.SkewBy(this._duration,(-this._skewX),(-this._skewY));
        return this._cloneDecoration(t),
        this._reverseEaseList(t),
        t
    }
}),
cc.skewBy = function(t, e, i) {
    return new cc.SkewBy(t,e,i)
}
,
cc.SkewBy.create = cc.skewBy,
cc.JumpBy = cc.ActionInterval.extend({
    _startPosition: null,
    _delta: null,
    _height: 0,
    _jumps: 0,
    _previousPosition: null,
    ctor: function(t, e, i, n, r) {
        cc.ActionInterval.prototype.ctor.call(this),
        this._startPosition = cc.p(0, 0),
        this._previousPosition = cc.p(0, 0),
        this._delta = cc.p(0, 0),
        void 0 !== n && this.initWithDuration(t, e, i, n, r)
    },
    initWithDuration: function(t, e, i, n, r) {
        return !!cc.ActionInterval.prototype.initWithDuration.call(this, t) && (void 0 === r && (r = n,
        n = i,
        i = e.y,
        e = e.x),
        this._delta.x = e,
        this._delta.y = i,
        this._height = n,
        this._jumps = r,
        !0)
    },
    clone: function() {
        var t = new cc.JumpBy;
        return this._cloneDecoration(t),
        t.initWithDuration(this._duration, this._delta, this._height, this._jumps),
        t
    },
    startWithTarget: function(t) {
        cc.ActionInterval.prototype.startWithTarget.call(this, t);
        var e = t.getPositionX();
        t = t.getPositionY(),
        this._previousPosition.x = e,
        this._previousPosition.y = t,
        this._startPosition.x = e,
        this._startPosition.y = t
    },
    update: function(t) {
        if (t = this._computeEaseTime(t),
        this.target) {
            var e = t * this._jumps % 1
              , e = 4 * this._height * e * (1 - e)
              , e = e + this._delta.y * t;
            t *= this._delta.x;
            var i = this._startPosition;
            if (cc.ENABLE_STACKABLE_ACTIONS) {
                var n = this.target.getPositionX()
                  , r = this.target.getPositionY()
                  , c = this._previousPosition;
                i.x = i.x + n - c.x,
                i.y = i.y + r - c.y,
                t += i.x,
                e += i.y,
                c.x = t,
                c.y = e,
                this.target.setPosition(t, e)
            } else
                this.target.setPosition(i.x + t, i.y + e)
        }
    },
    reverse: function() {
        var t = new cc.JumpBy(this._duration,cc.p(-this._delta.x, -this._delta.y),this._height,this._jumps);
        return this._cloneDecoration(t),
        this._reverseEaseList(t),
        t
    }
}),
cc.jumpBy = function(t, e, i, n, r) {
    return new cc.JumpBy(t,e,i,n,r)
}
,
cc.JumpBy.create = cc.jumpBy,
cc.JumpTo = cc.JumpBy.extend({
    _endPosition: null,
    ctor: function(t, e, i, n, r) {
        cc.JumpBy.prototype.ctor.call(this),
        this._endPosition = cc.p(0, 0),
        void 0 !== n && this.initWithDuration(t, e, i, n, r)
    },
    initWithDuration: function(t, e, i, n, r) {
        return !!cc.JumpBy.prototype.initWithDuration.call(this, t, e, i, n, r) && (void 0 === r && (i = e.y,
        e = e.x),
        this._endPosition.x = e,
        this._endPosition.y = i,
        !0)
    },
    startWithTarget: function(t) {
        cc.JumpBy.prototype.startWithTarget.call(this, t),
        this._delta.x = this._endPosition.x - this._startPosition.x,
        this._delta.y = this._endPosition.y - this._startPosition.y
    },
    clone: function() {
        var t = new cc.JumpTo;
        return this._cloneDecoration(t),
        t.initWithDuration(this._duration, this._endPosition, this._height, this._jumps),
        t
    }
}),
cc.jumpTo = function(t, e, i, n, r) {
    return new cc.JumpTo(t,e,i,n,r)
}
,
cc.JumpTo.create = cc.jumpTo,
cc.bezierAt = function(t, e, i, n, r) {
    return Math.pow(1 - r, 3) * t + 3 * r * Math.pow(1 - r, 2) * e + 3 * Math.pow(r, 2) * (1 - r) * i + Math.pow(r, 3) * n
}
,
cc.BezierBy = cc.ActionInterval.extend({
    _config: null,
    _startPosition: null,
    _previousPosition: null,
    ctor: function(t, e) {
        cc.ActionInterval.prototype.ctor.call(this),
        this._config = [],
        this._startPosition = cc.p(0, 0),
        this._previousPosition = cc.p(0, 0),
        e && this.initWithDuration(t, e)
    },
    initWithDuration: function(t, e) {
        return !!cc.ActionInterval.prototype.initWithDuration.call(this, t) && (this._config = e,
        !0)
    },
    clone: function() {
        var t = new cc.BezierBy;
        this._cloneDecoration(t);
        for (var e = [], i = 0; i < this._config.length; i++) {
            var n = this._config[i];
            e.push(cc.p(n.x, n.y))
        }
        return t.initWithDuration(this._duration, e),
        t
    },
    startWithTarget: function(t) {
        cc.ActionInterval.prototype.startWithTarget.call(this, t);
        var e = t.getPositionX();
        t = t.getPositionY(),
        this._previousPosition.x = e,
        this._previousPosition.y = t,
        this._startPosition.x = e,
        this._startPosition.y = t
    },
    update: function(t) {
        if (t = this._computeEaseTime(t),
        this.target) {
            var e = this._config
              , i = e[0].y
              , n = e[1].y
              , r = e[2].y
              , e = cc.bezierAt(0, e[0].x, e[1].x, e[2].x, t);
            if (t = cc.bezierAt(0, i, n, r, t),
            i = this._startPosition,
            cc.ENABLE_STACKABLE_ACTIONS) {
                var n = this.target.getPositionX()
                  , r = this.target.getPositionY()
                  , c = this._previousPosition;
                i.x = i.x + n - c.x,
                i.y = i.y + r - c.y,
                e += i.x,
                t += i.y,
                c.x = e,
                c.y = t,
                this.target.setPosition(e, t)
            } else
                this.target.setPosition(i.x + e, i.y + t)
        }
    },
    reverse: function() {
        var t = this._config
          , t = [cc.pAdd(t[1], cc.pNeg(t[2])), cc.pAdd(t[0], cc.pNeg(t[2])), cc.pNeg(t[2])]
          , t = new cc.BezierBy(this._duration,t);
        return this._cloneDecoration(t),
        this._reverseEaseList(t),
        t
    }
}),
cc.bezierBy = function(t, e) {
    return new cc.BezierBy(t,e)
}
,
cc.BezierBy.create = cc.bezierBy,
cc.BezierTo = cc.BezierBy.extend({
    _toConfig: null,
    ctor: function(t, e) {
        cc.BezierBy.prototype.ctor.call(this),
        this._toConfig = [],
        e && this.initWithDuration(t, e)
    },
    initWithDuration: function(t, e) {
        return !!cc.ActionInterval.prototype.initWithDuration.call(this, t) && (this._toConfig = e,
        !0)
    },
    clone: function() {
        var t = new cc.BezierTo;
        return this._cloneDecoration(t),
        t.initWithDuration(this._duration, this._toConfig),
        t
    },
    startWithTarget: function(t) {
        cc.BezierBy.prototype.startWithTarget.call(this, t),
        t = this._startPosition;
        var e = this._toConfig
          , i = this._config;
        i[0] = cc.pSub(e[0], t),
        i[1] = cc.pSub(e[1], t),
        i[2] = cc.pSub(e[2], t)
    }
}),
cc.bezierTo = function(t, e) {
    return new cc.BezierTo(t,e)
}
,
cc.BezierTo.create = cc.bezierTo,
cc.ScaleTo = cc.ActionInterval.extend({
    _scaleX: 1,
    _scaleY: 1,
    _startScaleX: 1,
    _startScaleY: 1,
    _endScaleX: 0,
    _endScaleY: 0,
    _deltaX: 0,
    _deltaY: 0,
    ctor: function(t, e, i) {
        cc.ActionInterval.prototype.ctor.call(this),
        void 0 !== e && this.initWithDuration(t, e, i)
    },
    initWithDuration: function(t, e, i) {
        return !!cc.ActionInterval.prototype.initWithDuration.call(this, t) && (this._endScaleX = e,
        this._endScaleY = null != i ? i : e,
        !0)
    },
    clone: function() {
        var t = new cc.ScaleTo;
        return this._cloneDecoration(t),
        t.initWithDuration(this._duration, this._endScaleX, this._endScaleY),
        t
    },
    startWithTarget: function(t) {
        cc.ActionInterval.prototype.startWithTarget.call(this, t),
        this._startScaleX = t.scaleX,
        this._startScaleY = t.scaleY,
        this._deltaX = this._endScaleX - this._startScaleX,
        this._deltaY = this._endScaleY - this._startScaleY
    },
    update: function(t) {
        t = this._computeEaseTime(t),
        this.target && (this.target.scaleX = this._startScaleX + this._deltaX * t,
        this.target.scaleY = this._startScaleY + this._deltaY * t)
    }
}),
cc.scaleTo = function(t, e, i) {
    return new cc.ScaleTo(t,e,i)
}
,
cc.ScaleTo.create = cc.scaleTo,
cc.ScaleBy = cc.ScaleTo.extend({
    startWithTarget: function(t) {
        cc.ScaleTo.prototype.startWithTarget.call(this, t),
        this._deltaX = this._startScaleX * this._endScaleX - this._startScaleX,
        this._deltaY = this._startScaleY * this._endScaleY - this._startScaleY
    },
    reverse: function() {
        var t = new cc.ScaleBy(this._duration,1 / this._endScaleX,1 / this._endScaleY);
        return this._cloneDecoration(t),
        this._reverseEaseList(t),
        t
    },
    clone: function() {
        var t = new cc.ScaleBy;
        return this._cloneDecoration(t),
        t.initWithDuration(this._duration, this._endScaleX, this._endScaleY),
        t
    }
}),
cc.scaleBy = function(t, e, i) {
    return new cc.ScaleBy(t,e,i)
}
,
cc.ScaleBy.create = cc.scaleBy,
cc.Blink = cc.ActionInterval.extend({
    _times: 0,
    _originalState: !1,
    ctor: function(t, e) {
        cc.ActionInterval.prototype.ctor.call(this),
        void 0 !== e && this.initWithDuration(t, e)
    },
    initWithDuration: function(t, e) {
        return !!cc.ActionInterval.prototype.initWithDuration.call(this, t) && (this._times = e,
        !0)
    },
    clone: function() {
        var t = new cc.Blink;
        return this._cloneDecoration(t),
        t.initWithDuration(this._duration, this._times),
        t
    },
    update: function(t) {
        if (t = this._computeEaseTime(t),
        this.target && !this.isDone()) {
            var e = 1 / this._times;
            this.target.visible = t % e > e / 2
        }
    },
    startWithTarget: function(t) {
        cc.ActionInterval.prototype.startWithTarget.call(this, t),
        this._originalState = t.visible
    },
    stop: function() {
        this.target.visible = this._originalState,
        cc.ActionInterval.prototype.stop.call(this)
    },
    reverse: function() {
        var t = new cc.Blink(this._duration,this._times);
        return this._cloneDecoration(t),
        this._reverseEaseList(t),
        t
    }
}),
cc.blink = function(t, e) {
    return new cc.Blink(t,e)
}
,
cc.Blink.create = cc.blink,
cc.FadeTo = cc.ActionInterval.extend({
    _toOpacity: 0,
    _fromOpacity: 0,
    ctor: function(t, e) {
        cc.ActionInterval.prototype.ctor.call(this),
        void 0 !== e && this.initWithDuration(t, e)
    },
    initWithDuration: function(t, e) {
        return !!cc.ActionInterval.prototype.initWithDuration.call(this, t) && (this._toOpacity = e,
        !0)
    },
    clone: function() {
        var t = new cc.FadeTo;
        return this._cloneDecoration(t),
        t.initWithDuration(this._duration, this._toOpacity),
        t
    },
    update: function(t) {
        t = this._computeEaseTime(t);
        var e = void 0 !== this._fromOpacity ? this._fromOpacity : 255;
        this.target.opacity = e + (this._toOpacity - e) * t
    },
    startWithTarget: function(t) {
        cc.ActionInterval.prototype.startWithTarget.call(this, t),
        this._fromOpacity = t.opacity
    }
}),
cc.fadeTo = function(t, e) {
    return new cc.FadeTo(t,e)
}
,
cc.FadeTo.create = cc.fadeTo,
cc.FadeIn = cc.FadeTo.extend({
    _reverseAction: null,
    ctor: function(t) {
        cc.FadeTo.prototype.ctor.call(this),
        null == t && (t = 0),
        this.initWithDuration(t, 255)
    },
    reverse: function() {
        var t = new cc.FadeOut;
        return t.initWithDuration(this._duration, 0),
        this._cloneDecoration(t),
        this._reverseEaseList(t),
        t
    },
    clone: function() {
        var t = new cc.FadeIn;
        return this._cloneDecoration(t),
        t.initWithDuration(this._duration, this._toOpacity),
        t
    },
    startWithTarget: function(t) {
        this._reverseAction && (this._toOpacity = this._reverseAction._fromOpacity),
        cc.FadeTo.prototype.startWithTarget.call(this, t)
    }
}),
cc.fadeIn = function(t) {
    return new cc.FadeIn(t)
}
,
cc.FadeIn.create = cc.fadeIn,
cc.FadeOut = cc.FadeTo.extend({
    ctor: function(t) {
        cc.FadeTo.prototype.ctor.call(this),
        null == t && (t = 0),
        this.initWithDuration(t, 0)
    },
    reverse: function() {
        var t = new cc.FadeIn;
        return t._reverseAction = this,
        t.initWithDuration(this._duration, 255),
        this._cloneDecoration(t),
        this._reverseEaseList(t),
        t
    },
    clone: function() {
        var t = new cc.FadeOut;
        return this._cloneDecoration(t),
        t.initWithDuration(this._duration, this._toOpacity),
        t
    }
}),
cc.fadeOut = function(t) {
    return new cc.FadeOut(t)
}
,
cc.FadeOut.create = cc.fadeOut,
cc.TintTo = cc.ActionInterval.extend({
    _to: null,
    _from: null,
    ctor: function(t, e, i, n) {
        cc.ActionInterval.prototype.ctor.call(this),
        this._to = cc.color(0, 0, 0),
        this._from = cc.color(0, 0, 0),
        void 0 !== n && this.initWithDuration(t, e, i, n)
    },
    initWithDuration: function(t, e, i, n) {
        return !!cc.ActionInterval.prototype.initWithDuration.call(this, t) && (this._to = cc.color(e, i, n),
        !0)
    },
    clone: function() {
        var t = new cc.TintTo;
        this._cloneDecoration(t);
        var e = this._to;
        return t.initWithDuration(this._duration, e.r, e.g, e.b),
        t
    },
    startWithTarget: function(t) {
        cc.ActionInterval.prototype.startWithTarget.call(this, t),
        this._from = this.target.color
    },
    update: function(t) {
        t = this._computeEaseTime(t);
        var e = this._from
          , i = this._to;
        e && this.target.setColor(cc.color(e.r + (i.r - e.r) * t, e.g + (i.g - e.g) * t, e.b + (i.b - e.b) * t))
    }
}),
cc.tintTo = function(t, e, i, n) {
    return new cc.TintTo(t,e,i,n)
}
,
cc.TintTo.create = cc.tintTo,
cc.TintBy = cc.ActionInterval.extend({
    _deltaR: 0,
    _deltaG: 0,
    _deltaB: 0,
    _fromR: 0,
    _fromG: 0,
    _fromB: 0,
    ctor: function(t, e, i, n) {
        cc.ActionInterval.prototype.ctor.call(this),
        void 0 !== n && this.initWithDuration(t, e, i, n)
    },
    initWithDuration: function(t, e, i, n) {
        return !!cc.ActionInterval.prototype.initWithDuration.call(this, t) && (this._deltaR = e,
        this._deltaG = i,
        this._deltaB = n,
        !0)
    },
    clone: function() {
        var t = new cc.TintBy;
        return this._cloneDecoration(t),
        t.initWithDuration(this._duration, this._deltaR, this._deltaG, this._deltaB),
        t
    },
    startWithTarget: function(t) {
        cc.ActionInterval.prototype.startWithTarget.call(this, t),
        t = t.color,
        this._fromR = t.r,
        this._fromG = t.g,
        this._fromB = t.b
    },
    update: function(t) {
        t = this._computeEaseTime(t),
        this.target.color = cc.color(this._fromR + this._deltaR * t, this._fromG + this._deltaG * t, this._fromB + this._deltaB * t)
    },
    reverse: function() {
        var t = new cc.TintBy(this._duration,(-this._deltaR),(-this._deltaG),(-this._deltaB));
        return this._cloneDecoration(t),
        this._reverseEaseList(t),
        t
    }
}),
cc.tintBy = function(t, e, i, n) {
    return new cc.TintBy(t,e,i,n)
}
,
cc.TintBy.create = cc.tintBy,
cc.DelayTime = cc.ActionInterval.extend({
    update: function(t) {},
    reverse: function() {
        var t = new cc.DelayTime(this._duration);
        return this._cloneDecoration(t),
        this._reverseEaseList(t),
        t
    },
    clone: function() {
        var t = new cc.DelayTime;
        return this._cloneDecoration(t),
        t.initWithDuration(this._duration),
        t
    }
}),
cc.delayTime = function(t) {
    return new cc.DelayTime(t)
}
,
cc.DelayTime.create = cc.delayTime,
cc.ReverseTime = cc.ActionInterval.extend({
    _other: null,
    ctor: function(t) {
        cc.ActionInterval.prototype.ctor.call(this),
        this._other = null,
        t && this.initWithAction(t)
    },
    initWithAction: function(t) {
        if (!t)
            throw Error("cc.ReverseTime.initWithAction(): action must be non null");
        if (t === this._other)
            throw Error("cc.ReverseTime.initWithAction(): the action was already passed in.");
        return !!cc.ActionInterval.prototype.initWithDuration.call(this, t._duration) && (this._other = t,
        !0)
    },
    clone: function() {
        var t = new cc.ReverseTime;
        return this._cloneDecoration(t),
        t.initWithAction(this._other.clone()),
        t
    },
    startWithTarget: function(t) {
        cc.ActionInterval.prototype.startWithTarget.call(this, t),
        this._other.startWithTarget(t)
    },
    update: function(t) {
        t = this._computeEaseTime(t),
        this._other && this._other.update(1 - t)
    },
    reverse: function() {
        return this._other.clone()
    },
    stop: function() {
        this._other.stop(),
        cc.Action.prototype.stop.call(this)
    }
}),
cc.reverseTime = function(t) {
    return new cc.ReverseTime(t)
}
,
cc.ReverseTime.create = cc.reverseTime,
cc.Animate = cc.ActionInterval.extend({
    _animation: null,
    _nextFrame: 0,
    _origFrame: null,
    _executedLoops: 0,
    _splitTimes: null,
    _currFrameIndex: 0,
    ctor: function(t) {
        cc.ActionInterval.prototype.ctor.call(this),
        this._splitTimes = [],
        t && this.initWithAnimation(t)
    },
    getAnimation: function() {
        return this._animation
    },
    setAnimation: function(t) {
        this._animation = t
    },
    getCurrentFrameIndex: function() {
        return this._currFrameIndex
    },
    initWithAnimation: function(t) {
        if (!t)
            throw Error("cc.Animate.initWithAnimation(): animation must be non-NULL");
        var e = t.getDuration();
        if (this.initWithDuration(e * t.getLoops())) {
            this._nextFrame = 0,
            this.setAnimation(t),
            this._origFrame = null,
            this._executedLoops = 0;
            var i = this._splitTimes
              , n = i.length = 0
              , r = e / t.getTotalDelayUnits();
            t = t.getFrames(),
            cc.arrayVerifyType(t, cc.AnimationFrame);
            for (var c = 0; c < t.length; c++) {
                var s = n * r / e
                  , n = n + t[c].getDelayUnits();
                i.push(s)
            }
            return !0
        }
        return !1
    },
    clone: function() {
        var t = new cc.Animate;
        return this._cloneDecoration(t),
        t.initWithAnimation(this._animation.clone()),
        t
    },
    startWithTarget: function(t) {
        cc.ActionInterval.prototype.startWithTarget.call(this, t),
        this._animation.getRestoreOriginalFrame() && (this._origFrame = t.displayFrame()),
        this._executedLoops = this._nextFrame = 0
    },
    update: function(t) {
        t = this._computeEaseTime(t),
        1 > t && (t *= this._animation.getLoops(),
        (0 | t) > this._executedLoops && (this._nextFrame = 0,
        this._executedLoops++),
        t %= 1);
        for (var e = this._animation.getFrames(), i = e.length, n = this._splitTimes, r = this._nextFrame; r < i && n[r] <= t; r++)
            _currFrameIndex = r,
            this.target.setSpriteFrame(e[_currFrameIndex].getSpriteFrame()),
            this._nextFrame = r + 1
    },
    reverse: function() {
        var t = this._animation
          , e = t.getFrames()
          , i = [];
        if (cc.arrayVerifyType(e, cc.AnimationFrame),
        0 < e.length)
            for (var n = e.length - 1; 0 <= n; n--) {
                var r = e[n];
                if (!r)
                    break;
                i.push(r.clone())
            }
        return e = new cc.Animation(i,t.getDelayPerUnit(),t.getLoops()),
        e.setRestoreOriginalFrame(t.getRestoreOriginalFrame()),
        t = new cc.Animate(e),
        this._cloneDecoration(t),
        this._reverseEaseList(t),
        t
    },
    stop: function() {
        this._animation.getRestoreOriginalFrame() && this.target && this.target.setSpriteFrame(this._origFrame),
        cc.Action.prototype.stop.call(this)
    }
}),
cc.animate = function(t) {
    return new cc.Animate(t)
}
,
cc.Animate.create = cc.animate,
cc.TargetedAction = cc.ActionInterval.extend({
    _action: null,
    _forcedTarget: null,
    ctor: function(t, e) {
        cc.ActionInterval.prototype.ctor.call(this),
        e && this.initWithTarget(t, e)
    },
    initWithTarget: function(t, e) {
        return !!this.initWithDuration(e._duration) && (this._forcedTarget = t,
        this._action = e,
        !0)
    },
    clone: function() {
        var t = new cc.TargetedAction;
        return this._cloneDecoration(t),
        t.initWithTarget(this._forcedTarget, this._action.clone()),
        t
    },
    startWithTarget: function(t) {
        cc.ActionInterval.prototype.startWithTarget.call(this, t),
        this._action.startWithTarget(this._forcedTarget)
    },
    stop: function() {
        this._action.stop()
    },
    update: function(t) {
        t = this._computeEaseTime(t),
        this._action.update(t)
    },
    getForcedTarget: function() {
        return this._forcedTarget
    },
    setForcedTarget: function(t) {
        this._forcedTarget !== t && (this._forcedTarget = t)
    }
}),
cc.targetedAction = function(t, e) {
    return new cc.TargetedAction(t,e)
}
,
cc.TargetedAction.create = cc.targetedAction,
cc.ActionInstant = cc.FiniteTimeAction.extend({
    isDone: function() {
        return !0
    },
    step: function(t) {
        this.update(1)
    },
    update: function(t) {},
    reverse: function() {
        return this.clone()
    },
    clone: function() {
        return new cc.ActionInstant
    }
}),
cc.Show = cc.ActionInstant.extend({
    update: function(t) {
        this.target.visible = !0
    },
    reverse: function() {
        return new cc.Hide
    },
    clone: function() {
        return new cc.Show
    }
}),
cc.show = function() {
    return new cc.Show
}
,
cc.Show.create = cc.show,
cc.Hide = cc.ActionInstant.extend({
    update: function(t) {
        this.target.visible = !1
    },
    reverse: function() {
        return new cc.Show
    },
    clone: function() {
        return new cc.Hide
    }
}),
cc.hide = function() {
    return new cc.Hide
}
,
cc.Hide.create = cc.hide,
cc.ToggleVisibility = cc.ActionInstant.extend({
    update: function(t) {
        this.target.visible = !this.target.visible
    },
    reverse: function() {
        return new cc.ToggleVisibility
    },
    clone: function() {
        return new cc.ToggleVisibility
    }
}),
cc.toggleVisibility = function() {
    return new cc.ToggleVisibility
}
,
cc.ToggleVisibility.create = cc.toggleVisibility,
cc.RemoveSelf = cc.ActionInstant.extend({
    _isNeedCleanUp: !0,
    ctor: function(t) {
        cc.FiniteTimeAction.prototype.ctor.call(this),
        void 0 !== t && this.init(t)
    },
    update: function(t) {
        this.target.removeFromParent(this._isNeedCleanUp)
    },
    init: function(t) {
        return this._isNeedCleanUp = t,
        !0
    },
    reverse: function() {
        return new cc.RemoveSelf(this._isNeedCleanUp)
    },
    clone: function() {
        return new cc.RemoveSelf(this._isNeedCleanUp)
    }
}),
cc.removeSelf = function(t) {
    return new cc.RemoveSelf(t)
}
,
cc.RemoveSelf.create = cc.removeSelf,
cc.FlipX = cc.ActionInstant.extend({
    _flippedX: !1,
    ctor: function(t) {
        cc.FiniteTimeAction.prototype.ctor.call(this),
        this._flippedX = !1,
        void 0 !== t && this.initWithFlipX(t)
    },
    initWithFlipX: function(t) {
        return this._flippedX = t,
        !0
    },
    update: function(t) {
        this.target.flippedX = this._flippedX
    },
    reverse: function() {
        return new cc.FlipX((!this._flippedX))
    },
    clone: function() {
        var t = new cc.FlipX;
        return t.initWithFlipX(this._flippedX),
        t
    }
}),
cc.flipX = function(t) {
    return new cc.FlipX(t)
}
,
cc.FlipX.create = cc.flipX,
cc.FlipY = cc.ActionInstant.extend({
    _flippedY: !1,
    ctor: function(t) {
        cc.FiniteTimeAction.prototype.ctor.call(this),
        this._flippedY = !1,
        void 0 !== t && this.initWithFlipY(t)
    },
    initWithFlipY: function(t) {
        return this._flippedY = t,
        !0
    },
    update: function(t) {
        this.target.flippedY = this._flippedY
    },
    reverse: function() {
        return new cc.FlipY((!this._flippedY))
    },
    clone: function() {
        var t = new cc.FlipY;
        return t.initWithFlipY(this._flippedY),
        t
    }
}),
cc.flipY = function(t) {
    return new cc.FlipY(t)
}
,
cc.FlipY.create = cc.flipY,
cc.Place = cc.ActionInstant.extend({
    _x: 0,
    _y: 0,
    ctor: function(t, e) {
        cc.FiniteTimeAction.prototype.ctor.call(this),
        this._y = this._x = 0,
        void 0 !== t && (void 0 !== t.x && (e = t.y,
        t = t.x),
        this.initWithPosition(t, e))
    },
    initWithPosition: function(t, e) {
        return this._x = t,
        this._y = e,
        !0
    },
    update: function(t) {
        this.target.setPosition(this._x, this._y)
    },
    clone: function() {
        var t = new cc.Place;
        return t.initWithPosition(this._x, this._y),
        t
    }
}),
cc.place = function(t, e) {
    return new cc.Place(t,e)
}
,
cc.Place.create = cc.place,
cc.CallFunc = cc.ActionInstant.extend({
    _selectorTarget: null,
    _function: null,
    _data: null,
    ctor: function(t, e, i) {
        cc.FiniteTimeAction.prototype.ctor.call(this),
        this.initWithFunction(t, e, i)
    },
    initWithFunction: function(t, e, i) {
        return t && (this._function = t),
        e && (this._selectorTarget = e),
        void 0 !== i && (this._data = i),
        !0
    },
    execute: function() {
        this._function && this._function.call(this._selectorTarget, this.target, this._data)
    },
    update: function(t) {
        this.execute()
    },
    getTargetCallback: function() {
        return this._selectorTarget
    },
    setTargetCallback: function(t) {
        t !== this._selectorTarget && (this._selectorTarget && (this._selectorTarget = null),
        this._selectorTarget = t)
    },
    clone: function() {
        var t = new cc.CallFunc;
        return t.initWithFunction(this._function, this._selectorTarget, this._data),
        t
    }
}),
cc.callFunc = function(t, e, i) {
    return new cc.CallFunc(t,e,i)
}
,
cc.CallFunc.create = cc.callFunc,
cc.ActionCamera = cc.ActionInterval.extend({
    _centerXOrig: 0,
    _centerYOrig: 0,
    _centerZOrig: 0,
    _eyeXOrig: 0,
    _eyeYOrig: 0,
    _eyeZOrig: 0,
    _upXOrig: 0,
    _upYOrig: 0,
    _upZOrig: 0,
    ctor: function() {
        cc.ActionInterval.prototype.ctor.call(this),
        this._upZOrig = this._upYOrig = this._upXOrig = this._eyeZOrig = this._eyeYOrig = this._eyeXOrig = this._centerZOrig = this._centerYOrig = this._centerXOrig = 0
    },
    startWithTarget: function(t) {
        cc.ActionInterval.prototype.startWithTarget.call(this, t),
        t = t.getCamera();
        var e = t.getCenter();
        this._centerXOrig = e.x,
        this._centerYOrig = e.y,
        this._centerZOrig = e.z,
        e = t.getEye(),
        this._eyeXOrig = e.x,
        this._eyeYOrig = e.y,
        this._eyeZOrig = e.z,
        t = t.getUp(),
        this._upXOrig = t.x,
        this._upYOrig = t.y,
        this._upZOrig = t.z
    },
    clone: function() {
        return new cc.ActionCamera
    },
    reverse: function() {
        return new cc.ReverseTime(this)
    }
}),
cc.OrbitCamera = cc.ActionCamera.extend({
    _radius: 0,
    _deltaRadius: 0,
    _angleZ: 0,
    _deltaAngleZ: 0,
    _angleX: 0,
    _deltaAngleX: 0,
    _radZ: 0,
    _radDeltaZ: 0,
    _radX: 0,
    _radDeltaX: 0,
    ctor: function(t, e, i, n, r, c, s) {
        cc.ActionCamera.prototype.ctor.call(this),
        void 0 !== s && this.initWithDuration(t, e, i, n, r, c, s)
    },
    initWithDuration: function(t, e, i, n, r, c, s) {
        return !!cc.ActionInterval.prototype.initWithDuration.call(this, t) && (this._radius = e,
        this._deltaRadius = i,
        this._angleZ = n,
        this._deltaAngleZ = r,
        this._angleX = c,
        this._deltaAngleX = s,
        this._radDeltaZ = cc.degreesToRadians(r),
        this._radDeltaX = cc.degreesToRadians(s),
        !0)
    },
    sphericalRadius: function() {
        var t, e;
        e = this.target.getCamera();
        var i = e.getEye();
        t = e.getCenter(),
        e = i.x - t.x;
        var n = i.y - t.y;
        t = i.z - t.z;
        var i = Math.sqrt(Math.pow(e, 2) + Math.pow(n, 2) + Math.pow(t, 2))
          , r = Math.sqrt(Math.pow(e, 2) + Math.pow(n, 2));
        return 0 === r && (r = cc.FLT_EPSILON),
        0 === i && (i = cc.FLT_EPSILON),
        t = Math.acos(t / i),
        e = 0 > e ? Math.PI - Math.asin(n / r) : Math.asin(n / r),
        {
            newRadius: i / cc.Camera.getZEye(),
            zenith: t,
            azimuth: e
        }
    },
    startWithTarget: function(t) {
        cc.ActionInterval.prototype.startWithTarget.call(this, t),
        t = this.sphericalRadius(),
        isNaN(this._radius) && (this._radius = t.newRadius),
        isNaN(this._angleZ) && (this._angleZ = cc.radiansToDegrees(t.zenith)),
        isNaN(this._angleX) && (this._angleX = cc.radiansToDegrees(t.azimuth)),
        this._radZ = cc.degreesToRadians(this._angleZ),
        this._radX = cc.degreesToRadians(this._angleX)
    },
    clone: function() {
        var t = new cc.OrbitCamera;
        return t.initWithDuration(this._duration, this._radius, this._deltaRadius, this._angleZ, this._deltaAngleZ, this._angleX, this._deltaAngleX),
        t
    },
    update: function(t) {
        t = this._computeEaseTime(t);
        var e = (this._radius + this._deltaRadius * t) * cc.Camera.getZEye()
          , i = this._radZ + this._radDeltaZ * t
          , n = this._radX + this._radDeltaX * t;
        t = Math.sin(i) * Math.cos(n) * e + this._centerXOrig,
        n = Math.sin(i) * Math.sin(n) * e + this._centerYOrig,
        e = Math.cos(i) * e + this._centerZOrig,
        this.target.getCamera().setEye(t, n, e),
        this.target.setNodeDirty()
    }
}),
cc.orbitCamera = function(t, e, i, n, r, c, s) {
    return new cc.OrbitCamera(t,e,i,n,r,c,s)
}
,
cc.OrbitCamera.create = cc.orbitCamera,
cc.ActionEase = cc.ActionInterval.extend({
    _inner: null,
    ctor: function(t) {
        cc.ActionInterval.prototype.ctor.call(this),
        t && this.initWithAction(t)
    },
    initWithAction: function(t) {
        if (!t)
            throw Error("cc.ActionEase.initWithAction(): action must be non nil");
        return !!this.initWithDuration(t.getDuration()) && (this._inner = t,
        !0)
    },
    clone: function() {
        var t = new cc.ActionEase;
        return t.initWithAction(this._inner.clone()),
        t
    },
    startWithTarget: function(t) {
        cc.ActionInterval.prototype.startWithTarget.call(this, t),
        this._inner.startWithTarget(this.target)
    },
    stop: function() {
        this._inner.stop(),
        cc.ActionInterval.prototype.stop.call(this)
    },
    update: function(t) {
        this._inner.update(t)
    },
    reverse: function() {
        return new cc.ActionEase(this._inner.reverse())
    },
    getInnerAction: function() {
        return this._inner
    }
}),
cc.actionEase = function(t) {
    return new cc.ActionEase(t)
}
,
cc.ActionEase.create = cc.actionEase,
cc.EaseRateAction = cc.ActionEase.extend({
    _rate: 0,
    ctor: function(t, e) {
        cc.ActionEase.prototype.ctor.call(this),
        void 0 !== e && this.initWithAction(t, e)
    },
    setRate: function(t) {
        this._rate = t
    },
    getRate: function() {
        return this._rate
    },
    initWithAction: function(t, e) {
        return !!cc.ActionEase.prototype.initWithAction.call(this, t) && (this._rate = e,
        !0)
    },
    clone: function() {
        var t = new cc.EaseRateAction;
        return t.initWithAction(this._inner.clone(), this._rate),
        t
    },
    reverse: function() {
        return new cc.EaseRateAction(this._inner.reverse(),1 / this._rate)
    }
}),
cc.easeRateAction = function(t, e) {
    return new cc.EaseRateAction(t,e)
}
,
cc.EaseRateAction.create = cc.easeRateAction,
cc.EaseIn = cc.EaseRateAction.extend({
    update: function(t) {
        this._inner.update(Math.pow(t, this._rate))
    },
    reverse: function() {
        return new cc.EaseIn(this._inner.reverse(),1 / this._rate)
    },
    clone: function() {
        var t = new cc.EaseIn;
        return t.initWithAction(this._inner.clone(), this._rate),
        t
    }
}),
cc.EaseIn.create = function(t, e) {
    return new cc.EaseIn(t,e)
}
,
cc.easeIn = function(t) {
    return {
        _rate: t,
        easing: function(t) {
            return Math.pow(t, this._rate)
        },
        reverse: function() {
            return cc.easeIn(1 / this._rate)
        }
    }
}
,
cc.EaseOut = cc.EaseRateAction.extend({
    update: function(t) {
        this._inner.update(Math.pow(t, 1 / this._rate))
    },
    reverse: function() {
        return new cc.EaseOut(this._inner.reverse(),1 / this._rate)
    },
    clone: function() {
        var t = new cc.EaseOut;
        return t.initWithAction(this._inner.clone(), this._rate),
        t
    }
}),
cc.EaseOut.create = function(t, e) {
    return new cc.EaseOut(t,e)
}
,
cc.easeOut = function(t) {
    return {
        _rate: t,
        easing: function(t) {
            return Math.pow(t, 1 / this._rate)
        },
        reverse: function() {
            return cc.easeOut(1 / this._rate)
        }
    }
}
,
cc.EaseInOut = cc.EaseRateAction.extend({
    update: function(t) {
        t *= 2,
        1 > t ? this._inner.update(.5 * Math.pow(t, this._rate)) : this._inner.update(1 - .5 * Math.pow(2 - t, this._rate))
    },
    clone: function() {
        var t = new cc.EaseInOut;
        return t.initWithAction(this._inner.clone(), this._rate),
        t
    },
    reverse: function() {
        return new cc.EaseInOut(this._inner.reverse(),this._rate)
    }
}),
cc.EaseInOut.create = function(t, e) {
    return new cc.EaseInOut(t,e)
}
,
cc.easeInOut = function(t) {
    return {
        _rate: t,
        easing: function(t) {
            return t *= 2,
            1 > t ? .5 * Math.pow(t, this._rate) : 1 - .5 * Math.pow(2 - t, this._rate)
        },
        reverse: function() {
            return cc.easeInOut(this._rate)
        }
    }
}
,
cc.EaseExponentialIn = cc.ActionEase.extend({
    update: function(t) {
        this._inner.update(0 === t ? 0 : Math.pow(2, 10 * (t - 1)))
    },
    reverse: function() {
        return new cc.EaseExponentialOut(this._inner.reverse())
    },
    clone: function() {
        var t = new cc.EaseExponentialIn;
        return t.initWithAction(this._inner.clone()),
        t
    }
}),
cc.EaseExponentialIn.create = function(t) {
    return new cc.EaseExponentialIn(t)
}
,
cc._easeExponentialInObj = {
    easing: function(t) {
        return 0 === t ? 0 : Math.pow(2, 10 * (t - 1))
    },
    reverse: function() {
        return cc._easeExponentialOutObj
    }
},
cc.easeExponentialIn = function() {
    return cc._easeExponentialInObj
}
,
cc.EaseExponentialOut = cc.ActionEase.extend({
    update: function(t) {
        this._inner.update(1 === t ? 1 : -Math.pow(2, -10 * t) + 1)
    },
    reverse: function() {
        return new cc.EaseExponentialIn(this._inner.reverse())
    },
    clone: function() {
        var t = new cc.EaseExponentialOut;
        return t.initWithAction(this._inner.clone()),
        t
    }
}),
cc.EaseExponentialOut.create = function(t) {
    return new cc.EaseExponentialOut(t)
}
,
cc._easeExponentialOutObj = {
    easing: function(t) {
        return 1 === t ? 1 : -Math.pow(2, -10 * t) + 1
    },
    reverse: function() {
        return cc._easeExponentialInObj
    }
},
cc.easeExponentialOut = function() {
    return cc._easeExponentialOutObj
}
,
cc.EaseExponentialInOut = cc.ActionEase.extend({
    update: function(t) {
        1 !== t && 0 !== t && (t *= 2,
        t = 1 > t ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (-Math.pow(2, -10 * (t - 1)) + 2)),
        this._inner.update(t)
    },
    reverse: function() {
        return new cc.EaseExponentialInOut(this._inner.reverse())
    },
    clone: function() {
        var t = new cc.EaseExponentialInOut;
        return t.initWithAction(this._inner.clone()),
        t
    }
}),
cc.EaseExponentialInOut.create = function(t) {
    return new cc.EaseExponentialInOut(t)
}
,
cc._easeExponentialInOutObj = {
    easing: function(t) {
        return 1 !== t && 0 !== t ? (t *= 2,
        1 > t ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (-Math.pow(2, -10 * (t - 1)) + 2)) : t
    },
    reverse: function() {
        return cc._easeExponentialInOutObj
    }
},
cc.easeExponentialInOut = function() {
    return cc._easeExponentialInOutObj
}
,
cc.EaseSineIn = cc.ActionEase.extend({
    update: function(t) {
        t = 0 === t || 1 === t ? t : -1 * Math.cos(t * Math.PI / 2) + 1,
        this._inner.update(t)
    },
    reverse: function() {
        return new cc.EaseSineOut(this._inner.reverse())
    },
    clone: function() {
        var t = new cc.EaseSineIn;
        return t.initWithAction(this._inner.clone()),
        t
    }
}),
cc.EaseSineIn.create = function(t) {
    return new cc.EaseSineIn(t)
}
,
cc._easeSineInObj = {
    easing: function(t) {
        return 0 === t || 1 === t ? t : -1 * Math.cos(t * Math.PI / 2) + 1
    },
    reverse: function() {
        return cc._easeSineOutObj
    }
},
cc.easeSineIn = function() {
    return cc._easeSineInObj
}
,
cc.EaseSineOut = cc.ActionEase.extend({
    update: function(t) {
        t = 0 === t || 1 === t ? t : Math.sin(t * Math.PI / 2),
        this._inner.update(t)
    },
    reverse: function() {
        return new cc.EaseSineIn(this._inner.reverse())
    },
    clone: function() {
        var t = new cc.EaseSineOut;
        return t.initWithAction(this._inner.clone()),
        t
    }
}),
cc.EaseSineOut.create = function(t) {
    return new cc.EaseSineOut(t)
}
,
cc._easeSineOutObj = {
    easing: function(t) {
        return 0 === t || 1 === t ? t : Math.sin(t * Math.PI / 2)
    },
    reverse: function() {
        return cc._easeSineInObj
    }
},
cc.easeSineOut = function() {
    return cc._easeSineOutObj
}
,
cc.EaseSineInOut = cc.ActionEase.extend({
    update: function(t) {
        t = 0 === t || 1 === t ? t : -.5 * (Math.cos(Math.PI * t) - 1),
        this._inner.update(t)
    },
    clone: function() {
        var t = new cc.EaseSineInOut;
        return t.initWithAction(this._inner.clone()),
        t
    },
    reverse: function() {
        return new cc.EaseSineInOut(this._inner.reverse())
    }
}),
cc.EaseSineInOut.create = function(t) {
    return new cc.EaseSineInOut(t)
}
,
cc._easeSineInOutObj = {
    easing: function(t) {
        return 0 === t || 1 === t ? t : -.5 * (Math.cos(Math.PI * t) - 1)
    },
    reverse: function() {
        return cc._easeSineInOutObj
    }
},
cc.easeSineInOut = function() {
    return cc._easeSineInOutObj
}
,
cc.EaseElastic = cc.ActionEase.extend({
    _period: .3,
    ctor: function(t, e) {
        cc.ActionEase.prototype.ctor.call(this),
        t && this.initWithAction(t, e)
    },
    getPeriod: function() {
        return this._period
    },
    setPeriod: function(t) {
        this._period = t
    },
    initWithAction: function(t, e) {
        return cc.ActionEase.prototype.initWithAction.call(this, t),
        this._period = null == e ? .3 : e,
        !0
    },
    reverse: function() {
        return cc.log("cc.EaseElastic.reverse(): it should be overridden in subclass."),
        null
    },
    clone: function() {
        var t = new cc.EaseElastic;
        return t.initWithAction(this._inner.clone(), this._period),
        t
    }
}),
cc.EaseElastic.create = function(t, e) {
    return new cc.EaseElastic(t,e)
}
,
cc.EaseElasticIn = cc.EaseElastic.extend({
    update: function(t) {
        var e = 0;
        0 === t || 1 === t ? e = t : (e = this._period / 4,
        t -= 1,
        e = -Math.pow(2, 10 * t) * Math.sin((t - e) * Math.PI * 2 / this._period)),
        this._inner.update(e)
    },
    reverse: function() {
        return new cc.EaseElasticOut(this._inner.reverse(),this._period)
    },
    clone: function() {
        var t = new cc.EaseElasticIn;
        return t.initWithAction(this._inner.clone(), this._period),
        t
    }
}),
cc.EaseElasticIn.create = function(t, e) {
    return new cc.EaseElasticIn(t,e)
}
,
cc._easeElasticInObj = {
    easing: function(t) {
        return 0 === t || 1 === t ? t : (t -= 1,
        -Math.pow(2, 10 * t) * Math.sin((t - .075) * Math.PI * 2 / .3))
    },
    reverse: function() {
        return cc._easeElasticOutObj
    }
},
cc.easeElasticIn = function(t) {
    return t && .3 !== t ? {
        _period: t,
        easing: function(t) {
            return 0 === t || 1 === t ? t : (t -= 1,
            -Math.pow(2, 10 * t) * Math.sin((t - this._period / 4) * Math.PI * 2 / this._period))
        },
        reverse: function() {
            return cc.easeElasticOut(this._period)
        }
    } : cc._easeElasticInObj
}
,
cc.EaseElasticOut = cc.EaseElastic.extend({
    update: function(t) {
        var e = 0;
        0 === t || 1 === t ? e = t : (e = this._period / 4,
        e = Math.pow(2, -10 * t) * Math.sin((t - e) * Math.PI * 2 / this._period) + 1),
        this._inner.update(e)
    },
    reverse: function() {
        return new cc.EaseElasticIn(this._inner.reverse(),this._period)
    },
    clone: function() {
        var t = new cc.EaseElasticOut;
        return t.initWithAction(this._inner.clone(), this._period),
        t
    }
}),
cc.EaseElasticOut.create = function(t, e) {
    return new cc.EaseElasticOut(t,e)
}
,
cc._easeElasticOutObj = {
    easing: function(t) {
        return 0 === t || 1 === t ? t : Math.pow(2, -10 * t) * Math.sin((t - .075) * Math.PI * 2 / .3) + 1
    },
    reverse: function() {
        return cc._easeElasticInObj
    }
},
cc.easeElasticOut = function(t) {
    return t && .3 !== t ? {
        _period: t,
        easing: function(t) {
            return 0 === t || 1 === t ? t : Math.pow(2, -10 * t) * Math.sin((t - this._period / 4) * Math.PI * 2 / this._period) + 1
        },
        reverse: function() {
            return cc.easeElasticIn(this._period)
        }
    } : cc._easeElasticOutObj
}
,
cc.EaseElasticInOut = cc.EaseElastic.extend({
    update: function(t) {
        var e = 0
          , e = this._period;
        if (0 === t || 1 === t)
            e = t;
        else {
            e || (e = this._period = .3 * 1.5);
            var i = e / 4;
            t = 2 * t - 1,
            e = 0 > t ? -.5 * Math.pow(2, 10 * t) * Math.sin((t - i) * Math.PI * 2 / e) : Math.pow(2, -10 * t) * Math.sin((t - i) * Math.PI * 2 / e) * .5 + 1
        }
        this._inner.update(e)
    },
    reverse: function() {
        return new cc.EaseElasticInOut(this._inner.reverse(),this._period)
    },
    clone: function() {
        var t = new cc.EaseElasticInOut;
        return t.initWithAction(this._inner.clone(), this._period),
        t
    }
}),
cc.EaseElasticInOut.create = function(t, e) {
    return new cc.EaseElasticInOut(t,e)
}
,
cc.easeElasticInOut = function(t) {
    return {
        _period: t || .3,
        easing: function(t) {
            var e = 0
              , e = this._period;
            if (0 === t || 1 === t)
                e = t;
            else {
                e || (e = this._period = .3 * 1.5);
                var i = e / 4;
                t = 2 * t - 1,
                e = 0 > t ? -.5 * Math.pow(2, 10 * t) * Math.sin((t - i) * Math.PI * 2 / e) : Math.pow(2, -10 * t) * Math.sin((t - i) * Math.PI * 2 / e) * .5 + 1
            }
            return e
        },
        reverse: function() {
            return cc.easeElasticInOut(this._period)
        }
    }
}
,
cc.EaseBounce = cc.ActionEase.extend({
    bounceTime: function(t) {
        return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? (t -= 1.5 / 2.75,
        7.5625 * t * t + .75) : t < 2.5 / 2.75 ? (t -= 2.25 / 2.75,
        7.5625 * t * t + .9375) : (t -= 2.625 / 2.75,
        7.5625 * t * t + .984375)
    },
    clone: function() {
        var t = new cc.EaseBounce;
        return t.initWithAction(this._inner.clone()),
        t
    },
    reverse: function() {
        return new cc.EaseBounce(this._inner.reverse())
    }
}),
cc.EaseBounce.create = function(t) {
    return new cc.EaseBounce(t)
}
,
cc.EaseBounceIn = cc.EaseBounce.extend({
    update: function(t) {
        t = 1 - this.bounceTime(1 - t),
        this._inner.update(t)
    },
    reverse: function() {
        return new cc.EaseBounceOut(this._inner.reverse())
    },
    clone: function() {
        var t = new cc.EaseBounceIn;
        return t.initWithAction(this._inner.clone()),
        t
    }
}),
cc.EaseBounceIn.create = function(t) {
    return new cc.EaseBounceIn(t)
}
,
cc._bounceTime = function(t) {
    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? (t -= 1.5 / 2.75,
    7.5625 * t * t + .75) : t < 2.5 / 2.75 ? (t -= 2.25 / 2.75,
    7.5625 * t * t + .9375) : (t -= 2.625 / 2.75,
    7.5625 * t * t + .984375)
}
,
cc._easeBounceInObj = {
    easing: function(t) {
        return 1 - cc._bounceTime(1 - t)
    },
    reverse: function() {
        return cc._easeBounceOutObj
    }
},
cc.easeBounceIn = function() {
    return cc._easeBounceInObj
}
,
cc.EaseBounceOut = cc.EaseBounce.extend({
    update: function(t) {
        t = this.bounceTime(t),
        this._inner.update(t)
    },
    reverse: function() {
        return new cc.EaseBounceIn(this._inner.reverse())
    },
    clone: function() {
        var t = new cc.EaseBounceOut;
        return t.initWithAction(this._inner.clone()),
        t
    }
}),
cc.EaseBounceOut.create = function(t) {
    return new cc.EaseBounceOut(t)
}
,
cc._easeBounceOutObj = {
    easing: function(t) {
        return cc._bounceTime(t)
    },
    reverse: function() {
        return cc._easeBounceInObj
    }
},
cc.easeBounceOut = function() {
    return cc._easeBounceOutObj
}
,
cc.EaseBounceInOut = cc.EaseBounce.extend({
    update: function(t) {
        var e = 0
          , e = .5 > t ? .5 * (1 - this.bounceTime(1 - 2 * t)) : .5 * this.bounceTime(2 * t - 1) + .5;
        this._inner.update(e)
    },
    clone: function() {
        var t = new cc.EaseBounceInOut;
        return t.initWithAction(this._inner.clone()),
        t
    },
    reverse: function() {
        return new cc.EaseBounceInOut(this._inner.reverse())
    }
}),
cc.EaseBounceInOut.create = function(t) {
    return new cc.EaseBounceInOut(t)
}
,
cc._easeBounceInOutObj = {
    easing: function(t) {
        return t = .5 > t ? .5 * (1 - cc._bounceTime(1 - 2 * t)) : .5 * cc._bounceTime(2 * t - 1) + .5
    },
    reverse: function() {
        return cc._easeBounceInOutObj
    }
},
cc.easeBounceInOut = function() {
    return cc._easeBounceInOutObj
}
,
cc.EaseBackIn = cc.ActionEase.extend({
    update: function(t) {
        this._inner.update(0 === t || 1 === t ? t : t * t * (2.70158 * t - 1.70158))
    },
    reverse: function() {
        return new cc.EaseBackOut(this._inner.reverse())
    },
    clone: function() {
        var t = new cc.EaseBackIn;
        return t.initWithAction(this._inner.clone()),
        t
    }
}),
cc.EaseBackIn.create = function(t) {
    return new cc.EaseBackIn(t)
}
,
cc._easeBackInObj = {
    easing: function(t) {
        return 0 === t || 1 === t ? t : t * t * (2.70158 * t - 1.70158)
    },
    reverse: function() {
        return cc._easeBackOutObj
    }
},
cc.easeBackIn = function() {
    return cc._easeBackInObj
}
,
cc.EaseBackOut = cc.ActionEase.extend({
    update: function(t) {
        t -= 1,
        this._inner.update(t * t * (2.70158 * t + 1.70158) + 1)
    },
    reverse: function() {
        return new cc.EaseBackIn(this._inner.reverse())
    },
    clone: function() {
        var t = new cc.EaseBackOut;
        return t.initWithAction(this._inner.clone()),
        t
    }
}),
cc.EaseBackOut.create = function(t) {
    return new cc.EaseBackOut(t)
}
,
cc._easeBackOutObj = {
    easing: function(t) {
        return t -= 1,
        t * t * (2.70158 * t + 1.70158) + 1
    },
    reverse: function() {
        return cc._easeBackInObj
    }
},
cc.easeBackOut = function() {
    return cc._easeBackOutObj
}
,
cc.EaseBackInOut = cc.ActionEase.extend({
    update: function(t) {
        t *= 2,
        1 > t ? this._inner.update(t * t * (3.5949095 * t - 2.5949095) / 2) : (t -= 2,
        this._inner.update(t * t * (3.5949095 * t + 2.5949095) / 2 + 1))
    },
    clone: function() {
        var t = new cc.EaseBackInOut;
        return t.initWithAction(this._inner.clone()),
        t
    },
    reverse: function() {
        return new cc.EaseBackInOut(this._inner.reverse())
    }
}),
cc.EaseBackInOut.create = function(t) {
    return new cc.EaseBackInOut(t)
}
,
cc._easeBackInOutObj = {
    easing: function(t) {
        return t *= 2,
        1 > t ? t * t * (3.5949095 * t - 2.5949095) / 2 : (t -= 2,
        t * t * (3.5949095 * t + 2.5949095) / 2 + 1)
    },
    reverse: function() {
        return cc._easeBackInOutObj
    }
},
cc.easeBackInOut = function() {
    return cc._easeBackInOutObj
}
,
cc.EaseBezierAction = cc.ActionEase.extend({
    _p0: null,
    _p1: null,
    _p2: null,
    _p3: null,
    ctor: function(t) {
        cc.ActionEase.prototype.ctor.call(this, t)
    },
    _updateTime: function(t, e, i, n, r) {
        return Math.pow(1 - r, 3) * t + 3 * r * Math.pow(1 - r, 2) * e + 3 * Math.pow(r, 2) * (1 - r) * i + Math.pow(r, 3) * n
    },
    update: function(t) {
        t = this._updateTime(this._p0, this._p1, this._p2, this._p3, t),
        this._inner.update(t)
    },
    clone: function() {
        var t = new cc.EaseBezierAction;
        return t.initWithAction(this._inner.clone()),
        t.setBezierParamer(this._p0, this._p1, this._p2, this._p3),
        t
    },
    reverse: function() {
        var t = new cc.EaseBezierAction(this._inner.reverse());
        return t.setBezierParamer(this._p3, this._p2, this._p1, this._p0),
        t
    },
    setBezierParamer: function(t, e, i, n) {
        this._p0 = t || 0,
        this._p1 = e || 0,
        this._p2 = i || 0,
        this._p3 = n || 0
    }
}),
cc.EaseBezierAction.create = function(t) {
    return new cc.EaseBezierAction(t)
}
,
cc.easeBezierAction = function(t, e, i, n) {
    return {
        easing: function(r) {
            return cc.EaseBezierAction.prototype._updateTime(t, e, i, n, r)
        },
        reverse: function() {
            return cc.easeBezierAction(n, i, e, t)
        }
    }
}
,
cc.EaseQuadraticActionIn = cc.ActionEase.extend({
    _updateTime: function(t) {
        return Math.pow(t, 2)
    },
    update: function(t) {
        this._inner.update(this._updateTime(t))
    },
    clone: function() {
        var t = new cc.EaseQuadraticActionIn;
        return t.initWithAction(this._inner.clone()),
        t
    },
    reverse: function() {
        return new cc.EaseQuadraticActionIn(this._inner.reverse())
    }
}),
cc.EaseQuadraticActionIn.create = function(t) {
    return new cc.EaseQuadraticActionIn(t)
}
,
cc._easeQuadraticActionIn = {
    easing: cc.EaseQuadraticActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeQuadraticActionIn
    }
},
cc.easeQuadraticActionIn = function() {
    return cc._easeQuadraticActionIn
}
,
cc.EaseQuadraticActionOut = cc.ActionEase.extend({
    _updateTime: function(t) {
        return -t * (t - 2)
    },
    update: function(t) {
        this._inner.update(this._updateTime(t))
    },
    clone: function() {
        var t = new cc.EaseQuadraticActionOut;
        return t.initWithAction(),
        t
    },
    reverse: function() {
        return new cc.EaseQuadraticActionOut(this._inner.reverse())
    }
}),
cc.EaseQuadraticActionOut.create = function(t) {
    return new cc.EaseQuadraticActionOut(t)
}
,
cc._easeQuadraticActionOut = {
    easing: cc.EaseQuadraticActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuadraticActionOut
    }
},
cc.easeQuadraticActionOut = function() {
    return cc._easeQuadraticActionOut
}
,
cc.EaseQuadraticActionInOut = cc.ActionEase.extend({
    _updateTime: function(t) {
        var e = t;
        return t *= 2,
        1 > t ? e = t * t * .5 : (--t,
        e = -.5 * (t * (t - 2) - 1)),
        e
    },
    update: function(t) {
        this._inner.update(this._updateTime(t))
    },
    clone: function() {
        var t = new cc.EaseQuadraticActionInOut;
        return t.initWithAction(this._inner.clone()),
        t
    },
    reverse: function() {
        return new cc.EaseQuadraticActionInOut(this._inner.reverse())
    }
}),
cc.EaseQuadraticActionInOut.create = function(t) {
    return new cc.EaseQuadraticActionInOut(t)
}
,
cc._easeQuadraticActionInOut = {
    easing: cc.EaseQuadraticActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuadraticActionInOut
    }
},
cc.easeQuadraticActionInOut = function() {
    return cc._easeQuadraticActionInOut
}
,
cc.EaseQuarticActionIn = cc.ActionEase.extend({
    _updateTime: function(t) {
        return t * t * t * t
    },
    update: function(t) {
        this._inner.update(this._updateTime(t))
    },
    clone: function() {
        var t = new cc.EaseQuarticActionIn;
        return t.initWithAction(this._inner.clone()),
        t
    },
    reverse: function() {
        return new cc.EaseQuarticActionIn(this._inner.reverse())
    }
}),
cc.EaseQuarticActionIn.create = function(t) {
    return new cc.EaseQuarticActionIn(t)
}
,
cc._easeQuarticActionIn = {
    easing: cc.EaseQuarticActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeQuarticActionIn
    }
},
cc.easeQuarticActionIn = function() {
    return cc._easeQuarticActionIn
}
,
cc.EaseQuarticActionOut = cc.ActionEase.extend({
    _updateTime: function(t) {
        return t -= 1,
        -(t * t * t * t - 1)
    },
    update: function(t) {
        this._inner.update(this._updateTime(t))
    },
    clone: function() {
        var t = new cc.EaseQuarticActionOut;
        return t.initWithAction(this._inner.clone()),
        t
    },
    reverse: function() {
        return new cc.EaseQuarticActionOut(this._inner.reverse())
    }
}),
cc.EaseQuarticActionOut.create = function(t) {
    return new cc.EaseQuarticActionOut(t);
}
,
cc._easeQuarticActionOut = {
    easing: cc.EaseQuarticActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuarticActionOut
    }
},
cc.easeQuarticActionOut = function() {
    return cc._easeQuarticActionOut
}
,
cc.EaseQuarticActionInOut = cc.ActionEase.extend({
    _updateTime: function(t) {
        return t *= 2,
        1 > t ? .5 * t * t * t * t : (t -= 2,
        -.5 * (t * t * t * t - 2))
    },
    update: function(t) {
        this._inner.update(this._updateTime(t))
    },
    clone: function() {
        var t = new cc.EaseQuarticActionInOut;
        return t.initWithAction(this._inner.clone()),
        t
    },
    reverse: function() {
        return new cc.EaseQuarticActionInOut(this._inner.reverse())
    }
}),
cc.EaseQuarticActionInOut.create = function(t) {
    return new cc.EaseQuarticActionInOut(t)
}
,
cc._easeQuarticActionInOut = {
    easing: cc.EaseQuarticActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuarticActionInOut
    }
},
cc.easeQuarticActionInOut = function() {
    return cc._easeQuarticActionInOut
}
,
cc.EaseQuinticActionIn = cc.ActionEase.extend({
    _updateTime: function(t) {
        return t * t * t * t * t
    },
    update: function(t) {
        this._inner.update(this._updateTime(t))
    },
    clone: function() {
        var t = new cc.EaseQuinticActionIn;
        return t.initWithAction(this._inner.clone()),
        t
    },
    reverse: function() {
        return new cc.EaseQuinticActionIn(this._inner.reverse())
    }
}),
cc.EaseQuinticActionIn.create = function(t) {
    return new cc.EaseQuinticActionIn(t)
}
,
cc._easeQuinticActionIn = {
    easing: cc.EaseQuinticActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeQuinticActionIn
    }
},
cc.easeQuinticActionIn = function() {
    return cc._easeQuinticActionIn
}
,
cc.EaseQuinticActionOut = cc.ActionEase.extend({
    _updateTime: function(t) {
        return t -= 1,
        t * t * t * t * t + 1
    },
    update: function(t) {
        this._inner.update(this._updateTime(t))
    },
    clone: function() {
        var t = new cc.EaseQuinticActionOut;
        return t.initWithAction(this._inner.clone()),
        t
    },
    reverse: function() {
        return new cc.EaseQuinticActionOut(this._inner.reverse())
    }
}),
cc.EaseQuinticActionOut.create = function(t) {
    return new cc.EaseQuinticActionOut(t)
}
,
cc._easeQuinticActionOut = {
    easing: cc.EaseQuinticActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuinticActionOut
    }
},
cc.easeQuinticActionOut = function() {
    return cc._easeQuinticActionOut
}
,
cc.EaseQuinticActionInOut = cc.ActionEase.extend({
    _updateTime: function(t) {
        return t *= 2,
        1 > t ? .5 * t * t * t * t * t : (t -= 2,
        .5 * (t * t * t * t * t + 2))
    },
    update: function(t) {
        this._inner.update(this._updateTime(t))
    },
    clone: function() {
        var t = new cc.EaseQuinticActionInOut;
        return t.initWithAction(this._inner.clone()),
        t
    },
    reverse: function() {
        return new cc.EaseQuinticActionInOut(this._inner.reverse())
    }
}),
cc.EaseQuinticActionInOut.create = function(t) {
    return new cc.EaseQuinticActionInOut(t)
}
,
cc._easeQuinticActionInOut = {
    easing: cc.EaseQuinticActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuinticActionInOut
    }
},
cc.easeQuinticActionInOut = function() {
    return cc._easeQuinticActionInOut
}
,
cc.EaseCircleActionIn = cc.ActionEase.extend({
    _updateTime: function(t) {
        return -1 * (Math.sqrt(1 - t * t) - 1)
    },
    update: function(t) {
        this._inner.update(this._updateTime(t))
    },
    clone: function() {
        var t = new cc.EaseCircleActionIn;
        return t.initWithAction(this._inner.clone()),
        t
    },
    reverse: function() {
        return new cc.EaseCircleActionIn(this._inner.reverse())
    }
}),
cc.EaseCircleActionIn.create = function(t) {
    return new cc.EaseCircleActionIn(t)
}
,
cc._easeCircleActionIn = {
    easing: cc.EaseCircleActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeCircleActionIn
    }
},
cc.easeCircleActionIn = function() {
    return cc._easeCircleActionIn
}
,
cc.EaseCircleActionOut = cc.ActionEase.extend({
    _updateTime: function(t) {
        return t -= 1,
        Math.sqrt(1 - t * t)
    },
    update: function(t) {
        this._inner.update(this._updateTime(t))
    },
    clone: function() {
        var t = new cc.EaseCircleActionOut;
        return t.initWithAction(this._inner.clone()),
        t
    },
    reverse: function() {
        return new cc.EaseCircleActionOut(this._inner.reverse())
    }
}),
cc.EaseCircleActionOut.create = function(t) {
    return new cc.EaseCircleActionOut(t)
}
,
cc._easeCircleActionOut = {
    easing: cc.EaseCircleActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeCircleActionOut
    }
},
cc.easeCircleActionOut = function() {
    return cc._easeCircleActionOut
}
,
cc.EaseCircleActionInOut = cc.ActionEase.extend({
    _updateTime: function(t) {
        return t *= 2,
        1 > t ? -.5 * (Math.sqrt(1 - t * t) - 1) : (t -= 2,
        .5 * (Math.sqrt(1 - t * t) + 1))
    },
    update: function(t) {
        this._inner.update(this._updateTime(t))
    },
    clone: function() {
        var t = new cc.EaseCircleActionInOut;
        return t.initWithAction(this._inner.clone()),
        t
    },
    reverse: function() {
        return new cc.EaseCircleActionInOut(this._inner.reverse())
    }
}),
cc.EaseCircleActionInOut.create = function(t) {
    return new cc.EaseCircleActionInOut(t)
}
,
cc._easeCircleActionInOut = {
    easing: cc.EaseCircleActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeCircleActionInOut
    }
},
cc.easeCircleActionInOut = function() {
    return cc._easeCircleActionInOut
}
,
cc.EaseCubicActionIn = cc.ActionEase.extend({
    _updateTime: function(t) {
        return t * t * t
    },
    update: function(t) {
        this._inner.update(this._updateTime(t))
    },
    clone: function() {
        var t = new cc.EaseCubicActionIn;
        return t.initWithAction(this._inner.clone()),
        t
    },
    reverse: function() {
        return new cc.EaseCubicActionIn(this._inner.reverse())
    }
}),
cc.EaseCubicActionIn.create = function(t) {
    return new cc.EaseCubicActionIn(t)
}
,
cc._easeCubicActionIn = {
    easing: cc.EaseCubicActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeCubicActionIn
    }
},
cc.easeCubicActionIn = function() {
    return cc._easeCubicActionIn
}
,
cc.EaseCubicActionOut = cc.ActionEase.extend({
    _updateTime: function(t) {
        return t -= 1,
        t * t * t + 1
    },
    update: function(t) {
        this._inner.update(this._updateTime(t))
    },
    clone: function() {
        var t = new cc.EaseCubicActionOut;
        return t.initWithAction(this._inner.clone()),
        t
    },
    reverse: function() {
        return new cc.EaseCubicActionOut(this._inner.reverse())
    }
}),
cc.EaseCubicActionOut.create = function(t) {
    return new cc.EaseCubicActionOut(t)
}
,
cc._easeCubicActionOut = {
    easing: cc.EaseCubicActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeCubicActionOut
    }
},
cc.easeCubicActionOut = function() {
    return cc._easeCubicActionOut
}
,
cc.EaseCubicActionInOut = cc.ActionEase.extend({
    _updateTime: function(t) {
        return t *= 2,
        1 > t ? .5 * t * t * t : (t -= 2,
        .5 * (t * t * t + 2))
    },
    update: function(t) {
        this._inner.update(this._updateTime(t))
    },
    clone: function() {
        var t = new cc.EaseCubicActionInOut;
        return t.initWithAction(this._inner.clone()),
        t
    },
    reverse: function() {
        return new cc.EaseCubicActionInOut(this._inner.reverse())
    }
}),
cc.EaseCubicActionInOut.create = function(t) {
    return new cc.EaseCubicActionInOut(t)
}
,
cc._easeCubicActionInOut = {
    easing: cc.EaseCubicActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeCubicActionInOut
    }
},
cc.easeCubicActionInOut = function() {
    return cc._easeCubicActionInOut
}
,
cc.cardinalSplineAt = function(t, e, i, n, r, c) {
    var s = c * c
      , o = s * c
      , a = (1 - r) / 2;
    r = a * (-o + 2 * s - c);
    var h = a * (-o + s) + (2 * o - 3 * s + 1);
    return c = a * (o - 2 * s + c) + (-2 * o + 3 * s),
    s = a * (o - s),
    cc.p(t.x * r + e.x * h + i.x * c + n.x * s, t.y * r + e.y * h + i.y * c + n.y * s)
}
,
cc.reverseControlPoints = function(t) {
    for (var e = [], i = t.length - 1; 0 <= i; i--)
        e.push(cc.p(t[i].x, t[i].y));
    return e
}
,
cc.cloneControlPoints = function(t) {
    for (var e = [], i = 0; i < t.length; i++)
        e.push(cc.p(t[i].x, t[i].y));
    return e
}
,
cc.copyControlPoints = cc.cloneControlPoints,
cc.getControlPointAt = function(t, e) {
    var i = Math.min(t.length - 1, Math.max(e, 0));
    return t[i]
}
,
cc.reverseControlPointsInline = function(t) {
    for (var e = t.length, i = 0 | e / 2, n = 0; n < i; ++n) {
        var r = t[n];
        t[n] = t[e - n - 1],
        t[e - n - 1] = r
    }
}
,
cc.CardinalSplineTo = cc.ActionInterval.extend({
    _points: null,
    _deltaT: 0,
    _tension: 0,
    _previousPosition: null,
    _accumulatedDiff: null,
    ctor: function(t, e, i) {
        cc.ActionInterval.prototype.ctor.call(this),
        this._points = [],
        void 0 !== i && this.initWithDuration(t, e, i)
    },
    initWithDuration: function(t, e, i) {
        if (!e || 0 === e.length)
            throw Error("Invalid configuration. It must at least have one control point");
        return !!cc.ActionInterval.prototype.initWithDuration.call(this, t) && (this.setPoints(e),
        this._tension = i,
        !0)
    },
    clone: function() {
        var t = new cc.CardinalSplineTo;
        return t.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension),
        t
    },
    startWithTarget: function(t) {
        cc.ActionInterval.prototype.startWithTarget.call(this, t),
        this._deltaT = 1 / (this._points.length - 1),
        this._previousPosition = cc.p(this.target.getPositionX(), this.target.getPositionY()),
        this._accumulatedDiff = cc.p(0, 0)
    },
    update: function(t) {
        t = this._computeEaseTime(t);
        var e, i = this._points;
        if (1 === t)
            e = i.length - 1,
            t = 1;
        else {
            var n = this._deltaT;
            e = 0 | t / n,
            t = (t - n * e) / n
        }
        e = cc.cardinalSplineAt(cc.getControlPointAt(i, e - 1), cc.getControlPointAt(i, e - 0), cc.getControlPointAt(i, e + 1), cc.getControlPointAt(i, e + 2), this._tension, t),
        cc.ENABLE_STACKABLE_ACTIONS && (i = this.target.getPositionX() - this._previousPosition.x,
        t = this.target.getPositionY() - this._previousPosition.y,
        0 !== i || 0 !== t) && (n = this._accumulatedDiff,
        i = n.x + i,
        t = n.y + t,
        n.x = i,
        n.y = t,
        e.x += i,
        e.y += t),
        this.updatePosition(e)
    },
    reverse: function() {
        var t = cc.reverseControlPoints(this._points);
        return cc.cardinalSplineTo(this._duration, t, this._tension)
    },
    updatePosition: function(t) {
        this.target.setPosition(t),
        this._previousPosition = t
    },
    getPoints: function() {
        return this._points
    },
    setPoints: function(t) {
        this._points = t
    }
}),
cc.cardinalSplineTo = function(t, e, i) {
    return new cc.CardinalSplineTo(t,e,i)
}
,
cc.CardinalSplineTo.create = cc.cardinalSplineTo,
cc.CardinalSplineBy = cc.CardinalSplineTo.extend({
    _startPosition: null,
    ctor: function(t, e, i) {
        cc.CardinalSplineTo.prototype.ctor.call(this),
        this._startPosition = cc.p(0, 0),
        void 0 !== i && this.initWithDuration(t, e, i)
    },
    startWithTarget: function(t) {
        cc.CardinalSplineTo.prototype.startWithTarget.call(this, t),
        this._startPosition.x = t.getPositionX(),
        this._startPosition.y = t.getPositionY()
    },
    reverse: function() {
        for (var t, e = this._points.slice(), i = e[0], n = 1; n < e.length; ++n)
            t = e[n],
            e[n] = cc.pSub(t, i),
            i = t;
        for (e = cc.reverseControlPoints(e),
        i = e[e.length - 1],
        e.pop(),
        i.x = -i.x,
        i.y = -i.y,
        e.unshift(i),
        n = 1; n < e.length; ++n)
            t = e[n],
            t.x = -t.x,
            t.y = -t.y,
            t.x += i.x,
            t.y += i.y,
            i = e[n] = t;
        return cc.cardinalSplineBy(this._duration, e, this._tension)
    },
    updatePosition: function(t) {
        var e = this._startPosition
          , i = t.x + e.x;
        t = t.y + e.y,
        this._previousPosition.x = i,
        this._previousPosition.y = t,
        this.target.setPosition(i, t)
    },
    clone: function() {
        var t = new cc.CardinalSplineBy;
        return t.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension),
        t
    }
}),
cc.cardinalSplineBy = function(t, e, i) {
    return new cc.CardinalSplineBy(t,e,i)
}
,
cc.CardinalSplineBy.create = cc.cardinalSplineBy,
cc.CatmullRomTo = cc.CardinalSplineTo.extend({
    ctor: function(t, e) {
        e && this.initWithDuration(t, e)
    },
    initWithDuration: function(t, e) {
        return cc.CardinalSplineTo.prototype.initWithDuration.call(this, t, e, .5)
    },
    clone: function() {
        var t = new cc.CatmullRomTo;
        return t.initWithDuration(this._duration, cc.copyControlPoints(this._points)),
        t
    }
}),
cc.catmullRomTo = function(t, e) {
    return new cc.CatmullRomTo(t,e)
}
,
cc.CatmullRomTo.create = cc.catmullRomTo,
cc.CatmullRomBy = cc.CardinalSplineBy.extend({
    ctor: function(t, e) {
        cc.CardinalSplineBy.prototype.ctor.call(this),
        e && this.initWithDuration(t, e)
    },
    initWithDuration: function(t, e) {
        return cc.CardinalSplineTo.prototype.initWithDuration.call(this, t, e, .5)
    },
    clone: function() {
        var t = new cc.CatmullRomBy;
        return t.initWithDuration(this._duration, cc.copyControlPoints(this._points)),
        t
    }
}),
cc.catmullRomBy = function(t, e) {
    return new cc.CatmullRomBy(t,e)
}
,
cc.CatmullRomBy.create = cc.catmullRomBy,
cc.ActionTweenDelegate = cc.Class.extend({
    updateTweenAction: function(t, e) {}
}),
cc.ActionTween = cc.ActionInterval.extend({
    key: "",
    from: 0,
    to: 0,
    delta: 0,
    ctor: function(t, e, i, n) {
        cc.ActionInterval.prototype.ctor.call(this),
        this.key = "",
        void 0 !== n && this.initWithDuration(t, e, i, n)
    },
    initWithDuration: function(t, e, i, n) {
        return !!cc.ActionInterval.prototype.initWithDuration.call(this, t) && (this.key = e,
        this.to = n,
        this.from = i,
        !0)
    },
    startWithTarget: function(t) {
        if (!t || !t.updateTweenAction)
            throw Error("cc.ActionTween.startWithTarget(): target must be non-null, and target must implement updateTweenAction function");
        cc.ActionInterval.prototype.startWithTarget.call(this, t),
        this.delta = this.to - this.from
    },
    update: function(t) {
        this.target.updateTweenAction(this.to - this.delta * (1 - t), this.key)
    },
    reverse: function() {
        return new cc.ActionTween(this.duration,this.key,this.to,this.from)
    },
    clone: function() {
        var t = new cc.ActionTween;
        return t.initWithDuration(this._duration, this.key, this.from, this.to),
        t
    }
}),
cc.actionTween = function(t, e, i, n) {
    return new cc.ActionTween(t,e,i,n)
}
,
cc.ActionTween.create = cc.actionTween,
cc.GridAction = cc.ActionInterval.extend({
    _gridSize: null,
    _gridNodeTarget: null,
    ctor: function(t, e) {
        cc.sys._checkWebGLRenderMode(),
        cc.ActionInterval.prototype.ctor.call(this),
        this._gridSize = cc.size(0, 0),
        e && this.initWithDuration(t, e)
    },
    _cacheTargetAsGridNode: function(t) {
        this._gridNodeTarget = t
    },
    clone: function() {
        var t = new cc.GridAction
          , e = this._gridSize;
        return t.initWithDuration(this._duration, cc.size(e.width, e.height)),
        t
    },
    startWithTarget: function(t) {
        cc.ActionInterval.prototype.startWithTarget.call(this, t),
        cc.renderer.childrenOrderDirty = !0,
        this._cacheTargetAsGridNode(t);
        var e = this.getGrid();
        (t = this._gridNodeTarget.getGrid()) && 0 < t.getReuseGrid() ? (e = t.getGridSize(),
        t.isActive() && e.width === this._gridSize.width && e.height === this._gridSize.height && t.reuse()) : (t && t.isActive() && t.setActive(!1),
        this._gridNodeTarget.setGrid(e),
        this._gridNodeTarget.getGrid().setActive(!0))
    },
    reverse: function() {
        return new cc.ReverseTime(this)
    },
    initWithDuration: function(t, e) {
        return !!cc.ActionInterval.prototype.initWithDuration.call(this, t) && (this._gridSize.width = e.width,
        this._gridSize.height = e.height,
        !0)
    },
    getGrid: function() {
        cc.log("cc.GridAction.getGrid(): it should be overridden in subclass.")
    }
}),
cc.gridAction = function(t, e) {
    return new cc.GridAction(t,e)
}
,
cc.GridAction.create = cc.gridAction,
cc.Grid3DAction = cc.GridAction.extend({
    getGrid: function() {
        return new cc.Grid3D(this._gridSize,(void 0),(void 0),this._gridNodeTarget.getGridRect())
    },
    getGridRect: function() {
        return this._gridNodeTarget.getGridRect()
    },
    vertex: function(t) {
        return this.getVertex(t)
    },
    getVertex: function(t) {
        return this.target.grid.getVertex(t)
    },
    originalVertex: function(t) {
        return this.getOriginalVertex(t)
    },
    getOriginalVertex: function(t) {
        return this.target.grid.originalVertex(t)
    },
    setVertex: function(t, e) {
        this.target.grid.setVertex(t, e)
    }
}),
cc.grid3DAction = function(t, e) {
    return new cc.Grid3DAction(t,e)
}
,
cc.Grid3DAction.create = cc.grid3DAction,
cc.TiledGrid3DAction = cc.GridAction.extend({
    tile: function(t) {
        return this.getTile(t)
    },
    getTile: function(t) {
        return this.target.grid.tile(t)
    },
    originalTile: function(t) {
        return this.getOriginalTile(t)
    },
    getOriginalTile: function(t) {
        return this.target.grid.originalTile(t)
    },
    setTile: function(t, e) {
        this.target.grid.setTile(t, e)
    },
    getGrid: function() {
        return new cc.TiledGrid3D(this._gridSize,(void 0),(void 0),this._gridNodeTarget.getGridRect())
    }
}),
cc.tiledGrid3DAction = function(t, e) {
    return new cc.TiledGrid3DAction(t,e)
}
,
cc.TiledGrid3DAction.create = cc.tiledGrid3DAction,
cc.StopGrid = cc.ActionInstant.extend({
    startWithTarget: function(t) {
        cc.ActionInstant.prototype.startWithTarget.call(this, t),
        cc.renderer.childrenOrderDirty = !0,
        (t = this.target.grid) && t.isActive() && t.setActive(!1)
    }
}),
cc.stopGrid = function() {
    return new cc.StopGrid
}
,
cc.StopGrid.create = cc.stopGrid,
cc.ReuseGrid = cc.ActionInstant.extend({
    _times: null,
    ctor: function(t) {
        cc.ActionInstant.prototype.ctor.call(this),
        void 0 !== t && this.initWithTimes(t)
    },
    initWithTimes: function(t) {
        return this._times = t,
        !0
    },
    startWithTarget: function(t) {
        cc.ActionInstant.prototype.startWithTarget.call(this, t),
        cc.renderer.childrenOrderDirty = !0,
        this.target.grid && this.target.grid.isActive() && this.target.grid.setReuseGrid(this.target.grid.getReuseGrid() + this._times)
    }
}),
cc.reuseGrid = function(t) {
    return new cc.ReuseGrid(t)
}
,
cc.ReuseGrid.create = cc.reuseGrid,
cc.Waves3D = cc.Grid3DAction.extend({
    _waves: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    ctor: function(t, e, i, n) {
        cc.GridAction.prototype.ctor.call(this),
        void 0 !== n && this.initWithDuration(t, e, i, n)
    },
    getAmplitude: function() {
        return this._amplitude
    },
    setAmplitude: function(t) {
        this._amplitude = t
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate
    },
    setAmplitudeRate: function(t) {
        this._amplitudeRate = t
    },
    initWithDuration: function(t, e, i, n) {
        return !!cc.Grid3DAction.prototype.initWithDuration.call(this, t, e) && (this._waves = i,
        this._amplitude = n,
        this._amplitudeRate = 1,
        !0)
    },
    update: function(t) {
        for (var e = this._gridSize, i = this._amplitude, n = cc.p(0, 0), r = this._amplitudeRate, c = this._waves, s = 0; s < e.width + 1; ++s)
            for (var o = 0; o < e.height + 1; ++o) {
                n.x = s,
                n.y = o;
                var a = this.originalVertex(n);
                a.z += Math.sin(Math.PI * t * c * 2 + .01 * (a.y + a.x)) * i * r,
                this.setVertex(n, a)
            }
    }
}),
cc.waves3D = function(t, e, i, n) {
    return new cc.Waves3D(t,e,i,n)
}
,
cc.Waves3D.create = cc.waves3D,
cc.FlipX3D = cc.Grid3DAction.extend({
    ctor: function(t) {
        void 0 !== t ? cc.GridAction.prototype.ctor.call(this, t, cc.size(1, 1)) : cc.GridAction.prototype.ctor.call(this)
    },
    initWithDuration: function(t) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, t, cc.size(1, 1))
    },
    initWithSize: function(t, e) {
        return 1 !== t.width || 1 !== t.height ? (cc.log("Grid size must be (1,1)"),
        !1) : cc.Grid3DAction.prototype.initWithDuration.call(this, e, t)
    },
    update: function(t) {
        var e = Math.PI * t;
        t = Math.sin(e);
        var i = Math.cos(e / 2)
          , e = new cc.Vertex3F
          , n = cc.p(0, 0);
        n.x = n.y = 1;
        var r = this.originalVertex(n);
        n.x = n.y = 0;
        var c, s, n = this.originalVertex(n), o = r.x, a = n.x;
        o > a ? (r = cc.p(0, 0),
        n = cc.p(0, 1),
        c = cc.p(1, 0),
        s = cc.p(1, 1)) : (c = cc.p(0, 0),
        s = cc.p(0, 1),
        r = cc.p(1, 0),
        n = cc.p(1, 1),
        o = a),
        e.x = o - o * i,
        e.z = Math.abs(parseFloat(o * t / 4)),
        t = this.originalVertex(r),
        t.x = e.x,
        t.z += e.z,
        this.setVertex(r, t),
        t = this.originalVertex(n),
        t.x = e.x,
        t.z += e.z,
        this.setVertex(n, t),
        t = this.originalVertex(c),
        t.x -= e.x,
        t.z -= e.z,
        this.setVertex(c, t),
        t = this.originalVertex(s),
        t.x -= e.x,
        t.z -= e.z,
        this.setVertex(s, t)
    }
}),
cc.flipX3D = function(t) {
    return new cc.FlipX3D(t)
}
,
cc.FlipX3D.create = cc.flipX3D,
cc.FlipY3D = cc.FlipX3D.extend({
    ctor: function(t) {
        void 0 !== t ? cc.GridAction.prototype.ctor.call(this, t, cc.size(1, 1)) : cc.GridAction.prototype.ctor.call(this)
    },
    update: function(t) {
        var e = Math.PI * t;
        t = Math.sin(e);
        var i = Math.cos(e / 2)
          , e = new cc.Vertex3F
          , n = cc.p(0, 0);
        n.x = n.y = 1;
        var r = this.originalVertex(n);
        n.x = n.y = 0;
        var c, s, n = this.originalVertex(n), o = r.y, a = n.y;
        o > a ? (r = cc.p(0, 0),
        n = cc.p(0, 1),
        c = cc.p(1, 0),
        s = cc.p(1, 1)) : (n = cc.p(0, 0),
        r = cc.p(0, 1),
        s = cc.p(1, 0),
        c = cc.p(1, 1),
        o = a),
        e.y = o - o * i,
        e.z = Math.abs(parseFloat(o * t) / 4),
        t = this.originalVertex(r),
        t.y = e.y,
        t.z += e.z,
        this.setVertex(r, t),
        t = this.originalVertex(n),
        t.y -= e.y,
        t.z -= e.z,
        this.setVertex(n, t),
        t = this.originalVertex(c),
        t.y = e.y,
        t.z += e.z,
        this.setVertex(c, t),
        t = this.originalVertex(s),
        t.y -= e.y,
        t.z -= e.z,
        this.setVertex(s, t)
    }
}),
cc.flipY3D = function(t) {
    return new cc.FlipY3D(t)
}
,
cc.FlipY3D.create = cc.flipY3D,
cc.Lens3D = cc.Grid3DAction.extend({
    _position: null,
    _radius: 0,
    _lensEffect: 0,
    _concave: !1,
    _dirty: !1,
    ctor: function(t, e, i, n) {
        cc.GridAction.prototype.ctor.call(this),
        this._position = cc.p(0, 0),
        void 0 !== n && this.initWithDuration(t, e, i, n)
    },
    getLensEffect: function() {
        return this._lensEffect
    },
    setLensEffect: function(t) {
        this._lensEffect = t
    },
    setConcave: function(t) {
        this._concave = t
    },
    getPosition: function() {
        return this._position
    },
    setPosition: function(t) {
        cc.pointEqualToPoint(t, this._position) || (this._position.x = t.x,
        this._position.y = t.y,
        this._dirty = !0)
    },
    initWithDuration: function(t, e, i, n) {
        return !!cc.Grid3DAction.prototype.initWithDuration.call(this, t, e) && (this.setPosition(i),
        this._radius = n,
        this._lensEffect = .7,
        this._dirty = !0)
    },
    update: function(t) {
        if (this._dirty) {
            t = this._gridSize.width;
            for (var e, i, n, r = this._gridSize.height, c = this._radius, s = this._lensEffect, o = cc.p(0, 0), a = cc.p(0, 0), h = 0; h < t + 1; ++h)
                for (var l = 0; l < r + 1; ++l)
                    o.x = h,
                    o.y = l,
                    e = this.originalVertex(o),
                    a.x = this._position.x - e.x,
                    a.y = this._position.y - e.y,
                    i = cc.pLength(a),
                    i < c && (i = c - i,
                    i /= c,
                    0 === i && (i = .001),
                    i = Math.log(i) * s,
                    n = Math.exp(i) * c,
                    i = cc.pLength(a),
                    0 < i && (a.x /= i,
                    a.y /= i,
                    a.x *= n,
                    a.y *= n,
                    e.z += cc.pLength(a) * s)),
                    this.setVertex(o, e);
            this._dirty = !1
        }
    }
}),
cc.lens3D = function(t, e, i, n) {
    return new cc.Lens3D(t,e,i,n)
}
,
cc.Lens3D.create = cc.lens3D,
cc.Ripple3D = cc.Grid3DAction.extend({
    _position: null,
    _radius: 0,
    _waves: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    ctor: function(t, e, i, n, r, c) {
        cc.GridAction.prototype.ctor.call(this),
        this._position = cc.p(0, 0),
        void 0 !== c && this.initWithDuration(t, e, i, n, r, c)
    },
    getPosition: function() {
        return this._position
    },
    setPosition: function(t) {
        this._position.x = t.x,
        this._position.y = t.y
    },
    getAmplitude: function() {
        return this._amplitude
    },
    setAmplitude: function(t) {
        this._amplitude = t
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate
    },
    setAmplitudeRate: function(t) {
        this._amplitudeRate = t
    },
    initWithDuration: function(t, e, i, n, r, c) {
        return !!cc.Grid3DAction.prototype.initWithDuration.call(this, t, e) && (this.setPosition(i),
        this._radius = n,
        this._waves = r,
        this._amplitude = c,
        this._amplitudeRate = 1,
        !0)
    },
    update: function(t) {
        for (var e, i, n = this._gridSize.width, r = this._gridSize.height, c = cc.p(0, 0), s = this._radius, o = this._waves, a = this._amplitude, h = this._amplitudeRate, l = cc.p(0, 0), u = 0; u < n + 1; ++u)
            for (var d = 0; d < r + 1; ++d) {
                if (c.x = u,
                c.y = d,
                e = this.originalVertex(c),
                l.x = this._position.x - e.x,
                l.y = this._position.y - e.y,
                i = cc.pLength(l),
                i < s) {
                    i = s - i;
                    var _ = Math.pow(i / s, 2);
                    e.z += Math.sin(t * Math.PI * o * 2 + .1 * i) * a * h * _
                }
                this.setVertex(c, e)
            }
    }
}),
cc.ripple3D = function(t, e, i, n, r, c) {
    return new cc.Ripple3D(t,e,i,n,r,c)
}
,
cc.Ripple3D.create = cc.ripple3D,
cc.Shaky3D = cc.Grid3DAction.extend({
    _randRange: 0,
    _shakeZ: !1,
    ctor: function(t, e, i, n) {
        cc.GridAction.prototype.ctor.call(this),
        void 0 !== n && this.initWithDuration(t, e, i, n)
    },
    initWithDuration: function(t, e, i, n) {
        return !!cc.Grid3DAction.prototype.initWithDuration.call(this, t, e) && (this._randRange = i,
        this._shakeZ = n,
        !0)
    },
    update: function(t) {
        t = this._gridSize.width;
        for (var e, i = this._gridSize.height, n = this._randRange, r = this._shakeZ, c = cc.p(0, 0), s = 0; s < t + 1; ++s)
            for (var o = 0; o < i + 1; ++o)
                c.x = s,
                c.y = o,
                e = this.originalVertex(c),
                e.x += cc.rand() % (2 * n) - n,
                e.y += cc.rand() % (2 * n) - n,
                r && (e.z += cc.rand() % (2 * n) - n),
                this.setVertex(c, e)
    }
}),
cc.shaky3D = function(t, e, i, n) {
    return new cc.Shaky3D(t,e,i,n)
}
,
cc.Shaky3D.create = cc.shaky3D,
cc.Liquid = cc.Grid3DAction.extend({
    _waves: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    ctor: function(t, e, i, n) {
        cc.GridAction.prototype.ctor.call(this),
        void 0 !== n && this.initWithDuration(t, e, i, n)
    },
    getAmplitude: function() {
        return this._amplitude
    },
    setAmplitude: function(t) {
        this._amplitude = t
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate
    },
    setAmplitudeRate: function(t) {
        this._amplitudeRate = t
    },
    initWithDuration: function(t, e, i, n) {
        return !!cc.Grid3DAction.prototype.initWithDuration.call(this, t, e) && (this._waves = i,
        this._amplitude = n,
        this._amplitudeRate = 1,
        !0)
    },
    update: function(t) {
        for (var e, i = this._gridSize.width, n = this._gridSize.height, r = cc.p(0, 0), c = this._waves, s = this._amplitude, o = this._amplitudeRate, a = 1; a < i; ++a)
            for (var h = 1; h < n; ++h)
                r.x = a,
                r.y = h,
                e = this.originalVertex(r),
                e.x += Math.sin(t * Math.PI * c * 2 + .01 * e.x) * s * o,
                e.y += Math.sin(t * Math.PI * c * 2 + .01 * e.y) * s * o,
                this.setVertex(r, e)
    }
}),
cc.liquid = function(t, e, i, n) {
    return new cc.Liquid(t,e,i,n)
}
,
cc.Liquid.create = cc.liquid,
cc.Waves = cc.Grid3DAction.extend({
    _waves: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    _vertical: !1,
    _horizontal: !1,
    ctor: function(t, e, i, n, r, c) {
        cc.GridAction.prototype.ctor.call(this),
        void 0 !== c && this.initWithDuration(t, e, i, n, r, c)
    },
    getAmplitude: function() {
        return this._amplitude
    },
    setAmplitude: function(t) {
        this._amplitude = t
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate
    },
    setAmplitudeRate: function(t) {
        this._amplitudeRate = t
    },
    initWithDuration: function(t, e, i, n, r, c) {
        return !!cc.Grid3DAction.prototype.initWithDuration.call(this, t, e) && (this._waves = i,
        this._amplitude = n,
        this._amplitudeRate = 1,
        this._horizontal = r,
        this._vertical = c,
        !0)
    },
    update: function(t) {
        for (var e, i = this._gridSize.width, n = this._gridSize.height, r = cc.p(0, 0), c = this._vertical, s = this._horizontal, o = this._waves, a = this._amplitude, h = this._amplitudeRate, l = 0; l < i + 1; ++l)
            for (var u = 0; u < n + 1; ++u)
                r.x = l,
                r.y = u,
                e = this.originalVertex(r),
                c && (e.x += Math.sin(t * Math.PI * o * 2 + .01 * e.y) * a * h),
                s && (e.y += Math.sin(t * Math.PI * o * 2 + .01 * e.x) * a * h),
                this.setVertex(r, e)
    }
}),
cc.waves = function(t, e, i, n, r, c) {
    return new cc.Waves(t,e,i,n,r,c)
}
,
cc.Waves.create = cc.waves,
cc.Twirl = cc.Grid3DAction.extend({
    _position: null,
    _twirls: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    ctor: function(t, e, i, n, r) {
        cc.GridAction.prototype.ctor.call(this),
        this._position = cc.p(0, 0),
        void 0 !== r && this.initWithDuration(t, e, i, n, r)
    },
    getPosition: function() {
        return this._position
    },
    setPosition: function(t) {
        this._position.x = t.x,
        this._position.y = t.y
    },
    getAmplitude: function() {
        return this._amplitude
    },
    setAmplitude: function(t) {
        this._amplitude = t
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate
    },
    setAmplitudeRate: function(t) {
        this._amplitudeRate = t
    },
    initWithDuration: function(t, e, i, n, r) {
        return !!cc.Grid3DAction.prototype.initWithDuration.call(this, t, e) && (this.setPosition(i),
        this._twirls = n,
        this._amplitude = r,
        this._amplitudeRate = 1,
        !0)
    },
    update: function(t) {
        for (var e, i, n, r = this._position, c = this._gridSize.width, s = this._gridSize.height, o = cc.p(0, 0), a = .1 * this._amplitude * this._amplitudeRate, h = this._twirls, l = cc.p(0, 0), u = 0; u < c + 1; ++u)
            for (var d = 0; d < s + 1; ++d)
                o.x = u,
                o.y = d,
                e = this.originalVertex(o),
                l.x = u - c / 2,
                l.y = d - s / 2,
                i = cc.pLength(l) * Math.cos(Math.PI / 2 + t * Math.PI * h * 2) * a,
                n = Math.sin(i) * (e.y - r.y) + Math.cos(i) * (e.x - r.x),
                i = Math.cos(i) * (e.y - r.y) - Math.sin(i) * (e.x - r.x),
                e.x = r.x + n,
                e.y = r.y + i,
                this.setVertex(o, e)
    }
}),
cc.twirl = function(t, e, i, n, r) {
    return new cc.Twirl(t,e,i,n,r)
}
,
cc.Twirl.create = cc.twirl,
cc.ShakyTiles3D = cc.TiledGrid3DAction.extend({
    _randRange: 0,
    _shakeZ: !1,
    ctor: function(t, e, i, n) {
        cc.GridAction.prototype.ctor.call(this),
        void 0 !== n && this.initWithDuration(t, e, i, n)
    },
    initWithDuration: function(t, e, i, n) {
        return !!cc.TiledGrid3DAction.prototype.initWithDuration.call(this, t, e) && (this._randRange = i,
        this._shakeZ = n,
        !0)
    },
    update: function(t) {
        t = this._gridSize;
        for (var e = this._randRange, i = cc.p(0, 0), n = 0; n < t.width; ++n)
            for (var r = 0; r < t.height; ++r) {
                i.x = n,
                i.y = r;
                var c = this.originalTile(i);
                c.bl.x += cc.rand() % (2 * e) - e,
                c.br.x += cc.rand() % (2 * e) - e,
                c.tl.x += cc.rand() % (2 * e) - e,
                c.tr.x += cc.rand() % (2 * e) - e,
                c.bl.y += cc.rand() % (2 * e) - e,
                c.br.y += cc.rand() % (2 * e) - e,
                c.tl.y += cc.rand() % (2 * e) - e,
                c.tr.y += cc.rand() % (2 * e) - e,
                this._shakeZ && (c.bl.z += cc.rand() % (2 * e) - e,
                c.br.z += cc.rand() % (2 * e) - e,
                c.tl.z += cc.rand() % (2 * e) - e,
                c.tr.z += cc.rand() % (2 * e) - e),
                this.setTile(i, c)
            }
    }
}),
cc.shakyTiles3D = function(t, e, i, n) {
    return new cc.ShakyTiles3D(t,e,i,n)
}
,
cc.ShakyTiles3D.create = cc.shakyTiles3D,
cc.ShatteredTiles3D = cc.TiledGrid3DAction.extend({
    _randRange: 0,
    _once: !1,
    _shatterZ: !1,
    ctor: function(t, e, i, n) {
        cc.GridAction.prototype.ctor.call(this),
        void 0 !== n && this.initWithDuration(t, e, i, n)
    },
    initWithDuration: function(t, e, i, n) {
        return !!cc.TiledGrid3DAction.prototype.initWithDuration.call(this, t, e) && (this._once = !1,
        this._randRange = i,
        this._shatterZ = n,
        !0)
    },
    update: function(t) {
        if (!1 === this._once) {
            t = this._gridSize;
            for (var e, i = this._randRange, n = cc.p(0, 0), r = 0; r < t.width; ++r)
                for (var c = 0; c < t.height; ++c)
                    n.x = r,
                    n.y = c,
                    e = this.originalTile(n),
                    e.bl.x += cc.rand() % (2 * i) - i,
                    e.br.x += cc.rand() % (2 * i) - i,
                    e.tl.x += cc.rand() % (2 * i) - i,
                    e.tr.x += cc.rand() % (2 * i) - i,
                    e.bl.y += cc.rand() % (2 * i) - i,
                    e.br.y += cc.rand() % (2 * i) - i,
                    e.tl.y += cc.rand() % (2 * i) - i,
                    e.tr.y += cc.rand() % (2 * i) - i,
                    this._shatterZ && (e.bl.z += cc.rand() % (2 * i) - i,
                    e.br.z += cc.rand() % (2 * i) - i,
                    e.tl.z += cc.rand() % (2 * i) - i,
                    e.tr.z += cc.rand() % (2 * i) - i),
                    this.setTile(n, e);
            this._once = !0
        }
    }
}),
cc.shatteredTiles3D = function(t, e, i, n) {
    return new cc.ShatteredTiles3D(t,e,i,n)
}
,
cc.ShatteredTiles3D.create = cc.shatteredTiles3D,
cc.Tile = function(t, e, i) {
    this.position = t || cc.p(0, 0),
    this.startPosition = e || cc.p(0, 0),
    this.delta = i || cc.p(0, 0)
}
,
cc.ShuffleTiles = cc.TiledGrid3DAction.extend({
    _seed: 0,
    _tilesCount: 0,
    _tilesOrder: null,
    _tiles: null,
    ctor: function(t, e, i) {
        cc.GridAction.prototype.ctor.call(this),
        this._tilesOrder = [],
        this._tiles = [],
        void 0 !== i && this.initWithDuration(t, e, i)
    },
    initWithDuration: function(t, e, i) {
        return !!cc.TiledGrid3DAction.prototype.initWithDuration.call(this, t, e) && (this._seed = i,
        this._tilesOrder.length = 0,
        this._tiles.length = 0,
        !0)
    },
    shuffle: function(t, e) {
        for (var i = e - 1; 0 <= i; i--) {
            var n = 0 | cc.rand() % (i + 1)
              , r = t[i];
            t[i] = t[n],
            t[n] = r
        }
    },
    getDelta: function(t) {
        var e = this._gridSize
          , i = t.width * e.height + t.height;
        return cc.size(this._tilesOrder[i] / e.height - t.width, this._tilesOrder[i] % e.height - t.height)
    },
    placeTile: function(t, e) {
        var i = this.originalTile(t)
          , n = this.target.grid.getStep()
          , r = e.position;
        i.bl.x += r.x * n.x,
        i.bl.y += r.y * n.y,
        i.br.x += r.x * n.x,
        i.br.y += r.y * n.y,
        i.tl.x += r.x * n.x,
        i.tl.y += r.y * n.y,
        i.tr.x += r.x * n.x,
        i.tr.y += r.y * n.y,
        this.setTile(t, i)
    },
    startWithTarget: function(t) {
        cc.TiledGrid3DAction.prototype.startWithTarget.call(this, t),
        t = this._gridSize,
        this._tilesCount = t.width * t.height;
        for (var e = this._tilesOrder, i = e.length = 0; i < this._tilesCount; ++i)
            e[i] = i;
        this.shuffle(e, this._tilesCount);
        for (var e = this._tiles, i = e.length = 0, n = cc.size(0, 0), r = 0; r < t.width; ++r)
            for (var c = 0; c < t.height; ++c)
                e[i] = new cc.Tile,
                e[i].position = cc.p(r, c),
                e[i].startPosition = cc.p(r, c),
                n.width = r,
                n.height = c,
                e[i].delta = this.getDelta(n),
                ++i
    },
    update: function(t) {
        for (var e, i = 0, n = this._gridSize, r = this._tiles, c = cc.p(0, 0), s = 0; s < n.width; ++s)
            for (var o = 0; o < n.height; ++o)
                c.x = s,
                c.y = o,
                e = r[i],
                e.position.x = e.delta.width * t,
                e.position.y = e.delta.height * t,
                this.placeTile(c, e),
                ++i
    }
}),
cc.shuffleTiles = function(t, e, i) {
    return new cc.ShuffleTiles(t,e,i)
}
,
cc.ShuffleTiles.create = cc.shuffleTiles,
cc.FadeOutTRTiles = cc.TiledGrid3DAction.extend({
    testFunc: function(t, e) {
        var i = this._gridSize.width * e
          , n = this._gridSize.height * e;
        return i === this._gridSize.width && n === this._gridSize.height ? 0 : 0 === i + n ? 1 : Math.pow((t.x + t.y) / (i + n), 6)
    },
    turnOnTile: function(t) {
        this.setTile(t, this.originalTile(t))
    },
    turnOffTile: function(t) {
        this.setTile(t, new cc.Quad3)
    },
    transformTile: function(t, e) {
        var i = this.originalTile(t)
          , n = this.target.grid.getStep();
        i.bl.x += n.x / 2 * (1 - e),
        i.bl.y += n.y / 2 * (1 - e),
        i.br.x -= n.x / 2 * (1 - e),
        i.br.y += n.y / 2 * (1 - e),
        i.tl.x += n.x / 2 * (1 - e),
        i.tl.y -= n.y / 2 * (1 - e),
        i.tr.x -= n.x / 2 * (1 - e),
        i.tr.y -= n.y / 2 * (1 - e),
        this.setTile(t, i)
    },
    update: function(t) {
        for (var e, i = this._gridSize, n = cc.p(0, 0), r = 0; r < i.width; ++r)
            for (var c = 0; c < i.height; ++c)
                n.x = r,
                n.y = c,
                e = this.testFunc(n, t),
                0 === e ? this.turnOffTile(n) : 1 > e ? this.transformTile(n, e) : this.turnOnTile(n)
    }
}),
cc.fadeOutTRTiles = function(t, e) {
    return new cc.FadeOutTRTiles(t,e)
}
,
cc.FadeOutTRTiles.create = cc.fadeOutTRTiles,
cc.FadeOutBLTiles = cc.FadeOutTRTiles.extend({
    testFunc: function(t, e) {
        var i = this._gridSize.width * (1 - e)
          , n = this._gridSize.height * (1 - e);
        return 0 === i + n ? 0 : 0 === t.x + t.y ? 1 : Math.pow((i + n) / (t.x + t.y), 6)
    }
}),
cc.fadeOutBLTiles = function(t, e) {
    return new cc.FadeOutBLTiles(t,e)
}
,
cc.FadeOutBLTiles.create = cc.fadeOutBLTiles,
cc.FadeOutUpTiles = cc.FadeOutTRTiles.extend({
    testFunc: function(t, e) {
        var i = this._gridSize.height * e;
        return i === this._gridSize.height ? 0 : 0 === i ? 1 : Math.pow(t.y / i, 6)
    },
    transformTile: function(t, e) {
        var i = this.originalTile(t)
          , n = this.target.grid.getStep();
        i.bl.y += n.y / 2 * (1 - e),
        i.br.y += n.y / 2 * (1 - e),
        i.tl.y -= n.y / 2 * (1 - e),
        i.tr.y -= n.y / 2 * (1 - e),
        this.setTile(t, i)
    }
}),
cc.fadeOutUpTiles = function(t, e) {
    return new cc.FadeOutUpTiles(t,e)
}
,
cc.FadeOutUpTiles.create = cc.fadeOutUpTiles,
cc.FadeOutDownTiles = cc.FadeOutUpTiles.extend({
    testFunc: function(t, e) {
        var i = this._gridSize.height * (1 - e);
        return 0 === i ? 0 : 0 === t.y ? 1 : Math.pow(i / t.y, 6)
    }
}),
cc.fadeOutDownTiles = function(t, e) {
    return new cc.FadeOutDownTiles(t,e)
}
,
cc.FadeOutDownTiles.create = cc.fadeOutDownTiles,
cc.TurnOffTiles = cc.TiledGrid3DAction.extend({
    _seed: null,
    _tilesCount: 0,
    _tilesOrder: null,
    ctor: function(t, e, i) {
        cc.GridAction.prototype.ctor.call(this),
        this._tilesOrder = [],
        void 0 !== e && this.initWithDuration(t, e, i)
    },
    initWithDuration: function(t, e, i) {
        return !!cc.TiledGrid3DAction.prototype.initWithDuration.call(this, t, e) && (this._seed = i || 0,
        this._tilesOrder.length = 0,
        !0)
    },
    shuffle: function(t, e) {
        for (var i = e - 1; 0 <= i; i--) {
            var n = 0 | cc.rand() % (i + 1)
              , r = t[i];
            t[i] = t[n],
            t[n] = r
        }
    },
    turnOnTile: function(t) {
        this.setTile(t, this.originalTile(t))
    },
    turnOffTile: function(t) {
        this.setTile(t, new cc.Quad3)
    },
    startWithTarget: function(t) {
        cc.TiledGrid3DAction.prototype.startWithTarget.call(this, t),
        this._tilesCount = this._gridSize.width * this._gridSize.height,
        t = this._tilesOrder;
        for (var e = t.length = 0; e < this._tilesCount; ++e)
            t[e] = e;
        this.shuffle(t, this._tilesCount)
    },
    update: function(t) {
        t = 0 | t * this._tilesCount;
        for (var e, i = this._gridSize, n = cc.p(0, 0), r = this._tilesOrder, c = 0; c < this._tilesCount; c++)
            e = r[c],
            n.x = 0 | e / i.height,
            n.y = e % (0 | i.height),
            c < t ? this.turnOffTile(n) : this.turnOnTile(n)
    }
}),
cc.turnOffTiles = function(t, e, i) {
    return new cc.TurnOffTiles(t,e,i)
}
,
cc.TurnOffTiles.create = cc.turnOffTiles,
cc.WavesTiles3D = cc.TiledGrid3DAction.extend({
    _waves: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    ctor: function(t, e, i, n) {
        cc.GridAction.prototype.ctor.call(this),
        void 0 !== n && this.initWithDuration(t, e, i, n)
    },
    getAmplitude: function() {
        return this._amplitude
    },
    setAmplitude: function(t) {
        this._amplitude = t
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate
    },
    setAmplitudeRate: function(t) {
        this._amplitudeRate = t
    },
    initWithDuration: function(t, e, i, n) {
        return !!cc.TiledGrid3DAction.prototype.initWithDuration.call(this, t, e) && (this._waves = i,
        this._amplitude = n,
        this._amplitudeRate = 1,
        !0)
    },
    update: function(t) {
        for (var e, i = this._gridSize, n = this._waves, r = this._amplitude, c = this._amplitudeRate, s = cc.p(0, 0), o = 0; o < i.width; o++)
            for (var a = 0; a < i.height; a++)
                s.x = o,
                s.y = a,
                e = this.originalTile(s),
                e.bl.z = Math.sin(t * Math.PI * n * 2 + .01 * (e.bl.y + e.bl.x)) * r * c,
                e.br.z = e.bl.z,
                e.tl.z = e.bl.z,
                e.tr.z = e.bl.z,
                this.setTile(s, e)
    }
}),
cc.wavesTiles3D = function(t, e, i, n) {
    return new cc.WavesTiles3D(t,e,i,n)
}
,
cc.WavesTiles3D.create = cc.wavesTiles3D,
cc.JumpTiles3D = cc.TiledGrid3DAction.extend({
    _jumps: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    ctor: function(t, e, i, n) {
        cc.GridAction.prototype.ctor.call(this),
        void 0 !== n && this.initWithDuration(t, e, i, n)
    },
    getAmplitude: function() {
        return this._amplitude
    },
    setAmplitude: function(t) {
        this._amplitude = t
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate
    },
    setAmplitudeRate: function(t) {
        this._amplitudeRate = t
    },
    initWithDuration: function(t, e, i, n) {
        return !!cc.TiledGrid3DAction.prototype.initWithDuration.call(this, t, e) && (this._jumps = i,
        this._amplitude = n,
        this._amplitudeRate = 1,
        !0)
    },
    update: function(t) {
        var e = Math.sin(Math.PI * t * this._jumps * 2) * this._amplitude * this._amplitudeRate;
        t = Math.sin(Math.PI * (t * this._jumps * 2 + 1)) * this._amplitude * this._amplitudeRate;
        for (var i, n = this._gridSize, r = this.target.grid, c = cc.p(0, 0), s = 0; s < n.width; s++)
            for (var o = 0; o < n.height; o++)
                c.x = s,
                c.y = o,
                i = r.originalTile(c),
                0 === (s + o) % 2 ? (i.bl.z += e,
                i.br.z += e,
                i.tl.z += e,
                i.tr.z += e) : (i.bl.z += t,
                i.br.z += t,
                i.tl.z += t,
                i.tr.z += t),
                r.setTile(c, i)
    }
}),
cc.jumpTiles3D = function(t, e, i, n) {
    return new cc.JumpTiles3D(t,e,i,n)
}
,
cc.JumpTiles3D.create = cc.jumpTiles3D,
cc.SplitRows = cc.TiledGrid3DAction.extend({
    _rows: 0,
    _winSize: null,
    ctor: function(t, e) {
        cc.GridAction.prototype.ctor.call(this),
        void 0 !== e && this.initWithDuration(t, e)
    },
    initWithDuration: function(t, e) {
        return this._rows = e,
        cc.TiledGrid3DAction.prototype.initWithDuration.call(this, t, cc.size(1, e))
    },
    update: function(t) {
        for (var e, i, n = this._gridSize, r = this._winSize.width, c = cc.p(0, 0), s = 0; s < n.height; ++s)
            c.y = s,
            e = this.originalTile(c),
            i = 1,
            0 === s % 2 && (i = -1),
            e.bl.x += i * r * t,
            e.br.x += i * r * t,
            e.tl.x += i * r * t,
            e.tr.x += i * r * t,
            this.setTile(c, e)
    },
    startWithTarget: function(t) {
        cc.TiledGrid3DAction.prototype.startWithTarget.call(this, t),
        this._winSize = cc.director.getWinSizeInPixels()
    }
}),
cc.splitRows = function(t, e) {
    return new cc.SplitRows(t,e)
}
,
cc.SplitRows.create = cc.splitRows,
cc.SplitCols = cc.TiledGrid3DAction.extend({
    _cols: 0,
    _winSize: null,
    ctor: function(t, e) {
        cc.GridAction.prototype.ctor.call(this),
        void 0 !== e && this.initWithDuration(t, e)
    },
    initWithDuration: function(t, e) {
        return this._cols = e,
        cc.TiledGrid3DAction.prototype.initWithDuration.call(this, t, cc.size(e, 1))
    },
    update: function(t) {
        for (var e, i, n = this._gridSize.width, r = this._winSize.height, c = cc.p(0, 0), s = 0; s < n; ++s)
            c.x = s,
            e = this.originalTile(c),
            i = 1,
            0 === s % 2 && (i = -1),
            e.bl.y += i * r * t,
            e.br.y += i * r * t,
            e.tl.y += i * r * t,
            e.tr.y += i * r * t,
            this.setTile(c, e);
        cc.renderer.childrenOrderDirty = !0
    },
    startWithTarget: function(t) {
        cc.TiledGrid3DAction.prototype.startWithTarget.call(this, t),
        this._winSize = cc.director.getWinSizeInPixels()
    }
}),
cc.splitCols = function(t, e) {
    return new cc.SplitCols(t,e)
}
,
cc.SplitCols.create = cc.splitCols,
cc.PageTurn3D = cc.Grid3DAction.extend({
    getGrid: function() {
        var t = new cc.Grid3D(this._gridSize,(void 0),(void 0),this._gridNodeTarget.getGridRect());
        return t.setNeedDepthTestForBlit(!0),
        t
    },
    clone: function() {
        var t = new cc.PageTurn3D;
        return t.initWithDuration(this._duration, this._gridSize),
        t
    },
    update: function(t) {
        var e = Math.max(0, t - .25)
          , e = -100 - e * e * 500
          , i = Math.sqrt(t)
          , n = .5 < i ? Math.PI / 2 * i : Math.PI / 2 * (1 - i);
        t = (2 - t) * Math.PI;
        for (var i = Math.sin(n), n = Math.cos(n), r = this._gridSize, c = cc.p(0, 0), s = 0; s <= r.width; ++s)
            for (var o = 0; o <= r.height; ++o) {
                c.x = s,
                c.y = o;
                var a = this.getOriginalVertex(c);
                a.x -= this.getGridRect().x;
                var h = Math.sqrt(a.x * a.x + (a.y - e) * (a.y - e))
                  , l = h * i
                  , u = Math.asin(a.x / h) / i
                  , d = Math.cos(u);
                a.x = u <= Math.PI ? l * Math.sin(u) : 0,
                a.y = h + e - l * (1 - d) * i,
                a.z = l * (1 - d) * n,
                a.x = a.z * Math.sin(t) + a.x * Math.cos(t),
                a.z = a.z * Math.cos(t) - a.x * Math.cos(t),
                a.z /= 7,
                .5 > a.z && (a.z = .5),
                a.x += this.getGridRect().x,
                this.setVertex(c, a)
            }
    }
}),
cc.pageTurn3D = function(t, e) {
    return new cc.PageTurn3D(t,e)
}
,
cc.PageTurn3D.create = cc.pageTurn3D,
cc.ProgressTimer = cc.Node.extend({
    _type: null,
    _percentage: 0,
    _sprite: null,
    _midPoint: null,
    _barChangeRate: null,
    _reverseDirection: !1,
    _className: "ProgressTimer",
    ctor: function(t) {
        cc.Node.prototype.ctor.call(this),
        this._type = cc.ProgressTimer.TYPE_RADIAL,
        this._percentage = 0,
        this._midPoint = cc.p(0, 0),
        this._barChangeRate = cc.p(0, 0),
        this._reverseDirection = !1,
        this._sprite = null,
        t && this.initWithSprite(t)
    },
    getMidpoint: function() {
        return cc.p(this._midPoint.x, this._midPoint.y)
    },
    setMidpoint: function(t) {
        this._midPoint = cc.pClamp(t, cc.p(0, 0), cc.p(1, 1))
    },
    getBarChangeRate: function() {
        return cc.p(this._barChangeRate.x, this._barChangeRate.y)
    },
    setBarChangeRate: function(t) {
        this._barChangeRate = cc.pClamp(t, cc.p(0, 0), cc.p(1, 1))
    },
    getType: function() {
        return this._type
    },
    getPercentage: function() {
        return this._percentage
    },
    getSprite: function() {
        return this._sprite
    },
    setPercentage: function(t) {
        this._percentage !== t && (this._percentage = cc.clampf(t, 0, 100),
        this._renderCmd._updateProgress())
    },
    setOpacityModifyRGB: function(t) {},
    isOpacityModifyRGB: function() {
        return !1
    },
    isReverseDirection: function() {
        return this._reverseDirection
    },
    setColor: function(t) {
        this._sprite.color = t,
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty)
    },
    setOpacity: function(t) {
        this._sprite.opacity = t,
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
    },
    getColor: function() {
        return this._sprite.color
    },
    getOpacity: function() {
        return this._sprite.opacity
    },
    setReverseProgress: function(t) {
        this._reverseDirection !== t && (this._reverseDirection = t,
        this._renderCmd.releaseData())
    },
    setSprite: function(t) {
        this._sprite !== t && ((this._sprite = t) ? this.setContentSize(t.width, t.height) : this.setContentSize(0, 0),
        this._renderCmd.releaseData())
    },
    setType: function(t) {
        t !== this._type && (this._type = t,
        this._renderCmd.releaseData())
    },
    setReverseDirection: function(t) {
        this._reverseDirection !== t && (this._reverseDirection = t,
        this._renderCmd.releaseData())
    },
    initWithSprite: function(t) {
        return this.percentage = 0,
        this.setAnchorPoint(.5, .5),
        this._type = cc.ProgressTimer.TYPE_RADIAL,
        this._reverseDirection = !1,
        this.midPoint = cc.p(.5, .5),
        this.barChangeRate = cc.p(1, 1),
        this.setSprite(t),
        this._renderCmd.initCmd(),
        !0
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.ProgressTimer.CanvasRenderCmd(this) : new cc.ProgressTimer.WebGLRenderCmd(this)
    }
}),
_p = cc.ProgressTimer.prototype,
cc.defineGetterSetter(_p, "midPoint", _p.getMidpoint, _p.setMidpoint),
cc.defineGetterSetter(_p, "barChangeRate", _p.getBarChangeRate, _p.setBarChangeRate),
cc.defineGetterSetter(_p, "type", _p.getType, _p.setType),
cc.defineGetterSetter(_p, "percentage", _p.getPercentage, _p.setPercentage),
cc.defineGetterSetter(_p, "sprite", _p.getSprite, _p.setSprite),
cc.defineGetterSetter(_p, "reverseDir", _p.isReverseDirection, _p.setReverseDirection),
cc.ProgressTimer.create = function(t) {
    return new cc.ProgressTimer(t)
}
,
cc.ProgressTimer.TEXTURE_COORDS_COUNT = 4,
cc.ProgressTimer.TEXTURE_COORDS = 75,
cc.ProgressTimer.TYPE_RADIAL = 0,
cc.ProgressTimer.TYPE_BAR = 1,
cc.ProgressTo = cc.ActionInterval.extend({
    _to: 0,
    _from: 0,
    ctor: function(t, e) {
        cc.ActionInterval.prototype.ctor.call(this),
        this._from = this._to = 0,
        void 0 !== e && this.initWithDuration(t, e)
    },
    initWithDuration: function(t, e) {
        return !!cc.ActionInterval.prototype.initWithDuration.call(this, t) && (this._to = e,
        !0)
    },
    clone: function() {
        var t = new cc.ProgressTo;
        return t.initWithDuration(this._duration, this._to),
        t
    },
    reverse: function() {
        return cc.log("cc.ProgressTo.reverse(): reverse hasn't been supported."),
        null
    },
    startWithTarget: function(t) {
        cc.ActionInterval.prototype.startWithTarget.call(this, t),
        this._from = t.percentage
    },
    update: function(t) {
        this.target instanceof cc.ProgressTimer && (this.target.percentage = this._from + (this._to - this._from) * t)
    }
}),
cc.progressTo = function(t, e) {
    return new cc.ProgressTo(t,e)
}
,
cc.ProgressTo.create = cc.progressTo,
cc.ProgressFromTo = cc.ActionInterval.extend({
    _to: 0,
    _from: 0,
    ctor: function(t, e, i) {
        cc.ActionInterval.prototype.ctor.call(this),
        this._from = this._to = 0,
        void 0 !== i && this.initWithDuration(t, e, i)
    },
    initWithDuration: function(t, e, i) {
        return !!cc.ActionInterval.prototype.initWithDuration.call(this, t) && (this._to = i,
        this._from = e,
        !0)
    },
    clone: function() {
        var t = new cc.ProgressFromTo;
        return t.initWithDuration(this._duration, this._from, this._to),
        t
    },
    reverse: function() {
        return cc.progressFromTo(this._duration, this._to, this._from)
    },
    startWithTarget: function(t) {
        cc.ActionInterval.prototype.startWithTarget.call(this, t)
    },
    update: function(t) {
        this.target instanceof cc.ProgressTimer && (this.target.percentage = this._from + (this._to - this._from) * t)
    }
}),
cc.progressFromTo = function(t, e, i) {
    return new cc.ProgressFromTo(t,e,i)
}
,
cc.ProgressFromTo.create = cc.progressFromTo,
function() {
    cc.ProgressTimer.CanvasRenderCmd = function(t) {
        cc.Node.CanvasRenderCmd.call(this, t),
        this._needDraw = !0,
        this._PI180 = Math.PI / 180,
        this._barRect = cc.rect(0, 0, 0, 0),
        this._origin = cc.p(0, 0),
        this._radius = 0,
        this._endAngle = this._startAngle = 270,
        this._counterClockWise = !1
    }
    ;
    var t = cc.ProgressTimer.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    t.constructor = cc.ProgressTimer.CanvasRenderCmd,
    t.rendering = function(t, e, i) {
        t = t || cc._renderContext;
        var n = t.getContext()
          , r = this._node
          , c = r._sprite
          , s = c._renderCmd._textureCoord
          , o = c._renderCmd._displayedOpacity / 255;
        if (0 !== s.width && 0 !== s.height && c._texture && s.validRect && 0 !== o) {
            t.setTransform(this._worldTransform, e, i),
            t.setCompositeOperation(c._blendFuncStr),
            t.setGlobalAlpha(o);
            var a = c._rect
              , h = c._offsetPosition
              , o = h.x
              , l = -h.y - a.height
              , u = a.width
              , a = a.height;
            t.save(),
            c._flippedX && (o = -o - u,
            n.scale(-1, 1)),
            c._flippedY && (l = h.y,
            n.scale(1, -1)),
            r._type === cc.ProgressTimer.TYPE_BAR ? (r = this._barRect,
            n.beginPath(),
            n.rect(r.x * e, r.y * i, r.width * e, r.height * i),
            n.clip(),
            n.closePath()) : r._type === cc.ProgressTimer.TYPE_RADIAL && (r = this._origin.x * e,
            h = this._origin.y * i,
            n.beginPath(),
            n.arc(r, h, this._radius * i, this._PI180 * this._startAngle, this._PI180 * this._endAngle, this._counterClockWise),
            n.lineTo(r, h),
            n.clip(),
            n.closePath()),
            r = c._texture.getHtmlElementObj(),
            c._renderCmd._colorized ? n.drawImage(r, 0, 0, s.width, s.height, o * e, l * i, u * e, a * i) : n.drawImage(r, s.renderX, s.renderY, s.width, s.height, o * e, l * i, u * e, a * i),
            t.restore(),
            cc.g_NumberOfDraws++
        }
    }
    ,
    t.releaseData = function() {}
    ,
    t.initCmd = function() {}
    ,
    t._updateProgress = function() {
        var t = this._node
          , e = t._sprite
          , i = e.width
          , n = e.height
          , r = t._midPoint;
        if (t._type === cc.ProgressTimer.TYPE_RADIAL) {
            this._radius = Math.round(Math.sqrt(i * i + n * n));
            var c, s = !1, o = this._origin;
            o.x = i * r.x,
            o.y = -n * r.y,
            t._reverseDirection ? (c = 270,
            r = 270 - 3.6 * t._percentage) : (r = -90,
            c = -90 + 3.6 * t._percentage),
            e._flippedX && (o.x -= 2 * i * t._midPoint.x,
            r = -r - 180,
            c = -c - 180,
            s = !s),
            e._flippedY && (o.y += 2 * n * t._midPoint.y,
            s = !s,
            r = -r,
            c = -c),
            this._startAngle = r,
            this._endAngle = c,
            this._counterClockWise = s
        } else
            s = t._barChangeRate,
            o = t._percentage / 100,
            t = this._barRect,
            s = cc.size(i * (1 - s.x), n * (1 - s.y)),
            o = cc.size((i - s.width) * o, (n - s.height) * o),
            s = cc.size(s.width + o.width, s.height + o.height),
            c = cc.p(i * r.x, n * r.y),
            o = c.x - s.width / 2,
            .5 < r.x && s.width / 2 >= i - c.x && (o = i - s.width),
            i = c.y - s.height / 2,
            .5 < r.y && s.height / 2 >= n - c.y && (i = n - s.height),
            t.x = 0,
            n = 1,
            e._flippedX && (t.x -= s.width,
            n = -1),
            0 < o && (t.x += o * n),
            t.y = 0,
            n = 1,
            e._flippedY && (t.y += s.height,
            n = -1),
            0 < i && (t.y -= i * n),
            t.width = s.width,
            t.height = -s.height
    }
    ,
    t._updateColor = function() {}
    ,
    t._syncStatus = function(t) {
        var e = this._node;
        if (e._sprite) {
            var i = cc.Node._dirtyFlags
              , n = this._dirtyFlag
              , r = t ? t._node : null;
            r && r._cascadeColorEnabled && t._dirtyFlag & i.colorDirty && (n |= i.colorDirty),
            r && r._cascadeOpacityEnabled && t._dirtyFlag & i.opacityDirty && (n |= i.opacityDirty),
            t && t._dirtyFlag & i.transformDirty && (n |= i.transformDirty),
            this._dirtyFlag = n;
            var e = e._sprite._renderCmd
              , c = e._dirtyFlag
              , r = c & i.colorDirty
              , c = c & i.opacityDirty;
            r && e._syncDisplayColor(),
            c && e._syncDisplayOpacity(),
            (r || c) && e._updateColor(),
            n & i.transformDirty && this.transform(t),
            n & i.orderDirty && (this._dirtyFlag ^= this._dirtyFlag & i.orderDirty)
        }
    }
    ,
    t.updateStatus = function() {
        var t = this._node;
        if (t._sprite) {
            var e = cc.Node._dirtyFlags
              , i = this._dirtyFlag
              , t = t._sprite._renderCmd
              , n = t._dirtyFlag
              , r = n & e.colorDirty
              , n = n & e.opacityDirty;
            r && t._updateDisplayColor(),
            n && t._updateDisplayOpacity(),
            (r || n) && t._updateColor(),
            i & e.transformDirty && this.transform(this.getParentRenderCmd(), !0),
            this._dirtyFlag = 0
        }
    }
}(),
function() {
    cc.ProgressTimer.WebGLRenderCmd = function(t) {
        cc.Node.WebGLRenderCmd.call(this, t),
        this._needDraw = !0,
        this._vertexWebGLBuffer = cc._renderContext.createBuffer(),
        this._vertexDataCount = 0,
        this._vertexArrayBuffer = this._vertexData = null,
        this._vertexDataDirty = !1
    }
    ;
    var t = cc.ProgressTimer.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    t.constructor = cc.ProgressTimer.WebGLRenderCmd,
    t.rendering = function(t) {
        var e = this._node;
        if (t = t || cc._renderContext,
        this._vertexData && e._sprite) {
            this._shaderProgram.use(),
            this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
            var i = e._sprite._blendFunc;
            cc.glBlendFunc(i.src, i.dst),
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX),
            cc.glBindTexture2D(e._sprite.texture),
            t.bindBuffer(t.ARRAY_BUFFER, this._vertexWebGLBuffer),
            this._vertexDataDirty && (t.bufferData(t.ARRAY_BUFFER, this._vertexArrayBuffer, t.DYNAMIC_DRAW),
            this._vertexDataDirty = !1),
            i = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT,
            t.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, t.FLOAT, !1, i, 0),
            t.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, t.UNSIGNED_BYTE, !0, i, 8),
            t.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, t.FLOAT, !1, i, 12),
            e._type === cc.ProgressTimer.TYPE_RADIAL ? t.drawArrays(t.TRIANGLE_FAN, 0, this._vertexDataCount) : e._type === cc.ProgressTimer.TYPE_BAR && (e._reverseDirection ? (t.drawArrays(t.TRIANGLE_STRIP, 0, this._vertexDataCount / 2),
            t.drawArrays(t.TRIANGLE_STRIP, 4, this._vertexDataCount / 2),
            cc.g_NumberOfDraws++) : t.drawArrays(t.TRIANGLE_STRIP, 0, this._vertexDataCount)),
            cc.g_NumberOfDraws++
        }
    }
    ,
    t._syncStatus = function(t) {
        var e = this._node;
        if (e._sprite) {
            var i = cc.Node._dirtyFlags
              , n = this._dirtyFlag
              , r = t ? t._node : null;
            r && r._cascadeColorEnabled && t._dirtyFlag & i.colorDirty && (n |= i.colorDirty),
            r && r._cascadeOpacityEnabled && t._dirtyFlag & i.opacityDirty && (n |= i.opacityDirty),
            t && t._dirtyFlag & i.transformDirty && (n |= i.transformDirty),
            this._dirtyFlag = n,
            e = e._sprite._renderCmd,
            r = e._dirtyFlag,
            n = r & i.colorDirty,
            i = r & i.opacityDirty,
            n && e._syncDisplayColor(),
            i && e._syncDisplayOpacity(),
            (n || i) && (e._updateColor(),
            this._updateColor()),
            this.transform(t),
            e._dirtyFlag = 0
        }
    }
    ,
    t.updateStatus = function() {
        var t = this._node;
        if (t._sprite) {
            var e = cc.Node._dirtyFlags
              , i = this._dirtyFlag
              , t = t._sprite._renderCmd
              , n = t._dirtyFlag
              , r = n & e.colorDirty
              , n = n & e.opacityDirty;
            r && (t._updateDisplayColor(),
            this._dirtyFlag ^= this._dirtyFlag & e.colorDirty),
            n && (t._updateDisplayOpacity(),
            this._dirtyFlag ^= this._dirtyFlag & e.opacityDirty),
            (r || n) && (t._updateColor(),
            this._updateColor()),
            i & e.transformDirty && this.transform(this.getParentRenderCmd(), !0),
            i & e.orderDirty && (this._dirtyFlag ^= this._dirtyFlag & e.orderDirty)
        }
    }
    ,
    t.releaseData = function() {
        this._vertexData && (this._vertexArrayBuffer = this._vertexData = null,
        this._vertexDataCount = 0)
    }
    ,
    t.initCmd = function() {
        this._vertexArrayBuffer = this._vertexData = null,
        this._vertexDataCount = 0,
        this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)
    }
    ,
    t._updateProgress = function() {
        var t = this._node._type;
        t === cc.ProgressTimer.TYPE_RADIAL ? this._updateRadial() : t === cc.ProgressTimer.TYPE_BAR && this._updateBar(),
        this._vertexDataDirty = !0
    }
    ,
    t._updateBar = function() {
        var t = this._node;
        if (t._sprite) {
            var e, i = t._percentage / 100;
            if (e = t._barChangeRate,
            e = cc.pMult(cc.p(1 - e.x + i * e.x, 1 - e.y + i * e.y), .5),
            i = cc.pSub(t._midPoint, e),
            t = cc.pAdd(t._midPoint, e),
            0 > i.x && (t.x += -i.x,
            i.x = 0),
            1 < t.x && (i.x -= t.x - 1,
            t.x = 1),
            0 > i.y && (t.y += -i.y,
            i.y = 0),
            1 < t.y && (i.y -= t.y - 1,
            t.y = 1),
            this._reverseDirection) {
                if (!this._vertexData) {
                    this._vertexDataCount = 8;
                    var n = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
                    this._vertexArrayBuffer = new ArrayBuffer(8 * n);
                    var r = [];
                    for (e = 0; 8 > e; e++)
                        r[e] = new cc.V2F_C4B_T2F(null,null,null,this._vertexArrayBuffer,e * n);
                    r[0].texCoords = this._textureCoordFromAlphaPoint(cc.p(0, 1)),
                    r[0].vertices = this._vertexFromAlphaPoint(cc.p(0, 1)),
                    r[1].texCoords = this._textureCoordFromAlphaPoint(cc.p(0, 0)),
                    r[1].vertices = this._vertexFromAlphaPoint(cc.p(0, 0)),
                    r[6].texCoords = this._textureCoordFromAlphaPoint(cc.p(1, 1)),
                    r[6].vertices = this._vertexFromAlphaPoint(cc.p(1, 1)),
                    r[7].texCoords = this._textureCoordFromAlphaPoint(cc.p(1, 0)),
                    r[7].vertices = this._vertexFromAlphaPoint(cc.p(1, 0)),
                    this._vertexData = r
                }
                e = this._vertexData,
                e[2].texCoords = this._textureCoordFromAlphaPoint(cc.p(i.x, t.y)),
                e[2].vertices = this._vertexFromAlphaPoint(cc.p(i.x, t.y)),
                e[3].texCoords = this._textureCoordFromAlphaPoint(cc.p(i.x, i.y)),
                e[3].vertices = this._vertexFromAlphaPoint(cc.p(i.x, i.y)),
                e[4].texCoords = this._textureCoordFromAlphaPoint(cc.p(t.x, t.y)),
                e[4].vertices = this._vertexFromAlphaPoint(cc.p(t.x, t.y)),
                e[5].texCoords = this._textureCoordFromAlphaPoint(cc.p(t.x, i.y)),
                e[5].vertices = this._vertexFromAlphaPoint(cc.p(t.x, i.y))
            } else {
                if (!this._vertexData)
                    for (this._vertexDataCount = 4,
                    n = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT,
                    this._vertexArrayBuffer = new ArrayBuffer(4 * n),
                    this._vertexData = [],
                    e = 0; 4 > e; e++)
                        this._vertexData[e] = new cc.V2F_C4B_T2F(null,null,null,this._vertexArrayBuffer,e * n);
                e = this._vertexData,
                e[0].texCoords = this._textureCoordFromAlphaPoint(cc.p(i.x, t.y)),
                e[0].vertices = this._vertexFromAlphaPoint(cc.p(i.x, t.y)),
                e[1].texCoords = this._textureCoordFromAlphaPoint(cc.p(i.x, i.y)),
                e[1].vertices = this._vertexFromAlphaPoint(cc.p(i.x, i.y)),
                e[2].texCoords = this._textureCoordFromAlphaPoint(cc.p(t.x, t.y)),
                e[2].vertices = this._vertexFromAlphaPoint(cc.p(t.x, t.y)),
                e[3].texCoords = this._textureCoordFromAlphaPoint(cc.p(t.x, i.y)),
                e[3].vertices = this._vertexFromAlphaPoint(cc.p(t.x, i.y))
            }
            this._updateColor()
        }
    }
    ,
    t._updateRadial = function() {
        var t = this._node;
        if (t._sprite) {
            var e, i = t._midPoint;
            e = t._percentage / 100;
            var n = 2 * cc.PI * (t._reverseDirection ? e : 1 - e)
              , t = cc.p(i.x, 1)
              , r = cc.pRotateByAngle(t, i, n)
              , n = 0;
            if (0 === e)
                r = t,
                n = 0;
            else if (1 === e)
                r = t,
                n = 4;
            else {
                var c = cc.FLT_MAX
                  , s = cc.ProgressTimer.TEXTURE_COORDS_COUNT;
                for (e = 0; e <= s; ++e) {
                    var o = (e + (s - 1)) % s
                      , a = this._boundaryTexCoord(e % s)
                      , o = this._boundaryTexCoord(o);
                    0 === e ? o = cc.pLerp(a, o, 1 - i.x) : 4 === e && (a = cc.pLerp(a, o, 1 - i.x));
                    var h = cc.p(0, 0);
                    cc.pLineIntersect(a, o, i, r, h) && (0 !== e && 4 !== e || 0 <= h.x && 1 >= h.x) && 0 <= h.y && h.y < c && (c = h.y,
                    n = e)
                }
                r = cc.pAdd(i, cc.pMult(cc.pSub(r, i), c))
            }
            if (c = !0,
            this._vertexDataCount !== n + 3 && (c = !1,
            this._vertexArrayBuffer = this._vertexData = null,
            this._vertexDataCount = 0),
            !this._vertexData) {
                for (s = this._vertexDataCount = n + 3,
                a = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT,
                this._vertexArrayBuffer = new ArrayBuffer(s * a),
                o = [],
                e = 0; e < s; e++)
                    o[e] = new cc.V2F_C4B_T2F(null,null,null,this._vertexArrayBuffer,e * a);
                if (this._vertexData = o,
                !this._vertexData)
                    return void cc.log("cc.ProgressTimer._updateRadial() : Not enough memory")
            }
            if (this._updateColor(),
            s = this._vertexData,
            !c)
                for (s[0].texCoords = this._textureCoordFromAlphaPoint(i),
                s[0].vertices = this._vertexFromAlphaPoint(i),
                s[1].texCoords = this._textureCoordFromAlphaPoint(t),
                s[1].vertices = this._vertexFromAlphaPoint(t),
                e = 0; e < n; e++)
                    i = this._boundaryTexCoord(e),
                    s[e + 2].texCoords = this._textureCoordFromAlphaPoint(i),
                    s[e + 2].vertices = this._vertexFromAlphaPoint(i);
            s[this._vertexDataCount - 1].texCoords = this._textureCoordFromAlphaPoint(r),
            s[this._vertexDataCount - 1].vertices = this._vertexFromAlphaPoint(r)
        }
    }
    ,
    t._boundaryTexCoord = function(t) {
        if (t < cc.ProgressTimer.TEXTURE_COORDS_COUNT) {
            var e = cc.ProgressTimer.TEXTURE_COORDS;
            return this._node._reverseDirection ? cc.p(e >> 7 - (t << 1) & 1, e >> 7 - ((t << 1) + 1) & 1) : cc.p(e >> (t << 1) + 1 & 1, e >> (t << 1) & 1)
        }
        return cc.p(0, 0)
    }
    ,
    t._textureCoordFromAlphaPoint = function(t) {
        var e = this._node._sprite;
        if (!e)
            return {
                u: 0,
                v: 0
            };
        var i = e.quad
          , n = cc.p(i.bl.texCoords.u, i.bl.texCoords.v)
          , i = cc.p(i.tr.texCoords.u, i.tr.texCoords.v);
        return e.textureRectRotated && (e = t.x,
        t.x = t.y,
        t.y = e),
        {
            u: n.x * (1 - t.x) + i.x * t.x,
            v: n.y * (1 - t.y) + i.y * t.y
        }
    }
    ,
    t._vertexFromAlphaPoint = function(t) {
        var e = this._node._sprite;
        if (!e)
            return {
                x: 0,
                y: 0
            };
        var i = e.quad
          , e = cc.p(i.bl.vertices.x, i.bl.vertices.y)
          , i = cc.p(i.tr.vertices.x, i.tr.vertices.y);
        return {
            x: e.x * (1 - t.x) + i.x * t.x,
            y: e.y * (1 - t.y) + i.y * t.y
        }
    }
    ,
    t._updateColor = function() {
        var t = this._node;
        if (t._sprite && this._vertexData) {
            for (var t = t._sprite.quad.tl.colors, e = this._vertexData, i = 0, n = this._vertexDataCount; i < n; ++i)
                e[i].colors = t;
            this._vertexDataDirty = !0
        }
    }
}(),
cc.SCENE_FADE = 4208917214,
cc.TRANSITION_ORIENTATION_LEFT_OVER = 0,
cc.TRANSITION_ORIENTATION_RIGHT_OVER = 1,
cc.TRANSITION_ORIENTATION_UP_OVER = 0,
cc.TRANSITION_ORIENTATION_DOWN_OVER = 1,
cc.TransitionScene = cc.Scene.extend({
    _inScene: null,
    _outScene: null,
    _duration: null,
    _isInSceneOnTop: !1,
    _isSendCleanupToScene: !1,
    _className: "TransitionScene",
    ctor: function(t, e) {
        cc.Scene.prototype.ctor.call(this),
        void 0 !== t && void 0 !== e && this.initWithDuration(t, e)
    },
    _setNewScene: function(t) {
        this.unschedule(this._setNewScene),
        t = cc.director,
        this._isSendCleanupToScene = t.isSendCleanupToScene(),
        t.runScene(this._inScene),
        cc.eventManager.setEnabled(!0),
        this._outScene.visible = !0
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !0
    },
    visit: function() {
        this._isInSceneOnTop ? (this._outScene.visit(),
        this._inScene.visit()) : (this._inScene.visit(),
        this._outScene.visit()),
        cc.Node.prototype.visit.call(this)
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this),
        cc.eventManager.setEnabled(!1),
        this._outScene.onExitTransitionDidStart(),
        this._inScene.onEnter()
    },
    onExit: function() {
        cc.Node.prototype.onExit.call(this),
        cc.eventManager.setEnabled(!0),
        this._outScene.onExit(),
        this._inScene.onEnterTransitionDidFinish()
    },
    cleanup: function() {
        cc.Node.prototype.cleanup.call(this),
        this._isSendCleanupToScene && this._outScene.cleanup()
    },
    initWithDuration: function(t, e) {
        if (!e)
            throw Error("cc.TransitionScene.initWithDuration(): Argument scene must be non-nil");
        if (this.init()) {
            if (this._duration = t,
            this.attr({
                x: 0,
                y: 0,
                anchorX: 0,
                anchorY: 0
            }),
            this._inScene = e,
            this._outScene = cc.director.getRunningScene(),
            this._outScene || (this._outScene = new cc.Scene,
            this._outScene.init()),
            this._inScene === this._outScene)
                throw Error("cc.TransitionScene.initWithDuration(): Incoming scene must be different from the outgoing scene");
            return this._sceneOrder(),
            !0
        }
        return !1
    },
    finish: function() {
        this._inScene.attr({
            visible: !0,
            x: 0,
            y: 0,
            scale: 1,
            rotation: 0
        }),
        cc._renderType === cc.game.RENDER_TYPE_WEBGL && this._inScene.getCamera().restore(),
        this._outScene.attr({
            visible: !1,
            x: 0,
            y: 0,
            scale: 1,
            rotation: 0
        }),
        cc._renderType === cc.game.RENDER_TYPE_WEBGL && this._outScene.getCamera().restore(),
        this.schedule(this._setNewScene, 0)
    },
    hideOutShowIn: function() {
        this._inScene.visible = !0,
        this._outScene.visible = !1
    }
}),
cc.TransitionScene.create = function(t, e) {
    return new cc.TransitionScene(t,e)
}
,
cc.TransitionSceneOriented = cc.TransitionScene.extend({
    _orientation: 0,
    ctor: function(t, e, i) {
        cc.TransitionScene.prototype.ctor.call(this),
        void 0 != i && this.initWithDuration(t, e, i)
    },
    initWithDuration: function(t, e, i) {
        return cc.TransitionScene.prototype.initWithDuration.call(this, t, e) && (this._orientation = i),
        !0
    }
}),
cc.TransitionSceneOriented.create = function(t, e, i) {
    return new cc.TransitionSceneOriented(t,e,i)
}
,
cc.TransitionRotoZoom = cc.TransitionScene.extend({
    ctor: function(t, e) {
        cc.TransitionScene.prototype.ctor.call(this),
        e && this.initWithDuration(t, e)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this),
        this._inScene.attr({
            scale: .001,
            anchorX: .5,
            anchorY: .5
        }),
        this._outScene.attr({
            scale: 1,
            anchorX: .5,
            anchorY: .5
        });
        var t = cc.sequence(cc.spawn(cc.scaleBy(this._duration / 2, .001), cc.rotateBy(this._duration / 2, 720)), cc.delayTime(this._duration / 2));
        this._outScene.runAction(t),
        this._inScene.runAction(cc.sequence(t.reverse(), cc.callFunc(this.finish, this)))
    }
}),
cc.TransitionRotoZoom.create = function(t, e) {
    return new cc.TransitionRotoZoom(t,e)
}
,
cc.TransitionJumpZoom = cc.TransitionScene.extend({
    ctor: function(t, e) {
        cc.TransitionScene.prototype.ctor.call(this),
        e && this.initWithDuration(t, e)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var t = cc.director.getWinSize();
        this._inScene.attr({
            scale: .5,
            x: t.width,
            y: 0,
            anchorX: .5,
            anchorY: .5
        }),
        this._outScene.anchorX = .5,
        this._outScene.anchorY = .5;
        var e = cc.jumpBy(this._duration / 4, cc.p(-t.width, 0), t.width / 4, 2)
          , i = cc.scaleTo(this._duration / 4, 1)
          , t = cc.scaleTo(this._duration / 4, .5)
          , t = cc.sequence(t, e)
          , e = cc.sequence(e, i)
          , i = cc.delayTime(this._duration / 2);
        this._outScene.runAction(t),
        this._inScene.runAction(cc.sequence(i, e, cc.callFunc(this.finish, this)))
    }
}),
cc.TransitionJumpZoom.create = function(t, e) {
    return new cc.TransitionJumpZoom(t,e)
}
,
cc.TransitionMoveInL = cc.TransitionScene.extend({
    ctor: function(t, e) {
        cc.TransitionScene.prototype.ctor.call(this),
        e && this.initWithDuration(t, e)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this),
        this.initScenes();
        var t = this.action();
        this._inScene.runAction(cc.sequence(this.easeActionWithAction(t), cc.callFunc(this.finish, this)))
    },
    initScenes: function() {
        this._inScene.setPosition(-cc.director.getWinSize().width, 0)
    },
    action: function() {
        return cc.moveTo(this._duration, cc.p(0, 0))
    },
    easeActionWithAction: function(t) {
        return new cc.EaseOut(t,2)
    }
}),
cc.TransitionMoveInL.create = function(t, e) {
    return new cc.TransitionMoveInL(t,e)
}
,
cc.TransitionMoveInR = cc.TransitionMoveInL.extend({
    ctor: function(t, e) {
        cc.TransitionMoveInL.prototype.ctor.call(this),
        e && this.initWithDuration(t, e)
    },
    initScenes: function() {
        this._inScene.setPosition(cc.director.getWinSize().width, 0)
    }
}),
cc.TransitionMoveInR.create = function(t, e) {
    return new cc.TransitionMoveInR(t,e)
}
,
cc.TransitionMoveInT = cc.TransitionMoveInL.extend({
    ctor: function(t, e) {
        cc.TransitionMoveInL.prototype.ctor.call(this),
        e && this.initWithDuration(t, e)
    },
    initScenes: function() {
        this._inScene.setPosition(0, cc.director.getWinSize().height)
    }
}),
cc.TransitionMoveInT.create = function(t, e) {
    return new cc.TransitionMoveInT(t,e)
}
,
cc.TransitionMoveInB = cc.TransitionMoveInL.extend({
    ctor: function(t, e) {
        cc.TransitionMoveInL.prototype.ctor.call(this),
        e && this.initWithDuration(t, e)
    },
    initScenes: function() {
        this._inScene.setPosition(0, -cc.director.getWinSize().height)
    }
}),
cc.TransitionMoveInB.create = function(t, e) {
    return new cc.TransitionMoveInB(t,e)
}
,
cc.ADJUST_FACTOR = .5,
cc.TransitionSlideInL = cc.TransitionScene.extend({
    ctor: function(t, e) {
        cc.TransitionScene.prototype.ctor.call(this),
        e && this.initWithDuration(t, e)
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !1
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this),
        this.initScenes();
        var t = this.action()
          , e = this.action()
          , t = cc.sequence(this.easeActionWithAction(t), cc.callFunc(this.finish, this))
          , e = this.easeActionWithAction(e);
        this._inScene.runAction(t),
        this._outScene.runAction(e)
    },
    initScenes: function() {
        this._inScene.setPosition(-cc.director.getWinSize().width + cc.ADJUST_FACTOR, 0)
    },
    action: function() {
        return cc.moveBy(this._duration, cc.p(cc.director.getWinSize().width - cc.ADJUST_FACTOR, 0))
    },
    easeActionWithAction: function(t) {
        return new cc.EaseInOut(t,2)
    }
}),
cc.TransitionSlideInL.create = function(t, e) {
    return new cc.TransitionSlideInL(t,e)
}
,
cc.TransitionSlideInR = cc.TransitionSlideInL.extend({
    ctor: function(t, e) {
        cc.TransitionSlideInL.prototype.ctor.call(this),
        e && this.initWithDuration(t, e)
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !0
    },
    initScenes: function() {
        this._inScene.setPosition(cc.director.getWinSize().width - cc.ADJUST_FACTOR, 0)
    },
    action: function() {
        return cc.moveBy(this._duration, cc.p(-(cc.director.getWinSize().width - cc.ADJUST_FACTOR), 0))
    }
}),
cc.TransitionSlideInR.create = function(t, e) {
    return new cc.TransitionSlideInR(t,e)
}
,
cc.TransitionSlideInB = cc.TransitionSlideInL.extend({
    ctor: function(t, e) {
        cc.TransitionSlideInL.prototype.ctor.call(this),
        e && this.initWithDuration(t, e)
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !1
    },
    initScenes: function() {
        this._inScene.setPosition(0, -(cc.director.getWinSize().height - cc.ADJUST_FACTOR))
    },
    action: function() {
        return cc.moveBy(this._duration, cc.p(0, cc.director.getWinSize().height - cc.ADJUST_FACTOR))
    }
}),
cc.TransitionSlideInB.create = function(t, e) {
    return new cc.TransitionSlideInB(t,e)
}
,
cc.TransitionSlideInT = cc.TransitionSlideInL.extend({
    ctor: function(t, e) {
        cc.TransitionSlideInL.prototype.ctor.call(this),
        e && this.initWithDuration(t, e)
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !0
    },
    initScenes: function() {
        this._inScene.setPosition(0, cc.director.getWinSize().height - cc.ADJUST_FACTOR)
    },
    action: function() {
        return cc.moveBy(this._duration, cc.p(0, -(cc.director.getWinSize().height - cc.ADJUST_FACTOR)))
    }
}),
cc.TransitionSlideInT.create = function(t, e) {
    return new cc.TransitionSlideInT(t,e)
}
,
cc.TransitionShrinkGrow = cc.TransitionScene.extend({
    ctor: function(t, e) {
        cc.TransitionScene.prototype.ctor.call(this),
        e && this.initWithDuration(t, e)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this),
        this._inScene.attr({
            scale: .001,
            anchorX: 2 / 3,
            anchorY: .5
        }),
        this._outScene.attr({
            scale: 1,
            anchorX: 1 / 3,
            anchorY: .5
        });
        var t = cc.scaleTo(this._duration, .01)
          , e = cc.scaleTo(this._duration, 1);
        this._inScene.runAction(cc.sequence(this.easeActionWithAction(e), cc.callFunc(this.finish, this))),
        this._outScene.runAction(this.easeActionWithAction(t))
    },
    easeActionWithAction: function(t) {
        return new cc.EaseOut(t,2)
    }
}),
cc.TransitionShrinkGrow.create = function(t, e) {
    return new cc.TransitionShrinkGrow(t,e)
}
,
cc.TransitionFlipX = cc.TransitionSceneOriented.extend({
    ctor: function(t, e, i) {
        cc.TransitionSceneOriented.prototype.ctor.call(this),
        null == i && (i = cc.TRANSITION_ORIENTATION_RIGHT_OVER),
        e && this.initWithDuration(t, e, i)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var t, e;
        this._inScene.visible = !1;
        var i;
        this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (t = 90,
        i = 270,
        e = 90) : (t = -90,
        i = 90,
        e = -90),
        t = cc.sequence(cc.delayTime(this._duration / 2), cc.show(), cc.orbitCamera(this._duration / 2, 1, 0, i, t, 0, 0), cc.callFunc(this.finish, this)),
        e = cc.sequence(cc.orbitCamera(this._duration / 2, 1, 0, 0, e, 0, 0), cc.hide(), cc.delayTime(this._duration / 2)),
        this._inScene.runAction(t),
        this._outScene.runAction(e)
    }
}),
cc.TransitionFlipX.create = function(t, e, i) {
    return new cc.TransitionFlipX(t,e,i)
}
,
cc.TransitionFlipY = cc.TransitionSceneOriented.extend({
    ctor: function(t, e, i) {
        cc.TransitionSceneOriented.prototype.ctor.call(this),
        null == i && (i = cc.TRANSITION_ORIENTATION_UP_OVER),
        e && this.initWithDuration(t, e, i)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var t, e;
        this._inScene.visible = !1;
        var i;
        this._orientation === cc.TRANSITION_ORIENTATION_UP_OVER ? (t = 90,
        i = 270,
        e = 90) : (t = -90,
        i = 90,
        e = -90),
        t = cc.sequence(cc.delayTime(this._duration / 2), cc.show(), cc.orbitCamera(this._duration / 2, 1, 0, i, t, 90, 0), cc.callFunc(this.finish, this)),
        e = cc.sequence(cc.orbitCamera(this._duration / 2, 1, 0, 0, e, 90, 0), cc.hide(), cc.delayTime(this._duration / 2)),
        this._inScene.runAction(t),
        this._outScene.runAction(e)
    }
}),
cc.TransitionFlipY.create = function(t, e, i) {
    return new cc.TransitionFlipY(t,e,i)
}
,
cc.TransitionFlipAngular = cc.TransitionSceneOriented.extend({
    ctor: function(t, e, i) {
        cc.TransitionSceneOriented.prototype.ctor.call(this),
        null == i && (i = cc.TRANSITION_ORIENTATION_RIGHT_OVER),
        e && this.initWithDuration(t, e, i)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var t, e;
        this._inScene.visible = !1;
        var i;
        this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (t = 90,
        i = 270,
        e = 90) : (t = -90,
        i = 90,
        e = -90),
        t = cc.sequence(cc.delayTime(this._duration / 2), cc.show(), cc.orbitCamera(this._duration / 2, 1, 0, i, t, -45, 0), cc.callFunc(this.finish, this)),
        e = cc.sequence(cc.orbitCamera(this._duration / 2, 1, 0, 0, e, 45, 0), cc.hide(), cc.delayTime(this._duration / 2)),
        this._inScene.runAction(t),
        this._outScene.runAction(e)
    }
}),
cc.TransitionFlipAngular.create = function(t, e, i) {
    return new cc.TransitionFlipAngular(t,e,i)
}
,
cc.TransitionZoomFlipX = cc.TransitionSceneOriented.extend({
    ctor: function(t, e, i) {
        cc.TransitionSceneOriented.prototype.ctor.call(this),
        null == i && (i = cc.TRANSITION_ORIENTATION_RIGHT_OVER),
        e && this.initWithDuration(t, e, i)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var t, e;
        this._inScene.visible = !1;
        var i;
        this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (t = 90,
        i = 270,
        e = 90) : (t = -90,
        i = 90,
        e = -90),
        t = cc.sequence(cc.delayTime(this._duration / 2), cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, i, t, 0, 0), cc.scaleTo(this._duration / 2, 1), cc.show()), cc.callFunc(this.finish, this)),
        e = cc.sequence(cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, 0, e, 0, 0), cc.scaleTo(this._duration / 2, .5)), cc.hide(), cc.delayTime(this._duration / 2)),
        this._inScene.scale = .5,
        this._inScene.runAction(t),
        this._outScene.runAction(e)
    }
}),
cc.TransitionZoomFlipX.create = function(t, e, i) {
    return new cc.TransitionZoomFlipX(t,e,i)
}
,
cc.TransitionZoomFlipY = cc.TransitionSceneOriented.extend({
    ctor: function(t, e, i) {
        cc.TransitionSceneOriented.prototype.ctor.call(this),
        null == i && (i = cc.TRANSITION_ORIENTATION_UP_OVER),
        e && this.initWithDuration(t, e, i);
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var t, e;
        this._inScene.visible = !1;
        var i;
        this._orientation === cc.TRANSITION_ORIENTATION_UP_OVER ? (t = 90,
        i = 270,
        e = 90) : (t = -90,
        i = 90,
        e = -90),
        t = cc.sequence(cc.delayTime(this._duration / 2), cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, i, t, 90, 0), cc.scaleTo(this._duration / 2, 1), cc.show()), cc.callFunc(this.finish, this)),
        e = cc.sequence(cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, 0, e, 90, 0), cc.scaleTo(this._duration / 2, .5)), cc.hide(), cc.delayTime(this._duration / 2)),
        this._inScene.scale = .5,
        this._inScene.runAction(t),
        this._outScene.runAction(e)
    }
}),
cc.TransitionZoomFlipY.create = function(t, e, i) {
    return new cc.TransitionZoomFlipY(t,e,i)
}
,
cc.TransitionZoomFlipAngular = cc.TransitionSceneOriented.extend({
    ctor: function(t, e, i) {
        cc.TransitionSceneOriented.prototype.ctor.call(this),
        null == i && (i = cc.TRANSITION_ORIENTATION_RIGHT_OVER),
        e && this.initWithDuration(t, e, i)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var t, e;
        this._inScene.visible = !1;
        var i;
        this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (t = 90,
        i = 270,
        e = 90) : (t = -90,
        i = 90,
        e = -90),
        t = cc.sequence(cc.delayTime(this._duration / 2), cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, i, t, -45, 0), cc.scaleTo(this._duration / 2, 1), cc.show()), cc.show(), cc.callFunc(this.finish, this)),
        e = cc.sequence(cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, 0, e, 45, 0), cc.scaleTo(this._duration / 2, .5)), cc.hide(), cc.delayTime(this._duration / 2)),
        this._inScene.scale = .5,
        this._inScene.runAction(t),
        this._outScene.runAction(e)
    }
}),
cc.TransitionZoomFlipAngular.create = function(t, e, i) {
    return new cc.TransitionZoomFlipAngular(t,e,i)
}
,
cc.TransitionFade = cc.TransitionScene.extend({
    _color: null,
    ctor: function(t, e, i) {
        cc.TransitionScene.prototype.ctor.call(this),
        this._color = cc.color(),
        e && this.initWithDuration(t, e, i)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var t = new cc.LayerColor(this._color);
        this._inScene.visible = !1,
        this.addChild(t, 2, cc.SCENE_FADE);
        var t = this.getChildByTag(cc.SCENE_FADE)
          , e = cc.sequence(cc.fadeIn(this._duration / 2), cc.callFunc(this.hideOutShowIn, this), cc.fadeOut(this._duration / 2), cc.callFunc(this.finish, this));
        t.runAction(e)
    },
    onExit: function() {
        cc.TransitionScene.prototype.onExit.call(this),
        this.removeChildByTag(cc.SCENE_FADE, !1)
    },
    initWithDuration: function(t, e, i) {
        return i = i || cc.color.BLACK,
        cc.TransitionScene.prototype.initWithDuration.call(this, t, e) && (this._color.r = i.r,
        this._color.g = i.g,
        this._color.b = i.b,
        this._color.a = 0),
        !0
    }
}),
cc.TransitionFade.create = function(t, e, i) {
    return new cc.TransitionFade(t,e,i)
}
,
cc.TransitionCrossFade = cc.TransitionScene.extend({
    ctor: function(t, e) {
        cc.TransitionScene.prototype.ctor.call(this),
        e && this.initWithDuration(t, e)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var t = cc.color(0, 0, 0, 0)
          , e = cc.director.getWinSize()
          , t = new cc.LayerColor(t)
          , i = new cc.RenderTexture(e.width,e.height);
        i.sprite.anchorX = .5,
        i.sprite.anchorY = .5,
        i.attr({
            x: e.width / 2,
            y: e.height / 2,
            anchorX: .5,
            anchorY: .5
        }),
        i.begin(),
        this._inScene.visit(),
        i.end();
        var n = new cc.RenderTexture(e.width,e.height);
        n.setPosition(e.width / 2, e.height / 2),
        n.sprite.anchorX = n.anchorX = .5,
        n.sprite.anchorY = n.anchorY = .5,
        n.begin(),
        this._outScene.visit(),
        n.end(),
        i.sprite.setBlendFunc(cc.ONE, cc.ONE),
        n.sprite.setBlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA),
        t.addChild(i),
        t.addChild(n),
        i.sprite.opacity = 255,
        n.sprite.opacity = 255,
        e = cc.sequence(cc.fadeTo(this._duration, 0), cc.callFunc(this.hideOutShowIn, this), cc.callFunc(this.finish, this)),
        n.sprite.runAction(e),
        this.addChild(t, 2, cc.SCENE_FADE)
    },
    onExit: function() {
        this.removeChildByTag(cc.SCENE_FADE, !1),
        cc.TransitionScene.prototype.onExit.call(this)
    },
    visit: function() {
        cc.Node.prototype.visit.call(this)
    },
    draw: function() {}
}),
cc.TransitionCrossFade.create = function(t, e) {
    return new cc.TransitionCrossFade(t,e)
}
,
cc.TransitionTurnOffTiles = cc.TransitionScene.extend({
    _gridProxy: null,
    ctor: function(t, e) {
        cc.TransitionScene.prototype.ctor.call(this),
        this._gridProxy = new cc.NodeGrid,
        e && this.initWithDuration(t, e)
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !1
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this),
        this._gridProxy.setTarget(this._outScene),
        this._gridProxy.onEnter();
        var t = cc.director.getWinSize()
          , t = cc.turnOffTiles(this._duration, cc.size(0 | t.width / t.height * 12, 12))
          , t = this.easeActionWithAction(t);
        this._gridProxy.runAction(cc.sequence(t, cc.callFunc(this.finish, this), cc.stopGrid()))
    },
    visit: function() {
        this._inScene.visit(),
        this._gridProxy.visit()
    },
    easeActionWithAction: function(t) {
        return t
    }
}),
cc.TransitionTurnOffTiles.create = function(t, e) {
    return new cc.TransitionTurnOffTiles(t,e)
}
,
cc.TransitionSplitCols = cc.TransitionScene.extend({
    _gridProxy: null,
    _switchTargetToInscene: function() {
        this._gridProxy.setTarget(this._inScene)
    },
    ctor: function(t, e) {
        cc.TransitionScene.prototype.ctor.call(this),
        this._gridProxy = new cc.NodeGrid,
        e && this.initWithDuration(t, e)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this),
        this._gridProxy.setTarget(this._outScene),
        this._gridProxy.onEnter();
        var t = this.action()
          , t = cc.sequence(t, cc.callFunc(this._switchTargetToInscene, this), t.reverse());
        this._gridProxy.runAction(cc.sequence(this.easeActionWithAction(t), cc.callFunc(this.finish, this), cc.stopGrid()))
    },
    onExit: function() {
        this._gridProxy.setTarget(null),
        this._gridProxy.onExit(),
        cc.TransitionScene.prototype.onExit.call(this)
    },
    visit: function() {
        this._gridProxy.visit()
    },
    easeActionWithAction: function(t) {
        return new cc.EaseInOut(t,3)
    },
    action: function() {
        return cc.splitCols(this._duration / 2, 3)
    }
}),
cc.TransitionSplitCols.create = function(t, e) {
    return new cc.TransitionSplitCols(t,e)
}
,
cc.TransitionSplitRows = cc.TransitionSplitCols.extend({
    ctor: function(t, e) {
        cc.TransitionSplitCols.prototype.ctor.call(this),
        e && this.initWithDuration(t, e)
    },
    action: function() {
        return cc.splitRows(this._duration / 2, 3)
    }
}),
cc.TransitionSplitRows.create = function(t, e) {
    return new cc.TransitionSplitRows(t,e)
}
,
cc.TransitionFadeTR = cc.TransitionScene.extend({
    _gridProxy: null,
    ctor: function(t, e) {
        cc.TransitionScene.prototype.ctor.call(this),
        this._gridProxy = new cc.NodeGrid,
        e && this.initWithDuration(t, e)
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !1
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this),
        this._gridProxy.setTarget(this._outScene),
        this._gridProxy.onEnter();
        var t = cc.director.getWinSize()
          , t = this.actionWithSize(cc.size(0 | t.width / t.height * 12, 12));
        this._gridProxy.runAction(cc.sequence(this.easeActionWithAction(t), cc.callFunc(this.finish, this), cc.stopGrid()))
    },
    visit: function() {
        this._inScene.visit(),
        this._gridProxy.visit()
    },
    easeActionWithAction: function(t) {
        return t
    },
    actionWithSize: function(t) {
        return cc.fadeOutTRTiles(this._duration, t)
    }
}),
cc.TransitionFadeTR.create = function(t, e) {
    return new cc.TransitionFadeTR(t,e)
}
,
cc.TransitionFadeBL = cc.TransitionFadeTR.extend({
    ctor: function(t, e) {
        cc.TransitionFadeTR.prototype.ctor.call(this),
        e && this.initWithDuration(t, e)
    },
    actionWithSize: function(t) {
        return cc.fadeOutBLTiles(this._duration, t)
    }
}),
cc.TransitionFadeBL.create = function(t, e) {
    return new cc.TransitionFadeBL(t,e)
}
,
cc.TransitionFadeUp = cc.TransitionFadeTR.extend({
    ctor: function(t, e) {
        cc.TransitionFadeTR.prototype.ctor.call(this),
        e && this.initWithDuration(t, e)
    },
    actionWithSize: function(t) {
        return new cc.FadeOutUpTiles(this._duration,t)
    }
}),
cc.TransitionFadeUp.create = function(t, e) {
    return new cc.TransitionFadeUp(t,e)
}
,
cc.TransitionFadeDown = cc.TransitionFadeTR.extend({
    ctor: function(t, e) {
        cc.TransitionFadeTR.prototype.ctor.call(this),
        e && this.initWithDuration(t, e)
    },
    actionWithSize: function(t) {
        return cc.fadeOutDownTiles(this._duration, t)
    }
}),
cc.TransitionFadeDown.create = function(t, e) {
    return new cc.TransitionFadeDown(t,e)
}
,
cc.SCENE_RADIAL = 49153,
cc.TransitionProgress = cc.TransitionScene.extend({
    _to: 0,
    _from: 0,
    _sceneToBeModified: null,
    _className: "TransitionProgress",
    ctor: function(t, e) {
        cc.TransitionScene.prototype.ctor.call(this),
        e && this.initWithDuration(t, e)
    },
    _setAttrs: function(t, e, i) {
        t.attr({
            x: e,
            y: i,
            anchorX: .5,
            anchorY: .5
        })
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this),
        this._setupTransition();
        var t = cc.director.getWinSize()
          , e = new cc.RenderTexture(t.width,t.height);
        e.sprite.anchorX = .5,
        e.sprite.anchorY = .5,
        this._setAttrs(e, t.width / 2, t.height / 2),
        e.clear(0, 0, 0, 1),
        e.begin(),
        this._sceneToBeModified.visit(),
        e.end(),
        this._sceneToBeModified === this._outScene && this.hideOutShowIn(),
        t = this._progressTimerNodeWithRenderTexture(e),
        e = cc.sequence(cc.progressFromTo(this._duration, this._from, this._to), cc.callFunc(this.finish, this)),
        t.runAction(e),
        this.addChild(t, 2, cc.SCENE_RADIAL)
    },
    onExit: function() {
        this.removeChildByTag(cc.SCENE_RADIAL, !0),
        cc.TransitionScene.prototype.onExit.call(this)
    },
    _setupTransition: function() {
        this._sceneToBeModified = this._outScene,
        this._from = 100,
        this._to = 0
    },
    _progressTimerNodeWithRenderTexture: function(t) {
        return cc.log("cc.TransitionProgress._progressTimerNodeWithRenderTexture(): should be overridden in subclass"),
        null
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !1
    }
}),
cc.TransitionProgress.create = function(t, e) {
    return new cc.TransitionProgress(t,e)
}
,
cc.TransitionProgressRadialCCW = cc.TransitionProgress.extend({
    ctor: function(t, e) {
        cc.TransitionProgress.prototype.ctor.call(this),
        e && this.initWithDuration(t, e)
    },
    _progressTimerNodeWithRenderTexture: function(t) {
        var e = cc.director.getWinSize();
        return t = new cc.ProgressTimer(t.sprite),
        cc._renderType === cc.game.RENDER_TYPE_WEBGL && (t.sprite.flippedY = !0),
        t.type = cc.ProgressTimer.TYPE_RADIAL,
        t.reverseDir = !1,
        t.percentage = 100,
        this._setAttrs(t, e.width / 2, e.height / 2),
        t
    }
}),
cc.TransitionProgressRadialCCW.create = function(t, e) {
    return new cc.TransitionProgressRadialCCW(t,e)
}
,
cc.TransitionProgressRadialCW = cc.TransitionProgress.extend({
    ctor: function(t, e) {
        cc.TransitionProgress.prototype.ctor.call(this),
        e && this.initWithDuration(t, e)
    },
    _progressTimerNodeWithRenderTexture: function(t) {
        var e = cc.director.getWinSize();
        return t = new cc.ProgressTimer(t.sprite),
        cc._renderType === cc.game.RENDER_TYPE_WEBGL && (t.sprite.flippedY = !0),
        t.type = cc.ProgressTimer.TYPE_RADIAL,
        t.reverseDir = !0,
        t.percentage = 100,
        this._setAttrs(t, e.width / 2, e.height / 2),
        t
    }
}),
cc.TransitionProgressRadialCW.create = function(t, e) {
    var i = new cc.TransitionProgressRadialCW;
    return null !== i && i.initWithDuration(t, e) ? i : new cc.TransitionProgressRadialCW(t,e)
}
,
cc.TransitionProgressHorizontal = cc.TransitionProgress.extend({
    ctor: function(t, e) {
        cc.TransitionProgress.prototype.ctor.call(this),
        e && this.initWithDuration(t, e)
    },
    _progressTimerNodeWithRenderTexture: function(t) {
        var e = cc.director.getWinSize();
        return t = new cc.ProgressTimer(t.sprite),
        cc._renderType === cc.game.RENDER_TYPE_WEBGL && (t.sprite.flippedY = !0),
        t.type = cc.ProgressTimer.TYPE_BAR,
        t.midPoint = cc.p(1, 0),
        t.barChangeRate = cc.p(1, 0),
        t.percentage = 100,
        this._setAttrs(t, e.width / 2, e.height / 2),
        t
    }
}),
cc.TransitionProgressHorizontal.create = function(t, e) {
    return new cc.TransitionProgressHorizontal(t,e)
}
,
cc.TransitionProgressVertical = cc.TransitionProgress.extend({
    ctor: function(t, e) {
        cc.TransitionProgress.prototype.ctor.call(this),
        e && this.initWithDuration(t, e)
    },
    _progressTimerNodeWithRenderTexture: function(t) {
        var e = cc.director.getWinSize();
        return t = new cc.ProgressTimer(t.sprite),
        cc._renderType === cc.game.RENDER_TYPE_WEBGL && (t.sprite.flippedY = !0),
        t.type = cc.ProgressTimer.TYPE_BAR,
        t.midPoint = cc.p(0, 0),
        t.barChangeRate = cc.p(0, 1),
        t.percentage = 100,
        this._setAttrs(t, e.width / 2, e.height / 2),
        t
    }
}),
cc.TransitionProgressVertical.create = function(t, e) {
    return new cc.TransitionProgressVertical(t,e)
}
,
cc.TransitionProgressInOut = cc.TransitionProgress.extend({
    ctor: function(t, e) {
        cc.TransitionProgress.prototype.ctor.call(this),
        e && this.initWithDuration(t, e)
    },
    _progressTimerNodeWithRenderTexture: function(t) {
        var e = cc.director.getWinSize();
        return t = new cc.ProgressTimer(t.sprite),
        cc._renderType === cc.game.RENDER_TYPE_WEBGL && (t.sprite.flippedY = !0),
        t.type = cc.ProgressTimer.TYPE_BAR,
        t.midPoint = cc.p(.5, .5),
        t.barChangeRate = cc.p(1, 1),
        t.percentage = 0,
        this._setAttrs(t, e.width / 2, e.height / 2),
        t
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !1
    },
    _setupTransition: function() {
        this._sceneToBeModified = this._inScene,
        this._from = 0,
        this._to = 100
    }
}),
cc.TransitionProgressInOut.create = function(t, e) {
    return new cc.TransitionProgressInOut(t,e)
}
,
cc.TransitionProgressOutIn = cc.TransitionProgress.extend({
    ctor: function(t, e) {
        cc.TransitionProgress.prototype.ctor.call(this),
        e && this.initWithDuration(t, e)
    },
    _progressTimerNodeWithRenderTexture: function(t) {
        var e = cc.director.getWinSize();
        return t = new cc.ProgressTimer(t.sprite),
        cc._renderType === cc.game.RENDER_TYPE_WEBGL && (t.sprite.flippedY = !0),
        t.type = cc.ProgressTimer.TYPE_BAR,
        t.midPoint = cc.p(.5, .5),
        t.barChangeRate = cc.p(1, 1),
        t.percentage = 100,
        this._setAttrs(t, e.width / 2, e.height / 2),
        t
    }
}),
cc.TransitionProgressOutIn.create = function(t, e) {
    return new cc.TransitionProgressOutIn(t,e)
}
,
cc.TransitionPageTurn = cc.TransitionScene.extend({
    ctor: function(t, e, i) {
        cc.TransitionScene.prototype.ctor.call(this),
        this._gridProxy = new cc.NodeGrid,
        this.initWithDuration(t, e, i)
    },
    _back: !0,
    _gridProxy: null,
    _className: "TransitionPageTurn",
    initWithDuration: function(t, e, i) {
        return this._back = i,
        cc.TransitionScene.prototype.initWithDuration.call(this, t, e),
        !0
    },
    actionWithSize: function(t) {
        return this._back ? cc.reverseTime(cc.pageTurn3D(this._duration, t)) : cc.pageTurn3D(this._duration, t)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var t, e = cc.director.getWinSize();
        e.width > e.height ? (e = 16,
        t = 12) : (e = 12,
        t = 16),
        e = this.actionWithSize(cc.size(e, t)),
        t = this._gridProxy,
        this._back ? (t.setTarget(this._inScene),
        t.onEnter(),
        this._inScene.visible = !1,
        t.runAction(cc.sequence(e, cc.callFunc(this.finish, this), cc.stopGrid())),
        this._inScene.runAction(cc.show())) : (t.setTarget(this._outScene),
        t.onEnter(),
        t.runAction(cc.sequence(e, cc.callFunc(this.finish, this), cc.stopGrid())))
    },
    visit: function() {
        this._back ? this._outScene.visit() : this._inScene.visit(),
        this._gridProxy.visit()
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = this._back
    }
}),
cc.TransitionPageTurn.create = function(t, e, i) {
    return new cc.TransitionPageTurn(t,e,i)
}
,
cc.Codec = {
    name: "Jacob__Codec"
},
cc.unzip = function() {
    return cc.Codec.GZip.gunzip.apply(cc.Codec.GZip, arguments)
}
,
cc.unzipBase64 = function() {
    var t = cc.Codec.Base64.decode.apply(cc.Codec.Base64, arguments);
    return cc.Codec.GZip.gunzip.apply(cc.Codec.GZip, [t])
}
,
cc.unzipBase64AsArray = function(t, e) {
    e = e || 1;
    var i, n, r, c = this.unzipBase64(t), s = [];
    for (i = 0,
    r = c.length / e; i < r; i++)
        for (s[i] = 0,
        n = e - 1; 0 <= n; --n)
            s[i] += c.charCodeAt(i * e + n) << 8 * n;
    return s
}
,
cc.unzipAsArray = function(t, e) {
    e = e || 1;
    var i, n, r, c = this.unzip(t), s = [];
    for (i = 0,
    r = c.length / e; i < r; i++)
        for (s[i] = 0,
        n = e - 1; 0 <= n; --n)
            s[i] += c.charCodeAt(i * e + n) << 8 * n;
    return s
}
,
cc.StringToArray = function(t) {
    t = t.split(",");
    var e, i = [];
    for (e = 0; e < t.length; e++)
        i.push(parseInt(t[e]));
    return i
}
,
cc.Codec.Base64 = {
    name: "Jacob__Codec__Base64"
},
cc.Codec.Base64._keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
cc.Codec.Base64.decode = function(t) {
    var e, i, n, r, c, s = [], o = 0;
    for (t = t.replace(/[^A-Za-z0-9\+\/\=]/g, ""); o < t.length; )
        e = this._keyStr.indexOf(t.charAt(o++)),
        i = this._keyStr.indexOf(t.charAt(o++)),
        r = this._keyStr.indexOf(t.charAt(o++)),
        c = this._keyStr.indexOf(t.charAt(o++)),
        e = e << 2 | i >> 4,
        i = (15 & i) << 4 | r >> 2,
        n = (3 & r) << 6 | c,
        s.push(String.fromCharCode(e)),
        64 !== r && s.push(String.fromCharCode(i)),
        64 !== c && s.push(String.fromCharCode(n));
    return s = s.join("")
}
,
cc.Codec.Base64.decodeAsArray = function(t, e) {
    var i, n, r, c = this.decode(t), s = [];
    for (i = 0,
    r = c.length / e; i < r; i++)
        for (s[i] = 0,
        n = e - 1; 0 <= n; --n)
            s[i] += c.charCodeAt(i * e + n) << 8 * n;
    return s
}
,
cc.uint8ArrayToUint32Array = function(t) {
    if (0 !== t.length % 4)
        return null;
    for (var e = t.length / 4, i = window.Uint32Array ? new Uint32Array(e) : [], n = 0; n < e; n++) {
        var r = 4 * n;
        i[n] = t[r] + 256 * t[r + 1] + 65536 * t[r + 2] + 16777216 * t[r + 3]
    }
    return i
}
,
cc.Codec.GZip = function(t) {
    this.data = t,
    this.debug = !1,
    this.gpflags = void 0,
    this.files = 0,
    this.unzipped = [],
    this.buf32k = Array(32768),
    this.bIdx = 0,
    this.modeZIP = !1,
    this.bytepos = 0,
    this.bb = 1,
    this.bits = 0,
    this.nameBuf = [],
    this.fileout = void 0,
    this.literalTree = Array(cc.Codec.GZip.LITERALS),
    this.distanceTree = Array(32),
    this.treepos = 0,
    this.Places = null,
    this.len = 0,
    this.fpos = Array(17),
    this.fpos[0] = 0,
    this.fmax = this.flens = void 0
}
,
cc.Codec.GZip.gunzip = function(t) {
    return new cc.Codec.GZip(t).gunzip()[0][0]
}
,
cc.Codec.GZip.HufNode = function() {
    this.b1 = this.b0 = 0,
    this.jump = null,
    this.jumppos = -1
}
,
cc.Codec.GZip.LITERALS = 288,
cc.Codec.GZip.NAMEMAX = 256,
cc.Codec.GZip.bitReverse = [0, 128, 64, 192, 32, 160, 96, 224, 16, 144, 80, 208, 48, 176, 112, 240, 8, 136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184, 120, 248, 4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244, 12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82, 210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161, 97, 225, 17, 145, 81, 209, 49, 177, 113, 241, 9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245, 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 3, 131, 67, 195, 35, 163, 99, 227, 19, 147, 83, 211, 51, 179, 115, 243, 11, 139, 75, 203, 43, 171, 107, 235, 27, 155, 91, 219, 59, 187, 123, 251, 7, 135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247, 15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255],
cc.Codec.GZip.cplens = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0],
cc.Codec.GZip.cplext = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99],
cc.Codec.GZip.cpdist = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577],
cc.Codec.GZip.cpdext = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13],
cc.Codec.GZip.border = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
cc.Codec.GZip.prototype.gunzip = function() {
    return this.outputArr = [],
    this.nextFile(),
    this.unzipped
}
,
cc.Codec.GZip.prototype.readByte = function() {
    return this.bits += 8,
    this.bytepos < this.data.length ? this.data.charCodeAt(this.bytepos++) : -1
}
,
cc.Codec.GZip.prototype.byteAlign = function() {
    this.bb = 1
}
,
cc.Codec.GZip.prototype.readBit = function() {
    var t;
    return this.bits++,
    t = 1 & this.bb,
    this.bb >>= 1,
    0 === this.bb && (this.bb = this.readByte(),
    t = 1 & this.bb,
    this.bb = this.bb >> 1 | 128),
    t
}
,
cc.Codec.GZip.prototype.readBits = function(t) {
    for (var e = 0, i = t; i--; )
        e = e << 1 | this.readBit();
    return t && (e = cc.Codec.GZip.bitReverse[e] >> 8 - t),
    e
}
,
cc.Codec.GZip.prototype.flushBuffer = function() {
    this.bIdx = 0
}
,
cc.Codec.GZip.prototype.addBuffer = function(t) {
    this.buf32k[this.bIdx++] = t,
    this.outputArr.push(String.fromCharCode(t)),
    32768 === this.bIdx && (this.bIdx = 0)
}
,
cc.Codec.GZip.prototype.IsPat = function() {
    for (; ; ) {
        if (this.fpos[this.len] >= this.fmax)
            return -1;
        if (this.flens[this.fpos[this.len]] === this.len)
            return this.fpos[this.len]++;
        this.fpos[this.len]++
    }
}
,
cc.Codec.GZip.prototype.Rec = function() {
    var t, e = this.Places[this.treepos];
    if (17 === this.len)
        return -1;
    if (this.treepos++,
    this.len++,
    t = this.IsPat(),
    0 <= t)
        e.b0 = t;
    else if (e.b0 = 32768,
    this.Rec())
        return -1;
    if (t = this.IsPat(),
    0 <= t)
        e.b1 = t,
        e.jump = null;
    else if (e.b1 = 32768,
    e.jump = this.Places[this.treepos],
    e.jumppos = this.treepos,
    this.Rec())
        return -1;
    return this.len--,
    0
}
,
cc.Codec.GZip.prototype.CreateTree = function(t, e, i, n) {
    for (this.Places = t,
    this.treepos = 0,
    this.flens = i,
    this.fmax = e,
    t = 0; 17 > t; t++)
        this.fpos[t] = 0;
    return this.len = 0,
    this.Rec() ? -1 : 0
}
,
cc.Codec.GZip.prototype.DecodeValue = function(t) {
    for (var e, i, n = 0, r = t[n]; ; )
        if (e = this.readBit()) {
            if (!(32768 & r.b1))
                return r.b1;
            for (r = r.jump,
            e = t.length,
            i = 0; i < e; i++)
                if (t[i] === r) {
                    n = i;
                    break
                }
        } else {
            if (!(32768 & r.b0))
                return r.b0;
            n++,
            r = t[n]
        }
    return -1
}
,
cc.Codec.GZip.prototype.DeflateLoop = function() {
    var t, e, i, n, r;
    do
        if (t = this.readBit(),
        i = this.readBits(2),
        0 === i)
            for (this.byteAlign(),
            i = this.readByte(),
            i |= this.readByte() << 8,
            e = this.readByte(),
            e |= this.readByte() << 8,
            65535 & (i ^ ~e) && document.write("BlockLen checksum mismatch\n"); i--; )
                e = this.readByte(),
                this.addBuffer(e);
        else if (1 === i)
            for (; ; )
                if (i = cc.Codec.GZip.bitReverse[this.readBits(7)] >> 1,
                23 < i ? (i = i << 1 | this.readBit(),
                199 < i ? (i -= 128,
                i = i << 1 | this.readBit()) : (i -= 48,
                143 < i && (i += 136))) : i += 256,
                256 > i)
                    this.addBuffer(i);
                else {
                    if (256 === i)
                        break;
                    var c;
                    for (i -= 257,
                    r = this.readBits(cc.Codec.GZip.cplext[i]) + cc.Codec.GZip.cplens[i],
                    i = cc.Codec.GZip.bitReverse[this.readBits(5)] >> 3,
                    8 < cc.Codec.GZip.cpdext[i] ? (c = this.readBits(8),
                    c |= this.readBits(cc.Codec.GZip.cpdext[i] - 8) << 8) : c = this.readBits(cc.Codec.GZip.cpdext[i]),
                    c += cc.Codec.GZip.cpdist[i],
                    i = 0; i < r; i++)
                        e = this.buf32k[this.bIdx - c & 32767],
                        this.addBuffer(e)
                }
        else if (2 === i) {
            var s = Array(320);
            for (e = 257 + this.readBits(5),
            c = 1 + this.readBits(5),
            n = 4 + this.readBits(4),
            i = 0; 19 > i; i++)
                s[i] = 0;
            for (i = 0; i < n; i++)
                s[cc.Codec.GZip.border[i]] = this.readBits(3);
            for (r = this.distanceTree.length,
            n = 0; n < r; n++)
                this.distanceTree[n] = new cc.Codec.GZip.HufNode;
            if (this.CreateTree(this.distanceTree, 19, s, 0))
                return this.flushBuffer(),
                1;
            r = e + c,
            n = 0;
            for (var o = -1; n < r; )
                if (o++,
                i = this.DecodeValue(this.distanceTree),
                16 > i)
                    s[n++] = i;
                else if (16 === i) {
                    var a;
                    if (i = 3 + this.readBits(2),
                    n + i > r)
                        return this.flushBuffer(),
                        1;
                    for (a = n ? s[n - 1] : 0; i--; )
                        s[n++] = a
                } else {
                    if (i = 17 === i ? 3 + this.readBits(3) : 11 + this.readBits(7),
                    n + i > r)
                        return this.flushBuffer(),
                        1;
                    for (; i--; )
                        s[n++] = 0
                }
            for (r = this.literalTree.length,
            n = 0; n < r; n++)
                this.literalTree[n] = new cc.Codec.GZip.HufNode;
            if (this.CreateTree(this.literalTree, e, s, 0))
                return this.flushBuffer(),
                1;
            for (r = this.literalTree.length,
            n = 0; n < r; n++)
                this.distanceTree[n] = new cc.Codec.GZip.HufNode;
            for (i = [],
            n = e; n < s.length; n++)
                i[n - e] = s[n];
            if (this.CreateTree(this.distanceTree, c, i, 0))
                return this.flushBuffer(),
                1;
            for (; ; )
                if (i = this.DecodeValue(this.literalTree),
                256 <= i) {
                    if (i -= 256,
                    0 === i)
                        break;
                    for (i--,
                    r = this.readBits(cc.Codec.GZip.cplext[i]) + cc.Codec.GZip.cplens[i],
                    i = this.DecodeValue(this.distanceTree),
                    8 < cc.Codec.GZip.cpdext[i] ? (c = this.readBits(8),
                    c |= this.readBits(cc.Codec.GZip.cpdext[i] - 8) << 8) : c = this.readBits(cc.Codec.GZip.cpdext[i]),
                    c += cc.Codec.GZip.cpdist[i]; r--; )
                        e = this.buf32k[this.bIdx - c & 32767],
                        this.addBuffer(e)
                } else
                    this.addBuffer(i)
        }
    while (!t);
    return this.flushBuffer(),
    this.byteAlign(),
    0
}
,
cc.Codec.GZip.prototype.unzipFile = function(t) {
    var e;
    for (this.gunzip(),
    e = 0; e < this.unzipped.length; e++)
        if (this.unzipped[e][1] === t)
            return this.unzipped[e][0]
}
,
cc.Codec.GZip.prototype.nextFile = function() {
    this.outputArr = [],
    this.modeZIP = !1;
    var t = [];
    if (t[0] = this.readByte(),
    t[1] = this.readByte(),
    120 === t[0] && 218 === t[1] && (this.DeflateLoop(),
    this.unzipped[this.files] = [this.outputArr.join(""), "geonext.gxt"],
    this.files++),
    31 === t[0] && 139 === t[1] && (this.skipdir(),
    this.unzipped[this.files] = [this.outputArr.join(""), "file"],
    this.files++),
    80 === t[0] && 75 === t[1] && (this.modeZIP = !0,
    t[2] = this.readByte(),
    t[3] = this.readByte(),
    3 === t[2] && 4 === t[3])) {
        t[0] = this.readByte(),
        t[1] = this.readByte(),
        this.gpflags = this.readByte(),
        this.gpflags |= this.readByte() << 8,
        t = this.readByte(),
        t |= this.readByte() << 8,
        this.readByte(),
        this.readByte(),
        this.readByte(),
        this.readByte(),
        this.readByte(),
        this.readByte(),
        this.readByte(),
        this.readByte(),
        this.readByte(),
        this.readByte(),
        this.readByte(),
        this.readByte();
        var e = this.readByte()
          , e = e | this.readByte() << 8
          , i = this.readByte()
          , i = i | this.readByte() << 8
          , n = 0;
        for (this.nameBuf = []; e--; ) {
            var r = this.readByte();
            "/" === r | ":" === r ? n = 0 : n < cc.Codec.GZip.NAMEMAX - 1 && (this.nameBuf[n++] = String.fromCharCode(r))
        }
        this.fileout || (this.fileout = this.nameBuf);
        for (var n = 0; n < i; )
            this.readByte(),
            n++;
        8 === t && (this.DeflateLoop(),
        this.unzipped[this.files] = [this.outputArr.join(""), this.nameBuf.join("")],
        this.files++),
        this.skipdir()
    }
}
,
cc.Codec.GZip.prototype.skipdir = function() {
    var t, e = [];
    if (8 & this.gpflags && (e[0] = this.readByte(),
    e[1] = this.readByte(),
    e[2] = this.readByte(),
    e[3] = this.readByte(),
    this.readByte(),
    this.readByte(),
    this.readByte(),
    this.readByte(),
    this.readByte(),
    this.readByte(),
    this.readByte(),
    this.readByte()),
    this.modeZIP && this.nextFile(),
    e[0] = this.readByte(),
    8 !== e[0])
        return 0;
    if (this.gpflags = this.readByte(),
    this.readByte(),
    this.readByte(),
    this.readByte(),
    this.readByte(),
    this.readByte(),
    this.readByte(),
    4 & this.gpflags)
        for (e[0] = this.readByte(),
        e[2] = this.readByte(),
        this.len = e[0] + 256 * e[1],
        e = 0; e < this.len; e++)
            this.readByte();
    if (8 & this.gpflags)
        for (e = 0,
        this.nameBuf = []; t = this.readByte(); )
            "7" !== t && ":" !== t || (e = 0),
            e < cc.Codec.GZip.NAMEMAX - 1 && (this.nameBuf[e++] = t);
    if (16 & this.gpflags)
        for (; this.readByte(); )
            ;
    2 & this.gpflags && (this.readByte(),
    this.readByte()),
    this.DeflateLoop(),
    this.readByte(),
    this.readByte(),
    this.readByte(),
    this.readByte(),
    this.modeZIP && this.nextFile()
}
,
function() {
    function t(t) {
        throw t
    }
    function e(t, e) {
        var i = t.split(".")
          , n = v;
        i[0]in n || !n.execScript || n.execScript("var " + i[0]);
        for (var r; i.length && (r = i.shift()); )
            i.length || e === y ? n = n[r] ? n[r] : n[r] = {} : n[r] = e
    }
    function i(t) {
        if ("string" == typeof t) {
            t = t.split("");
            var e, i;
            for (e = 0,
            i = t.length; e < i; e++)
                t[e] = (255 & t[e].charCodeAt(0)) >>> 0
        }
        e = 1,
        i = 0;
        for (var n, r = t.length, c = 0; 0 < r; ) {
            n = 1024 < r ? 1024 : r,
            r -= n;
            do
                e += t[c++],
                i += e;
            while (--n);
            e %= 65521,
            i %= 65521
        }
        return (i << 16 | e) >>> 0
    }
    function n(e, i) {
        this.index = "number" == typeof i ? i : 0,
        this.i = 0,
        this.buffer = e instanceof (A ? Uint8Array : Array) ? e : new (A ? Uint8Array : Array)(32768),
        2 * this.buffer.length <= this.index && t(Error("invalid index")),
        this.buffer.length <= this.index && this.f()
    }
    function r(t) {
        this.buffer = new (A ? Uint16Array : Array)(2 * t),
        this.length = 0
    }
    function c(t) {
        var e, i, n, r, c, s, o, a, h, l = t.length, u = 0, d = Number.POSITIVE_INFINITY;
        for (a = 0; a < l; ++a)
            t[a] > u && (u = t[a]),
            t[a] < d && (d = t[a]);
        for (e = 1 << u,
        i = new (A ? Uint32Array : Array)(e),
        n = 1,
        r = 0,
        c = 2; n <= u; ) {
            for (a = 0; a < l; ++a)
                if (t[a] === n) {
                    for (s = 0,
                    o = r,
                    h = 0; h < n; ++h)
                        s = s << 1 | 1 & o,
                        o >>= 1;
                    for (h = s; h < e; h += c)
                        i[h] = n << 16 | a;
                    ++r
                }
            ++n,
            r <<= 1,
            c <<= 1
        }
        return [i, u, d]
    }
    function s(t, e) {
        this.h = R,
        this.w = 0,
        this.input = t,
        this.b = 0,
        e && (e.lazy && (this.w = e.lazy),
        "number" == typeof e.compressionType && (this.h = e.compressionType),
        e.outputBuffer && (this.a = A && e.outputBuffer instanceof Array ? new Uint8Array(e.outputBuffer) : e.outputBuffer),
        "number" == typeof e.outputIndex && (this.b = e.outputIndex)),
        this.a || (this.a = new (A ? Uint8Array : Array)(32768))
    }
    function o(t, e) {
        this.length = t,
        this.G = e
    }
    function a() {
        var e = P;
        switch (T) {
        case 3 === e:
            return [257, e - 3, 0];
        case 4 === e:
            return [258, e - 4, 0];
        case 5 === e:
            return [259, e - 5, 0];
        case 6 === e:
            return [260, e - 6, 0];
        case 7 === e:
            return [261, e - 7, 0];
        case 8 === e:
            return [262, e - 8, 0];
        case 9 === e:
            return [263, e - 9, 0];
        case 10 === e:
            return [264, e - 10, 0];
        case 12 >= e:
            return [265, e - 11, 1];
        case 14 >= e:
            return [266, e - 13, 1];
        case 16 >= e:
            return [267, e - 15, 1];
        case 18 >= e:
            return [268, e - 17, 1];
        case 22 >= e:
            return [269, e - 19, 2];
        case 26 >= e:
            return [270, e - 23, 2];
        case 30 >= e:
            return [271, e - 27, 2];
        case 34 >= e:
            return [272, e - 31, 2];
        case 42 >= e:
            return [273, e - 35, 3];
        case 50 >= e:
            return [274, e - 43, 3];
        case 58 >= e:
            return [275, e - 51, 3];
        case 66 >= e:
            return [276, e - 59, 3];
        case 82 >= e:
            return [277, e - 67, 4];
        case 98 >= e:
            return [278, e - 83, 4];
        case 114 >= e:
            return [279, e - 99, 4];
        case 130 >= e:
            return [280, e - 115, 4];
        case 162 >= e:
            return [281, e - 131, 5];
        case 194 >= e:
            return [282, e - 163, 5];
        case 226 >= e:
            return [283, e - 195, 5];
        case 257 >= e:
            return [284, e - 227, 5];
        case 258 === e:
            return [285, e - 258, 0];
        default:
            t("invalid length: " + e)
        }
    }
    function h(e, i) {
        function n(e, i) {
            var n, r = e.G, c = [], s = 0;
            n = L[e.length],
            c[s++] = 65535 & n,
            c[s++] = n >> 16 & 255,
            c[s++] = n >> 24;
            var o;
            switch (T) {
            case 1 === r:
                o = [0, r - 1, 0];
                break;
            case 2 === r:
                o = [1, r - 2, 0];
                break;
            case 3 === r:
                o = [2, r - 3, 0];
                break;
            case 4 === r:
                o = [3, r - 4, 0];
                break;
            case 6 >= r:
                o = [4, r - 5, 1];
                break;
            case 8 >= r:
                o = [5, r - 7, 1];
                break;
            case 12 >= r:
                o = [6, r - 9, 2];
                break;
            case 16 >= r:
                o = [7, r - 13, 2];
                break;
            case 24 >= r:
                o = [8, r - 17, 3];
                break;
            case 32 >= r:
                o = [9, r - 25, 3];
                break;
            case 48 >= r:
                o = [10, r - 33, 4];
                break;
            case 64 >= r:
                o = [11, r - 49, 4];
                break;
            case 96 >= r:
                o = [12, r - 65, 5];
                break;
            case 128 >= r:
                o = [13, r - 97, 5];
                break;
            case 192 >= r:
                o = [14, r - 129, 6];
                break;
            case 256 >= r:
                o = [15, r - 193, 6];
                break;
            case 384 >= r:
                o = [16, r - 257, 7];
                break;
            case 512 >= r:
                o = [17, r - 385, 7];
                break;
            case 768 >= r:
                o = [18, r - 513, 8];
                break;
            case 1024 >= r:
                o = [19, r - 769, 8];
                break;
            case 1536 >= r:
                o = [20, r - 1025, 9];
                break;
            case 2048 >= r:
                o = [21, r - 1537, 9];
                break;
            case 3072 >= r:
                o = [22, r - 2049, 10];
                break;
            case 4096 >= r:
                o = [23, r - 3073, 10];
                break;
            case 6144 >= r:
                o = [24, r - 4097, 11];
                break;
            case 8192 >= r:
                o = [25, r - 6145, 11];
                break;
            case 12288 >= r:
                o = [26, r - 8193, 12];
                break;
            case 16384 >= r:
                o = [27, r - 12289, 12];
                break;
            case 24576 >= r:
                o = [28, r - 16385, 13];
                break;
            case 32768 >= r:
                o = [29, r - 24577, 13];
                break;
            default:
                t("invalid distance")
            }
            for (n = o,
            c[s++] = n[0],
            c[s++] = n[1],
            c[s++] = n[2],
            r = 0,
            s = c.length; r < s; ++r)
                _[p++] = c[r];
            g[c[0]]++,
            m[c[3]]++,
            f = e.length + i - 1,
            l = null
        }
        var r, c, s, a, h, l, u, d = {}, _ = A ? new Uint16Array(2 * i.length) : [], p = 0, f = 0, g = new (A ? Uint32Array : Array)(286), m = new (A ? Uint32Array : Array)(30), v = e.w;
        if (!A) {
            for (s = 0; 285 >= s; )
                g[s++] = 0;
            for (s = 0; 29 >= s; )
                m[s++] = 0
        }
        for (g[256] = 1,
        r = 0,
        c = i.length; r < c; ++r) {
            for (s = h = 0,
            a = 3; s < a && r + s !== c; ++s)
                h = h << 8 | i[r + s];
            if (d[h] === y && (d[h] = []),
            s = d[h],
            !(0 < f--)) {
                for (; 0 < s.length && 32768 < r - s[0]; )
                    s.shift();
                if (r + 3 >= c) {
                    for (l && n(l, -1),
                    s = 0,
                    a = c - r; s < a; ++s)
                        u = i[r + s],
                        _[p++] = u,
                        ++g[u];
                    break
                }
                if (0 < s.length) {
                    h = a = y;
                    var S = 0
                      , E = y
                      , x = y
                      , C = E = y
                      , I = i.length
                      , x = 0
                      , C = s.length;
                    t: for (; x < C; x++) {
                        if (a = s[C - x - 1],
                        E = 3,
                        3 < S) {
                            for (E = S; 3 < E; E--)
                                if (i[a + E - 1] !== i[r + E - 1])
                                    continue t;
                            E = S
                        }
                        for (; 258 > E && r + E < I && i[a + E] === i[r + E]; )
                            ++E;
                        if (E > S && (h = a,
                        S = E),
                        258 === E)
                            break
                    }
                    a = new o(S,r - h),
                    l ? l.length < a.length ? (u = i[r - 1],
                    _[p++] = u,
                    ++g[u],
                    n(a, 0)) : n(l, -1) : a.length < v ? l = a : n(a, 0)
                } else
                    l ? n(l, -1) : (u = i[r],
                    _[p++] = u,
                    ++g[u])
            }
            s.push(r)
        }
        return _[p++] = 256,
        g[256]++,
        e.L = g,
        e.K = m,
        A ? _.subarray(0, p) : _
    }
    function l(t, e) {
        function i(t) {
            var e = f[t][g[t]];
            e === l ? (i(t + 1),
            i(t + 1)) : --u[e],
            ++g[t]
        }
        var n, c, s, o = t.length, a = new r(572), h = new (A ? Uint8Array : Array)(o);
        if (!A)
            for (c = 0; c < o; c++)
                h[c] = 0;
        for (c = 0; c < o; ++c)
            0 < t[c] && a.push(c, t[c]);
        if (o = Array(a.length / 2),
        n = new (A ? Uint32Array : Array)(a.length / 2),
        1 === o.length)
            return h[a.pop().index] = 1,
            h;
        for (c = 0,
        s = a.length / 2; c < s; ++c)
            o[c] = a.pop(),
            n[c] = o[c].value;
        var l = n.length;
        c = new (A ? Uint16Array : Array)(e);
        var a = new (A ? Uint8Array : Array)(e)
          , u = new (A ? Uint8Array : Array)(l);
        s = Array(e);
        var d, _, p, f = Array(e), g = Array(e), m = (1 << e) - l, y = 1 << e - 1;
        for (c[e - 1] = l,
        d = 0; d < e; ++d)
            m < y ? a[d] = 0 : (a[d] = 1,
            m -= y),
            m <<= 1,
            c[e - 2 - d] = (c[e - 1 - d] / 2 | 0) + l;
        for (c[0] = a[0],
        s[0] = Array(c[0]),
        f[0] = Array(c[0]),
        d = 1; d < e; ++d)
            c[d] > 2 * c[d - 1] + a[d] && (c[d] = 2 * c[d - 1] + a[d]),
            s[d] = Array(c[d]),
            f[d] = Array(c[d]);
        for (m = 0; m < l; ++m)
            u[m] = e;
        for (y = 0; y < c[e - 1]; ++y)
            s[e - 1][y] = n[y],
            f[e - 1][y] = y;
        for (m = 0; m < e; ++m)
            g[m] = 0;
        for (1 === a[e - 1] && (--u[0],
        ++g[e - 1]),
        d = e - 2; 0 <= d; --d) {
            for (_ = m = 0,
            p = g[d + 1],
            y = 0; y < c[d]; y++)
                _ = s[d + 1][p] + s[d + 1][p + 1],
                _ > n[m] ? (s[d][y] = _,
                f[d][y] = l,
                p += 2) : (s[d][y] = n[m],
                f[d][y] = m,
                ++m);
            g[d] = 0,
            1 === a[d] && i(d)
        }
        for (n = u,
        c = 0,
        s = o.length; c < s; ++c)
            h[o[c].index] = n[c];
        return h
    }
    function u(e) {
        var i, n, r, c = new (A ? Uint16Array : Array)(e.length), s = [], o = [], a = 0;
        for (i = 0,
        n = e.length; i < n; i++)
            s[e[i]] = (0 | s[e[i]]) + 1;
        for (i = 1,
        n = 16; i <= n; i++)
            o[i] = a,
            a += 0 | s[i],
            a > 1 << i && t("overcommitted"),
            a <<= 1;
        for (65536 > a && t("undercommitted"),
        i = 0,
        n = e.length; i < n; i++)
            for (a = o[e[i]],
            o[e[i]] += 1,
            s = c[i] = 0,
            r = e[i]; s < r; s++)
                c[i] = c[i] << 1 | 1 & a,
                a >>>= 1;
        return c
    }
    function d(t, e) {
        this.input = t,
        this.a = new (A ? Uint8Array : Array)(32768),
        this.h = F.j;
        var i, n = {};
        !e && (e = {}) || "number" != typeof e.compressionType || (this.h = e.compressionType);
        for (i in e)
            n[i] = e[i];
        n.outputBuffer = this.a,
        this.z = new s(this.input,n)
    }
    function _(e, i) {
        switch (this.k = [],
        this.l = 32768,
        this.e = this.g = this.c = this.q = 0,
        this.input = A ? new Uint8Array(e) : e,
        this.s = !1,
        this.m = D,
        this.B = !1,
        !i && (i = {}) || (i.index && (this.c = i.index),
        i.bufferSize && (this.l = i.bufferSize),
        i.bufferType && (this.m = i.bufferType),
        i.resize && (this.B = i.resize)),
        this.m) {
        case O:
            this.b = 32768,
            this.a = new (A ? Uint8Array : Array)(32768 + this.l + 258);
            break;
        case D:
            this.b = 0,
            this.a = new (A ? Uint8Array : Array)(this.l),
            this.f = this.J,
            this.t = this.H,
            this.o = this.I;
            break;
        default:
            t(Error("invalid inflate mode"))
        }
    }
    function p(e, i) {
        for (var n, r = e.g, c = e.e, s = e.input, o = e.c; c < i; )
            n = s[o++],
            n === y && t(Error("input buffer is broken")),
            r |= n << c,
            c += 8;
        return e.g = r >>> i,
        e.e = c - i,
        e.c = o,
        r & (1 << i) - 1
    }
    function f(e, i) {
        for (var n, r = e.g, c = e.e, s = e.input, o = e.c, a = i[0], h = i[1]; c < h; )
            n = s[o++],
            n === y && t(Error("input buffer is broken")),
            r |= n << c,
            c += 8;
        return s = a[r & (1 << h) - 1],
        a = s >>> 16,
        e.g = r >> a,
        e.e = c - a,
        e.c = o,
        65535 & s
    }
    function g(t) {
        function e(t, e, i) {
            var n, r, c, s;
            for (s = 0; s < t; )
                switch (n = f(this, e)) {
                case 16:
                    for (c = 3 + p(this, 2); c--; )
                        i[s++] = r;
                    break;
                case 17:
                    for (c = 3 + p(this, 3); c--; )
                        i[s++] = 0;
                    r = 0;
                    break;
                case 18:
                    for (c = 11 + p(this, 7); c--; )
                        i[s++] = 0;
                    r = 0;
                    break;
                default:
                    r = i[s++] = n
                }
            return i
        }
        var i, n = p(t, 5) + 257, r = p(t, 5) + 1, s = p(t, 4) + 4, o = new (A ? Uint8Array : Array)(B.length);
        for (i = 0; i < s; ++i)
            o[B[i]] = p(t, 3);
        s = c(o),
        o = new (A ? Uint8Array : Array)(n),
        i = new (A ? Uint8Array : Array)(r),
        t.o(c(e.call(t, n, s, o)), c(e.call(t, r, s, i)))
    }
    function m(e, i) {
        var n, r;
        switch (this.input = e,
        this.c = 0,
        !i && (i = {}) || (i.index && (this.c = i.index),
        i.verify && (this.M = i.verify)),
        n = e[this.c++],
        r = e[this.c++],
        15 & n) {
        case U:
            this.method = U;
            break;
        default:
            t(Error("unsupported compression method"))
        }
        0 !== ((n << 8) + r) % 31 && t(Error("invalid fcheck flag:" + ((n << 8) + r) % 31)),
        32 & r && t(Error("fdict flag is not supported")),
        this.A = new _(e,{
            index: this.c,
            bufferSize: i.bufferSize,
            bufferType: i.bufferType,
            resize: i.resize
        })
    }
    var y = void 0
      , T = !0
      , v = this
      , A = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array;
    n.prototype.f = function() {
        var t, e = this.buffer, i = e.length, n = new (A ? Uint8Array : Array)(i << 1);
        if (A)
            n.set(e);
        else
            for (t = 0; t < i; ++t)
                n[t] = e[t];
        return this.buffer = n
    }
    ,
    n.prototype.d = function(t, e, i) {
        var n = this.buffer
          , r = this.index
          , c = this.i
          , s = n[r];
        if (i && 1 < e && (t = 8 < e ? (b[255 & t] << 24 | b[t >>> 8 & 255] << 16 | b[t >>> 16 & 255] << 8 | b[t >>> 24 & 255]) >> 32 - e : b[t] >> 8 - e),
        8 > e + c)
            s = s << e | t,
            c += e;
        else
            for (i = 0; i < e; ++i)
                s = s << 1 | t >> e - i - 1 & 1,
                8 === ++c && (c = 0,
                n[r++] = b[s],
                s = 0,
                r === n.length && (n = this.f()));
        n[r] = s,
        this.buffer = n,
        this.i = c,
        this.index = r
    }
    ,
    n.prototype.finish = function() {
        var t, e = this.buffer, i = this.index;
        return 0 < this.i && (e[i] <<= 8 - this.i,
        e[i] = b[e[i]],
        i++),
        A ? t = e.subarray(0, i) : (e.length = i,
        t = e),
        t
    }
    ;
    var S, E = new (A ? Uint8Array : Array)(256);
    for (S = 0; 256 > S; ++S) {
        for (var x = S, C = x, I = 7, x = x >>> 1; x; x >>>= 1)
            C <<= 1,
            C |= 1 & x,
            --I;
        E[S] = (C << I & 255) >>> 0
    }
    var b = E
      , E = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117];
    A && new Uint32Array(E),
    r.prototype.getParent = function(t) {
        return 2 * ((t - 2) / 4 | 0)
    }
    ,
    r.prototype.push = function(t, e) {
        var i, n, r, c = this.buffer;
        for (i = this.length,
        c[this.length++] = e,
        c[this.length++] = t; 0 < i && (n = this.getParent(i),
        c[i] > c[n]); )
            r = c[i],
            c[i] = c[n],
            c[n] = r,
            r = c[i + 1],
            c[i + 1] = c[n + 1],
            c[n + 1] = r,
            i = n;
        return this.length
    }
    ,
    r.prototype.pop = function() {
        var t, e, i, n, r, c = this.buffer;
        for (e = c[0],
        t = c[1],
        this.length -= 2,
        c[0] = c[this.length],
        c[1] = c[this.length + 1],
        r = 0; (n = 2 * r + 2,
        !(n >= this.length)) && (n + 2 < this.length && c[n + 2] > c[n] && (n += 2),
        c[n] > c[r]); )
            i = c[r],
            c[r] = c[n],
            c[n] = i,
            i = c[r + 1],
            c[r + 1] = c[n + 1],
            c[n + 1] = i,
            r = n;
        return {
            index: t,
            value: e,
            length: this.length
        }
    }
    ;
    var R = 2
      , E = {
        NONE: 0,
        r: 1,
        j: R,
        N: 3
    }
      , w = [];
    for (S = 0; 288 > S; S++)
        switch (T) {
        case 143 >= S:
            w.push([S + 48, 8]);
            break;
        case 255 >= S:
            w.push([S - 144 + 400, 9]);
            break;
        case 279 >= S:
            w.push([S - 256 + 0, 7]);
            break;
        case 287 >= S:
            w.push([S - 280 + 192, 8]);
            break;
        default:
            t("invalid literal: " + S)
        }
    s.prototype.n = function() {
        var e, i, r, c, s = this.input;
        switch (this.h) {
        case 0:
            for (r = 0,
            c = s.length; r < c; ) {
                i = A ? s.subarray(r, r + 65535) : s.slice(r, r + 65535),
                r += i.length;
                var o = r === c
                  , a = y
                  , d = a = y
                  , d = a = y
                  , _ = this.a
                  , p = this.b;
                if (A) {
                    for (_ = new Uint8Array(this.a.buffer); _.length <= p + i.length + 5; )
                        _ = new Uint8Array(_.length << 1);
                    _.set(this.a)
                }
                if (a = o ? 1 : 0,
                _[p++] = 0 | a,
                a = i.length,
                d = ~a + 65536 & 65535,
                _[p++] = 255 & a,
                _[p++] = a >>> 8 & 255,
                _[p++] = 255 & d,
                _[p++] = d >>> 8 & 255,
                A)
                    _.set(i, p),
                    p += i.length,
                    _ = _.subarray(0, p);
                else {
                    for (a = 0,
                    d = i.length; a < d; ++a)
                        _[p++] = i[a];
                    _.length = p
                }
                this.b = p,
                this.a = _
            }
            break;
        case 1:
            for (r = new n(new Uint8Array(this.a.buffer),this.b),
            r.d(1, 1, T),
            r.d(1, 2, T),
            s = h(this, s),
            i = 0,
            o = s.length; i < o; i++)
                if (c = s[i],
                n.prototype.d.apply(r, w[c]),
                256 < c)
                    r.d(s[++i], s[++i], T),
                    r.d(s[++i], 5),
                    r.d(s[++i], s[++i], T);
                else if (256 === c)
                    break;
            this.a = r.finish(),
            this.b = this.a.length;
            break;
        case R:
            c = new n(new Uint8Array(this.a),this.b);
            var f, g, m, v, S, E, x = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], a = Array(19), _ = R;
            for (c.d(1, 1, T),
            c.d(_, 2, T),
            s = h(this, s),
            d = l(this.L, 15),
            v = u(d),
            _ = l(this.K, 7),
            p = u(_),
            f = 286; 257 < f && 0 === d[f - 1]; f--)
                ;
            for (g = 30; 1 < g && 0 === _[g - 1]; g--)
                ;
            var C = f
              , I = g;
            e = new (A ? Uint32Array : Array)(C + I);
            var b, P, L = new (A ? Uint32Array : Array)(316);
            for (S = new (A ? Uint8Array : Array)(19),
            E = m = 0; E < C; E++)
                e[m++] = d[E];
            for (E = 0; E < I; E++)
                e[m++] = _[E];
            if (!A)
                for (E = 0,
                I = S.length; E < I; ++E)
                    S[E] = 0;
            for (E = b = 0,
            I = e.length; E < I; E += m) {
                for (m = 1; E + m < I && e[E + m] === e[E]; ++m)
                    ;
                if (C = m,
                0 === e[E])
                    if (3 > C)
                        for (; 0 < C--; )
                            L[b++] = 0,
                            S[0]++;
                    else
                        for (; 0 < C; )
                            P = 138 > C ? C : 138,
                            P > C - 3 && P < C && (P = C - 3),
                            10 >= P ? (L[b++] = 17,
                            L[b++] = P - 3,
                            S[17]++) : (L[b++] = 18,
                            L[b++] = P - 11,
                            S[18]++),
                            C -= P;
                else if (L[b++] = e[E],
                S[e[E]]++,
                C--,
                3 > C)
                    for (; 0 < C--; )
                        L[b++] = e[E],
                        S[e[E]]++;
                else
                    for (; 0 < C; )
                        P = 6 > C ? C : 6,
                        P > C - 3 && P < C && (P = C - 3),
                        L[b++] = 16,
                        L[b++] = P - 3,
                        S[16]++,
                        C -= P
            }
            for (e = A ? L.subarray(0, b) : L.slice(0, b),
            S = l(S, 7),
            E = 0; 19 > E; E++)
                a[E] = S[x[E]];
            for (m = 19; 4 < m && 0 === a[m - 1]; m--)
                ;
            for (x = u(S),
            c.d(f - 257, 5, T),
            c.d(g - 1, 5, T),
            c.d(m - 4, 4, T),
            E = 0; E < m; E++)
                c.d(a[E], 3, T);
            for (E = 0,
            a = e.length; E < a; E++)
                if (i = e[E],
                c.d(x[i], S[i], T),
                16 <= i) {
                    switch (E++,
                    i) {
                    case 16:
                        o = 2;
                        break;
                    case 17:
                        o = 3;
                        break;
                    case 18:
                        o = 7;
                        break;
                    default:
                        t("invalid code: " + i)
                    }
                    c.d(e[E], o, T)
                }
            for (o = [v, d],
            p = [p, _],
            i = o[0],
            o = o[1],
            _ = p[0],
            v = p[1],
            p = 0,
            a = s.length; p < a; ++p)
                if (r = s[p],
                c.d(i[r], o[r], T),
                256 < r)
                    c.d(s[++p], s[++p], T),
                    d = s[++p],
                    c.d(_[d], v[d], T),
                    c.d(s[++p], s[++p], T);
                else if (256 === r)
                    break;
            this.a = c.finish(),
            this.b = this.a.length;
            break;
        default:
            t("invalid compression type")
        }
        return this.a
    }
    ,
    S = [];
    var P;
    for (P = 3; 258 >= P; P++)
        x = a(),
        S[P] = x[2] << 24 | x[1] << 16 | x[0];
    var L = A ? new Uint32Array(S) : S
      , F = E;
    d.prototype.n = function() {
        var e, n, r, c, s = 0;
        switch (c = this.a,
        e = U) {
        case U:
            n = Math.LOG2E * Math.log(32768) - 8;
            break;
        default:
            t(Error("invalid compression method"))
        }
        switch (n = n << 4 | e,
        c[s++] = n,
        e) {
        case U:
            switch (this.h) {
            case F.NONE:
                r = 0;
                break;
            case F.r:
                r = 1;
                break;
            case F.j:
                r = 2;
                break;
            default:
                t(Error("unsupported compression type"))
            }
            break;
        default:
            t(Error("invalid compression method"))
        }
        return e = r << 6 | 0,
        c[s++] = e | 31 - (256 * n + e) % 31,
        e = i(this.input),
        this.z.b = s,
        c = this.z.n(),
        s = c.length,
        A && (c = new Uint8Array(c.buffer),
        c.length <= s + 4 && (this.a = new Uint8Array(c.length + 4),
        this.a.set(c),
        c = this.a),
        c = c.subarray(0, s + 4)),
        c[s++] = e >> 24 & 255,
        c[s++] = e >> 16 & 255,
        c[s++] = e >> 8 & 255,
        c[s++] = 255 & e,
        c
    }
    ,
    e("Zlib.Deflate", d),
    e("Zlib.Deflate.compress", function(t, e) {
        return new d(t,e).n()
    }),
    e("Zlib.Deflate.CompressionType", F),
    e("Zlib.Deflate.CompressionType.NONE", F.NONE),
    e("Zlib.Deflate.CompressionType.FIXED", F.r),
    e("Zlib.Deflate.CompressionType.DYNAMIC", F.j);
    var O = 0
      , D = 1
      , E = {
        D: O,
        C: D
    };
    _.prototype.p = function() {
        for (; !this.s; ) {
            var e = p(this, 3);
            switch (1 & e && (this.s = T),
            e >>>= 1) {
            case 0:
                var e = this.input
                  , i = this.c
                  , n = this.a
                  , r = this.b
                  , c = y
                  , s = y
                  , o = y
                  , a = n.length
                  , c = y;
                switch (this.e = this.g = 0,
                c = e[i++],
                c === y && t(Error("invalid uncompressed block header: LEN (first byte)")),
                s = c,
                c = e[i++],
                c === y && t(Error("invalid uncompressed block header: LEN (second byte)")),
                s |= c << 8,
                c = e[i++],
                c === y && t(Error("invalid uncompressed block header: NLEN (first byte)")),
                o = c,
                c = e[i++],
                c === y && t(Error("invalid uncompressed block header: NLEN (second byte)")),
                o |= c << 8,
                s === ~o && t(Error("invalid uncompressed block header: length verify")),
                i + s > e.length && t(Error("input buffer is broken")),
                this.m) {
                case O:
                    for (; r + s > n.length; ) {
                        if (c = a - r,
                        s -= c,
                        A)
                            n.set(e.subarray(i, i + c), r),
                            r += c,
                            i += c;
                        else
                            for (; c--; )
                                n[r++] = e[i++];
                        this.b = r,
                        n = this.f(),
                        r = this.b
                    }
                    break;
                case D:
                    for (; r + s > n.length; )
                        n = this.f({
                            v: 2
                        });
                    break;
                default:
                    t(Error("invalid inflate mode"))
                }
                if (A)
                    n.set(e.subarray(i, i + s), r),
                    r += s,
                    i += s;
                else
                    for (; s--; )
                        n[r++] = e[i++];
                this.c = i,
                this.b = r,
                this.a = n;
                break;
            case 1:
                this.o(V, z);
                break;
            case 2:
                g(this);
                break;
            default:
                t(Error("unknown BTYPE: " + e))
            }
        }
        return this.t()
    }
    ,
    S = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var B = A ? new Uint16Array(S) : S;
    S = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258];
    var N = A ? new Uint16Array(S) : S;
    S = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0];
    var M = A ? new Uint8Array(S) : S;
    S = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
    var W = A ? new Uint16Array(S) : S;
    S = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
    var G = A ? new Uint8Array(S) : S;
    for (S = new (A ? Uint8Array : Array)(288),
    x = 0,
    C = S.length; x < C; ++x)
        S[x] = 143 >= x ? 8 : 255 >= x ? 9 : 279 >= x ? 7 : 8;
    var V = c(S);
    for (S = new (A ? Uint8Array : Array)(30),
    x = 0,
    C = S.length; x < C; ++x)
        S[x] = 5;
    var z = c(S);
    for (_.prototype.o = function(t, e) {
        var i = this.a
          , n = this.b;
        this.u = t;
        for (var r, c, s, o = i.length - 258; 256 !== (r = f(this, t)); )
            if (256 > r)
                n >= o && (this.b = n,
                i = this.f(),
                n = this.b),
                i[n++] = r;
            else
                for (r -= 257,
                s = N[r],
                0 < M[r] && (s += p(this, M[r])),
                r = f(this, e),
                c = W[r],
                0 < G[r] && (c += p(this, G[r])),
                n >= o && (this.b = n,
                i = this.f(),
                n = this.b); s--; )
                    i[n] = i[n++ - c];
        for (; 8 <= this.e; )
            this.e -= 8,
            this.c--;
        this.b = n
    }
    ,
    _.prototype.I = function(t, e) {
        var i = this.a
          , n = this.b;
        this.u = t;
        for (var r, c, s, o = i.length; 256 !== (r = f(this, t)); )
            if (256 > r)
                n >= o && (i = this.f(),
                o = i.length),
                i[n++] = r;
            else
                for (r -= 257,
                s = N[r],
                0 < M[r] && (s += p(this, M[r])),
                r = f(this, e),
                c = W[r],
                0 < G[r] && (c += p(this, G[r])),
                n + s > o && (i = this.f(),
                o = i.length); s--; )
                    i[n] = i[n++ - c];
        for (; 8 <= this.e; )
            this.e -= 8,
            this.c--;
        this.b = n
    }
    ,
    _.prototype.f = function() {
        var t, e, i = new (A ? Uint8Array : Array)(this.b - 32768), n = this.b - 32768, r = this.a;
        if (A)
            i.set(r.subarray(32768, i.length));
        else
            for (t = 0,
            e = i.length; t < e; ++t)
                i[t] = r[t + 32768];
        if (this.k.push(i),
        this.q += i.length,
        A)
            r.set(r.subarray(n, n + 32768));
        else
            for (t = 0; 32768 > t; ++t)
                r[t] = r[n + t];
        return this.b = 32768,
        r
    }
    ,
    _.prototype.J = function(t) {
        var e, i, n, r, c = this.input.length / this.c + 1 | 0, s = this.input, o = this.a;
        return t && ("number" == typeof t.v && (c = t.v),
        "number" == typeof t.F && (c += t.F)),
        2 > c ? (i = (s.length - this.c) / this.u[2],
        r = i / 2 * 258 | 0,
        n = r < o.length ? o.length + r : o.length << 1) : n = o.length * c,
        A ? (e = new Uint8Array(n),
        e.set(o)) : e = o,
        this.a = e
    }
    ,
    _.prototype.t = function() {
        var t, e, i, n, r, c = 0, s = this.a, o = this.k, a = new (A ? Uint8Array : Array)(this.q + (this.b - 32768));
        if (0 === o.length)
            return A ? this.a.subarray(32768, this.b) : this.a.slice(32768, this.b);
        for (e = 0,
        i = o.length; e < i; ++e)
            for (t = o[e],
            n = 0,
            r = t.length; n < r; ++n)
                a[c++] = t[n];
        for (e = 32768,
        i = this.b; e < i; ++e)
            a[c++] = s[e];
        return this.k = [],
        this.buffer = a
    }
    ,
    _.prototype.H = function() {
        var t, e = this.b;
        return A ? this.B ? (t = new Uint8Array(e),
        t.set(this.a.subarray(0, e))) : t = this.a.subarray(0, e) : (this.a.length > e && (this.a.length = e),
        t = this.a),
        this.buffer = t
    }
    ,
    m.prototype.p = function() {
        var e, n, r = this.input;
        return e = this.A.p(),
        this.c = this.A.c,
        this.M && (n = (r[this.c++] << 24 | r[this.c++] << 16 | r[this.c++] << 8 | r[this.c++]) >>> 0,
        n !== i(e) && t(Error("invalid adler-32 checksum"))),
        e
    }
    ,
    e("Zlib.Inflate", m),
    e("Zlib.Inflate.BufferType", E),
    E.ADAPTIVE = E.C,
    E.BLOCK = E.D,
    e("Zlib.Inflate.prototype.decompress", m.prototype.p),
    E = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
    A && new Uint16Array(E),
    E = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258],
    A && new Uint16Array(E),
    E = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0],
    A && new Uint8Array(E),
    E = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577],
    A && new Uint16Array(E),
    E = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13],
    A && new Uint8Array(E),
    E = new (A ? Uint8Array : Array)(288),
    S = 0,
    x = E.length; S < x; ++S)
        E[S] = 143 >= S ? 8 : 255 >= S ? 9 : 279 >= S ? 7 : 8;
    for (c(E),
    E = new (A ? Uint8Array : Array)(30),
    S = 0,
    x = E.length; S < x; ++S)
        E[S] = 5;
    c(E);
    var U = 8
}
.call(this),
_p = window,
_p = _p.Zlib = _p.Zlib,
_p.Deflate = _p.Deflate,
_p.Deflate.compress = _p.Deflate.compress,
_p.Inflate = _p.Inflate,
_p.Inflate.BufferType = _p.Inflate.BufferType,
_p.Inflate.prototype.decompress = _p.Inflate.prototype.decompress,
cc.PNGReader = cc.Class.extend({
    ctor: function(t) {
        var e, i, n, r;
        for (this.data = t,
        this.pos = 8,
        this.palette = [],
        this.imgData = [],
        this.transparency = {},
        this.animation = null,
        this.text = {},
        n = null; ; ) {
            for (e = this.readUInt32(),
            r = t = void 0,
            r = [],
            t = 0; 4 > t; ++t)
                r.push(String.fromCharCode(this.data[this.pos++]));
            switch (t = r.join("")) {
            case "IHDR":
                this.width = this.readUInt32(),
                this.height = this.readUInt32(),
                this.bits = this.data[this.pos++],
                this.colorType = this.data[this.pos++],
                this.compressionMethod = this.data[this.pos++],
                this.filterMethod = this.data[this.pos++],
                this.interlaceMethod = this.data[this.pos++];
                break;
            case "acTL":
                this.animation = {
                    numFrames: this.readUInt32(),
                    numPlays: this.readUInt32() || 1 / 0,
                    frames: []
                };
                break;
            case "PLTE":
                this.palette = this.read(e);
                break;
            case "fcTL":
                n && this.animation.frames.push(n),
                this.pos += 4,
                n = {
                    width: this.readUInt32(),
                    height: this.readUInt32(),
                    xOffset: this.readUInt32(),
                    yOffset: this.readUInt32()
                },
                t = this.readUInt16(),
                e = this.readUInt16() || 100,
                n.delay = 1e3 * t / e,
                n.disposeOp = this.data[this.pos++],
                n.blendOp = this.data[this.pos++],
                n.data = [];
                break;
            case "IDAT":
            case "fdAT":
                for ("fdAT" === t && (this.pos += 4,
                e -= 4),
                t = (null != n ? n.data : void 0) || this.imgData,
                r = 0; 0 <= e ? r < e : r > e; 0 <= e ? ++r : --r)
                    t.push(this.data[this.pos++]);
                break;
            case "tRNS":
                switch (this.transparency = {},
                this.colorType) {
                case 3:
                    if (this.transparency.indexed = this.read(e),
                    e = 255 - this.transparency.indexed.length,
                    0 < e)
                        for (t = 0; 0 <= e ? t < e : t > e; 0 <= e ? ++t : --t)
                            this.transparency.indexed.push(255);
                    break;
                case 0:
                    this.transparency.grayscale = this.read(e)[0];
                    break;
                case 2:
                    this.transparency.rgb = this.read(e)
                }
                break;
            case "tEXt":
                r = this.read(e),
                e = r.indexOf(0),
                t = String.fromCharCode.apply(String, r.slice(0, e)),
                this.text[t] = String.fromCharCode.apply(String, r.slice(e + 1));
                break;
            case "IEND":
                n && this.animation.frames.push(n);
                t: {
                    switch (this.colorType) {
                    case 0:
                    case 3:
                    case 4:
                        n = 1;
                        break t;
                    case 2:
                    case 6:
                        n = 3;
                        break t
                    }
                    n = void 0
                }
                this.colors = n,
                this.hasAlphaChannel = 4 === (i = this.colorType) || 6 === i,
                i = this.colors + (this.hasAlphaChannel ? 1 : 0),
                this.pixelBitlength = this.bits * i;
                t: {
                    switch (this.colors) {
                    case 1:
                        i = "DeviceGray";
                        break t;
                    case 3:
                        i = "DeviceRGB";
                        break t
                    }
                    i = void 0
                }
                return this.colorSpace = i,
                void (Uint8Array != Array && (this.imgData = new Uint8Array(this.imgData)));
            default:
                this.pos += e
            }
            if (this.pos += 4,
            this.pos > this.data.length)
                throw Error("Incomplete or corrupt PNG file")
        }
    },
    read: function(t) {
        var e, i;
        for (i = [],
        e = 0; 0 <= t ? e < t : e > t; 0 <= t ? ++e : --e)
            i.push(this.data[this.pos++]);
        return i
    },
    readUInt32: function() {
        var t, e, i, n;
        return t = this.data[this.pos++] << 24,
        e = this.data[this.pos++] << 16,
        i = this.data[this.pos++] << 8,
        n = this.data[this.pos++],
        t | e | i | n
    },
    readUInt16: function() {
        var t, e;
        return t = this.data[this.pos++] << 8,
        e = this.data[this.pos++],
        t | e
    },
    decodePixels: function(t) {
        var e, i, n, r, c, s, o, a, h, l, u, d, _, p, f;
        if (null == t && (t = this.imgData),
        0 === t.length)
            return new Uint8Array(0);
        for (t = new Zlib.Inflate(t,{
            index: 0,
            verify: !1
        }).decompress(),
        a = this.pixelBitlength / 8,
        d = a * this.width,
        h = new Uint8Array(d * this.height),
        s = t.length,
        i = l = u = 0; l < s; ) {
            switch (t[l++]) {
            case 0:
                for (e = 0; e < d; e += 1)
                    h[i++] = t[l++];
                break;
            case 1:
                for (r = _ = 0; _ < d; r = _ += 1)
                    e = t[l++],
                    c = r < a ? 0 : h[i - a],
                    h[i++] = (e + c) % 256;
                break;
            case 2:
                for (r = c = 0; c < d; r = c += 1)
                    e = t[l++],
                    n = (r - r % a) / a,
                    _ = u && h[(u - 1) * d + n * a + r % a],
                    h[i++] = (_ + e) % 256;
                break;
            case 3:
                for (r = f = 0; f < d; r = f += 1)
                    e = t[l++],
                    n = (r - r % a) / a,
                    c = r < a ? 0 : h[i - a],
                    _ = u && h[(u - 1) * d + n * a + r % a],
                    h[i++] = (e + Math.floor((c + _) / 2)) % 256;
                break;
            case 4:
                for (r = f = 0; f < d; r = f += 1)
                    e = t[l++],
                    n = (r - r % a) / a,
                    c = r < a ? 0 : h[i - a],
                    0 === u ? _ = p = 0 : (_ = h[(u - 1) * d + n * a + r % a],
                    p = n && h[(u - 1) * d + (n - 1) * a + r % a]),
                    o = c + _ - p,
                    r = Math.abs(o - c),
                    n = Math.abs(o - _),
                    o = Math.abs(o - p),
                    c = r <= n && r <= o ? c : n <= o ? _ : p,
                    h[i++] = (e + c) % 256;
                break;
            default:
                throw Error("Invalid filter algorithm: " + t[l - 1])
            }
            u++
        }
        return h
    },
    copyToImageData: function(t, e) {
        var i, n, r, c, s, o, a, h;
        if (n = this.colors,
        h = null,
        i = this.hasAlphaChannel,
        this.palette.length && (h = null != (r = this._decodedPalette) ? r : this._decodedPalette = this.decodePalette(),
        n = 4,
        i = !0),
        r = t.data || t,
        a = r.length,
        s = h || e,
        c = o = 0,
        1 === n)
            for (; c < a; )
                n = h ? 4 * e[c / 4] : o,
                o = s[n++],
                r[c++] = o,
                r[c++] = o,
                r[c++] = o,
                r[c++] = i ? s[n++] : 255,
                o = n;
        else
            for (; c < a; )
                n = h ? 4 * e[c / 4] : o,
                r[c++] = s[n++],
                r[c++] = s[n++],
                r[c++] = s[n++],
                r[c++] = i ? s[n++] : 255,
                o = n
    },
    decodePalette: function() {
        var t, e, i, n, r, c, s, o, a;
        for (i = this.palette,
        c = this.transparency.indexed || [],
        r = new Uint8Array((c.length || 0) + i.length),
        e = s = t = n = 0,
        o = i.length; s < o; e = s += 3)
            r[n++] = i[e],
            r[n++] = i[e + 1],
            r[n++] = i[e + 2],
            r[n++] = null != (a = c[t++]) ? a : 255;
        return r
    },
    render: function(t) {
        var e;
        return t.width = this.width,
        t.height = this.height,
        t = t.getContext("2d"),
        e = t.createImageData(this.width, this.height),
        this.copyToImageData(e, this.decodePixels()),
        t.putImageData(e, 0, 0)
    }
}),
cc.tiffReader = {
    _littleEndian: !1,
    _tiffData: null,
    _fileDirectories: [],
    getUint8: function(t) {
        return this._tiffData[t]
    },
    getUint16: function(t) {
        return this._littleEndian ? this._tiffData[t + 1] << 8 | this._tiffData[t] : this._tiffData[t] << 8 | this._tiffData[t + 1]
    },
    getUint32: function(t) {
        var e = this._tiffData;
        return this._littleEndian ? e[t + 3] << 24 | e[t + 2] << 16 | e[t + 1] << 8 | e[t] : e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]
    },
    checkLittleEndian: function() {
        var t = this.getUint16(0);
        if (18761 === t)
            this.littleEndian = !0;
        else {
            if (19789 !== t)
                throw console.log(t),
                TypeError("Invalid byte order value.");
            this.littleEndian = !1
        }
        return this.littleEndian
    },
    hasTowel: function() {
        if (42 !== this.getUint16(2))
            throw RangeError("You forgot your towel!");
        return !0
    },
    getFieldTypeName: function(t) {
        var e = this.fieldTypeNames;
        return t in e ? e[t] : null
    },
    getFieldTagName: function(t) {
        var e = this.fieldTagNames;
        return t in e ? e[t] : (console.log("Unknown Field Tag:", t),
        "Tag" + t)
    },
    getFieldTypeLength: function(t) {
        return -1 !== ["BYTE", "ASCII", "SBYTE", "UNDEFINED"].indexOf(t) ? 1 : -1 !== ["SHORT", "SSHORT"].indexOf(t) ? 2 : -1 !== ["LONG", "SLONG", "FLOAT"].indexOf(t) ? 4 : -1 !== ["RATIONAL", "SRATIONAL", "DOUBLE"].indexOf(t) ? 8 : null
    },
    getFieldValues: function(t, e, i, n) {
        t = [];
        var r = this.getFieldTypeLength(e);
        if (4 >= r * i)
            !1 === this.littleEndian ? t.push(n >>> 8 * (4 - r)) : t.push(n);
        else
            for (var c = 0; c < i; c++) {
                var s = r * c;
                8 <= r ? -1 !== ["RATIONAL", "SRATIONAL"].indexOf(e) ? (t.push(this.getUint32(n + s)),
                t.push(this.getUint32(n + s + 4))) : cc.log("Can't handle this field type or size") : t.push(this.getBytes(r, n + s))
            }
        return "ASCII" === e && t.forEach(function(t, e, i) {
            i[e] = String.fromCharCode(t)
        }),
        t
    },
    getBytes: function(t, e) {
        if (0 >= t)
            cc.log("No bytes requested");
        else {
            if (1 >= t)
                return this.getUint8(e);
            if (2 >= t)
                return this.getUint16(e);
            if (3 >= t)
                return this.getUint32(e) >>> 8;
            if (4 >= t)
                return this.getUint32(e);
            cc.log("Too many bytes requested")
        }
    },
    getBits: function(t, e, i) {
        i = i || 0,
        e += Math.floor(i / 8);
        var n = i + t;
        t = 32 - t;
        var r, c;
        return 0 >= n ? console.log("No bits requested") : 8 >= n ? (r = 24 + i,
        c = this.getUint8(e)) : 16 >= n ? (r = 16 + i,
        c = this.getUint16(e)) : 32 >= n ? (r = i,
        c = this.getUint32(e)) : console.log("Too many bits requested"),
        {
            bits: c << r >>> t,
            byteOffset: e + Math.floor(n / 8),
            bitOffset: n % 8
        }
    },
    parseFileDirectory: function(t) {
        var e = this.getUint16(t)
          , i = [];
        t += 2;
        for (var n = 0; n < e; t += 12,
        n++) {
            var r = this.getUint16(t)
              , c = this.getUint16(t + 2)
              , s = this.getUint32(t + 4)
              , o = this.getUint32(t + 8)
              , r = this.getFieldTagName(r)
              , c = this.getFieldTypeName(c)
              , s = this.getFieldValues(r, c, s, o);
            i[r] = {
                type: c,
                values: s
            }
        }
        this._fileDirectories.push(i),
        e = this.getUint32(t),
        0 !== e && this.parseFileDirectory(e)
    },
    clampColorSample: function(t, e) {
        var i = Math.pow(2, 8 - e);
        return Math.floor(t * i + (i - 1))
    },
    parseTIFF: function(t, e) {
        if (e = e || document.createElement("canvas"),
        this._tiffData = t,
        this.canvas = e,
        this.checkLittleEndian(),
        this.hasTowel()) {
            var i = this.getUint32(4);
            this._fileDirectories.length = 0,
            this.parseFileDirectory(i);
            var n = this._fileDirectories[0]
              , i = n.ImageWidth.values[0]
              , r = n.ImageLength.values[0];
            this.canvas.width = i,
            this.canvas.height = r;
            var c = []
              , s = n.Compression ? n.Compression.values[0] : 1
              , o = n.SamplesPerPixel.values[0]
              , a = []
              , h = 0
              , l = !1;
            if (n.BitsPerSample.values.forEach(function(t, e, i) {
                a[e] = {
                    bitsPerSample: t,
                    hasBytesPerSample: !1,
                    bytesPerSample: void 0
                },
                0 === t % 8 && (a[e].hasBytesPerSample = !0,
                a[e].bytesPerSample = t / 8),
                h += t
            }, this),
            0 === h % 8)
                var l = !0
                  , u = h / 8;
            var d = n.StripOffsets.values
              , _ = d.length;
            if (n.StripByteCounts)
                var p = n.StripByteCounts.values;
            else {
                if (cc.log("Missing StripByteCounts!"),
                1 !== _)
                    throw Error("Cannot recover from missing StripByteCounts");
                p = [Math.ceil(i * r * h / 8)]
            }
            for (var f = 0; f < _; f++) {
                var g = d[f];
                c[f] = [];
                for (var m = p[f], y = 0, T = 0, v = 1, A = !0, S = [], E = 0, x = 0, C = 0; y < m; y += v)
                    switch (s) {
                    case 1:
                        for (v = 0,
                        S = []; v < o; v++) {
                            if (!a[v].hasBytesPerSample) {
                                var I = this.getBits(a[v].bitsPerSample, g + y, T);
                                throw S.push(I.bits),
                                y = I.byteOffset - g,
                                T = I.bitOffset,
                                RangeError("Cannot handle sub-byte bits per sample")
                            }
                            S.push(this.getBytes(a[v].bytesPerSample, g + y + a[v].bytesPerSample * v))
                        }
                        if (c[f].push(S),
                        !l)
                            throw v = 0,
                            RangeError("Cannot handle sub-byte bits per pixel");
                        v = u;
                        break;
                    case 32773:
                        if (A) {
                            var A = !1
                              , b = 1
                              , R = 1
                              , v = this.getInt8(g + y);
                            0 <= v && 127 >= v ? b = v + 1 : -127 <= v && -1 >= v ? R = -v + 1 : A = !0
                        } else {
                            for (var w = this.getUint8(g + y), v = 0; v < R; v++) {
                                if (!a[x].hasBytesPerSample)
                                    throw RangeError("Cannot handle sub-byte bits per sample");
                                C = C << 8 * E | w,
                                E++,
                                E === a[x].bytesPerSample && (S.push(C),
                                C = E = 0,
                                x++),
                                x === o && (c[f].push(S),
                                S = [],
                                x = 0)
                            }
                            b--,
                            0 === b && (A = !0)
                        }
                        v = 1
                    }
            }
            if (e.getContext) {
                if (u = this.canvas.getContext("2d"),
                u.fillStyle = "rgba(255, 255, 255, 0)",
                f = n.RowsPerStrip ? n.RowsPerStrip.values[0] : r,
                g = c.length,
                r %= f,
                r = 0 === r ? f : r,
                y = f,
                s = 0,
                S = n.PhotometricInterpretation.values[0],
                b = [],
                R = 0,
                n.ExtraSamples && (b = n.ExtraSamples.values,
                R = b.length),
                n.ColorMap)
                    var I = n.ColorMap.values
                      , P = Math.pow(2, a[0].bitsPerSample);
                for (f = 0; f < g; f++) {
                    for (f + 1 === g && (y = r),
                    n = c[f].length,
                    s *= f,
                    l = o = 0; l < n; o++)
                        for (d = 0; d < i; d++,
                        l++) {
                            if (p = c[f][l],
                            A = T = m = 0,
                            _ = 1,
                            0 < R)
                                for (m = 0; m < R; m++)
                                    if (1 === b[m] || 2 === b[m]) {
                                        _ = p[3 + m] / 256;
                                        break
                                    }
                            switch (S) {
                            case 0:
                                if (a[0].hasBytesPerSample)
                                    var L = Math.pow(16, 2 * a[0].bytesPerSample);
                                p.forEach(function(t, e, i) {
                                    i[e] = L - t
                                });
                            case 1:
                                m = T = A = this.clampColorSample(p[0], a[0].bitsPerSample);
                                break;
                            case 2:
                                m = this.clampColorSample(p[0], a[0].bitsPerSample),
                                T = this.clampColorSample(p[1], a[1].bitsPerSample),
                                A = this.clampColorSample(p[2], a[2].bitsPerSample);
                                break;
                            case 3:
                                if (void 0 === I)
                                    throw Error("Palette image missing color map");
                                p = p[0],
                                m = this.clampColorSample(I[p], 16),
                                T = this.clampColorSample(I[P + p], 16),
                                A = this.clampColorSample(I[2 * P + p], 16);
                                break;
                            default:
                                throw RangeError("Unknown Photometric Interpretation:", S)
                            }
                            u.fillStyle = "rgba(" + m + ", " + T + ", " + A + ", " + _ + ")",
                            u.fillRect(d, s + o, 1, 1)
                        }
                    s = y
                }
            }
            return this.canvas
        }
    },
    fieldTagNames: {
        315: "Artist",
        258: "BitsPerSample",
        265: "CellLength",
        264: "CellWidth",
        320: "ColorMap",
        259: "Compression",
        33432: "Copyright",
        306: "DateTime",
        338: "ExtraSamples",
        266: "FillOrder",
        289: "FreeByteCounts",
        288: "FreeOffsets",
        291: "GrayResponseCurve",
        290: "GrayResponseUnit",
        316: "HostComputer",
        270: "ImageDescription",
        257: "ImageLength",
        256: "ImageWidth",
        271: "Make",
        281: "MaxSampleValue",
        280: "MinSampleValue",
        272: "Model",
        254: "NewSubfileType",
        274: "Orientation",
        262: "PhotometricInterpretation",
        284: "PlanarConfiguration",
        296: "ResolutionUnit",
        278: "RowsPerStrip",
        277: "SamplesPerPixel",
        305: "Software",
        279: "StripByteCounts",
        273: "StripOffsets",
        255: "SubfileType",
        263: "Threshholding",
        282: "XResolution",
        283: "YResolution",
        326: "BadFaxLines",
        327: "CleanFaxData",
        343: "ClipPath",
        328: "ConsecutiveBadFaxLines",
        433: "Decode",
        434: "DefaultImageColor",
        269: "DocumentName",
        336: "DotRange",
        321: "HalftoneHints",
        346: "Indexed",
        347: "JPEGTables",
        285: "PageName",
        297: "PageNumber",
        317: "Predictor",
        319: "PrimaryChromaticities",
        532: "ReferenceBlackWhite",
        339: "SampleFormat",
        559: "StripRowCounts",
        330: "SubIFDs",
        292: "T4Options",
        293: "T6Options",
        325: "TileByteCounts",
        323: "TileLength",
        324: "TileOffsets",
        322: "TileWidth",
        301: "TransferFunction",
        318: "WhitePoint",
        344: "XClipPathUnits",
        286: "XPosition",
        529: "YCbCrCoefficients",
        531: "YCbCrPositioning",
        530: "YCbCrSubSampling",
        345: "YClipPathUnits",
        287: "YPosition",
        37378: "ApertureValue",
        40961: "ColorSpace",
        36868: "DateTimeDigitized",
        36867: "DateTimeOriginal",
        34665: "Exif IFD",
        36864: "ExifVersion",
        33434: "ExposureTime",
        41728: "FileSource",
        37385: "Flash",
        40960: "FlashpixVersion",
        33437: "FNumber",
        42016: "ImageUniqueID",
        37384: "LightSource",
        37500: "MakerNote",
        37377: "ShutterSpeedValue",
        37510: "UserComment",
        33723: "IPTC",
        34675: "ICC Profile",
        700: "XMP",
        42112: "GDAL_METADATA",
        42113: "GDAL_NODATA",
        34377: "Photoshop"
    },
    fieldTypeNames: {
        1: "BYTE",
        2: "ASCII",
        3: "SHORT",
        4: "LONG",
        5: "RATIONAL",
        6: "SBYTE",
        7: "UNDEFINED",
        8: "SSHORT",
        9: "SLONG",
        10: "SRATIONAL",
        11: "FLOAT",
        12: "DOUBLE"
    }
},
cc.Particle = function(t, e, i, n, r, c, s, o, a, h, l, u) {
    this.pos = t ? t : cc.p(0, 0),
    this.startPos = e ? e : cc.p(0, 0),
    this.color = i ? i : {
        r: 0,
        g: 0,
        b: 0,
        a: 255
    },
    this.deltaColor = n ? n : {
        r: 0,
        g: 0,
        b: 0,
        a: 255
    },
    this.size = r || 0,
    this.deltaSize = c || 0,
    this.rotation = s || 0,
    this.deltaRotation = o || 0,
    this.timeToLive = a || 0,
    this.atlasIndex = h || 0,
    this.modeA = l ? l : new cc.Particle.ModeA,
    this.modeB = u ? u : new cc.Particle.ModeB,
    this.isChangeColor = !1,
    this.drawPos = cc.p(0, 0)
}
,
cc.Particle.ModeA = function(t, e, i) {
    this.dir = t ? t : cc.p(0, 0),
    this.radialAccel = e || 0,
    this.tangentialAccel = i || 0
}
,
cc.Particle.ModeB = function(t, e, i, n) {
    this.angle = t || 0,
    this.degreesPerSecond = e || 0,
    this.radius = i || 0,
    this.deltaRadius = n || 0
}
,
cc.Particle.TemporaryPoints = [cc.p(), cc.p(), cc.p(), cc.p()],
cc.ParticleSystem = cc.Node.extend({
    _className: "ParticleSystem",
    _plistFile: "",
    _elapsed: 0,
    _dontTint: !1,
    modeA: null,
    modeB: null,
    _pointZeroForParticle: cc.p(0, 0),
    _particles: null,
    _emitCounter: 0,
    _particleIdx: 0,
    _batchNode: null,
    atlasIndex: 0,
    _transformSystemDirty: !1,
    _allocatedParticles: 0,
    _isActive: !1,
    particleCount: 0,
    duration: 0,
    _sourcePosition: null,
    _posVar: null,
    life: 0,
    lifeVar: 0,
    angle: 0,
    angleVar: 0,
    startSize: 0,
    startSizeVar: 0,
    endSize: 0,
    endSizeVar: 0,
    _startColor: null,
    _startColorVar: null,
    _endColor: null,
    _endColorVar: null,
    startSpin: 0,
    startSpinVar: 0,
    endSpin: 0,
    endSpinVar: 0,
    emissionRate: 0,
    _totalParticles: 0,
    _texture: null,
    _blendFunc: null,
    _opacityModifyRGB: !1,
    positionType: null,
    autoRemoveOnFinish: !1,
    emitterMode: 0,
    _textureLoaded: null,
    ctor: function(t) {
        cc.Node.prototype.ctor.call(this),
        this.emitterMode = cc.ParticleSystem.MODE_GRAVITY,
        this.modeA = new cc.ParticleSystem.ModeA,
        this.modeB = new cc.ParticleSystem.ModeB,
        this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        },
        this._particles = [],
        this._sourcePosition = cc.p(0, 0),
        this._posVar = cc.p(0, 0),
        this._startColor = cc.color(255, 255, 255, 255),
        this._startColorVar = cc.color(255, 255, 255, 255),
        this._endColor = cc.color(255, 255, 255, 255),
        this._endColorVar = cc.color(255, 255, 255, 255),
        this._plistFile = "",
        this._elapsed = 0,
        this._dontTint = !1,
        this._pointZeroForParticle = cc.p(0, 0),
        this._particleIdx = this._emitCounter = 0,
        this._batchNode = null,
        this.atlasIndex = 0,
        this._transformSystemDirty = !1,
        this._allocatedParticles = 0,
        this._isActive = !1,
        this._totalParticles = this.emissionRate = this.endSpinVar = this.endSpin = this.startSpinVar = this.startSpin = this.endSizeVar = this.endSize = this.startSizeVar = this.startSize = this.angleVar = this.angle = this.lifeVar = this.life = this.duration = this.particleCount = 0,
        this._texture = null,
        this._opacityModifyRGB = !1,
        this.positionType = cc.ParticleSystem.TYPE_FREE,
        this.autoRemoveOnFinish = !1,
        this._textureLoaded = !0,
        !t || cc.isNumber(t) ? (t = t || 100,
        this.setDrawMode(cc.ParticleSystem.TEXTURE_MODE),
        this.initWithTotalParticles(t)) : cc.isString(t) ? this.initWithFile(t) : cc.isObject(t) && this.initWithDictionary(t, "")
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.ParticleSystem.CanvasRenderCmd(this) : new cc.ParticleSystem.WebGLRenderCmd(this)
    },
    ignoreColor: function(t) {
        this._dontTint = t
    },
    initTexCoordsWithRect: function(t) {
        this._renderCmd.initTexCoordsWithRect(t)
    },
    getBatchNode: function() {
        return this._batchNode
    },
    setBatchNode: function(t) {
        this._renderCmd.setBatchNode(t)
    },
    getAtlasIndex: function() {
        return this.atlasIndex
    },
    setAtlasIndex: function(t) {
        this.atlasIndex = t
    },
    getDrawMode: function() {
        return this._renderCmd.getDrawMode()
    },
    setDrawMode: function(t) {
        this._renderCmd.setDrawMode(t)
    },
    getShapeType: function() {
        return this._renderCmd.getShapeType()
    },
    setShapeType: function(t) {
        this._renderCmd.setShapeType(t)
    },
    isActive: function() {
        return this._isActive
    },
    getParticleCount: function() {
        return this.particleCount
    },
    setParticleCount: function(t) {
        this.particleCount = t
    },
    getDuration: function() {
        return this.duration
    },
    setDuration: function(t) {
        this.duration = t
    },
    getSourcePosition: function() {
        return {
            x: this._sourcePosition.x,
            y: this._sourcePosition.y
        }
    },
    setSourcePosition: function(t) {
        this._sourcePosition = t
    },
    getPosVar: function() {
        return {
            x: this._posVar.x,
            y: this._posVar.y
        }
    },
    setPosVar: function(t) {
        this._posVar = t
    },
    getLife: function() {
        return this.life
    },
    setLife: function(t) {
        this.life = t
    },
    getLifeVar: function() {
        return this.lifeVar
    },
    setLifeVar: function(t) {
        this.lifeVar = t
    },
    getAngle: function() {
        return this.angle
    },
    setAngle: function(t) {
        this.angle = t
    },
    getAngleVar: function() {
        return this.angleVar
    },
    setAngleVar: function(t) {
        this.angleVar = t
    },
    getGravity: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getGravity() : Particle Mode should be Gravity");
        var t = this.modeA.gravity;
        return cc.p(t.x, t.y)
    },
    setGravity: function(t) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setGravity() : Particle Mode should be Gravity"),
        this.modeA.gravity = t
    },
    getSpeed: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getSpeed() : Particle Mode should be Gravity"),
        this.modeA.speed
    },
    setSpeed: function(t) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setSpeed() : Particle Mode should be Gravity"),
        this.modeA.speed = t
    },
    getSpeedVar: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getSpeedVar() : Particle Mode should be Gravity"),
        this.modeA.speedVar
    },
    setSpeedVar: function(t) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setSpeedVar() : Particle Mode should be Gravity"),
        this.modeA.speedVar = t
    },
    getTangentialAccel: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getTangentialAccel() : Particle Mode should be Gravity"),
        this.modeA.tangentialAccel
    },
    setTangentialAccel: function(t) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setTangentialAccel() : Particle Mode should be Gravity"),
        this.modeA.tangentialAccel = t
    },
    getTangentialAccelVar: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getTangentialAccelVar() : Particle Mode should be Gravity"),
        this.modeA.tangentialAccelVar
    },
    setTangentialAccelVar: function(t) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setTangentialAccelVar() : Particle Mode should be Gravity"),
        this.modeA.tangentialAccelVar = t
    },
    getRadialAccel: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getRadialAccel() : Particle Mode should be Gravity"),
        this.modeA.radialAccel
    },
    setRadialAccel: function(t) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setRadialAccel() : Particle Mode should be Gravity"),
        this.modeA.radialAccel = t
    },
    getRadialAccelVar: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getRadialAccelVar() : Particle Mode should be Gravity"),
        this.modeA.radialAccelVar
    },
    setRadialAccelVar: function(t) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setRadialAccelVar() : Particle Mode should be Gravity"),
        this.modeA.radialAccelVar = t
    },
    getRotationIsDir: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getRotationIsDir() : Particle Mode should be Gravity"),
        this.modeA.rotationIsDir
    },
    setRotationIsDir: function(t) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setRotationIsDir() : Particle Mode should be Gravity"),
        this.modeA.rotationIsDir = t
    },
    getStartRadius: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getStartRadius() : Particle Mode should be Radius"),
        this.modeB.startRadius
    },
    setStartRadius: function(t) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setStartRadius() : Particle Mode should be Radius"),
        this.modeB.startRadius = t
    },
    getStartRadiusVar: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getStartRadiusVar() : Particle Mode should be Radius"),
        this.modeB.startRadiusVar
    },
    setStartRadiusVar: function(t) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setStartRadiusVar() : Particle Mode should be Radius"),
        this.modeB.startRadiusVar = t
    },
    getEndRadius: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getEndRadius() : Particle Mode should be Radius"),
        this.modeB.endRadius
    },
    setEndRadius: function(t) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setEndRadius() : Particle Mode should be Radius"),
        this.modeB.endRadius = t
    },
    getEndRadiusVar: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getEndRadiusVar() : Particle Mode should be Radius"),
        this.modeB.endRadiusVar
    },
    setEndRadiusVar: function(t) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setEndRadiusVar() : Particle Mode should be Radius"),
        this.modeB.endRadiusVar = t
    },
    getRotatePerSecond: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getRotatePerSecond() : Particle Mode should be Radius"),
        this.modeB.rotatePerSecond
    },
    setRotatePerSecond: function(t) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setRotatePerSecond() : Particle Mode should be Radius"),
        this.modeB.rotatePerSecond = t
    },
    getRotatePerSecondVar: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getRotatePerSecondVar() : Particle Mode should be Radius"),
        this.modeB.rotatePerSecondVar
    },
    setRotatePerSecondVar: function(t) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setRotatePerSecondVar() : Particle Mode should be Radius"),
        this.modeB.rotatePerSecondVar = t
    },
    setScale: function(t, e) {
        this._transformSystemDirty = !0,
        cc.Node.prototype.setScale.call(this, t, e)
    },
    setRotation: function(t) {
        this._transformSystemDirty = !0,
        cc.Node.prototype.setRotation.call(this, t)
    },
    setScaleX: function(t) {
        this._transformSystemDirty = !0,
        cc.Node.prototype.setScaleX.call(this, t)
    },
    setScaleY: function(t) {
        this._transformSystemDirty = !0,
        cc.Node.prototype.setScaleY.call(this, t)
    },
    getStartSize: function() {
        return this.startSize
    },
    setStartSize: function(t) {
        this.startSize = t
    },
    getStartSizeVar: function() {
        return this.startSizeVar
    },
    setStartSizeVar: function(t) {
        this.startSizeVar = t
    },
    getEndSize: function() {
        return this.endSize
    },
    setEndSize: function(t) {
        this.endSize = t
    },
    getEndSizeVar: function() {
        return this.endSizeVar
    },
    setEndSizeVar: function(t) {
        this.endSizeVar = t
    },
    getStartColor: function() {
        return cc.color(this._startColor.r, this._startColor.g, this._startColor.b, this._startColor.a)
    },
    setStartColor: function(t) {
        this._startColor = cc.color(t)
    },
    getStartColorVar: function() {
        return cc.color(this._startColorVar.r, this._startColorVar.g, this._startColorVar.b, this._startColorVar.a)
    },
    setStartColorVar: function(t) {
        this._startColorVar = cc.color(t)
    },
    getEndColor: function() {
        return cc.color(this._endColor.r, this._endColor.g, this._endColor.b, this._endColor.a)
    },
    setEndColor: function(t) {
        this._endColor = cc.color(t)
    },
    getEndColorVar: function() {
        return cc.color(this._endColorVar.r, this._endColorVar.g, this._endColorVar.b, this._endColorVar.a)
    },
    setEndColorVar: function(t) {
        this._endColorVar = cc.color(t)
    },
    getStartSpin: function() {
        return this.startSpin
    },
    setStartSpin: function(t) {
        this.startSpin = t
    },
    getStartSpinVar: function() {
        return this.startSpinVar
    },
    setStartSpinVar: function(t) {
        this.startSpinVar = t
    },
    getEndSpin: function() {
        return this.endSpin
    },
    setEndSpin: function(t) {
        this.endSpin = t
    },
    getEndSpinVar: function() {
        return this.endSpinVar
    },
    setEndSpinVar: function(t) {
        this.endSpinVar = t
    },
    getEmissionRate: function() {
        return this.emissionRate
    },
    setEmissionRate: function(t) {
        this.emissionRate = t
    },
    getTotalParticles: function() {
        return this._totalParticles
    },
    setTotalParticles: function(t) {
        this._renderCmd.setTotalParticles(t)
    },
    getTexture: function() {
        return this._texture
    },
    setTexture: function(t) {
        t && (t.isLoaded() ? this.setTextureWithRect(t, cc.rect(0, 0, t.width, t.height)) : (this._textureLoaded = !1,
        t.addEventListener("load", function(t) {
            this._textureLoaded = !0,
            this.setTextureWithRect(t, cc.rect(0, 0, t.width, t.height))
        }, this)))
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    setBlendFunc: function(t, e) {
        void 0 === e ? this._blendFunc !== t && (this._blendFunc = t,
        this._updateBlendFunc()) : this._blendFunc.src === t && this._blendFunc.dst === e || (this._blendFunc = {
            src: t,
            dst: e
        },
        this._updateBlendFunc())
    },
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB
    },
    setOpacityModifyRGB: function(t) {
        this._opacityModifyRGB = t
    },
    isBlendAdditive: function() {
        return this._blendFunc.src === cc.SRC_ALPHA && this._blendFunc.dst === cc.ONE || this._blendFunc.src === cc.ONE && this._blendFunc.dst === cc.ONE
    },
    setBlendAdditive: function(t) {
        var e = this._blendFunc;
        t ? (e.src = cc.SRC_ALPHA,
        e.dst = cc.ONE) : this._renderCmd._setBlendAdditive()
    },
    getPositionType: function() {
        return this.positionType
    },
    setPositionType: function(t) {
        this.positionType = t
    },
    isAutoRemoveOnFinish: function() {
        return this.autoRemoveOnFinish
    },
    setAutoRemoveOnFinish: function(t) {
        this.autoRemoveOnFinish = t
    },
    getEmitterMode: function() {
        return this.emitterMode
    },
    setEmitterMode: function(t) {
        this.emitterMode = t
    },
    init: function() {
        return this.initWithTotalParticles(150)
    },
    initWithFile: function(t) {
        return this._plistFile = t,
        t = cc.loader.getRes(t),
        t ? this.initWithDictionary(t, "") : (cc.log("cc.ParticleSystem.initWithFile(): Particles: file not found"),
        !1)
    },
    getBoundingBoxToWorld: function() {
        return cc.rect(0, 0, cc._canvas.width, cc._canvas.height)
    },
    initWithDictionary: function(t, e) {
        var i = !1
          , n = null
          , n = this._valueForKey
          , r = parseInt(n("maxParticles", t));
        if (this.initWithTotalParticles(r)) {
            if (this.angle = parseFloat(n("angle", t)),
            this.angleVar = parseFloat(n("angleVariance", t)),
            this.duration = parseFloat(n("duration", t)),
            this._blendFunc.src = parseInt(n("blendFuncSource", t)),
            this._blendFunc.dst = parseInt(n("blendFuncDestination", t)),
            i = this._startColor,
            i.r = 255 * parseFloat(n("startColorRed", t)),
            i.g = 255 * parseFloat(n("startColorGreen", t)),
            i.b = 255 * parseFloat(n("startColorBlue", t)),
            i.a = 255 * parseFloat(n("startColorAlpha", t)),
            i = this._startColorVar,
            i.r = 255 * parseFloat(n("startColorVarianceRed", t)),
            i.g = 255 * parseFloat(n("startColorVarianceGreen", t)),
            i.b = 255 * parseFloat(n("startColorVarianceBlue", t)),
            i.a = 255 * parseFloat(n("startColorVarianceAlpha", t)),
            i = this._endColor,
            i.r = 255 * parseFloat(n("finishColorRed", t)),
            i.g = 255 * parseFloat(n("finishColorGreen", t)),
            i.b = 255 * parseFloat(n("finishColorBlue", t)),
            i.a = 255 * parseFloat(n("finishColorAlpha", t)),
            i = this._endColorVar,
            i.r = 255 * parseFloat(n("finishColorVarianceRed", t)),
            i.g = 255 * parseFloat(n("finishColorVarianceGreen", t)),
            i.b = 255 * parseFloat(n("finishColorVarianceBlue", t)),
            i.a = 255 * parseFloat(n("finishColorVarianceAlpha", t)),
            this.startSize = parseFloat(n("startParticleSize", t)),
            this.startSizeVar = parseFloat(n("startParticleSizeVariance", t)),
            this.endSize = parseFloat(n("finishParticleSize", t)),
            this.endSizeVar = parseFloat(n("finishParticleSizeVariance", t)),
            this.setPosition(parseFloat(n("sourcePositionx", t)), parseFloat(n("sourcePositiony", t))),
            this._posVar.x = parseFloat(n("sourcePositionVariancex", t)),
            this._posVar.y = parseFloat(n("sourcePositionVariancey", t)),
            this.startSpin = parseFloat(n("rotationStart", t)),
            this.startSpinVar = parseFloat(n("rotationStartVariance", t)),
            this.endSpin = parseFloat(n("rotationEnd", t)),
            this.endSpinVar = parseFloat(n("rotationEndVariance", t)),
            this.emitterMode = parseInt(n("emitterType", t)),
            this.emitterMode === cc.ParticleSystem.MODE_GRAVITY)
                i = this.modeA,
                i.gravity.x = parseFloat(n("gravityx", t)),
                i.gravity.y = parseFloat(n("gravityy", t)),
                i.speed = parseFloat(n("speed", t)),
                i.speedVar = parseFloat(n("speedVariance", t)),
                r = n("radialAcceleration", t),
                i.radialAccel = r ? parseFloat(r) : 0,
                r = n("radialAccelVariance", t),
                i.radialAccelVar = r ? parseFloat(r) : 0,
                r = n("tangentialAcceleration", t),
                i.tangentialAccel = r ? parseFloat(r) : 0,
                r = n("tangentialAccelVariance", t),
                i.tangentialAccelVar = r ? parseFloat(r) : 0,
                r = n("rotationIsDir", t).toLowerCase(),
                i.rotationIsDir = null != r && ("true" === r || "1" === r);
            else {
                if (this.emitterMode !== cc.ParticleSystem.MODE_RADIUS)
                    return cc.log("cc.ParticleSystem.initWithDictionary(): Invalid emitterType in config file"),
                    !1;
                i = this.modeB,
                i.startRadius = parseFloat(n("maxRadius", t)),
                i.startRadiusVar = parseFloat(n("maxRadiusVariance", t)),
                i.endRadius = parseFloat(n("minRadius", t)),
                i.endRadiusVar = 0,
                i.rotatePerSecond = parseFloat(n("rotatePerSecond", t)),
                i.rotatePerSecondVar = parseFloat(n("rotatePerSecondVariance", t))
            }
            if (this.life = parseFloat(n("particleLifespan", t)),
            this.lifeVar = parseFloat(n("particleLifespanVariance", t)),
            this.emissionRate = this._totalParticles / this.life,
            !this._batchNode)
                if (this._opacityModifyRGB = !1,
                i = n("textureFileName", t),
                i = cc.path.changeBasename(this._plistFile, i),
                r = cc.textureCache.getTextureForKey(i))
                    this.setTexture(r);
                else if ((n = n("textureImageData", t)) && 0 !== n.length) {
                    if (n = cc.unzipBase64AsArray(n, 1),
                    !n)
                        return cc.log("cc.ParticleSystem: error decoding or ungzipping textureImageData"),
                        !1;
                    if (r = cc.getImageFormatByData(n),
                    r !== cc.FMT_TIFF && r !== cc.FMT_PNG)
                        return cc.log("cc.ParticleSystem: unknown image format with Data"),
                        !1;
                    var c = document.createElement("canvas");
                    r === cc.FMT_PNG ? new cc.PNGReader(n).render(c) : cc.tiffReader.parseTIFF(n, c),
                    cc.textureCache.cacheImage(i, c),
                    (n = cc.textureCache.getTextureForKey(i)) || cc.log("cc.ParticleSystem.initWithDictionary() : error loading the texture"),
                    this.setTexture(n)
                } else {
                    if (r = cc.textureCache.addImage(i),
                    !r)
                        return !1;
                    this.setTexture(r)
                }
            i = !0
        }
        return i
    },
    initWithTotalParticles: function(t) {
        this._totalParticles = t;
        var e, i = this._particles;
        for (e = i.length = 0; e < t; e++)
            i[e] = new cc.Particle;
        if (!i)
            return cc.log("Particle system: not enough memory"),
            !1;
        if (this._allocatedParticles = t,
        this._batchNode)
            for (e = 0; e < this._totalParticles; e++)
                i[e].atlasIndex = e;
        return this._isActive = !0,
        this._blendFunc.src = cc.BLEND_SRC,
        this._blendFunc.dst = cc.BLEND_DST,
        this.positionType = cc.ParticleSystem.TYPE_FREE,
        this.emitterMode = cc.ParticleSystem.MODE_GRAVITY,
        this._transformSystemDirty = this.autoRemoveOnFinish = !1,
        this.scheduleUpdateWithPriority(1),
        this._renderCmd._initWithTotalParticles(t),
        !0
    },
    destroyParticleSystem: function() {
        this.unscheduleUpdate()
    },
    addParticle: function() {
        if (this.isFull())
            return !1;
        var t = this._renderCmd.addParticle();
        return this.initParticle(t),
        ++this.particleCount,
        !0
    },
    initParticle: function(t) {
        var e = cc.randomMinus1To1;
        t.timeToLive = this.life + this.lifeVar * e(),
        t.timeToLive = Math.max(0, t.timeToLive),
        t.pos.x = this._sourcePosition.x + this._posVar.x * e(),
        t.pos.y = this._sourcePosition.y + this._posVar.y * e();
        var i, n;
        i = this._startColor;
        var r = this._startColorVar
          , c = this._endColor;
        if (n = this._endColorVar,
        i = {
            r: cc.clampf(i.r + r.r * e(), 0, 255),
            g: cc.clampf(i.g + r.g * e(), 0, 255),
            b: cc.clampf(i.b + r.b * e(), 0, 255),
            a: cc.clampf(i.a + r.a * e(), 0, 255)
        },
        n = {
            r: cc.clampf(c.r + n.r * e(), 0, 255),
            g: cc.clampf(c.g + n.g * e(), 0, 255),
            b: cc.clampf(c.b + n.b * e(), 0, 255),
            a: cc.clampf(c.a + n.a * e(), 0, 255)
        },
        t.color = i,
        r = t.deltaColor,
        c = t.timeToLive,
        r.r = (n.r - i.r) / c,
        r.g = (n.g - i.g) / c,
        r.b = (n.b - i.b) / c,
        r.a = (n.a - i.a) / c,
        i = this.startSize + this.startSizeVar * e(),
        i = Math.max(0, i),
        t.size = i,
        this.endSize === cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE ? t.deltaSize = 0 : (n = this.endSize + this.endSizeVar * e(),
        n = Math.max(0, n),
        t.deltaSize = (n - i) / c),
        i = this.startSpin + this.startSpinVar * e(),
        n = this.endSpin + this.endSpinVar * e(),
        t.rotation = i,
        t.deltaRotation = (n - i) / c,
        this.positionType === cc.ParticleSystem.TYPE_FREE ? t.startPos = this.convertToWorldSpace(this._pointZeroForParticle) : this.positionType === cc.ParticleSystem.TYPE_RELATIVE && (t.startPos.x = this._position.x,
        t.startPos.y = this._position.y),
        i = cc.degreesToRadians(this.angle + this.angleVar * e()),
        this.emitterMode === cc.ParticleSystem.MODE_GRAVITY)
            c = this.modeA,
            n = t.modeA,
            r = c.speed + c.speedVar * e(),
            n.dir.x = Math.cos(i),
            n.dir.y = Math.sin(i),
            cc.pMultIn(n.dir, r),
            n.radialAccel = c.radialAccel + c.radialAccelVar * e(),
            n.tangentialAccel = c.tangentialAccel + c.tangentialAccelVar * e(),
            c.rotationIsDir && (t.rotation = -cc.radiansToDegrees(cc.pToAngle(n.dir)));
        else {
            n = this.modeB,
            t = t.modeB;
            var r = n.startRadius + n.startRadiusVar * e()
              , s = n.endRadius + n.endRadiusVar * e();
            t.radius = r,
            t.deltaRadius = n.endRadius === cc.ParticleSystem.START_RADIUS_EQUAL_TO_END_RADIUS ? 0 : (s - r) / c,
            t.angle = i,
            t.degreesPerSecond = cc.degreesToRadians(n.rotatePerSecond + n.rotatePerSecondVar * e())
        }
    },
    stopSystem: function() {
        this._isActive = !1,
        this._elapsed = this.duration,
        this._emitCounter = 0
    },
    resetSystem: function() {
        this._isActive = !0,
        this._elapsed = 0;
        var t = this._particles;
        for (this._particleIdx = 0; this._particleIdx < this.particleCount; ++this._particleIdx)
            t[this._particleIdx].timeToLive = 0
    },
    isFull: function() {
        return this.particleCount >= this._totalParticles
    },
    updateQuadWithParticle: function(t, e) {
        this._renderCmd.updateQuadWithParticle(t, e)
    },
    postStep: function() {
        this._renderCmd.postStep()
    },
    update: function(t) {
        if (this._isActive && this.emissionRate) {
            var e = 1 / this.emissionRate;
            for (this.particleCount < this._totalParticles && (this._emitCounter += t); this.particleCount < this._totalParticles && this._emitCounter > e; )
                this.addParticle(),
                this._emitCounter -= e;
            this._elapsed += t,
            -1 !== this.duration && this.duration < this._elapsed && this.stopSystem()
        }
        if (this._particleIdx = 0,
        e = cc.Particle.TemporaryPoints[0],
        this.positionType === cc.ParticleSystem.TYPE_FREE ? cc.pIn(e, this.convertToWorldSpace(this._pointZeroForParticle)) : this.positionType === cc.ParticleSystem.TYPE_RELATIVE && (e.x = this._position.x,
        e.y = this._position.y),
        this._visible) {
            for (var i = cc.Particle.TemporaryPoints[1], n = cc.Particle.TemporaryPoints[2], r = cc.Particle.TemporaryPoints[3], c = this._particles; this._particleIdx < this.particleCount; ) {
                cc.pZeroIn(i),
                cc.pZeroIn(n),
                cc.pZeroIn(r);
                var s = c[this._particleIdx];
                if (s.timeToLive -= t,
                0 < s.timeToLive) {
                    if (this.emitterMode === cc.ParticleSystem.MODE_GRAVITY) {
                        var o = r
                          , a = i
                          , h = n;
                        s.pos.x || s.pos.y ? (cc.pIn(a, s.pos),
                        cc.pNormalizeIn(a)) : cc.pZeroIn(a),
                        cc.pIn(h, a),
                        cc.pMultIn(a, s.modeA.radialAccel);
                        var l = h.x;
                        h.x = -h.y,
                        h.y = l,
                        cc.pMultIn(h, s.modeA.tangentialAccel),
                        cc.pIn(o, a),
                        cc.pAddIn(o, h),
                        cc.pAddIn(o, this.modeA.gravity),
                        cc.pMultIn(o, t),
                        cc.pAddIn(s.modeA.dir, o),
                        cc.pIn(o, s.modeA.dir),
                        cc.pMultIn(o, t),
                        cc.pAddIn(s.pos, o)
                    } else
                        o = s.modeB,
                        o.angle += o.degreesPerSecond * t,
                        o.radius += o.deltaRadius * t,
                        s.pos.x = -Math.cos(o.angle) * o.radius,
                        s.pos.y = -Math.sin(o.angle) * o.radius;
                    this._renderCmd._updateDeltaColor(s, t),
                    s.size += s.deltaSize * t,
                    s.size = Math.max(0, s.size),
                    s.rotation += s.deltaRotation * t,
                    o = i,
                    this.positionType === cc.ParticleSystem.TYPE_FREE || this.positionType === cc.ParticleSystem.TYPE_RELATIVE ? (a = n,
                    cc.pIn(a, e),
                    cc.pSubIn(a, s.startPos),
                    cc.pIn(o, s.pos),
                    cc.pSubIn(o, a)) : cc.pIn(o, s.pos),
                    this._batchNode && (o.x += this._position.x,
                    o.y += this._position.y),
                    this._renderCmd.updateParticlePosition(s, o),
                    ++this._particleIdx
                } else if (s = s.atlasIndex,
                this._particleIdx !== this.particleCount - 1 && (o = c[this._particleIdx],
                c[this._particleIdx] = c[this.particleCount - 1],
                c[this.particleCount - 1] = o),
                this._batchNode && (this._batchNode.disableParticle(this.atlasIndex + s),
                c[this.particleCount - 1].atlasIndex = s),
                --this.particleCount,
                0 === this.particleCount && this.autoRemoveOnFinish)
                    return this.unscheduleUpdate(),
                    void this._parent.removeChild(this, !0)
            }
            this._transformSystemDirty = !1
        }
        this._batchNode || this.postStep()
    },
    updateWithNoTime: function() {
        this.update(0)
    },
    _valueForKey: function(t, e) {
        if (e) {
            var i = e[t];
            return null != i ? i : ""
        }
        return ""
    },
    _updateBlendFunc: function() {
        if (this._batchNode)
            cc.log("Can't change blending functions when the particle is being batched");
        else {
            var t = this._texture;
            if (t && t instanceof cc.Texture2D) {
                this._opacityModifyRGB = !1;
                var e = this._blendFunc;
                e.src === cc.BLEND_SRC && e.dst === cc.BLEND_DST && (t.hasPremultipliedAlpha() ? this._opacityModifyRGB = !0 : (e.src = cc.SRC_ALPHA,
                e.dst = cc.ONE_MINUS_SRC_ALPHA))
            }
        }
    },
    clone: function() {
        var t = new cc.ParticleSystem;
        if (t.initWithTotalParticles(this.getTotalParticles())) {
            t.setAngle(this.getAngle()),
            t.setAngleVar(this.getAngleVar()),
            t.setDuration(this.getDuration());
            var e = this.getBlendFunc();
            if (t.setBlendFunc(e.src, e.dst),
            t.setStartColor(this.getStartColor()),
            t.setStartColorVar(this.getStartColorVar()),
            t.setEndColor(this.getEndColor()),
            t.setEndColorVar(this.getEndColorVar()),
            t.setStartSize(this.getStartSize()),
            t.setStartSizeVar(this.getStartSizeVar()),
            t.setEndSize(this.getEndSize()),
            t.setEndSizeVar(this.getEndSizeVar()),
            t.setPosition(cc.p(this.x, this.y)),
            t.setPosVar(cc.p(this.getPosVar().x, this.getPosVar().y)),
            t.setPositionType(this.getPositionType()),
            t.setStartSpin(this.getStartSpin() || 0),
            t.setStartSpinVar(this.getStartSpinVar() || 0),
            t.setEndSpin(this.getEndSpin() || 0),
            t.setEndSpinVar(this.getEndSpinVar() || 0),
            t.setEmitterMode(this.getEmitterMode()),
            this.getEmitterMode() === cc.ParticleSystem.MODE_GRAVITY ? (e = this.getGravity(),
            t.setGravity(cc.p(e.x, e.y)),
            t.setSpeed(this.getSpeed()),
            t.setSpeedVar(this.getSpeedVar()),
            t.setRadialAccel(this.getRadialAccel()),
            t.setRadialAccelVar(this.getRadialAccelVar()),
            t.setTangentialAccel(this.getTangentialAccel()),
            t.setTangentialAccelVar(this.getTangentialAccelVar())) : this.getEmitterMode() === cc.ParticleSystem.MODE_RADIUS && (t.setStartRadius(this.getStartRadius()),
            t.setStartRadiusVar(this.getStartRadiusVar()),
            t.setEndRadius(this.getEndRadius()),
            t.setEndRadiusVar(this.getEndRadiusVar()),
            t.setRotatePerSecond(this.getRotatePerSecond()),
            t.setRotatePerSecondVar(this.getRotatePerSecondVar())),
            t.setLife(this.getLife()),
            t.setLifeVar(this.getLifeVar()),
            t.setEmissionRate(this.getEmissionRate()),
            !this.getBatchNode() && (t.setOpacityModifyRGB(this.isOpacityModifyRGB()),
            e = this.getTexture())) {
                var i = e.getContentSize();
                t.setTextureWithRect(e, cc.rect(0, 0, i.width, i.height))
            }
        }
        return t
    },
    setDisplayFrame: function(t) {
        if (t) {
            var e = t.getOffsetInPixels();
            0 === e.x && 0 === e.y || cc.log("cc.ParticleSystem.setDisplayFrame(): QuadParticle only supports SpriteFrames with no offsets"),
            t = t.getTexture(),
            this._texture !== t && this.setTexture(t)
        }
    },
    setTextureWithRect: function(t, e) {
        this._texture !== t && (this._texture = t,
        this._updateBlendFunc()),
        this.initTexCoordsWithRect(e)
    },
    listenBackToForeground: function(t) {}
}),
_p = cc.ParticleSystem.prototype,
cc.defineGetterSetter(_p, "opacityModifyRGB", _p.isOpacityModifyRGB, _p.setOpacityModifyRGB),
cc.defineGetterSetter(_p, "batchNode", _p.getBatchNode, _p.setBatchNode),
cc.defineGetterSetter(_p, "drawMode", _p.getDrawMode, _p.setDrawMode),
cc.defineGetterSetter(_p, "shapeType", _p.getShapeType, _p.setShapeType),
cc.defineGetterSetter(_p, "active", _p.isActive),
cc.defineGetterSetter(_p, "sourcePos", _p.getSourcePosition, _p.setSourcePosition),
cc.defineGetterSetter(_p, "posVar", _p.getPosVar, _p.setPosVar),
cc.defineGetterSetter(_p, "gravity", _p.getGravity, _p.setGravity),
cc.defineGetterSetter(_p, "speed", _p.getSpeed, _p.setSpeed),
cc.defineGetterSetter(_p, "speedVar", _p.getSpeedVar, _p.setSpeedVar),
cc.defineGetterSetter(_p, "tangentialAccel", _p.getTangentialAccel, _p.setTangentialAccel),
cc.defineGetterSetter(_p, "tangentialAccelVar", _p.getTangentialAccelVar, _p.setTangentialAccelVar),
cc.defineGetterSetter(_p, "radialAccel", _p.getRadialAccel, _p.setRadialAccel),
cc.defineGetterSetter(_p, "radialAccelVar", _p.getRadialAccelVar, _p.setRadialAccelVar),
cc.defineGetterSetter(_p, "rotationIsDir", _p.getRotationIsDir, _p.setRotationIsDir),
cc.defineGetterSetter(_p, "startRadius", _p.getStartRadius, _p.setStartRadius),
cc.defineGetterSetter(_p, "startRadiusVar", _p.getStartRadiusVar, _p.setStartRadiusVar),
cc.defineGetterSetter(_p, "endRadius", _p.getEndRadius, _p.setEndRadius),
cc.defineGetterSetter(_p, "endRadiusVar", _p.getEndRadiusVar, _p.setEndRadiusVar),
cc.defineGetterSetter(_p, "rotatePerS", _p.getRotatePerSecond, _p.setRotatePerSecond),
cc.defineGetterSetter(_p, "rotatePerSVar", _p.getRotatePerSecondVar, _p.setRotatePerSecondVar),
cc.defineGetterSetter(_p, "startColor", _p.getStartColor, _p.setStartColor),
cc.defineGetterSetter(_p, "startColorVar", _p.getStartColorVar, _p.setStartColorVar),
cc.defineGetterSetter(_p, "endColor", _p.getEndColor, _p.setEndColor),
cc.defineGetterSetter(_p, "endColorVar", _p.getEndColorVar, _p.setEndColorVar),
cc.defineGetterSetter(_p, "totalParticles", _p.getTotalParticles, _p.setTotalParticles),
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture),
cc.ParticleSystem.create = function(t) {
    return new cc.ParticleSystem(t)
}
,
cc.ParticleSystem.createWithTotalParticles = cc.ParticleSystem.create,
cc.ParticleSystem.ModeA = function(t, e, i, n, r, c, s, o) {
    this.gravity = t ? t : cc.p(0, 0),
    this.speed = e || 0,
    this.speedVar = i || 0,
    this.tangentialAccel = n || 0,
    this.tangentialAccelVar = r || 0,
    this.radialAccel = c || 0,
    this.radialAccelVar = s || 0,
    this.rotationIsDir = o || !1
}
,
cc.ParticleSystem.ModeB = function(t, e, i, n, r, c) {
    this.startRadius = t || 0,
    this.startRadiusVar = e || 0,
    this.endRadius = i || 0,
    this.endRadiusVar = n || 0,
    this.rotatePerSecond = r || 0,
    this.rotatePerSecondVar = c || 0
}
,
cc.ParticleSystem.SHAPE_MODE = 0,
cc.ParticleSystem.TEXTURE_MODE = 1,
cc.ParticleSystem.STAR_SHAPE = 0,
cc.ParticleSystem.BALL_SHAPE = 1,
cc.ParticleSystem.DURATION_INFINITY = -1,
cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE = -1,
cc.ParticleSystem.START_RADIUS_EQUAL_TO_END_RADIUS = -1,
cc.ParticleSystem.MODE_GRAVITY = 0,
cc.ParticleSystem.MODE_RADIUS = 1,
cc.ParticleSystem.TYPE_FREE = 0,
cc.ParticleSystem.TYPE_RELATIVE = 1,
cc.ParticleSystem.TYPE_GROUPED = 2,
function() {
    cc.ParticleSystem.CanvasRenderCmd = function(t) {
        cc.Node.CanvasRenderCmd.call(this, t),
        this._needDraw = !0,
        this._drawMode = cc.ParticleSystem.TEXTURE_MODE,
        this._shapeType = cc.ParticleSystem.BALL_SHAPE,
        this._pointRect = cc.rect(0, 0, 0, 0),
        this._tintCache = document.createElement("canvas")
    }
    ;
    var t = cc.ParticleSystem.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    t.constructor = cc.ParticleSystem.CanvasRenderCmd,
    t.getDrawMode = function() {
        return this._drawMode
    }
    ,
    t.setDrawMode = function(t) {
        this._drawMode = t
    }
    ,
    t.getShapeType = function() {
        return this._shapeType
    }
    ,
    t.setShapeType = function(t) {
        this._shapeType = t
    }
    ,
    t.setBatchNode = function(t) {
        this._batchNode !== t && (this._node._batchNode = t)
    }
    ,
    t.updateQuadWithParticle = function(t, e) {}
    ,
    t.updateParticlePosition = function(t, e) {
        cc.pIn(t.drawPos, e)
    }
    ,
    t.rendering = function(t, e, i) {
        t = t || cc._renderContext;
        var n = t.getContext()
          , r = this._node
          , c = this._pointRect;
        t.setTransform(this._worldTransform, e, i),
        t.save(),
        r.isBlendAdditive() ? n.globalCompositeOperation = "lighter" : n.globalCompositeOperation = "source-over";
        var s, o;
        i = this._node.particleCount;
        var a = this._node._particles;
        if (r.drawMode !== cc.ParticleSystem.SHAPE_MODE && r._texture) {
            if (!r._texture._textureLoaded)
                return void t.restore();
            var h = r._texture.getHtmlElementObj();
            if (!h.width || !h.height)
                return void t.restore();
            for (s = h,
            e = 0; e < i; e++)
                if (s = a[e],
                o = s.color.a / 255,
                0 !== o) {
                    n.globalAlpha = o,
                    n.save(),
                    n.translate(0 | s.drawPos.x, -(0 | s.drawPos.y));
                    var l = 4 * Math.floor(s.size / 4);
                    o = c.width;
                    var u = c.height;
                    n.scale(Math.max(1 / o * l, 1e-6), Math.max(1 / u * l, 1e-6)),
                    s.rotation && n.rotate(cc.degreesToRadians(s.rotation)),
                    s = s.isChangeColor ? this._changeTextureColor(r._texture, s.color, this._pointRect) : h,
                    n.drawImage(s, -(0 | o / 2), -(0 | u / 2)),
                    n.restore()
                }
        } else
            for (h = cc._drawingUtil,
            e = 0; e < i; e++)
                s = a[e],
                c = 0 | .5 * s.size,
                o = s.color.a / 255,
                0 !== o && (n.globalAlpha = o,
                n.save(),
                n.translate(0 | s.drawPos.x, -(0 | s.drawPos.y)),
                r.shapeType === cc.ParticleSystem.STAR_SHAPE ? (s.rotation && n.rotate(cc.degreesToRadians(s.rotation)),
                h.drawStar(t, c, s.color)) : h.drawColorBall(t, c, s.color),
                n.restore());
        t.restore(),
        cc.g_NumberOfDraws++
    }
    ,
    t._changeTextureColor = function(t, e, i) {
        var n = this._tintCache
          , r = t.getContentSize();
        return n.width = r.width,
        n.height = r.height,
        t._generateColorTexture(e.r, e.g, e.b, i, n)
    }
    ,
    t.initTexCoordsWithRect = function(t) {
        this._pointRect = t
    }
    ,
    t.setTotalParticles = function(t) {
        this._node._totalParticles = 200 > t ? t : 200
    }
    ,
    t.addParticle = function() {
        var t = this._node
          , e = t._particles;
        return t.particleCount < e.length ? t = e[t.particleCount] : (t = new cc.Particle,
        e.push(t)),
        t
    }
    ,
    t._setupVBO = function() {}
    ,
    t._allocMemory = function() {
        return !0
    }
    ,
    t.postStep = function() {}
    ,
    t._setBlendAdditive = function() {
        var t = this._node._blendFunc;
        t.src = cc.BLEND_SRC,
        t.dst = cc.BLEND_DST
    }
    ,
    t._initWithTotalParticles = function(t) {}
    ,
    t._updateDeltaColor = function(t, e) {
        this._node._dontTint || (t.color.r += t.deltaColor.r * e,
        t.color.g += t.deltaColor.g * e,
        t.color.b += t.deltaColor.b * e,
        t.color.a += t.deltaColor.a * e,
        t.isChangeColor = !0)
    }
}(),
function() {
    cc.ParticleSystem.WebGLRenderCmd = function(t) {
        cc.Node.WebGLRenderCmd.call(this, t),
        this._needDraw = !0,
        this._buffersVBO = [0, 0],
        this._quads = [],
        this._indices = [],
        this._quadsArrayBuffer = null
    }
    ;
    var t = cc.ParticleSystem.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    t.constructor = cc.ParticleSystem.WebGLRenderCmd,
    t.getDrawMode = function() {}
    ,
    t.setDrawMode = function(t) {}
    ,
    t.getShapeType = function() {}
    ,
    t.setShapeType = function(t) {}
    ,
    t.setBatchNode = function(t) {
        var e = this._node;
        if (e._batchNode !== t) {
            var i = e._batchNode;
            if (e._batchNode = t)
                for (var n = e._particles, r = 0; r < e._totalParticles; r++)
                    n[r].atlasIndex = r;
            t ? i || (e._batchNode.textureAtlas._copyQuadsToTextureAtlas(this._quads, e.atlasIndex),
            cc._renderContext.deleteBuffer(this._buffersVBO[1])) : (this._allocMemory(),
            this.initIndices(e._totalParticles),
            e.setTexture(i.getTexture()),
            this._setupVBO())
        }
    }
    ,
    t.initIndices = function(t) {
        for (var e = this._indices, i = 0; i < t; ++i) {
            var n = 6 * i
              , r = 4 * i;
            e[n + 0] = r + 0,
            e[n + 1] = r + 1,
            e[n + 2] = r + 2,
            e[n + 5] = r + 1,
            e[n + 4] = r + 2,
            e[n + 3] = r + 3
        }
    }
    ,
    t.isDifferentTexture = function(t, e) {
        return t === e
    }
    ,
    t.updateParticlePosition = function(t, e) {
        this.updateQuadWithParticle(t, e)
    }
    ,
    t.updateQuadWithParticle = function(t, e) {
        var i = null
          , n = this._node;
        n._batchNode ? (i = n._batchNode.textureAtlas.quads[n.atlasIndex + t.atlasIndex],
        n._batchNode.textureAtlas.dirty = !0) : i = this._quads[n._particleIdx];
        var r, c, s;
        n._opacityModifyRGB ? (n = 0 | t.color.r * t.color.a / 255,
        r = 0 | t.color.g * t.color.a / 255,
        c = 0 | t.color.b * t.color.a / 255) : (n = 0 | t.color.r,
        r = 0 | t.color.g,
        c = 0 | t.color.b),
        s = 0 | t.color.a;
        var o = i.bl.colors
          , a = i.br.colors
          , h = i.tl.colors
          , l = i.tr.colors;
        o.r = a.r = h.r = l.r = n,
        o.g = a.g = h.g = l.g = r,
        o.b = a.b = h.b = l.b = c,
        o.a = a.a = h.a = l.a = s,
        n = t.size / 2,
        t.rotation ? (r = -n,
        c = -n,
        s = e.x,
        o = e.y,
        h = -cc.degreesToRadians(t.rotation),
        a = Math.cos(h),
        h = Math.sin(h),
        i.bl.vertices.x = r * a - c * h + s,
        i.bl.vertices.y = r * h + c * a + o,
        i.br.vertices.x = n * a - c * h + s,
        i.br.vertices.y = n * h + c * a + o,
        i.tl.vertices.x = r * a - n * h + s,
        i.tl.vertices.y = r * h + n * a + o,
        i.tr.vertices.x = n * a - n * h + s,
        i.tr.vertices.y = n * h + n * a + o) : (i.bl.vertices.x = e.x - n,
        i.bl.vertices.y = e.y - n,
        i.br.vertices.x = e.x + n,
        i.br.vertices.y = e.y - n,
        i.tl.vertices.x = e.x - n,
        i.tl.vertices.y = e.y + n,
        i.tr.vertices.x = e.x + n,
        i.tr.vertices.y = e.y + n)
    }
    ,
    t.rendering = function(t) {
        var e = this._node;
        e._texture && (t = t || cc._renderContext,
        this._shaderProgram.use(),
        this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix),
        cc.glBindTexture2D(e._texture),
        cc.glBlendFuncForParticle(e._blendFunc.src, e._blendFunc.dst),
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX),
        t.bindBuffer(t.ARRAY_BUFFER, this._buffersVBO[0]),
        t.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, t.FLOAT, !1, 24, 0),
        t.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, t.UNSIGNED_BYTE, !0, 24, 12),
        t.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, t.FLOAT, !1, 24, 16),
        t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]),
        t.drawElements(t.TRIANGLES, 6 * e._particleIdx, t.UNSIGNED_SHORT, 0))
    }
    ,
    t.initTexCoordsWithRect = function(t) {
        var e = this._node
          , i = e.texture
          , n = cc.contentScaleFactor()
          , r = cc.rect(t.x * n, t.y * n, t.width * n, t.height * n)
          , n = t.width
          , c = t.height;
        i && (n = i.pixelsWidth,
        c = i.pixelsHeight),
        cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (i = (2 * r.x + 1) / (2 * n),
        t = (2 * r.y + 1) / (2 * c),
        n = i + (2 * r.width - 2) / (2 * n),
        r = t + (2 * r.height - 2) / (2 * c)) : (i = r.x / n,
        t = r.y / c,
        n = i + r.width / n,
        r = t + r.height / c),
        c = r,
        r = t,
        t = c;
        var s = 0
          , o = 0;
        for (e._batchNode ? (c = e._batchNode.textureAtlas.quads,
        s = e.atlasIndex,
        o = e.atlasIndex + e._totalParticles) : (c = this._quads,
        s = 0,
        o = e._totalParticles),
        e = s; e < o; e++)
            c[e] || (c[e] = cc.V3F_C4B_T2F_QuadZero()),
            s = c[e],
            s.bl.texCoords.u = i,
            s.bl.texCoords.v = t,
            s.br.texCoords.u = n,
            s.br.texCoords.v = t,
            s.tl.texCoords.u = i,
            s.tl.texCoords.v = r,
            s.tr.texCoords.u = n,
            s.tr.texCoords.v = r
    }
    ,
    t.setTotalParticles = function(t) {
        var e = this._node;
        if (t > e._allocatedParticles) {
            var i = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
            this._indices = new Uint16Array(6 * t);
            var n = new ArrayBuffer(t * i)
              , r = e._particles;
            r.length = 0;
            for (var c = this._quads, s = c.length = 0; s < t; s++)
                r[s] = new cc.Particle,
                c[s] = new cc.V3F_C4B_T2F_Quad(null,null,null,null,n,s * i);
            if (e._allocatedParticles = t,
            e._totalParticles = t,
            e._batchNode)
                for (i = 0; i < t; i++)
                    r[i].atlasIndex = i;
            this._quadsArrayBuffer = n,
            this.initIndices(t),
            this._setupVBO(),
            e._texture && this.initTexCoordsWithRect(cc.rect(0, 0, e._texture.width, e._texture.height))
        } else
            e._totalParticles = t;
        e.resetSystem()
    }
    ,
    t.addParticle = function() {
        var t = this._node;
        return t._particles[t.particleCount]
    }
    ,
    t._setupVBO = function() {
        var t = cc._renderContext;
        this._buffersVBO[0] = t.createBuffer(),
        t.bindBuffer(t.ARRAY_BUFFER, this._buffersVBO[0]),
        t.bufferData(t.ARRAY_BUFFER, this._quadsArrayBuffer, t.DYNAMIC_DRAW),
        this._buffersVBO[1] = t.createBuffer(),
        t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]),
        t.bufferData(t.ELEMENT_ARRAY_BUFFER, this._indices, t.STATIC_DRAW)
    }
    ,
    t._allocMemory = function() {
        var t = this._node;
        if (t._batchNode)
            return cc.log("cc.ParticleSystem._allocMemory(): Memory should not be allocated when not using batchNode"),
            !1;
        var e = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT
          , t = t._totalParticles
          , i = this._quads;
        i.length = 0,
        this._indices = new Uint16Array(6 * t);
        for (var n = new ArrayBuffer(e * t), r = 0; r < t; r++)
            i[r] = new cc.V3F_C4B_T2F_Quad(null,null,null,null,n,r * e);
        return i && this._indices ? (this._quadsArrayBuffer = n,
        !0) : (cc.log("cocos2d: Particle system: not enough memory"),
        !1)
    }
    ,
    t.postStep = function() {
        var t = cc._renderContext;
        t.bindBuffer(t.ARRAY_BUFFER, this._buffersVBO[0]),
        t.bufferData(t.ARRAY_BUFFER, this._quadsArrayBuffer, t.DYNAMIC_DRAW)
    }
    ,
    t._setBlendAdditive = function() {
        var t = this._node._blendFunc;
        this._texture && !this._texture.hasPremultipliedAlpha() ? (t.src = cc.SRC_ALPHA,
        t.dst = cc.ONE_MINUS_SRC_ALPHA) : (t.src = cc.BLEND_SRC,
        t.dst = cc.BLEND_DST)
    }
    ,
    t._initWithTotalParticles = function(t) {
        return !!this._allocMemory() && (this.initIndices(t),
        this._setupVBO(),
        void (this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)))
    }
    ,
    t._updateDeltaColor = function(t, e) {
        t.color.r += t.deltaColor.r * e,
        t.color.g += t.deltaColor.g * e,
        t.color.b += t.deltaColor.b * e,
        t.color.a += t.deltaColor.a * e,
        t.isChangeColor = !0
    }
}(),
cc.ParticleFire = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 300 : 150)
    },
    initWithTotalParticles: function(t) {
        return !!cc.ParticleSystem.prototype.initWithTotalParticles.call(this, t) && (this.setDuration(cc.ParticleSystem.DURATION_INFINITY),
        this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY),
        this.setGravity(cc.p(0, 0)),
        this.setRadialAccel(0),
        this.setRadialAccelVar(0),
        this.setSpeed(60),
        this.setSpeedVar(20),
        this.setAngle(90),
        this.setAngleVar(10),
        t = cc.director.getWinSize(),
        this.setPosition(t.width / 2, 60),
        this.setPosVar(cc.p(40, 20)),
        this.setLife(3),
        this.setLifeVar(.25),
        this.setStartSize(54),
        this.setStartSizeVar(10),
        this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE),
        this.setEmissionRate(this.getTotalParticles() / this.getLife()),
        this.setStartColor(cc.color(194, 64, 31, 255)),
        this.setStartColorVar(cc.color(0, 0, 0, 0)),
        this.setEndColor(cc.color(0, 0, 0, 255)),
        this.setEndColorVar(cc.color(0, 0, 0, 0)),
        this.setBlendAdditive(!0),
        !0)
    }
}),
cc.ParticleFire.create = function() {
    return new cc.ParticleFire
}
,
cc.ParticleFireworks = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 1500 : 150)
    },
    initWithTotalParticles: function(t) {
        return !!cc.ParticleSystem.prototype.initWithTotalParticles.call(this, t) && (this.setDuration(cc.ParticleSystem.DURATION_INFINITY),
        this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY),
        this.setGravity(cc.p(0, -90)),
        this.setRadialAccel(0),
        this.setRadialAccelVar(0),
        this.setSpeed(180),
        this.setSpeedVar(50),
        t = cc.director.getWinSize(),
        this.setPosition(t.width / 2, t.height / 2),
        this.setAngle(90),
        this.setAngleVar(20),
        this.setLife(3.5),
        this.setLifeVar(1),
        this.setEmissionRate(this.getTotalParticles() / this.getLife()),
        this.setStartColor(cc.color(128, 128, 128, 255)),
        this.setStartColorVar(cc.color(128, 128, 128, 255)),
        this.setEndColor(cc.color(26, 26, 26, 51)),
        this.setEndColorVar(cc.color(26, 26, 26, 51)),
        this.setStartSize(8),
        this.setStartSizeVar(2),
        this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE),
        this.setBlendAdditive(!1),
        !0)
    }
}),
cc.ParticleFireworks.create = function() {
    return new cc.ParticleFireworks;
}
,
cc.ParticleSun = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 350 : 150)
    },
    initWithTotalParticles: function(t) {
        return !!cc.ParticleSystem.prototype.initWithTotalParticles.call(this, t) && (this.setBlendAdditive(!0),
        this.setDuration(cc.ParticleSystem.DURATION_INFINITY),
        this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY),
        this.setGravity(cc.p(0, 0)),
        this.setRadialAccel(0),
        this.setRadialAccelVar(0),
        this.setSpeed(20),
        this.setSpeedVar(5),
        this.setAngle(90),
        this.setAngleVar(360),
        t = cc.director.getWinSize(),
        this.setPosition(t.width / 2, t.height / 2),
        this.setPosVar(cc.p(0, 0)),
        this.setLife(1),
        this.setLifeVar(.5),
        this.setStartSize(30),
        this.setStartSizeVar(10),
        this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE),
        this.setEmissionRate(this.getTotalParticles() / this.getLife()),
        this.setStartColor(cc.color(194, 64, 31, 255)),
        this.setStartColorVar(cc.color(0, 0, 0, 0)),
        this.setEndColor(cc.color(0, 0, 0, 255)),
        this.setEndColorVar(cc.color(0, 0, 0, 0)),
        !0)
    }
}),
cc.ParticleSun.create = function() {
    return new cc.ParticleSun
}
,
cc.ParticleGalaxy = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 200 : 100)
    },
    initWithTotalParticles: function(t) {
        return !!cc.ParticleSystem.prototype.initWithTotalParticles.call(this, t) && (this.setDuration(cc.ParticleSystem.DURATION_INFINITY),
        this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY),
        this.setGravity(cc.p(0, 0)),
        this.setSpeed(60),
        this.setSpeedVar(10),
        this.setRadialAccel(-80),
        this.setRadialAccelVar(0),
        this.setTangentialAccel(80),
        this.setTangentialAccelVar(0),
        this.setAngle(90),
        this.setAngleVar(360),
        t = cc.director.getWinSize(),
        this.setPosition(t.width / 2, t.height / 2),
        this.setPosVar(cc.p(0, 0)),
        this.setLife(4),
        this.setLifeVar(1),
        this.setStartSize(37),
        this.setStartSizeVar(10),
        this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE),
        this.setEmissionRate(this.getTotalParticles() / this.getLife()),
        this.setStartColor(cc.color(31, 64, 194, 255)),
        this.setStartColorVar(cc.color(0, 0, 0, 0)),
        this.setEndColor(cc.color(0, 0, 0, 255)),
        this.setEndColorVar(cc.color(0, 0, 0, 0)),
        this.setBlendAdditive(!0),
        !0)
    }
}),
cc.ParticleGalaxy.create = function() {
    return new cc.ParticleGalaxy
}
,
cc.ParticleFlower = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 250 : 100)
    },
    initWithTotalParticles: function(t) {
        return !!cc.ParticleSystem.prototype.initWithTotalParticles.call(this, t) && (this.setDuration(cc.ParticleSystem.DURATION_INFINITY),
        this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY),
        this.setGravity(cc.p(0, 0)),
        this.setSpeed(80),
        this.setSpeedVar(10),
        this.setRadialAccel(-60),
        this.setRadialAccelVar(0),
        this.setTangentialAccel(15),
        this.setTangentialAccelVar(0),
        this.setAngle(90),
        this.setAngleVar(360),
        t = cc.director.getWinSize(),
        this.setPosition(t.width / 2, t.height / 2),
        this.setPosVar(cc.p(0, 0)),
        this.setLife(4),
        this.setLifeVar(1),
        this.setStartSize(30),
        this.setStartSizeVar(10),
        this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE),
        this.setEmissionRate(this.getTotalParticles() / this.getLife()),
        this.setStartColor(cc.color(128, 128, 128, 255)),
        this.setStartColorVar(cc.color(128, 128, 128, 128)),
        this.setEndColor(cc.color(0, 0, 0, 255)),
        this.setEndColorVar(cc.color(0, 0, 0, 0)),
        this.setBlendAdditive(!0),
        !0)
    }
}),
cc.ParticleFlower.create = function() {
    return new cc.ParticleFlower
}
,
cc.ParticleMeteor = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 150 : 100)
    },
    initWithTotalParticles: function(t) {
        return !!cc.ParticleSystem.prototype.initWithTotalParticles.call(this, t) && (this.setDuration(cc.ParticleSystem.DURATION_INFINITY),
        this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY),
        this.setGravity(cc.p(-200, 200)),
        this.setSpeed(15),
        this.setSpeedVar(5),
        this.setRadialAccel(0),
        this.setRadialAccelVar(0),
        this.setTangentialAccel(0),
        this.setTangentialAccelVar(0),
        this.setAngle(90),
        this.setAngleVar(360),
        t = cc.director.getWinSize(),
        this.setPosition(t.width / 2, t.height / 2),
        this.setPosVar(cc.p(0, 0)),
        this.setLife(2),
        this.setLifeVar(1),
        this.setStartSize(60),
        this.setStartSizeVar(10),
        this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE),
        this.setEmissionRate(this.getTotalParticles() / this.getLife()),
        this.setStartColor(cc.color(51, 102, 179)),
        this.setStartColorVar(cc.color(0, 0, 51, 26)),
        this.setEndColor(cc.color(0, 0, 0, 255)),
        this.setEndColorVar(cc.color(0, 0, 0, 0)),
        this.setBlendAdditive(!0),
        !0)
    }
}),
cc.ParticleMeteor.create = function() {
    return new cc.ParticleMeteor
}
,
cc.ParticleSpiral = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 500 : 100)
    },
    initWithTotalParticles: function(t) {
        return !!cc.ParticleSystem.prototype.initWithTotalParticles.call(this, t) && (this.setDuration(cc.ParticleSystem.DURATION_INFINITY),
        this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY),
        this.setGravity(cc.p(0, 0)),
        this.setSpeed(150),
        this.setSpeedVar(0),
        this.setRadialAccel(-380),
        this.setRadialAccelVar(0),
        this.setTangentialAccel(45),
        this.setTangentialAccelVar(0),
        this.setAngle(90),
        this.setAngleVar(0),
        t = cc.director.getWinSize(),
        this.setPosition(t.width / 2, t.height / 2),
        this.setPosVar(cc.p(0, 0)),
        this.setLife(12),
        this.setLifeVar(0),
        this.setStartSize(20),
        this.setStartSizeVar(0),
        this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE),
        this.setEmissionRate(this.getTotalParticles() / this.getLife()),
        this.setStartColor(cc.color(128, 128, 128, 255)),
        this.setStartColorVar(cc.color(128, 128, 128, 0)),
        this.setEndColor(cc.color(128, 128, 128, 255)),
        this.setEndColorVar(cc.color(128, 128, 128, 0)),
        this.setBlendAdditive(!1),
        !0)
    }
}),
cc.ParticleSpiral.create = function() {
    return new cc.ParticleSpiral
}
,
cc.ParticleExplosion = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 700 : 300)
    },
    initWithTotalParticles: function(t) {
        return !!cc.ParticleSystem.prototype.initWithTotalParticles.call(this, t) && (this.setDuration(.1),
        this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY),
        this.setGravity(cc.p(0, 0)),
        this.setSpeed(70),
        this.setSpeedVar(40),
        this.setRadialAccel(0),
        this.setRadialAccelVar(0),
        this.setTangentialAccel(0),
        this.setTangentialAccelVar(0),
        this.setAngle(90),
        this.setAngleVar(360),
        t = cc.director.getWinSize(),
        this.setPosition(t.width / 2, t.height / 2),
        this.setPosVar(cc.p(0, 0)),
        this.setLife(5),
        this.setLifeVar(2),
        this.setStartSize(15),
        this.setStartSizeVar(10),
        this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE),
        this.setEmissionRate(this.getTotalParticles() / this.getDuration()),
        this.setStartColor(cc.color(179, 26, 51, 255)),
        this.setStartColorVar(cc.color(128, 128, 128, 0)),
        this.setEndColor(cc.color(128, 128, 128, 0)),
        this.setEndColorVar(cc.color(128, 128, 128, 0)),
        this.setBlendAdditive(!1),
        !0)
    }
}),
cc.ParticleExplosion.create = function() {
    return new cc.ParticleExplosion
}
,
cc.ParticleSmoke = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 200 : 100)
    },
    initWithTotalParticles: function(t) {
        return !!cc.ParticleSystem.prototype.initWithTotalParticles.call(this, t) && (this.setDuration(cc.ParticleSystem.DURATION_INFINITY),
        this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY),
        this.setGravity(cc.p(0, 0)),
        this.setRadialAccel(0),
        this.setRadialAccelVar(0),
        this.setSpeed(25),
        this.setSpeedVar(10),
        this.setAngle(90),
        this.setAngleVar(5),
        t = cc.director.getWinSize(),
        this.setPosition(t.width / 2, 0),
        this.setPosVar(cc.p(20, 0)),
        this.setLife(4),
        this.setLifeVar(1),
        this.setStartSize(60),
        this.setStartSizeVar(10),
        this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE),
        this.setEmissionRate(this.getTotalParticles() / this.getLife()),
        this.setStartColor(cc.color(204, 204, 204, 255)),
        this.setStartColorVar(cc.color(5, 5, 5, 0)),
        this.setEndColor(cc.color(0, 0, 0, 255)),
        this.setEndColorVar(cc.color(0, 0, 0, 0)),
        this.setBlendAdditive(!1),
        !0)
    }
}),
cc.ParticleSmoke.create = function() {
    return new cc.ParticleSmoke
}
,
cc.ParticleSnow = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 700 : 250)
    },
    initWithTotalParticles: function(t) {
        return !!cc.ParticleSystem.prototype.initWithTotalParticles.call(this, t) && (this.setDuration(cc.ParticleSystem.DURATION_INFINITY),
        this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY),
        this.setGravity(cc.p(0, -1)),
        this.setSpeed(5),
        this.setSpeedVar(1),
        this.setRadialAccel(0),
        this.setRadialAccelVar(1),
        this.setTangentialAccel(0),
        this.setTangentialAccelVar(1),
        t = cc.director.getWinSize(),
        this.setPosition(t.width / 2, t.height + 10),
        this.setPosVar(cc.p(t.width / 2, 0)),
        this.setAngle(-90),
        this.setAngleVar(5),
        this.setLife(45),
        this.setLifeVar(15),
        this.setStartSize(10),
        this.setStartSizeVar(5),
        this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE),
        this.setEmissionRate(10),
        this.setStartColor(cc.color(255, 255, 255, 255)),
        this.setStartColorVar(cc.color(0, 0, 0, 0)),
        this.setEndColor(cc.color(255, 255, 255, 0)),
        this.setEndColorVar(cc.color(0, 0, 0, 0)),
        this.setBlendAdditive(!1),
        !0)
    }
}),
cc.ParticleSnow.create = function() {
    return new cc.ParticleSnow
}
,
cc.ParticleRain = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 1e3 : 300)
    },
    initWithTotalParticles: function(t) {
        return !!cc.ParticleSystem.prototype.initWithTotalParticles.call(this, t) && (this.setDuration(cc.ParticleSystem.DURATION_INFINITY),
        this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY),
        this.setGravity(cc.p(10, -10)),
        this.setRadialAccel(0),
        this.setRadialAccelVar(1),
        this.setTangentialAccel(0),
        this.setTangentialAccelVar(1),
        this.setSpeed(130),
        this.setSpeedVar(30),
        this.setAngle(-90),
        this.setAngleVar(5),
        t = cc.director.getWinSize(),
        this.setPosition(t.width / 2, t.height),
        this.setPosVar(cc.p(t.width / 2, 0)),
        this.setLife(4.5),
        this.setLifeVar(0),
        this.setStartSize(4),
        this.setStartSizeVar(2),
        this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE),
        this.setEmissionRate(20),
        this.setStartColor(cc.color(179, 204, 255, 255)),
        this.setStartColorVar(cc.color(0, 0, 0, 0)),
        this.setEndColor(cc.color(179, 204, 255, 128)),
        this.setEndColorVar(cc.color(0, 0, 0, 0)),
        this.setBlendAdditive(!1),
        !0)
    }
}),
cc.ParticleRain.create = function() {
    return new cc.ParticleRain
}
,
cc.PARTICLE_DEFAULT_CAPACITY = 500,
cc.ParticleBatchNode = cc.Node.extend({
    textureAtlas: null,
    _blendFunc: null,
    _className: "ParticleBatchNode",
    ctor: function(t, e) {
        cc.Node.prototype.ctor.call(this),
        this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        },
        cc.isString(t) ? this.init(t, e) : t instanceof cc.Texture2D && this.initWithTexture(t, e)
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.ParticleBatchNode.CanvasRenderCmd(this) : new cc.ParticleBatchNode.WebGLRenderCmd(this)
    },
    initWithTexture: function(t, e) {
        return this.textureAtlas = new cc.TextureAtlas,
        this.textureAtlas.initWithTexture(t, e),
        this._children.length = 0,
        this._renderCmd._initWithTexture(),
        !0
    },
    initWithFile: function(t, e) {
        var i = cc.textureCache.addImage(t);
        return this.initWithTexture(i, e)
    },
    init: function(t, e) {
        var i = cc.textureCache.addImage(t);
        return this.initWithTexture(i, e)
    },
    addChild: function(t, e, i) {
        if (!t)
            throw Error("cc.ParticleBatchNode.addChild() : child should be non-null");
        if (!(t instanceof cc.ParticleSystem))
            throw Error("cc.ParticleBatchNode.addChild() : only supports cc.ParticleSystem as children");
        if (e = null == e ? t.zIndex : e,
        i = null == i ? t.tag : i,
        t.getTexture() !== this.textureAtlas.texture)
            throw Error("cc.ParticleSystem.addChild() : the child is not using the same texture id");
        var n = t.getBlendFunc();
        if (0 === this._children.length)
            this.setBlendFunc(n);
        else if (n.src !== this._blendFunc.src || n.dst !== this._blendFunc.dst)
            return void cc.log("cc.ParticleSystem.addChild() : Can't add a ParticleSystem that uses a different blending function");
        e = this._addChildHelper(t, e, i),
        i = 0,
        0 !== e ? (e = this._children[e - 1],
        i = e.getAtlasIndex() + e.getTotalParticles()) : i = 0,
        this.insertChild(t, i),
        t.setBatchNode(this)
    },
    insertChild: function(t, e) {
        var i = t.getTotalParticles()
          , n = this.textureAtlas
          , r = n.totalQuads;
        t.setAtlasIndex(e),
        r + i > n.getCapacity() && (this._increaseAtlasCapacityTo(r + i),
        n.fillWithEmptyQuadsFromIndex(n.getCapacity() - i, i)),
        t.getAtlasIndex() + i !== r && n.moveQuadsFromIndex(e, e + i),
        n.increaseTotalQuadsWith(i),
        this._updateAllAtlasIndexes()
    },
    removeChild: function(t, e) {
        if (null != t) {
            if (!(t instanceof cc.ParticleSystem))
                throw Error("cc.ParticleBatchNode.removeChild(): only supports cc.ParticleSystem as children");
            if (-1 === this._children.indexOf(t))
                cc.log("cc.ParticleBatchNode.removeChild(): doesn't contain the sprite. Can't remove it");
            else {
                cc.Node.prototype.removeChild.call(this, t, e);
                var i = this.textureAtlas;
                i.removeQuadsAtIndex(t.getAtlasIndex(), t.getTotalParticles()),
                i.fillWithEmptyQuadsFromIndex(i.totalQuads, t.getTotalParticles()),
                t.setBatchNode(null),
                this._updateAllAtlasIndexes()
            }
        }
    },
    reorderChild: function(t, e) {
        if (!t)
            throw Error("cc.ParticleBatchNode.reorderChild(): child should be non-null");
        if (!(t instanceof cc.ParticleSystem))
            throw Error("cc.ParticleBatchNode.reorderChild(): only supports cc.QuadParticleSystems as children");
        if (-1 === this._children.indexOf(t))
            cc.log("cc.ParticleBatchNode.reorderChild(): Child doesn't belong to batch");
        else if (e !== t.zIndex) {
            if (1 < this._children.length) {
                var i = this._getCurrentIndex(t, e);
                if (i.oldIndex !== i.newIndex) {
                    this._children.splice(i.oldIndex, 1),
                    this._children.splice(i.newIndex, 0, t),
                    i = t.getAtlasIndex(),
                    this._updateAllAtlasIndexes();
                    for (var n = 0, r = this._children, c = 0; c < r.length; c++)
                        if (r[c] === t) {
                            n = t.getAtlasIndex();
                            break
                        }
                    this.textureAtlas.moveQuadsFromIndex(i, t.getTotalParticles(), n),
                    t.updateWithNoTime()
                }
            }
            t._setLocalZOrder(e)
        }
    },
    removeChildAtIndex: function(t, e) {
        this.removeChild(this._children[i], e)
    },
    removeAllChildren: function(t) {
        for (var e = this._children, i = 0; i < e.length; i++)
            e[i].setBatchNode(null);
        cc.Node.prototype.removeAllChildren.call(this, t),
        this.textureAtlas.removeAllQuads()
    },
    disableParticle: function(t) {
        t = this.textureAtlas.quads[t],
        t.br.vertices.x = t.br.vertices.y = t.tr.vertices.x = t.tr.vertices.y = t.tl.vertices.x = t.tl.vertices.y = t.bl.vertices.x = t.bl.vertices.y = 0,
        this.textureAtlas._setDirty(!0)
    },
    getTexture: function() {
        return this.textureAtlas.texture
    },
    setTexture: function(t) {
        this.textureAtlas.texture = t;
        var e = this._blendFunc;
        t && !t.hasPremultipliedAlpha() && e.src === cc.BLEND_SRC && e.dst === cc.BLEND_DST && (e.src = cc.SRC_ALPHA,
        e.dst = cc.ONE_MINUS_SRC_ALPHA)
    },
    setBlendFunc: function(t, e) {
        void 0 === e ? (this._blendFunc.src = t.src,
        this._blendFunc.dst = t.dst) : (this._blendFunc.src = t,
        this._blendFunc.src = e)
    },
    getBlendFunc: function() {
        return new cc.BlendFunc(this._blendFunc.src,this._blendFunc.dst)
    },
    _updateAllAtlasIndexes: function() {
        for (var t = 0, e = this._children, i = 0; i < e.length; i++) {
            var n = e[i];
            n.setAtlasIndex(t),
            t += n.getTotalParticles()
        }
    },
    _increaseAtlasCapacityTo: function(t) {
        cc.log("cocos2d: cc.ParticleBatchNode: resizing TextureAtlas capacity from [" + this.textureAtlas.getCapacity() + "] to [" + t + "]."),
        this.textureAtlas.resizeCapacity(t) || cc.log("cc.ParticleBatchNode._increaseAtlasCapacityTo() : WARNING: Not enough memory to resize the atlas")
    },
    _searchNewPositionInChildrenForZ: function(t) {
        for (var e = this._children, i = e.length, n = 0; n < i; n++)
            if (e[n].zIndex > t)
                return n;
        return i
    },
    _getCurrentIndex: function(t, e) {
        for (var i = !1, n = !1, r = 0, c = 0, s = 0, o = this._children, a = o.length, h = 0; h < a; h++) {
            var l = o[h];
            if (l.zIndex > e && !n && (r = h,
            n = !0,
            i && n))
                break;
            if (t === l && (c = h,
            i = !0,
            n || (s = -1),
            i && n))
                break
        }
        return n || (r = a),
        {
            newIndex: r + s,
            oldIndex: c
        }
    },
    _addChildHelper: function(t, e, i) {
        if (!t)
            throw Error("cc.ParticleBatchNode._addChildHelper(): child should be non-null");
        if (t.parent)
            return cc.log("cc.ParticleBatchNode._addChildHelper(): child already added. It can't be added again"),
            null;
        this._children || (this._children = []);
        var n = this._searchNewPositionInChildrenForZ(e);
        return this._children.splice(n, 0, t),
        t.tag = i,
        t._setLocalZOrder(e),
        t.parent = this,
        this._running && (t.onEnter(),
        t.onEnterTransitionDidFinish()),
        n
    },
    _updateBlendFunc: function() {
        this.textureAtlas.texture.hasPremultipliedAlpha() || (this._blendFunc.src = cc.SRC_ALPHA,
        this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA)
    },
    getTextureAtlas: function() {
        return this.textureAtlas
    },
    setTextureAtlas: function(t) {
        this.textureAtlas = t
    }
}),
_p = cc.ParticleBatchNode.prototype,
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture),
cc.ParticleBatchNode.create = function(t, e) {
    return new cc.ParticleBatchNode(t,e)
}
,
function() {
    cc.ParticleBatchNode.CanvasRenderCmd = function(t) {
        cc.Node.CanvasRenderCmd.call(this, t),
        this._needDraw = !1
    }
    ;
    var t = cc.ParticleBatchNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    t.constructor = cc.ParticleBatchNode.CanvasRenderCmd,
    t._initWithTexture = function() {}
}(),
function() {
    cc.ParticleBatchNode.WebGLRenderCmd = function(t) {
        cc.Node.WebGLRenderCmd.call(this, t),
        this._needDraw = !0
    }
    ;
    var t = cc.ParticleBatchNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    t.constructor = cc.ParticleBatchNode.WebGLRenderCmd,
    t.rendering = function(t) {
        t = this._node,
        0 !== t.textureAtlas.totalQuads && (this._shaderProgram.use(),
        this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix),
        cc.glBlendFuncForParticle(t._blendFunc.src, t._blendFunc.dst),
        t.textureAtlas.drawQuads())
    }
    ,
    t._initWithTexture = function() {
        this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)
    }
    ,
    t.visit = function(t) {
        if (this._node._visible) {
            var e = cc.current_stack;
            e.stack.push(e.top),
            this._syncStatus(t),
            e.top = this._stackMatrix,
            cc.renderer.pushRenderCommand(this),
            this._dirtyFlag = 0,
            cc.kmGLPopMatrix()
        }
    }
}(),
cc.IMEKeyboardNotificationInfo = function(t, e, i) {
    this.begin = t || cc.rect(0, 0, 0, 0),
    this.end = e || cc.rect(0, 0, 0, 0),
    this.duration = i || 0
}
,
cc.IMEDelegate = cc.Class.extend({
    ctor: function() {
        cc.imeDispatcher.addDelegate(this)
    },
    removeDelegate: function() {
        cc.imeDispatcher.removeDelegate(this)
    },
    attachWithIME: function() {
        return cc.imeDispatcher.attachDelegateWithIME(this)
    },
    detachWithIME: function() {
        return cc.imeDispatcher.detachDelegateWithIME(this)
    },
    canAttachWithIME: function() {
        return !1
    },
    didAttachWithIME: function() {},
    canDetachWithIME: function() {
        return !1
    },
    didDetachWithIME: function() {},
    insertText: function(t, e) {},
    deleteBackward: function() {},
    getContentText: function() {
        return ""
    },
    keyboardWillShow: function(t) {},
    keyboardDidShow: function(t) {},
    keyboardWillHide: function(t) {},
    keyboardDidHide: function(t) {}
}),
cc.IMEDispatcher = cc.Class.extend({
    _domInputControl: null,
    impl: null,
    _currentInputString: "",
    _lastClickPosition: null,
    ctor: function() {
        this.impl = new cc.IMEDispatcher.Impl,
        this._lastClickPosition = cc.p(0, 0)
    },
    init: function() {
        if (!cc.sys.isMobile) {
            this._domInputControl = cc.$("#imeDispatcherInput"),
            this._domInputControl || (this._domInputControl = cc.$new("input"),
            this._domInputControl.setAttribute("type", "text"),
            this._domInputControl.setAttribute("id", "imeDispatcherInput"),
            this._domInputControl.resize(0, 0),
            this._domInputControl.translates(0, 0),
            this._domInputControl.style.opacity = "0",
            this._domInputControl.style.fontSize = "1px",
            this._domInputControl.setAttribute("tabindex", 2),
            this._domInputControl.style.position = "absolute",
            this._domInputControl.style.top = 0,
            this._domInputControl.style.left = 0,
            document.body.appendChild(this._domInputControl));
            var t = this;
            this._domInputControl.addEventListener("input", function() {
                t._processDomInputString(t._domInputControl.value)
            }, !1),
            this._domInputControl.addEventListener("keydown", function(e) {
                e.keyCode === cc.KEY.tab ? (e.stopPropagation(),
                e.preventDefault()) : e.keyCode === cc.KEY.enter && (t.dispatchInsertText("\n", 1),
                e.stopPropagation(),
                e.preventDefault())
            }, !1),
            /msie/i.test(navigator.userAgent) && this._domInputControl.addEventListener("keyup", function(e) {
                e.keyCode === cc.KEY.backspace && t._processDomInputString(t._domInputControl.value)
            }, !1),
            window.addEventListener("mousedown", function(e) {
                var i = e.pageY || 0;
                t._lastClickPosition.x = e.pageX || 0,
                t._lastClickPosition.y = i
            }, !1)
        }
    },
    _processDomInputString: function(t) {
        var e, i;
        for (e = this._currentInputString.length < t.length ? this._currentInputString.length : t.length,
        i = 0; i < e && t[i] === this._currentInputString[i]; i++)
            ;
        var n = this._currentInputString.length - i
          , r = t.length - i;
        for (e = 0; e < n; e++)
            this.dispatchDeleteBackward();
        for (e = 0; e < r; e++)
            this.dispatchInsertText(t[i + e], 1);
        this._currentInputString = t
    },
    dispatchInsertText: function(t, e) {
        !this.impl || !t || 0 >= e || this.impl._delegateWithIme && this.impl._delegateWithIme.insertText(t, e)
    },
    dispatchDeleteBackward: function() {
        this.impl && this.impl._delegateWithIme && this.impl._delegateWithIme.deleteBackward()
    },
    getContentText: function() {
        if (this.impl && this.impl._delegateWithIme) {
            var t = this.impl._delegateWithIme.getContentText();
            return t ? t : ""
        }
        return ""
    },
    dispatchKeyboardWillShow: function(t) {
        if (this.impl)
            for (var e = 0; e < this.impl._delegateList.length; e++) {
                var i = this.impl._delegateList[e];
                i && i.keyboardWillShow(t)
            }
    },
    dispatchKeyboardDidShow: function(t) {
        if (this.impl)
            for (var e = 0; e < this.impl._delegateList.length; e++) {
                var i = this.impl._delegateList[e];
                i && i.keyboardDidShow(t)
            }
    },
    dispatchKeyboardWillHide: function(t) {
        if (this.impl)
            for (var e = 0; e < this.impl._delegateList.length; e++) {
                var i = this.impl._delegateList[e];
                i && i.keyboardWillHide(t)
            }
    },
    dispatchKeyboardDidHide: function(t) {
        if (this.impl)
            for (var e = 0; e < this.impl._delegateList.length; e++) {
                var i = this.impl._delegateList[e];
                i && i.keyboardDidHide(t)
            }
    },
    addDelegate: function(t) {
        t && this.impl && (-1 < this.impl._delegateList.indexOf(t) || this.impl._delegateList.splice(0, 0, t))
    },
    attachDelegateWithIME: function(t) {
        if (!this.impl || !t || -1 === this.impl._delegateList.indexOf(t))
            return !1;
        if (this.impl._delegateWithIme) {
            if (!this.impl._delegateWithIme.canDetachWithIME() || !t.canAttachWithIME())
                return !1;
            var e = this.impl._delegateWithIme;
            return this.impl._delegateWithIme = null,
            e.didDetachWithIME(),
            this._focusDomInput(t),
            !0
        }
        return !!t.canAttachWithIME() && (this._focusDomInput(t),
        !0)
    },
    _focusDomInput: function(t) {
        cc.sys.isMobile ? (this.impl._delegateWithIme = t,
        t.didAttachWithIME(),
        this._currentInputString = t.string || "",
        t = t.getTipMessage ? t.getTipMessage() : "please enter your word:",
        t = window.Window && Window.prototype.prompt != prompt ? Window.prototype.prompt.call(window, t, this._currentInputString) : prompt(t, this._currentInputString),
        null != t && this._processDomInputString(t),
        this.dispatchInsertText("\n", 1)) : (this.impl._delegateWithIme = t,
        this._currentInputString = t.string || "",
        t.didAttachWithIME(),
        this._domInputControl.focus(),
        this._domInputControl.value = this._currentInputString,
        this._domInputControlTranslate())
    },
    _domInputControlTranslate: function() {
        /msie/i.test(navigator.userAgent) ? (this._domInputControl.style.left = this._lastClickPosition.x + "px",
        this._domInputControl.style.top = this._lastClickPosition.y + "px") : this._domInputControl.translates(this._lastClickPosition.x, this._lastClickPosition.y)
    },
    detachDelegateWithIME: function(t) {
        return !!(this.impl && t && this.impl._delegateWithIme === t && t.canDetachWithIME()) && (this.impl._delegateWithIme = null,
        t.didDetachWithIME(),
        cc._canvas.focus(),
        !0)
    },
    removeDelegate: function(t) {
        this.impl && t && -1 !== this.impl._delegateList.indexOf(t) && (this.impl._delegateWithIme && t === this.impl._delegateWithIme && (this.impl._delegateWithIme = null),
        cc.arrayRemoveObject(this.impl._delegateList, t))
    },
    processKeycode: function(t) {
        32 > t ? t === cc.KEY.backspace ? this.dispatchDeleteBackward() : t === cc.KEY.enter && this.dispatchInsertText("\n", 1) : 255 > t && this.dispatchInsertText(String.fromCharCode(t), 1)
    }
}),
cc.IMEDispatcher.Impl = cc.Class.extend({
    _delegateWithIme: null,
    _delegateList: null,
    ctor: function() {
        this._delegateList = []
    },
    findDelegate: function(t) {
        for (var e = 0; e < this._delegateList.length; e++)
            if (this._delegateList[e] === t)
                return e;
        return null
    }
}),
cc.imeDispatcher = new cc.IMEDispatcher,
document.body ? cc.imeDispatcher.init() : window.addEventListener("load", function() {
    cc.imeDispatcher.init()
}, !1),
cc.TextFieldDelegate = cc.Class.extend({
    onTextFieldAttachWithIME: function(t) {
        return !1
    },
    onTextFieldDetachWithIME: function(t) {
        return !1
    },
    onTextFieldInsertText: function(t, e, i) {
        return !1
    },
    onTextFieldDeleteBackward: function(t, e, i) {
        return !1
    },
    onDraw: function(t) {
        return !1
    }
}),
cc.TextFieldTTF = cc.LabelTTF.extend({
    delegate: null,
    colorSpaceHolder: null,
    _colorText: null,
    _lens: null,
    _inputText: "",
    _placeHolder: "",
    _charCount: 0,
    _className: "TextFieldTTF",
    ctor: function(t, e, i, n, r) {
        this.colorSpaceHolder = cc.color(127, 127, 127),
        this._colorText = cc.color(255, 255, 255, 255),
        cc.LabelTTF.prototype.ctor.call(this),
        void 0 !== r ? (this.initWithPlaceHolder("", e, i, n, r),
        t && this.setPlaceHolder(t)) : void 0 === n && void 0 !== i && (this.initWithString("", e, i),
        t && this.setPlaceHolder(t))
    },
    onEnter: function() {
        cc.LabelTTF.prototype.onEnter.call(this),
        cc.imeDispatcher.addDelegate(this)
    },
    onExit: function() {
        cc.LabelTTF.prototype.onExit.call(this),
        cc.imeDispatcher.removeDelegate(this)
    },
    getDelegate: function() {
        return this.delegate
    },
    setDelegate: function(t) {
        this.delegate = t
    },
    getCharCount: function() {
        return this._charCount
    },
    getColorSpaceHolder: function() {
        return cc.color(this.colorSpaceHolder)
    },
    setColorSpaceHolder: function(t) {
        this.colorSpaceHolder.r = t.r,
        this.colorSpaceHolder.g = t.g,
        this.colorSpaceHolder.b = t.b,
        this.colorSpaceHolder.a = cc.isUndefined(t.a) ? 255 : t.a,
        this._inputText.length || this.setColor(this.colorSpaceHolder)
    },
    setTextColor: function(t) {
        this._colorText.r = t.r,
        this._colorText.g = t.g,
        this._colorText.b = t.b,
        this._colorText.a = cc.isUndefined(t.a) ? 255 : t.a,
        this._inputText.length && this.setColor(this._colorText)
    },
    initWithPlaceHolder: function(t, e, i, n, r) {
        switch (arguments.length) {
        case 5:
            return t && this.setPlaceHolder(t),
            this.initWithString(this._placeHolder, n, r, e, i);
        case 3:
            return t && this.setPlaceHolder(t),
            this.initWithString(this._placeHolder, arguments[1], arguments[2]);
        default:
            throw Error("Argument must be non-nil ")
        }
    },
    setString: function(t) {
        this._inputText = (t = String(t)) || "",
        this._inputText.length ? (cc.LabelTTF.prototype.setString.call(this, this._inputText),
        this.setColor(this._colorText)) : (cc.LabelTTF.prototype.setString.call(this, this._placeHolder),
        this.setColor(this.colorSpaceHolder)),
        cc._renderType === cc.game.RENDER_TYPE_CANVAS && this._renderCmd._updateTexture(),
        this._charCount = this._inputText.length
    },
    getString: function() {
        return this._inputText
    },
    setPlaceHolder: function(t) {
        this._placeHolder = t || "",
        this._inputText.length || (cc.LabelTTF.prototype.setString.call(this, this._placeHolder),
        this.setColor(this.colorSpaceHolder))
    },
    getPlaceHolder: function() {
        return this._placeHolder
    },
    draw: function(t) {
        t = t || cc._renderContext,
        this.delegate && this.delegate.onDraw(this) || cc.LabelTTF.prototype.draw.call(this, t)
    },
    visit: function(t) {
        this._super(t)
    },
    attachWithIME: function() {
        return cc.imeDispatcher.attachDelegateWithIME(this)
    },
    detachWithIME: function() {
        return cc.imeDispatcher.detachDelegateWithIME(this)
    },
    canAttachWithIME: function() {
        return !this.delegate || !this.delegate.onTextFieldAttachWithIME(this)
    },
    didAttachWithIME: function() {},
    canDetachWithIME: function() {
        return !this.delegate || !this.delegate.onTextFieldDetachWithIME(this)
    },
    didDetachWithIME: function() {},
    deleteBackward: function() {
        var t = this._inputText.length;
        0 === t || this.delegate && this.delegate.onTextFieldDeleteBackward(this, this._inputText[t - 1], 1) || (1 >= t ? (this._inputText = "",
        this._charCount = 0,
        cc.LabelTTF.prototype.setString.call(this, this._placeHolder),
        this.setColor(this.colorSpaceHolder)) : this.string = this._inputText.substring(0, t - 1))
    },
    removeDelegate: function() {
        cc.imeDispatcher.removeDelegate(this)
    },
    _tipMessage: "please enter your word:",
    setTipMessage: function(t) {
        null != t && (this._tipMessage = t)
    },
    getTipMessage: function() {
        return this._tipMessage
    },
    insertText: function(t, e) {
        var i = t
          , n = i.indexOf("\n");
        if (-1 < n && (i = i.substring(0, n)),
        0 < i.length) {
            if (this.delegate && this.delegate.onTextFieldInsertText(this, i, i.length))
                return;
            i = this._inputText + i,
            this._charCount = i.length,
            this.string = i
        }
        -1 !== n && (this.delegate && this.delegate.onTextFieldInsertText(this, "\n", 1) || this.detachWithIME())
    },
    getContentText: function() {
        return this._inputText
    },
    keyboardWillShow: function(t) {},
    keyboardDidShow: function(t) {},
    keyboardWillHide: function(t) {},
    keyboardDidHide: function(t) {}
}),
_p = cc.TextFieldTTF.prototype,
cc.defineGetterSetter(_p, "charCount", _p.getCharCount),
cc.defineGetterSetter(_p, "placeHolder", _p.getPlaceHolder, _p.setPlaceHolder),
cc.TextFieldTTF.create = function(t, e, i, n, r) {
    return new cc.TextFieldTTF(t,e,i,n,r)
}
,
cc._globalFontSize = cc.ITEM_SIZE,
cc._globalFontName = "Arial",
cc._globalFontNameRelease = !1,
cc.MenuItem = cc.Node.extend({
    _enabled: !1,
    _target: null,
    _callback: null,
    _isSelected: !1,
    _className: "MenuItem",
    ctor: function(t, e) {
        var i = cc.Node.prototype;
        i.ctor.call(this),
        this._callback = this._target = null,
        this._enabled = this._isSelected = !1,
        i.setAnchorPoint.call(this, .5, .5),
        this._target = e || null,
        (this._callback = t || null) && (this._enabled = !0)
    },
    isSelected: function() {
        return this._isSelected
    },
    setOpacityModifyRGB: function(t) {},
    isOpacityModifyRGB: function() {
        return !1
    },
    setTarget: function(t, e) {
        this._target = e,
        this._callback = t
    },
    isEnabled: function() {
        return this._enabled
    },
    setEnabled: function(t) {
        this._enabled = t
    },
    initWithCallback: function(t, e) {
        return this.anchorY = this.anchorX = .5,
        this._target = e,
        this._callback = t,
        this._enabled = !0,
        this._isSelected = !1,
        !0
    },
    rect: function() {
        var t = this._position
          , e = this._contentSize
          , i = this._anchorPoint;
        return cc.rect(t.x - e.width * i.x, t.y - e.height * i.y, e.width, e.height)
    },
    selected: function() {
        this._isSelected = !0
    },
    unselected: function() {
        this._isSelected = !1
    },
    setCallback: function(t, e) {
        this._target = e,
        this._callback = t
    },
    activate: function() {
        if (this._enabled) {
            var t = this._target
              , e = this._callback;
            e && (t && cc.isString(e) ? t[e](this) : t && cc.isFunction(e) ? e.call(t, this) : e(this))
        }
    }
}),
_p = cc.MenuItem.prototype,
cc.defineGetterSetter(_p, "enabled", _p.isEnabled, _p.setEnabled),
cc.MenuItem.create = function(t, e) {
    return new cc.MenuItem(t,e)
}
,
cc.MenuItemLabel = cc.MenuItem.extend({
    _disabledColor: null,
    _label: null,
    _originalScale: 0,
    _colorBackup: null,
    ctor: function(t, e, i) {
        cc.MenuItem.prototype.ctor.call(this, e, i),
        this._colorBackup = this._label = this._disabledColor = null,
        t && (this._originalScale = 1,
        this._colorBackup = cc.color.WHITE,
        this._disabledColor = cc.color(126, 126, 126),
        this.setLabel(t),
        this.setCascadeColorEnabled(!0),
        this.setCascadeOpacityEnabled(!0))
    },
    getDisabledColor: function() {
        return this._disabledColor
    },
    setDisabledColor: function(t) {
        this._disabledColor = t
    },
    getLabel: function() {
        return this._label
    },
    setLabel: function(t) {
        t && (this.addChild(t),
        t.anchorX = 0,
        t.anchorY = 0,
        this.width = t.width,
        this.height = t.height,
        t.setCascadeColorEnabled(!0)),
        this._label && this.removeChild(this._label, !0),
        this._label = t
    },
    setEnabled: function(t) {
        this._enabled !== t && (t ? this.setColor(this._colorBackup) : (this._colorBackup = this.color,
        this.setColor(this._disabledColor))),
        cc.MenuItem.prototype.setEnabled.call(this, t)
    },
    initWithLabel: function(t, e, i) {
        return this.initWithCallback(e, i),
        this._originalScale = 1,
        this._colorBackup = cc.color.WHITE,
        this._disabledColor = cc.color(126, 126, 126),
        this.setLabel(t),
        this.setCascadeColorEnabled(!0),
        this.setCascadeOpacityEnabled(!0),
        !0
    },
    setString: function(t) {
        this._label.string = t,
        this.width = this._label.width,
        this.height = this._label.height
    },
    getString: function() {
        return this._label.string
    },
    activate: function() {
        this._enabled && (this.stopAllActions(),
        this.scale = this._originalScale,
        cc.MenuItem.prototype.activate.call(this))
    },
    selected: function() {
        if (this._enabled) {
            cc.MenuItem.prototype.selected.call(this);
            var t = this.getActionByTag(cc.ZOOM_ACTION_TAG);
            t ? this.stopAction(t) : this._originalScale = this.scale,
            t = cc.scaleTo(.1, 1.2 * this._originalScale),
            t.setTag(cc.ZOOM_ACTION_TAG),
            this.runAction(t)
        }
    },
    unselected: function() {
        if (this._enabled) {
            cc.MenuItem.prototype.unselected.call(this),
            this.stopActionByTag(cc.ZOOM_ACTION_TAG);
            var t = cc.scaleTo(.1, this._originalScale);
            t.setTag(cc.ZOOM_ACTION_TAG),
            this.runAction(t)
        }
    }
}),
_p = cc.MenuItemLabel.prototype,
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString),
cc.defineGetterSetter(_p, "disabledColor", _p.getDisabledColor, _p.setDisabledColor),
cc.defineGetterSetter(_p, "label", _p.getLabel, _p.setLabel),
cc.MenuItemLabel.create = function(t, e, i) {
    return new cc.MenuItemLabel(t,e,i)
}
,
cc.MenuItemAtlasFont = cc.MenuItemLabel.extend({
    ctor: function(t, e, i, n, r, c, s) {
        var o;
        t && 0 < t.length && (o = new cc.LabelAtlas(t,e,i,n,r)),
        cc.MenuItemLabel.prototype.ctor.call(this, o, c, s)
    },
    initWithString: function(t, e, i, n, r, c, s) {
        if (!t || 0 === t.length)
            throw Error("cc.MenuItemAtlasFont.initWithString(): value should be non-null and its length should be greater than 0");
        var o = new cc.LabelAtlas;
        return o.initWithString(t, e, i, n, r),
        this.initWithLabel(o, c, s),
        !0
    }
}),
cc.MenuItemAtlasFont.create = function(t, e, i, n, r, c, s) {
    return new cc.MenuItemAtlasFont(t,e,i,n,r,c,s);
}
,
cc.MenuItemFont = cc.MenuItemLabel.extend({
    _fontSize: null,
    _fontName: null,
    ctor: function(t, e, i) {
        var n;
        t && 0 < t.length ? (this._fontName = cc._globalFontName,
        this._fontSize = cc._globalFontSize,
        n = new cc.LabelTTF(t,this._fontName,this._fontSize)) : (this._fontSize = 0,
        this._fontName = ""),
        cc.MenuItemLabel.prototype.ctor.call(this, n, e, i)
    },
    initWithString: function(t, e, i) {
        if (!t || 0 === t.length)
            throw Error("Value should be non-null and its length should be greater than 0");
        return this._fontName = cc._globalFontName,
        this._fontSize = cc._globalFontSize,
        t = new cc.LabelTTF(t,this._fontName,this._fontSize),
        this.initWithLabel(t, e, i),
        !0
    },
    setFontSize: function(t) {
        this._fontSize = t,
        this._recreateLabel()
    },
    getFontSize: function() {
        return this._fontSize
    },
    setFontName: function(t) {
        this._fontName = t,
        this._recreateLabel()
    },
    getFontName: function() {
        return this._fontName
    },
    _recreateLabel: function() {
        var t = new cc.LabelTTF(this._label.string,this._fontName,this._fontSize);
        this.setLabel(t)
    }
}),
cc.MenuItemFont.setFontSize = function(t) {
    cc._globalFontSize = t
}
,
cc.MenuItemFont.fontSize = function() {
    return cc._globalFontSize
}
,
cc.MenuItemFont.setFontName = function(t) {
    cc._globalFontNameRelease && (cc._globalFontName = ""),
    cc._globalFontName = t,
    cc._globalFontNameRelease = !0
}
,
_p = cc.MenuItemFont.prototype,
cc.defineGetterSetter(_p, "fontSize", _p.getFontSize, _p.setFontSize),
cc.defineGetterSetter(_p, "fontName", _p.getFontName, _p.setFontName),
cc.MenuItemFont.fontName = function() {
    return cc._globalFontName
}
,
cc.MenuItemFont.create = function(t, e, i) {
    return new cc.MenuItemFont(t,e,i)
}
,
cc.MenuItemSprite = cc.MenuItem.extend({
    _normalImage: null,
    _selectedImage: null,
    _disabledImage: null,
    ctor: function(t, e, i, n, r) {
        if (cc.MenuItem.prototype.ctor.call(this),
        this._disabledImage = this._selectedImage = this._normalImage = null,
        void 0 !== e) {
            var c, s, o;
            void 0 !== r ? (c = i,
            o = n,
            s = r) : void 0 !== n && cc.isFunction(n) ? (c = i,
            o = n) : void 0 !== n && cc.isFunction(i) ? (s = n,
            o = i,
            c = null) : void 0 === i && (c = null),
            this.initWithNormalSprite(t, e, c, o, s)
        }
    },
    getNormalImage: function() {
        return this._normalImage
    },
    setNormalImage: function(t) {
        this._normalImage !== t && (t && (this.addChild(t, 0, cc.NORMAL_TAG),
        t.anchorX = 0,
        t.anchorY = 0),
        this._normalImage && this.removeChild(this._normalImage, !0),
        this._normalImage = t) && (this.width = this._normalImage.width,
        this.height = this._normalImage.height,
        this._updateImagesVisibility(),
        t.textureLoaded && !t.textureLoaded() && t.addEventListener("load", function(t) {
            this.width = t.width,
            this.height = t.height
        }, this))
    },
    getSelectedImage: function() {
        return this._selectedImage
    },
    setSelectedImage: function(t) {
        this._selectedImage !== t && (t && (this.addChild(t, 0, cc.SELECTED_TAG),
        t.anchorX = 0,
        t.anchorY = 0),
        this._selectedImage && this.removeChild(this._selectedImage, !0),
        this._selectedImage = t,
        this._updateImagesVisibility())
    },
    getDisabledImage: function() {
        return this._disabledImage
    },
    setDisabledImage: function(t) {
        this._disabledImage !== t && (t && (this.addChild(t, 0, cc.DISABLE_TAG),
        t.anchorX = 0,
        t.anchorY = 0),
        this._disabledImage && this.removeChild(this._disabledImage, !0),
        this._disabledImage = t,
        this._updateImagesVisibility())
    },
    initWithNormalSprite: function(t, e, i, n, r) {
        return this.initWithCallback(n, r),
        this.setNormalImage(t),
        this.setSelectedImage(e),
        this.setDisabledImage(i),
        (t = this._normalImage) && (this.width = t.width,
        this.height = t.height,
        t.textureLoaded && !t.textureLoaded() && t.addEventListener("load", function(t) {
            this.width = t.width,
            this.height = t.height,
            this.setCascadeColorEnabled(!0),
            this.setCascadeOpacityEnabled(!0)
        }, this)),
        this.setCascadeColorEnabled(!0),
        this.setCascadeOpacityEnabled(!0),
        !0
    },
    selected: function() {
        cc.MenuItem.prototype.selected.call(this),
        this._normalImage && (this._disabledImage && (this._disabledImage.visible = !1),
        this._selectedImage ? (this._normalImage.visible = !1,
        this._selectedImage.visible = !0) : this._normalImage.visible = !0)
    },
    unselected: function() {
        cc.MenuItem.prototype.unselected.call(this),
        this._normalImage && (this._normalImage.visible = !0,
        this._selectedImage && (this._selectedImage.visible = !1),
        this._disabledImage && (this._disabledImage.visible = !1))
    },
    setEnabled: function(t) {
        this._enabled !== t && (cc.MenuItem.prototype.setEnabled.call(this, t),
        this._updateImagesVisibility())
    },
    _updateImagesVisibility: function() {
        var t = this._normalImage
          , e = this._selectedImage
          , i = this._disabledImage;
        this._enabled ? (t && (t.visible = !0),
        e && (e.visible = !1),
        i && (i.visible = !1)) : i ? (t && (t.visible = !1),
        e && (e.visible = !1),
        i && (i.visible = !0)) : (t && (t.visible = !0),
        e && (e.visible = !1))
    }
}),
_p = cc.MenuItemSprite.prototype,
cc.defineGetterSetter(_p, "normalImage", _p.getNormalImage, _p.setNormalImage),
cc.defineGetterSetter(_p, "selectedImage", _p.getSelectedImage, _p.setSelectedImage),
cc.defineGetterSetter(_p, "disabledImage", _p.getDisabledImage, _p.setDisabledImage),
cc.MenuItemSprite.create = function(t, e, i, n, r) {
    return new cc.MenuItemSprite(t,e,i,n,r || void 0)
}
,
cc.MenuItemImage = cc.MenuItemSprite.extend({
    ctor: function(t, e, i, n, r) {
        var c = null
          , s = null
          , o = null
          , a = null
          , h = null;
        void 0 === t || null === t ? cc.MenuItemSprite.prototype.ctor.call(this) : (c = new cc.Sprite(t),
        e && (s = new cc.Sprite(e)),
        void 0 === n ? a = i : void 0 === r ? (a = i,
        h = n) : r && (o = new cc.Sprite(i),
        a = n,
        h = r),
        cc.MenuItemSprite.prototype.ctor.call(this, c, s, o, a, h))
    },
    setNormalSpriteFrame: function(t) {
        this.setNormalImage(new cc.Sprite(t))
    },
    setSelectedSpriteFrame: function(t) {
        this.setSelectedImage(new cc.Sprite(t))
    },
    setDisabledSpriteFrame: function(t) {
        this.setDisabledImage(new cc.Sprite(t))
    },
    initWithNormalImage: function(t, e, i, n, r) {
        var c = null
          , s = null
          , o = null;
        return t && (c = new cc.Sprite(t)),
        e && (s = new cc.Sprite(e)),
        i && (o = new cc.Sprite(i)),
        this.initWithNormalSprite(c, s, o, n, r)
    }
}),
cc.MenuItemImage.create = function(t, e, i, n, r) {
    return new cc.MenuItemImage(t,e,i,n,r)
}
,
cc.MenuItemToggle = cc.MenuItem.extend({
    subItems: null,
    _selectedIndex: 0,
    _opacity: null,
    _color: null,
    ctor: function() {
        cc.MenuItem.prototype.ctor.call(this),
        this._selectedIndex = 0,
        this.subItems = [],
        this._opacity = 0,
        this._color = cc.color.WHITE,
        0 < arguments.length && this.initWithItems(Array.prototype.slice.apply(arguments))
    },
    getOpacity: function() {
        return this._opacity
    },
    setOpacity: function(t) {
        if (this._opacity = t,
        this.subItems && 0 < this.subItems.length)
            for (var e = 0; e < this.subItems.length; e++)
                this.subItems[e].opacity = t;
        this._color.a = t
    },
    getColor: function() {
        var t = this._color;
        return cc.color(t.r, t.g, t.b, t.a)
    },
    setColor: function(t) {
        var e = this._color;
        if (e.r = t.r,
        e.g = t.g,
        e.b = t.b,
        this.subItems && 0 < this.subItems.length)
            for (e = 0; e < this.subItems.length; e++)
                this.subItems[e].setColor(t);
        void 0 === t.a || t.a_undefined || this.setOpacity(t.a)
    },
    getSelectedIndex: function() {
        return this._selectedIndex
    },
    setSelectedIndex: function(t) {
        if (t !== this._selectedIndex) {
            this._selectedIndex = t,
            (t = this.getChildByTag(cc.CURRENT_ITEM)) && t.removeFromParent(!1),
            t = this.subItems[this._selectedIndex],
            this.addChild(t, 0, cc.CURRENT_ITEM);
            var e = t.width
              , i = t.height;
            this.width = e,
            this.height = i,
            t.setPosition(e / 2, i / 2)
        }
    },
    getSubItems: function() {
        return this.subItems
    },
    setSubItems: function(t) {
        this.subItems = t
    },
    initWithItems: function(t) {
        var e = t.length;
        cc.isFunction(t[t.length - 2]) ? (this.initWithCallback(t[t.length - 2], t[t.length - 1]),
        e -= 2) : cc.isFunction(t[t.length - 1]) ? (this.initWithCallback(t[t.length - 1], null),
        e -= 1) : this.initWithCallback(null, null);
        for (var i = this.subItems, n = i.length = 0; n < e; n++)
            t[n] && i.push(t[n]);
        return this._selectedIndex = cc.UINT_MAX,
        this.setSelectedIndex(0),
        this.setCascadeColorEnabled(!0),
        this.setCascadeOpacityEnabled(!0),
        !0
    },
    addSubItem: function(t) {
        this.subItems.push(t)
    },
    activate: function() {
        this._enabled && this.setSelectedIndex((this._selectedIndex + 1) % this.subItems.length),
        cc.MenuItem.prototype.activate.call(this)
    },
    selected: function() {
        cc.MenuItem.prototype.selected.call(this),
        this.subItems[this._selectedIndex].selected()
    },
    unselected: function() {
        cc.MenuItem.prototype.unselected.call(this),
        this.subItems[this._selectedIndex].unselected()
    },
    setEnabled: function(t) {
        if (this._enabled !== t) {
            cc.MenuItem.prototype.setEnabled.call(this, t);
            var e = this.subItems;
            if (e && 0 < e.length)
                for (var i = 0; i < e.length; i++)
                    e[i].enabled = t
        }
    },
    selectedItem: function() {
        return this.subItems[this._selectedIndex]
    },
    getSelectedItem: function() {
        return this.subItems[this._selectedIndex]
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this),
        this.setSelectedIndex(this._selectedIndex)
    }
}),
_p = cc.MenuItemToggle.prototype,
cc.defineGetterSetter(_p, "selectedIndex", _p.getSelectedIndex, _p.setSelectedIndex),
cc.MenuItemToggle.create = function() {
    0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
    var t = new cc.MenuItemToggle;
    return t.initWithItems(Array.prototype.slice.apply(arguments)),
    t
}
,
cc.MENU_STATE_WAITING = 0,
cc.MENU_STATE_TRACKING_TOUCH = 1,
cc.MENU_HANDLER_PRIORITY = -128,
cc.DEFAULT_PADDING = 5,
cc.Menu = cc.Layer.extend({
    enabled: !1,
    _selectedItem: null,
    _state: -1,
    _touchListener: null,
    _className: "Menu",
    ctor: function(t) {
        cc.Layer.prototype.ctor.call(this),
        this._color = cc.color.WHITE,
        this.enabled = !1,
        this._opacity = 255,
        this._selectedItem = null,
        this._state = -1,
        this._touchListener = cc.EventListener.create({
            event: cc.EventListener.TOUCH_ONE_BY_ONE,
            swallowTouches: !0,
            onTouchBegan: this._onTouchBegan,
            onTouchMoved: this._onTouchMoved,
            onTouchEnded: this._onTouchEnded,
            onTouchCancelled: this._onTouchCancelled
        }),
        0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
        var e, i = arguments.length;
        if (0 === i)
            e = [];
        else if (1 === i)
            e = t instanceof Array ? t : [t];
        else if (1 < i) {
            e = [];
            for (var n = 0; n < i; n++)
                arguments[n] && e.push(arguments[n])
        }
        this.initWithArray(e)
    },
    onEnter: function() {
        var t = this._touchListener;
        t._isRegistered() || cc.eventManager.addListener(t, this),
        cc.Node.prototype.onEnter.call(this)
    },
    isEnabled: function() {
        return this.enabled
    },
    setEnabled: function(t) {
        this.enabled = t
    },
    initWithItems: function(t) {
        var e = [];
        if (t)
            for (var i = 0; i < t.length; i++)
                t[i] && e.push(t[i]);
        return this.initWithArray(e)
    },
    initWithArray: function(t) {
        if (cc.Layer.prototype.init.call(this)) {
            this.enabled = !0;
            var e = cc.winSize;
            if (this.setPosition(e.width / 2, e.height / 2),
            this.setContentSize(e),
            this.setAnchorPoint(.5, .5),
            this.ignoreAnchorPointForPosition(!0),
            t)
                for (e = 0; e < t.length; e++)
                    this.addChild(t[e], e);
            return this._selectedItem = null,
            this._state = cc.MENU_STATE_WAITING,
            this.cascadeOpacity = this.cascadeColor = !0
        }
        return !1
    },
    addChild: function(t, e, i) {
        if (!(t instanceof cc.MenuItem))
            throw Error("cc.Menu.addChild() : Menu only supports MenuItem objects as children");
        cc.Layer.prototype.addChild.call(this, t, e, i)
    },
    alignItemsVertically: function() {
        this.alignItemsVerticallyWithPadding(cc.DEFAULT_PADDING)
    },
    alignItemsVerticallyWithPadding: function(t) {
        var e, i, n, r, c = -t, s = this._children;
        if (s && 0 < s.length) {
            for (i = 0,
            e = s.length; i < e; i++)
                c += s[i].height * s[i].scaleY + t;
            var o = c / 2;
            for (i = 0,
            e = s.length; i < e; i++)
                r = s[i],
                n = r.height,
                c = r.scaleY,
                r.setPosition(0, o - n * c / 2),
                o -= n * c + t
        }
    },
    alignItemsHorizontally: function() {
        this.alignItemsHorizontallyWithPadding(cc.DEFAULT_PADDING)
    },
    alignItemsHorizontallyWithPadding: function(t) {
        var e, i, n, r, c = -t, s = this._children;
        if (s && 0 < s.length) {
            for (e = 0,
            i = s.length; e < i; e++)
                c += s[e].width * s[e].scaleX + t;
            var o = -c / 2;
            for (e = 0,
            i = s.length; e < i; e++)
                r = s[e],
                c = r.scaleX,
                n = s[e].width,
                r.setPosition(o + n * c / 2, 0),
                o += n * c + t
        }
    },
    alignItemsInColumns: function() {
        0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
        for (var t = [], e = 0; e < arguments.length; e++)
            t.push(arguments[e]);
        var i, n, r, c = -5, s = 0, o = 0, a = 0, h = this._children;
        if (h && 0 < h.length)
            for (e = 0,
            r = h.length; e < r; e++)
                s >= t.length || !(i = t[s]) || (n = h[e].height,
                o = o >= n || isNaN(n) ? o : n,
                ++a,
                a >= i && (c += o + 5,
                o = a = 0,
                ++s));
        var l = cc.director.getWinSize()
          , u = i = o = s = 0
          , d = 0
          , c = c / 2;
        if (h && 0 < h.length)
            for (e = 0,
            r = h.length; e < r; e++) {
                var _ = h[e];
                0 === i && (i = t[s],
                d = u = l.width / (1 + i)),
                n = _._getHeight(),
                o = o >= n || isNaN(n) ? o : n,
                _.setPosition(d - l.width / 2, c - n / 2),
                d += u,
                ++a,
                a >= i && (c -= o + 5,
                o = i = a = 0,
                ++s)
            }
    },
    alignItemsInRows: function() {
        0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
        var t, e = [];
        for (t = 0; t < arguments.length; t++)
            e.push(arguments[t]);
        var i, n, r, c, s = [], o = [], a = -10, h = -5, l = 0, u = 0, d = 0, _ = this._children;
        if (_ && 0 < _.length)
            for (t = 0,
            r = _.length; t < r; t++)
                n = _[t],
                l >= e.length || !(i = e[l]) || (c = n.width,
                u = u >= c || isNaN(c) ? u : c,
                h += n.height + 5,
                ++d,
                d >= i && (s.push(u),
                o.push(h),
                a += u + 10,
                u = d = 0,
                h = -5,
                ++l));
        h = cc.director.getWinSize(),
        i = u = l = 0;
        var a = -a / 2
          , p = 0;
        if (_ && 0 < _.length)
            for (t = 0,
            r = _.length; t < r; t++)
                n = _[t],
                0 === i && (i = e[l],
                p = o[l]),
                c = n._getWidth(),
                u = u >= c || isNaN(c) ? u : c,
                n.setPosition(a + s[l] / 2, p - h.height / 2),
                p -= n.height + 10,
                ++d,
                d >= i && (a += u + 5,
                u = i = d = 0,
                ++l)
    },
    removeChild: function(t, e) {
        null != t && (t instanceof cc.MenuItem ? (this._selectedItem === t && (this._selectedItem = null),
        cc.Node.prototype.removeChild.call(this, t, e)) : cc.log("cc.Menu.removeChild():Menu only supports MenuItem objects as children"))
    },
    _onTouchBegan: function(t, e) {
        var i = e.getCurrentTarget();
        if (i._state !== cc.MENU_STATE_WAITING || !i._visible || !i.enabled)
            return !1;
        for (var n = i.parent; null != n; n = n.parent)
            if (!n.isVisible())
                return !1;
        return i._selectedItem = i._itemForTouch(t),
        !!i._selectedItem && (i._state = cc.MENU_STATE_TRACKING_TOUCH,
        i._selectedItem.selected(),
        i._selectedItem.setNodeDirty(),
        !0)
    },
    _onTouchEnded: function(t, e) {
        var i = e.getCurrentTarget();
        i._state !== cc.MENU_STATE_TRACKING_TOUCH ? cc.log("cc.Menu.onTouchEnded(): invalid state") : (i._selectedItem && (i._selectedItem.unselected(),
        i._selectedItem.setNodeDirty(),
        i._selectedItem.activate()),
        i._state = cc.MENU_STATE_WAITING)
    },
    _onTouchCancelled: function(t, e) {
        var i = e.getCurrentTarget();
        i._state !== cc.MENU_STATE_TRACKING_TOUCH ? cc.log("cc.Menu.onTouchCancelled(): invalid state") : (i._selectedItem && (i._selectedItem.unselected(),
        i._selectedItem.setNodeDirty()),
        i._state = cc.MENU_STATE_WAITING)
    },
    _onTouchMoved: function(t, e) {
        var i = e.getCurrentTarget();
        if (i._state !== cc.MENU_STATE_TRACKING_TOUCH)
            cc.log("cc.Menu.onTouchMoved(): invalid state");
        else {
            var n = i._itemForTouch(t);
            n !== i._selectedItem && (i._selectedItem && (i._selectedItem.unselected(),
            i._selectedItem.setNodeDirty()),
            i._selectedItem = n,
            i._selectedItem && (i._selectedItem.selected(),
            i._selectedItem.setNodeDirty()))
        }
    },
    onExit: function() {
        this._state === cc.MENU_STATE_TRACKING_TOUCH && (this._selectedItem && (this._selectedItem.unselected(),
        this._selectedItem = null),
        this._state = cc.MENU_STATE_WAITING),
        cc.Node.prototype.onExit.call(this)
    },
    setOpacityModifyRGB: function(t) {},
    isOpacityModifyRGB: function() {
        return !1
    },
    _itemForTouch: function(t) {
        t = t.getLocation();
        var e, i = this._children;
        if (i && 0 < i.length)
            for (var n = i.length - 1; 0 <= n; n--)
                if (e = i[n],
                e.isVisible() && e.isEnabled()) {
                    var r = e.convertToNodeSpace(t)
                      , c = e.rect();
                    if (c.x = 0,
                    c.y = 0,
                    cc.rectContainsPoint(c, r))
                        return e
                }
        return null
    }
}),
_p = cc.Menu.prototype,
cc.Menu.create = function(t) {
    var e = arguments.length;
    return 0 < e && null == arguments[e - 1] && cc.log("parameters should not be ending with null in Javascript"),
    0 === e ? new cc.Menu : 1 === e ? new cc.Menu(t) : new cc.Menu(Array.prototype.slice.call(arguments, 0))
}
,
cc.TGA_OK = 0,
cc.TGA_ERROR_FILE_OPEN = 1,
cc.TGA_ERROR_READING_FILE = 2,
cc.TGA_ERROR_INDEXED_COLOR = 3,
cc.TGA_ERROR_MEMORY = 4,
cc.TGA_ERROR_COMPRESSED_FILE = 5,
cc.ImageTGA = function(t, e, i, n, r, c, s) {
    this.status = t || 0,
    this.type = e || 0,
    this.pixelDepth = i || 0,
    this.width = n || 0,
    this.height = r || 0,
    this.imageData = c || [],
    this.flipped = s || 0
}
,
cc.tgaLoadHeader = function(t, e, i) {
    var n = 2;
    return !(n + 1 > e) && (t = new cc.BinaryStreamReader(t),
    t.setOffset(n),
    i.type = t.readByte(),
    n += 10,
    !(n + 4 + 1 > e) && (t.setOffset(n),
    i.width = t.readUnsignedShort(),
    i.height = t.readUnsignedInteger(),
    i.pixelDepth = t.readByte(),
    !(n + 5 + 1 > e) && (e = t.readByte(),
    i.flipped = 0,
    32 & e && (i.flipped = 1),
    !0)))
}
,
cc.tgaLoadImageData = function(t, e, i) {
    var n, r;
    if (n = 0 | i.pixelDepth / 2,
    r = i.height * i.width * n,
    18 + r > e)
        return !1;
    if (i.imageData = cc.__getSubArray(t, 18, 18 + r),
    3 <= n)
        for (t = 0; t < r; t += n)
            e = i.imageData[t],
            i.imageData[t] = i.imageData[t + 2],
            i.imageData[t + 2] = e;
    return !0
}
,
cc.tgaRGBtogreyscale = function(t) {
    var e, i;
    if (8 !== t.pixelDepth) {
        var n = t.pixelDepth / 8
          , r = new Uint8Array(t.height * t.width);
        if (null !== r) {
            for (i = e = 0; i < t.width * t.height; e += n,
            i++)
                r[i] = .3 * t.imageData[e] + .59 * t.imageData[e + 1] + .11 * t.imageData[e + 2];
            t.pixelDepth = 8,
            t.type = 3,
            t.imageData = r
        }
    }
}
,
cc.tgaDestroy = function(t) {
    t && (t.imageData = null)
}
,
cc.tgaLoadRLEImageData = function(t, e, i) {
    var n, r, c, s = 0, o = 0, a = 0, h = [], l = 0, u = 18;
    for (n = i.pixelDepth / 8,
    r = i.height * i.width,
    c = 0; c < r; c++) {
        if (0 !== l)
            l--,
            o = 0 !== a;
        else {
            if (u + 1 > e)
                break;
            l = t[u],
            u += 1,
            (a = 128 & l) && (l -= 128),
            o = 0
        }
        if (!o) {
            if (u + n > e)
                break;
            h = cc.__getSubArray(t, u, u + n),
            u += n,
            3 <= n && (o = h[0],
            h[0] = h[2],
            h[2] = o)
        }
        for (o = 0; o < n; o++)
            i.imageData[s + o] = h[o];
        s += n
    }
    return !0
}
,
cc.tgaFlipImage = function(t) {
    for (var e = t.pixelDepth / 8 * t.width, i = 0; i < t.height / 2; i++) {
        var n = cc.__getSubArray(t.imageData, i * e, i * e + e);
        cc.__setDataToArray(cc.__getSubArray(t.imageData, (t.height - (i + 1)) * e, e), t.imageData, i * e),
        cc.__setDataToArray(n, t.imageData, (t.height - (i + 1)) * e)
    }
    t.flipped = 0
}
,
cc.__getSubArray = function(t, e, i) {
    return t instanceof Array ? t.slice(e, i) : t.subarray(e, i)
}
,
cc.__setDataToArray = function(t, e, i) {
    for (var n = 0; n < t.length; n++)
        e[i + n] = t[n]
}
,
cc.BinaryStreamReader = cc.Class.extend({
    _binaryData: null,
    _offset: 0,
    ctor: function(t) {
        this._binaryData = t
    },
    setBinaryData: function(t) {
        this._binaryData = t,
        this._offset = 0
    },
    getBinaryData: function() {
        return this._binaryData
    },
    _checkSize: function(t) {
        if (!(this._offset + Math.ceil(t / 8) < this._data.length))
            throw Error("Index out of bound")
    },
    _decodeFloat: function(t, e) {
        var i = t + e + 1
          , n = i >> 3;
        this._checkSize(i);
        var i = Math.pow(2, e - 1) - 1
          , r = this._readBits(t + e, 1, n)
          , c = this._readBits(t, e, n)
          , s = 0
          , o = 2
          , a = 0;
        do
            for (var h = this._readByte(++a, n), l = t % 8 || 8, u = 1 << l; u >>= 1; )
                h & u && (s += 1 / o),
                o *= 2;
        while (t -= l);
        return this._offset += n,
        c === (i << 1) + 1 ? s ? NaN : r ? -(1 / 0) : 1 / 0 : (1 + -2 * r) * (c || s ? c ? Math.pow(2, c - i) * (1 + s) : Math.pow(2, -i + 1) * s : 0)
    },
    _readByte: function(t, e) {
        return this._data[this._offset + e - t - 1]
    },
    _decodeInt: function(t, e) {
        var i = this._readBits(0, t, t / 8)
          , n = Math.pow(2, t);
        return this._offset += t / 8,
        e && i >= n / 2 ? i - n : i
    },
    _shl: function(t, e) {
        for (++e; --e; t = 1073741824 === (1073741824 & (t %= 2147483648)) ? 2 * t : 2 * (t - 1073741824) + 2147483648)
            ;
        return t
    },
    _readBits: function(t, e, i) {
        var n = (t + e) % 8
          , r = t % 8
          , c = i - (t >> 3) - 1;
        t = i + (-(t + e) >> 3);
        var s = c - t;
        for (e = this._readByte(c, i) >> r & (1 << (s ? 8 - r : e)) - 1,
        s && n && (e += (this._readByte(t++, i) & (1 << n) - 1) << (s-- << 3) - r); s; )
            e += this._shl(this._readByte(t++, i), (s-- << 3) - r);
        return e
    },
    readInteger: function() {
        return this._decodeInt(32, !0)
    },
    readUnsignedInteger: function() {
        return this._decodeInt(32, !1)
    },
    readSingle: function() {
        return this._decodeFloat(23, 8)
    },
    readShort: function() {
        return this._decodeInt(16, !0)
    },
    readUnsignedShort: function() {
        return this._decodeInt(16, !1)
    },
    readByte: function() {
        var t = this._data[this._offset];
        return this._offset += 1,
        t
    },
    readData: function(t, e) {
        return this._binaryData instanceof Array ? this._binaryData.slice(t, e) : this._binaryData.subarray(t, e)
    },
    setOffset: function(t) {
        this._offset = t
    },
    getOffset: function() {
        return this._offset
    }
}),
cc.TMX_ORIENTATION_ORTHO = 0,
cc.TMX_ORIENTATION_HEX = 1,
cc.TMX_ORIENTATION_ISO = 2,
cc.TMXTiledMap = cc.Node.extend({
    properties: null,
    mapOrientation: null,
    objectGroups: null,
    _mapSize: null,
    _tileSize: null,
    _tileProperties: null,
    _className: "TMXTiledMap",
    ctor: function(t, e) {
        cc.Node.prototype.ctor.call(this),
        this._mapSize = cc.size(0, 0),
        this._tileSize = cc.size(0, 0),
        void 0 !== e ? this.initWithXML(t, e) : void 0 !== t && this.initWithTMXFile(t)
    },
    getMapSize: function() {
        return cc.size(this._mapSize.width, this._mapSize.height)
    },
    setMapSize: function(t) {
        this._mapSize.width = t.width,
        this._mapSize.height = t.height
    },
    _getMapWidth: function() {
        return this._mapSize.width
    },
    _setMapWidth: function(t) {
        this._mapSize.width = t
    },
    _getMapHeight: function() {
        return this._mapSize.height
    },
    _setMapHeight: function(t) {
        this._mapSize.height = t
    },
    getTileSize: function() {
        return cc.size(this._tileSize.width, this._tileSize.height)
    },
    setTileSize: function(t) {
        this._tileSize.width = t.width,
        this._tileSize.height = t.height
    },
    _getTileWidth: function() {
        return this._tileSize.width
    },
    _setTileWidth: function(t) {
        this._tileSize.width = t
    },
    _getTileHeight: function() {
        return this._tileSize.height
    },
    _setTileHeight: function(t) {
        this._tileSize.height = t
    },
    getMapOrientation: function() {
        return this.mapOrientation
    },
    setMapOrientation: function(t) {
        this.mapOrientation = t
    },
    getObjectGroups: function() {
        return this.objectGroups
    },
    setObjectGroups: function(t) {
        this.objectGroups = t
    },
    getProperties: function() {
        return this.properties
    },
    setProperties: function(t) {
        this.properties = t
    },
    initWithTMXFile: function(t) {
        if (!t || 0 === t.length)
            throw Error("cc.TMXTiledMap.initWithTMXFile(): tmxFile should be non-null or non-empty string.");
        if (this.height = this.width = 0,
        t = new cc.TMXMapInfo(t),
        !t)
            return !1;
        var e = t.getTilesets();
        return e && 0 !== e.length || cc.log("cc.TMXTiledMap.initWithTMXFile(): Map not found. Please check the filename."),
        this._buildWithMapInfo(t),
        !0
    },
    initWithXML: function(t, e) {
        this.height = this.width = 0;
        var i = new cc.TMXMapInfo(t,e)
          , n = i.getTilesets();
        return n && 0 !== n.length || cc.log("cc.TMXTiledMap.initWithXML(): Map not found. Please check the filename."),
        this._buildWithMapInfo(i),
        !0
    },
    _buildWithMapInfo: function(t) {
        this._mapSize = t.getMapSize(),
        this._tileSize = t.getTileSize(),
        this.mapOrientation = t.orientation,
        this.objectGroups = t.getObjectGroups(),
        this.properties = t.properties,
        this._tileProperties = t.getTileProperties();
        var e = 0
          , i = t.getLayers();
        if (i)
            for (var n = null, r = 0, c = i.length; r < c; r++)
                (n = i[r]) && n.visible && (n = this._parseLayer(n, t),
                this.addChild(n, e, e),
                this.width = Math.max(this.width, n.width),
                this.height = Math.max(this.height, n.height),
                e++)
    },
    allLayers: function() {
        for (var t = [], e = this._children, i = 0, n = e.length; i < n; i++) {
            var r = e[i];
            r && r instanceof cc.TMXLayer && t.push(r)
        }
        return t
    },
    getLayer: function(t) {
        if (!t || 0 === t.length)
            throw Error("cc.TMXTiledMap.getLayer(): layerName should be non-null or non-empty string.");
        for (var e = this._children, i = 0; i < e.length; i++) {
            var n = e[i];
            if (n && n.layerName === t)
                return n
        }
        return null
    },
    getObjectGroup: function(t) {
        if (!t || 0 === t.length)
            throw Error("cc.TMXTiledMap.getObjectGroup(): groupName should be non-null or non-empty string.");
        if (this.objectGroups)
            for (var e = 0; e < this.objectGroups.length; e++) {
                var i = this.objectGroups[e];
                if (i && i.groupName === t)
                    return i
            }
        return null
    },
    getProperty: function(t) {
        return this.properties[t.toString()]
    },
    propertiesForGID: function(t) {
        return cc.log("propertiesForGID is deprecated. Please use getPropertiesForGID instead."),
        this.getPropertiesForGID[t]
    },
    getPropertiesForGID: function(t) {
        return this._tileProperties[t]
    },
    _parseLayer: function(t, e) {
        var i = this._tilesetForLayer(t, e)
          , i = new cc.TMXLayer(i,t,e);
        return t.ownTiles = !1,
        i.setupTiles(),
        i
    },
    _tilesetForLayer: function(t, e) {
        var i = t._layerSize
          , n = e.getTilesets();
        if (n)
            for (var r = n.length - 1; 0 <= r; r--) {
                var c = n[r];
                if (c)
                    for (var s = 0; s < i.height; s++)
                        for (var o = 0; o < i.width; o++) {
                            var a = t._tiles[o + i.width * s];
                            if (0 !== a && (a & cc.TMX_TILE_FLIPPED_MASK) >>> 0 >= c.firstGid)
                                return c
                        }
            }
        return cc.log("cocos2d: Warning: TMX Layer " + t.name + " has no tiles"),
        null
    }
}),
_p = cc.TMXTiledMap.prototype,
cc.defineGetterSetter(_p, "mapWidth", _p._getMapWidth, _p._setMapWidth),
cc.defineGetterSetter(_p, "mapHeight", _p._getMapHeight, _p._setMapHeight),
cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth),
cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight),
cc.TMXTiledMap.create = function(t, e) {
    return new cc.TMXTiledMap(t,e)
}
,
cc.TMX_PROPERTY_NONE = 0,
cc.TMX_PROPERTY_MAP = 1,
cc.TMX_PROPERTY_LAYER = 2,
cc.TMX_PROPERTY_OBJECTGROUP = 3,
cc.TMX_PROPERTY_OBJECT = 4,
cc.TMX_PROPERTY_TILE = 5,
cc.TMX_TILE_HORIZONTAL_FLAG = 2147483648,
cc.TMX_TILE_VERTICAL_FLAG = 1073741824,
cc.TMX_TILE_DIAGONAL_FLAG = 536870912,
cc.TMX_TILE_FLIPPED_ALL = (cc.TMX_TILE_HORIZONTAL_FLAG | cc.TMX_TILE_VERTICAL_FLAG | cc.TMX_TILE_DIAGONAL_FLAG) >>> 0,
cc.TMX_TILE_FLIPPED_MASK = ~cc.TMX_TILE_FLIPPED_ALL >>> 0,
cc.TMXLayerInfo = cc.Class.extend({
    properties: null,
    name: "",
    _layerSize: null,
    _tiles: null,
    visible: null,
    _opacity: null,
    ownTiles: !0,
    _minGID: 1e5,
    _maxGID: 0,
    offset: null,
    ctor: function() {
        this.properties = [],
        this.name = "",
        this._layerSize = null,
        this._tiles = [],
        this.visible = !0,
        this._opacity = 0,
        this.ownTiles = !0,
        this._minGID = 1e5,
        this._maxGID = 0,
        this.offset = cc.p(0, 0)
    },
    getProperties: function() {
        return this.properties
    },
    setProperties: function(t) {
        this.properties = t
    }
}),
cc.TMXTilesetInfo = cc.Class.extend({
    name: "",
    firstGid: 0,
    _tileSize: null,
    spacing: 0,
    margin: 0,
    sourceImage: "",
    imageSize: null,
    ctor: function() {
        this._tileSize = cc.size(0, 0),
        this.imageSize = cc.size(0, 0)
    },
    rectForGID: function(t) {
        var e = cc.rect(0, 0, 0, 0);
        e.width = this._tileSize.width,
        e.height = this._tileSize.height,
        t &= cc.TMX_TILE_FLIPPED_MASK,
        t -= parseInt(this.firstGid, 10);
        var i = parseInt((this.imageSize.width - 2 * this.margin + this.spacing) / (this._tileSize.width + this.spacing), 10);
        return e.x = parseInt(t % i * (this._tileSize.width + this.spacing) + this.margin, 10),
        e.y = parseInt(parseInt(t / i, 10) * (this._tileSize.height + this.spacing) + this.margin, 10),
        e
    }
}),
cc.TMXMapInfo = cc.SAXParser.extend({
    properties: null,
    orientation: null,
    parentElement: null,
    parentGID: null,
    layerAttrs: 0,
    storingCharacters: !1,
    tmxFileName: null,
    currentString: null,
    _objectGroups: null,
    _mapSize: null,
    _tileSize: null,
    _layers: null,
    _tilesets: null,
    _tileProperties: null,
    _resources: "",
    _currentFirstGID: 0,
    ctor: function(t, e) {
        cc.SAXParser.prototype.ctor.apply(this),
        this._mapSize = cc.size(0, 0),
        this._tileSize = cc.size(0, 0),
        this._layers = [],
        this._tilesets = [],
        this._objectGroups = [],
        this.properties = [],
        this._tileProperties = {},
        this._currentFirstGID = 0,
        void 0 !== e ? this.initWithXML(t, e) : void 0 !== t && this.initWithTMXFile(t)
    },
    getOrientation: function() {
        return this.orientation
    },
    setOrientation: function(t) {
        this.orientation = t
    },
    getMapSize: function() {
        return cc.size(this._mapSize.width, this._mapSize.height)
    },
    setMapSize: function(t) {
        this._mapSize.width = t.width,
        this._mapSize.height = t.height
    },
    _getMapWidth: function() {
        return this._mapSize.width
    },
    _setMapWidth: function(t) {
        this._mapSize.width = t
    },
    _getMapHeight: function() {
        return this._mapSize.height
    },
    _setMapHeight: function(t) {
        this._mapSize.height = t
    },
    getTileSize: function() {
        return cc.size(this._tileSize.width, this._tileSize.height)
    },
    setTileSize: function(t) {
        this._tileSize.width = t.width,
        this._tileSize.height = t.height
    },
    _getTileWidth: function() {
        return this._tileSize.width
    },
    _setTileWidth: function(t) {
        this._tileSize.width = t
    },
    _getTileHeight: function() {
        return this._tileSize.height
    },
    _setTileHeight: function(t) {
        this._tileSize.height = t
    },
    getLayers: function() {
        return this._layers
    },
    setLayers: function(t) {
        this._layers.push(t)
    },
    getTilesets: function() {
        return this._tilesets
    },
    setTilesets: function(t) {
        this._tilesets.push(t)
    },
    getObjectGroups: function() {
        return this._objectGroups
    },
    setObjectGroups: function(t) {
        this._objectGroups.push(t)
    },
    getParentElement: function() {
        return this.parentElement
    },
    setParentElement: function(t) {
        this.parentElement = t
    },
    getParentGID: function() {
        return this.parentGID
    },
    setParentGID: function(t) {
        this.parentGID = t
    },
    getLayerAttribs: function() {
        return this.layerAttrs
    },
    setLayerAttribs: function(t) {
        this.layerAttrs = t
    },
    getStoringCharacters: function() {
        return this.storingCharacters
    },
    setStoringCharacters: function(t) {
        this.storingCharacters = t
    },
    getProperties: function() {
        return this.properties
    },
    setProperties: function(t) {
        this.properties = t
    },
    initWithTMXFile: function(t) {
        return this._internalInit(t, null),
        this.parseXMLFile(t)
    },
    initWithXML: function(t, e) {
        return this._internalInit(null, e),
        this.parseXMLString(t)
    },
    parseXMLFile: function(t, e) {
        var i = (e = e || !1) ? t : cc.loader.getRes(t);
        if (!i)
            throw Error("Please load the resource first : " + t);
        var n, r, i = this._parseXML(i).documentElement;
        if (n = i.getAttribute("version"),
        r = i.getAttribute("orientation"),
        "map" === i.nodeName && ("1.0" !== n && null !== n && cc.log("cocos2d: TMXFormat: Unsupported TMX version:" + n),
        "orthogonal" === r ? this.orientation = cc.TMX_ORIENTATION_ORTHO : "isometric" === r ? this.orientation = cc.TMX_ORIENTATION_ISO : "hexagonal" === r ? this.orientation = cc.TMX_ORIENTATION_HEX : null !== r && cc.log("cocos2d: TMXFomat: Unsupported orientation:" + r),
        n = cc.size(0, 0),
        n.width = parseFloat(i.getAttribute("width")),
        n.height = parseFloat(i.getAttribute("height")),
        this.setMapSize(n),
        n = cc.size(0, 0),
        n.width = parseFloat(i.getAttribute("tilewidth")),
        n.height = parseFloat(i.getAttribute("tileheight")),
        this.setTileSize(n),
        r = i.querySelectorAll("map > properties >  property"))) {
            var c = {};
            for (n = 0; n < r.length; n++)
                c[r[n].getAttribute("name")] = r[n].getAttribute("value");
            this.properties = c
        }
        for (c = i.getElementsByTagName("tileset"),
        "map" !== i.nodeName && (c = [],
        c.push(i)),
        n = 0; n < c.length; n++) {
            r = c[n];
            var s = r.getAttribute("source");
            if (s)
                r = e ? cc.path.join(this._resources, s) : cc.path.changeBasename(t, s),
                this.parseXMLFile(r);
            else {
                s = new cc.TMXTilesetInfo,
                s.name = r.getAttribute("name") || "",
                s.firstGid = parseInt(r.getAttribute("firstgid")) || 0,
                s.spacing = parseInt(r.getAttribute("spacing")) || 0,
                s.margin = parseInt(r.getAttribute("margin")) || 0;
                var o = cc.size(0, 0);
                o.width = parseFloat(r.getAttribute("tilewidth")),
                o.height = parseFloat(r.getAttribute("tileheight")),
                s._tileSize = o;
                var o = r.getElementsByTagName("image")[0].getAttribute("source")
                  , a = -1;
                if (this.tmxFileName && (a = this.tmxFileName.lastIndexOf("/")),
                -1 !== a ? (a = this.tmxFileName.substr(0, a + 1),
                s.sourceImage = a + o) : s.sourceImage = this._resources + (this._resources ? "/" : "") + o,
                this.setTilesets(s),
                o = r.getElementsByTagName("tile"))
                    for (a = 0; a < o.length; a++) {
                        r = o[a],
                        this.parentGID = parseInt(s.firstGid) + parseInt(r.getAttribute("id") || 0);
                        var h = r.querySelectorAll("properties > property");
                        if (h) {
                            var l = {};
                            for (r = 0; r < h.length; r++) {
                                var u = h[r].getAttribute("name");
                                l[u] = h[r].getAttribute("value")
                            }
                            this._tileProperties[this.parentGID] = l
                        }
                    }
            }
        }
        if (c = i.getElementsByTagName("layer"))
            for (n = 0; n < c.length; n++) {
                for (o = c[n],
                a = o.getElementsByTagName("data")[0],
                s = new cc.TMXLayerInfo,
                s.name = o.getAttribute("name"),
                r = cc.size(0, 0),
                r.width = parseFloat(o.getAttribute("width")),
                r.height = parseFloat(o.getAttribute("height")),
                s._layerSize = r,
                r = o.getAttribute("visible"),
                s.visible = "0" != r,
                r = o.getAttribute("opacity") || 1,
                s._opacity = r ? parseInt(255 * parseFloat(r)) : 255,
                s.offset = cc.p(parseFloat(o.getAttribute("x")) || 0, parseFloat(o.getAttribute("y")) || 0),
                h = "",
                r = 0; r < a.childNodes.length; r++)
                    h += a.childNodes[r].nodeValue;
                if (h = h.trim(),
                r = a.getAttribute("compression"),
                l = a.getAttribute("encoding"),
                r && "gzip" !== r && "zlib" !== r)
                    return cc.log("cc.TMXMapInfo.parseXMLFile(): unsupported compression method"),
                    null;
                switch (r) {
                case "gzip":
                    s._tiles = cc.unzipBase64AsArray(h, 4);
                    break;
                case "zlib":
                    r = new Zlib.Inflate(cc.Codec.Base64.decodeAsArray(h, 1)),
                    s._tiles = cc.uint8ArrayToUint32Array(r.decompress());
                    break;
                case null:
                case "":
                    if ("base64" === l)
                        s._tiles = cc.Codec.Base64.decodeAsArray(h, 4);
                    else if ("csv" === l)
                        for (s._tiles = [],
                        r = h.split(","),
                        a = 0; a < r.length; a++)
                            s._tiles.push(parseInt(r[a]));
                    else
                        for (r = a.getElementsByTagName("tile"),
                        s._tiles = [],
                        a = 0; a < r.length; a++)
                            s._tiles.push(parseInt(r[a].getAttribute("gid")));
                    break;
                default:
                    this.layerAttrs === cc.TMXLayerInfo.ATTRIB_NONE && cc.log("cc.TMXMapInfo.parseXMLFile(): Only base64 and/or gzip/zlib maps are supported")
                }
                if (o = o.querySelectorAll("properties > property")) {
                    for (a = {},
                    r = 0; r < o.length; r++)
                        a[o[r].getAttribute("name")] = o[r].getAttribute("value");
                    s.properties = a
                }
                this.setLayers(s)
            }
        if (c = i.getElementsByTagName("objectgroup"))
            for (n = 0; n < c.length; n++) {
                if (o = c[n],
                s = new cc.TMXObjectGroup,
                s.groupName = o.getAttribute("name"),
                s.setPositionOffset(cc.p(parseFloat(o.getAttribute("x")) * this.getTileSize().width || 0, parseFloat(o.getAttribute("y")) * this.getTileSize().height || 0)),
                a = o.querySelectorAll("objectgroup > properties > property"))
                    for (r = 0; r < a.length; r++)
                        h = {},
                        h[a[r].getAttribute("name")] = a[r].getAttribute("value"),
                        s.properties = h;
                if (o = o.querySelectorAll("object"),
                a = cc.director.getContentScaleFactor(),
                o)
                    for (r = 0; r < o.length; r++) {
                        if (l = o[r],
                        h = {},
                        h.name = l.getAttribute("name") || "",
                        h.type = l.getAttribute("type") || "",
                        h.width = parseInt(l.getAttribute("width")) || 0,
                        h.height = parseInt(l.getAttribute("height")) || 0,
                        h.x = ((0 | (l.getAttribute("x") || 0)) + s.getPositionOffset().x) / a,
                        u = (0 | (l.getAttribute("y") || 0)) + s.getPositionOffset().y / a,
                        h.y = (parseInt(this.getMapSize().height * this.getTileSize().height) - u - h.height) / cc.director.getContentScaleFactor(),
                        h.rotation = parseInt(l.getAttribute("rotation")) || 0,
                        u = l.querySelectorAll("properties > property"))
                            for (var d = 0; d < u.length; d++)
                                h[u[d].getAttribute("name")] = u[d].getAttribute("value");
                        (u = l.querySelectorAll("polygon")) && 0 < u.length && (u = u[0].getAttribute("points")) && (h.points = this._parsePointsString(u)),
                        (l = l.querySelectorAll("polyline")) && 0 < l.length && (l = l[0].getAttribute("points")) && (h.polylinePoints = this._parsePointsString(l)),
                        s.setObjects(h)
                    }
                this.setObjectGroups(s)
            }
        return i
    },
    _parsePointsString: function(t) {
        if (!t)
            return null;
        var e = [];
        t = t.split(" ");
        for (var i = 0; i < t.length; i++) {
            var n = t[i].split(",");
            e.push({
                x: n[0],
                y: n[1]
            })
        }
        return e
    },
    parseXMLString: function(t) {
        return this.parseXMLFile(t, !0)
    },
    getTileProperties: function() {
        return this._tileProperties
    },
    setTileProperties: function(t) {
        this._tileProperties.push(t)
    },
    getCurrentString: function() {
        return this.currentString
    },
    setCurrentString: function(t) {
        this.currentString = t
    },
    getTMXFileName: function() {
        return this.tmxFileName
    },
    setTMXFileName: function(t) {
        this.tmxFileName = t
    },
    _internalInit: function(t, e) {
        this._tilesets.length = 0,
        this._layers.length = 0,
        this.tmxFileName = t,
        e && (this._resources = e),
        this._objectGroups.length = 0,
        this.properties.length = 0,
        this._tileProperties.length = 0,
        this.currentString = "",
        this.storingCharacters = !1,
        this.layerAttrs = cc.TMXLayerInfo.ATTRIB_NONE,
        this.parentElement = cc.TMX_PROPERTY_NONE,
        this._currentFirstGID = 0
    }
}),
_p = cc.TMXMapInfo.prototype,
cc.defineGetterSetter(_p, "mapWidth", _p._getMapWidth, _p._setMapWidth),
cc.defineGetterSetter(_p, "mapHeight", _p._getMapHeight, _p._setMapHeight),
cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth),
cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight),
cc.TMXMapInfo.create = function(t, e) {
    return new cc.TMXMapInfo(t,e)
}
,
cc.loader.register(["tmx", "tsx"], cc._txtLoader),
cc.TMXLayerInfo.ATTRIB_NONE = 1,
cc.TMXLayerInfo.ATTRIB_BASE64 = 2,
cc.TMXLayerInfo.ATTRIB_GZIP = 4,
cc.TMXLayerInfo.ATTRIB_ZLIB = 8,
cc.TMXObjectGroup = cc.Class.extend({
    properties: null,
    groupName: "",
    _positionOffset: null,
    _objects: null,
    ctor: function() {
        this.groupName = "",
        this._positionOffset = cc.p(0, 0),
        this.properties = [],
        this._objects = []
    },
    getPositionOffset: function() {
        return cc.p(this._positionOffset)
    },
    setPositionOffset: function(t) {
        this._positionOffset.x = t.x,
        this._positionOffset.y = t.y
    },
    getProperties: function() {
        return this.properties
    },
    setProperties: function(t) {
        this.properties.push(t)
    },
    getGroupName: function() {
        return this.groupName.toString()
    },
    setGroupName: function(t) {
        this.groupName = t
    },
    propertyNamed: function(t) {
        return this.properties[t]
    },
    objectNamed: function(t) {
        return this.getObject(t)
    },
    getObject: function(t) {
        if (this._objects && 0 < this._objects.length)
            for (var e = this._objects, i = 0, n = e.length; i < n; i++) {
                var r = e[i].name;
                if (r && r === t)
                    return e[i]
            }
        return null
    },
    getObjects: function() {
        return this._objects
    },
    setObjects: function(t) {
        this._objects.push(t)
    }
}),
cc.TMXLayer = cc.SpriteBatchNode.extend({
    tiles: null,
    tileset: null,
    layerOrientation: null,
    properties: null,
    layerName: "",
    _layerSize: null,
    _mapTileSize: null,
    _opacity: 255,
    _minGID: null,
    _maxGID: null,
    _vertexZvalue: null,
    _useAutomaticVertexZ: null,
    _reusedTile: null,
    _atlasIndexArray: null,
    _contentScaleFactor: null,
    _className: "TMXLayer",
    ctor: function(t, e, i) {
        cc.SpriteBatchNode.prototype.ctor.call(this),
        this._descendants = [],
        this._layerSize = cc.size(0, 0),
        this._mapTileSize = cc.size(0, 0),
        void 0 !== i && this.initWithTilesetInfo(t, e, i)
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.TMXLayer.CanvasRenderCmd(this) : new cc.TMXLayer.WebGLRenderCmd(this)
    },
    setContentSize: function(t, e) {
        cc.Node.prototype.setContentSize.call(this, t, e),
        this._renderCmd._updateCacheContext(t, e)
    },
    getTexture: function() {
        return this._renderCmd.getTexture()
    },
    getLayerSize: function() {
        return cc.size(this._layerSize.width, this._layerSize.height)
    },
    setLayerSize: function(t) {
        this._layerSize.width = t.width,
        this._layerSize.height = t.height
    },
    _getLayerWidth: function() {
        return this._layerSize.width
    },
    _setLayerWidth: function(t) {
        this._layerSize.width = t
    },
    _getLayerHeight: function() {
        return this._layerSize.height
    },
    _setLayerHeight: function(t) {
        this._layerSize.height = t
    },
    getMapTileSize: function() {
        return cc.size(this._mapTileSize.width, this._mapTileSize.height)
    },
    setMapTileSize: function(t) {
        this._mapTileSize.width = t.width,
        this._mapTileSize.height = t.height
    },
    _getTileWidth: function() {
        return this._mapTileSize.width
    },
    _setTileWidth: function(t) {
        this._mapTileSize.width = t
    },
    _getTileHeight: function() {
        return this._mapTileSize.height
    },
    _setTileHeight: function(t) {
        this._mapTileSize.height = t
    },
    getTiles: function() {
        return this.tiles
    },
    setTiles: function(t) {
        this.tiles = t
    },
    getTileset: function() {
        return this.tileset
    },
    setTileset: function(t) {
        this.tileset = t
    },
    getLayerOrientation: function() {
        return this.layerOrientation
    },
    setLayerOrientation: function(t) {
        this.layerOrientation = t
    },
    getProperties: function() {
        return this.properties
    },
    setProperties: function(t) {
        this.properties = t
    },
    initWithTilesetInfo: function(t, e, i) {
        var n, r = e._layerSize, c = .35 * parseInt(r.width * r.height) + 1;
        return t && (n = cc.textureCache.addImage(t.sourceImage)),
        !!this.initWithTexture(n, c) && (this.layerName = e.name,
        this._layerSize = r,
        this.tiles = e._tiles,
        this._minGID = e._minGID,
        this._maxGID = e._maxGID,
        this._opacity = e._opacity,
        this.properties = e.properties,
        this._contentScaleFactor = cc.director.getContentScaleFactor(),
        this.tileset = t,
        this._mapTileSize = i.getTileSize(),
        this.layerOrientation = i.orientation,
        t = this._calculateLayerOffset(e.offset),
        this.setPosition(cc.pointPixelsToPoints(t)),
        this._atlasIndexArray = [],
        this.setContentSize(cc.sizePixelsToPoints(cc.size(this._layerSize.width * this._mapTileSize.width, this._layerSize.height * this._mapTileSize.height))),
        this._useAutomaticVertexZ = !1,
        this._vertexZvalue = 0,
        !0)
    },
    releaseMap: function() {
        this.tiles && (this.tiles = null),
        this._atlasIndexArray && (this._atlasIndexArray = null)
    },
    getTileAt: function(t, e) {
        if (!t)
            throw Error("cc.TMXLayer.getTileAt(): pos should be non-null");
        if (void 0 !== e && (t = cc.p(t, e)),
        t.x >= this._layerSize.width || t.y >= this._layerSize.height || 0 > t.x || 0 > t.y)
            throw Error("cc.TMXLayer.getTileAt(): invalid position");
        if (!this.tiles || !this._atlasIndexArray)
            return cc.log("cc.TMXLayer.getTileAt(): TMXLayer: the tiles map has been released"),
            null;
        var i = null
          , n = this.getTileGIDAt(t);
        if (0 === n)
            return i;
        var r = 0 | t.x + t.y * this._layerSize.width
          , i = this.getChildByTag(r);
        return i || (n = this.tileset.rectForGID(n),
        n = cc.rectPixelsToPoints(n),
        i = new cc.Sprite,
        i.initWithTexture(this.texture, n),
        i.batchNode = this,
        i.setPosition(this.getPositionAt(t)),
        i.vertexZ = this._vertexZForPos(t),
        i.anchorX = 0,
        i.anchorY = 0,
        i.opacity = this._opacity,
        n = this._atlasIndexForExistantZ(r),
        this.addSpriteWithoutQuad(i, n, r)),
        i
    },
    getTileGIDAt: function(t, e) {
        if (null == t)
            throw Error("cc.TMXLayer.getTileGIDAt(): pos should be non-null");
        if (void 0 !== e && (t = cc.p(t, e)),
        t.x >= this._layerSize.width || t.y >= this._layerSize.height || 0 > t.x || 0 > t.y)
            throw Error("cc.TMXLayer.getTileGIDAt(): invalid position");
        return this.tiles && this._atlasIndexArray ? (this.tiles[0 | t.x + t.y * this._layerSize.width] & cc.TMX_TILE_FLIPPED_MASK) >>> 0 : (cc.log("cc.TMXLayer.getTileGIDAt(): TMXLayer: the tiles map has been released"),
        null)
    },
    getTileFlagsAt: function(t, e) {
        if (!t)
            throw Error("cc.TMXLayer.getTileFlagsAt(): pos should be non-null");
        if (void 0 !== e && (t = cc.p(t, e)),
        t.x >= this._layerSize.width || t.y >= this._layerSize.height || 0 > t.x || 0 > t.y)
            throw Error("cc.TMXLayer.getTileFlagsAt(): invalid position");
        return this.tiles && this._atlasIndexArray ? (this.tiles[0 | t.x + t.y * this._layerSize.width] & cc.TMX_TILE_FLIPPED_ALL) >>> 0 : (cc.log("cc.TMXLayer.getTileFlagsAt(): TMXLayer: the tiles map has been released"),
        null)
    },
    setTileGID: function(t, e, i, n) {
        if (!e)
            throw Error("cc.TMXLayer.setTileGID(): pos should be non-null");
        if (void 0 !== n ? e = cc.p(e, i) : n = i,
        e.x >= this._layerSize.width || e.y >= this._layerSize.height || 0 > e.x || 0 > e.y)
            throw Error("cc.TMXLayer.setTileGID(): invalid position");
        if (this.tiles && this._atlasIndexArray)
            if (0 !== t && t < this.tileset.firstGid)
                cc.log("cc.TMXLayer.setTileGID(): invalid gid:" + t);
            else {
                n = n || 0,
                this._setNodeDirtyForCache(),
                i = this.getTileFlagsAt(e);
                var r = this.getTileGIDAt(e);
                if (r !== t || i !== n)
                    if (i = (t | n) >>> 0,
                    0 === t)
                        this.removeTileAt(e);
                    else if (0 === r)
                        this._insertTileForGID(i, e);
                    else {
                        var r = e.x + e.y * this._layerSize.width
                          , c = this.getChildByTag(r);
                        c ? (t = this.tileset.rectForGID(t),
                        t = cc.rectPixelsToPoints(t),
                        c.setTextureRect(t, !1),
                        null != n && this._setupTileSprite(c, e, i),
                        this.tiles[r] = i) : this._updateTileForGID(i, e)
                    }
            }
        else
            cc.log("cc.TMXLayer.setTileGID(): TMXLayer: the tiles map has been released")
    },
    removeTileAt: function(t, e) {
        if (!t)
            throw Error("cc.TMXLayer.removeTileAt(): pos should be non-null");
        if (void 0 !== e && (t = cc.p(t, e)),
        t.x >= this._layerSize.width || t.y >= this._layerSize.height || 0 > t.x || 0 > t.y)
            throw Error("cc.TMXLayer.removeTileAt(): invalid position");
        if (this.tiles && this._atlasIndexArray) {
            if (0 !== this.getTileGIDAt(t)) {
                cc._renderType === cc.game.RENDER_TYPE_CANVAS && this._setNodeDirtyForCache();
                var i = 0 | t.x + t.y * this._layerSize.width
                  , n = this._atlasIndexForExistantZ(i);
                if (this.tiles[i] = 0,
                this._atlasIndexArray.splice(n, 1),
                i = this.getChildByTag(i))
                    cc.SpriteBatchNode.prototype.removeChild.call(this, i, !0);
                else if (cc._renderType === cc.game.RENDER_TYPE_WEBGL && this.textureAtlas.removeQuadAtIndex(n),
                this._children)
                    for (var i = this._children, r = 0, c = i.length; r < c; r++) {
                        var s = i[r];
                        if (s) {
                            var o = s.atlasIndex;
                            o >= n && (s.atlasIndex = o - 1)
                        }
                    }
            }
        } else
            cc.log("cc.TMXLayer.removeTileAt(): TMXLayer: the tiles map has been released")
    },
    getPositionAt: function(t, e) {
        void 0 !== e && (t = cc.p(t, e));
        var i = cc.p(0, 0);
        switch (this.layerOrientation) {
        case cc.TMX_ORIENTATION_ORTHO:
            i = this._positionForOrthoAt(t);
            break;
        case cc.TMX_ORIENTATION_ISO:
            i = this._positionForIsoAt(t);
            break;
        case cc.TMX_ORIENTATION_HEX:
            i = this._positionForHexAt(t)
        }
        return cc.pointPixelsToPoints(i)
    },
    getProperty: function(t) {
        return this.properties[t]
    },
    setupTiles: function() {
        this._renderCmd.initImageSize(),
        this._parseInternalProperties(),
        cc._renderType === cc.game.RENDER_TYPE_CANVAS && this._setNodeDirtyForCache();
        for (var t = this._layerSize.height, e = this._layerSize.width, i = 0; i < t; i++)
            for (var n = 0; n < e; n++) {
                var r = this.tiles[n + e * i];
                0 !== r && (this._appendTileForGID(r, cc.p(n, i)),
                this._minGID = Math.min(r, this._minGID),
                this._maxGID = Math.max(r, this._maxGID))
            }
        this._maxGID >= this.tileset.firstGid && this._minGID >= this.tileset.firstGid || cc.log("cocos2d:TMX: Only 1 tileset per layer is supported")
    },
    addChild: function(t, e, i) {
        cc.log("addChild: is not supported on cc.TMXLayer. Instead use setTileGID or tileAt.")
    },
    removeChild: function(t, e) {
        if (t)
            if (-1 === this._children.indexOf(t))
                cc.log("cc.TMXLayer.removeChild(): Tile does not belong to TMXLayer");
            else {
                cc._renderType === cc.game.RENDER_TYPE_CANVAS && this._setNodeDirtyForCache();
                var i = t.atlasIndex;
                this.tiles[this._atlasIndexArray[i]] = 0,
                this._atlasIndexArray.splice(i, 1),
                cc.SpriteBatchNode.prototype.removeChild.call(this, t, e),
                cc.renderer.childrenOrderDirty = !0
            }
    },
    getLayerName: function() {
        return this.layerName
    },
    setLayerName: function(t) {
        this.layerName = t
    },
    _positionForIsoAt: function(t) {
        return cc.p(this._mapTileSize.width / 2 * (this._layerSize.width + t.x - t.y - 1), this._mapTileSize.height / 2 * (2 * this._layerSize.height - t.x - t.y - 2))
    },
    _positionForOrthoAt: function(t) {
        return cc.p(t.x * this._mapTileSize.width, (this._layerSize.height - t.y - 1) * this._mapTileSize.height)
    },
    _positionForHexAt: function(t) {
        return cc.p(t.x * this._mapTileSize.width * 3 / 4, (this._layerSize.height - t.y - 1) * this._mapTileSize.height + (1 === t.x % 2 ? -this._mapTileSize.height / 2 : 0))
    },
    _calculateLayerOffset: function(t) {
        var e = cc.p(0, 0);
        switch (this.layerOrientation) {
        case cc.TMX_ORIENTATION_ORTHO:
            e = cc.p(t.x * this._mapTileSize.width, -t.y * this._mapTileSize.height);
            break;
        case cc.TMX_ORIENTATION_ISO:
            e = cc.p(this._mapTileSize.width / 2 * (t.x - t.y), this._mapTileSize.height / 2 * (-t.x - t.y));
            break;
        case cc.TMX_ORIENTATION_HEX:
            0 === t.x && 0 === t.y || cc.log("offset for hexagonal map not implemented yet")
        }
        return e
    },
    _appendTileForGID: function(t, e) {
        var i = this.tileset.rectForGID(t)
          , i = cc.rectPixelsToPoints(i)
          , n = 0 | e.x + e.y * this._layerSize.width
          , i = this._renderCmd._reusedTileWithRect(i);
        this._setupTileSprite(i, e, t);
        var r = this._atlasIndexArray.length;
        return this.insertQuadFromSprite(i, r),
        this._atlasIndexArray.splice(r, 0, n),
        i
    },
    _insertTileForGID: function(t, e) {
        var i = this.tileset.rectForGID(t)
          , i = cc.rectPixelsToPoints(i)
          , n = 0 | e.x + e.y * this._layerSize.width
          , i = this._renderCmd._reusedTileWithRect(i);
        this._setupTileSprite(i, e, t);
        var r = this._atlasIndexForNewZ(n);
        if (this.insertQuadFromSprite(i, r),
        this._atlasIndexArray.splice(r, 0, n),
        this._children)
            for (var c = this._children, s = 0, o = c.length; s < o; s++) {
                var a = c[s];
                if (a) {
                    var h = a.atlasIndex;
                    h >= r && (a.atlasIndex = h + 1)
                }
            }
        return this.tiles[n] = t,
        i
    },
    _updateTileForGID: function(t, e) {
        var i = this.tileset.rectForGID(t)
          , n = this._contentScaleFactor
          , i = cc.rect(i.x / n, i.y / n, i.width / n, i.height / n)
          , n = e.x + e.y * this._layerSize.width
          , i = this._renderCmd._reusedTileWithRect(i);
        return this._setupTileSprite(i, e, t),
        i.atlasIndex = this._atlasIndexForExistantZ(n),
        i.dirty = !0,
        i.updateTransform(),
        this.tiles[n] = t,
        i
    },
    _parseInternalProperties: function() {
        var t = this.getProperty("cc_vertexz");
        if (t)
            if ("automatic" === t) {
                this._useAutomaticVertexZ = !0;
                var e = this.getProperty("cc_alpha_func")
                  , t = 0;
                e && (t = parseFloat(e)),
                cc._renderType === cc.game.RENDER_TYPE_WEBGL && (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST),
                e = cc._renderContext.getUniformLocation(this.shaderProgram.getProgram(), cc.UNIFORM_ALPHA_TEST_VALUE_S),
                this.shaderProgram.use(),
                this.shaderProgram.setUniformLocationWith1f(e, t))
            } else
                this._vertexZvalue = parseInt(t, 10)
    },
    _setupTileSprite: function(t, e, i) {
        var n = e.x + e.y * this._layerSize.width;
        t.setPosition(this.getPositionAt(e)),
        cc._renderType === cc.game.RENDER_TYPE_WEBGL ? t.vertexZ = this._vertexZForPos(e) : t.tag = n,
        t.anchorX = 0,
        t.anchorY = 0,
        t.opacity = this._opacity,
        cc._renderType === cc.game.RENDER_TYPE_WEBGL && (t.rotation = 0),
        t.setFlippedX(!1),
        t.setFlippedY(!1),
        (i & cc.TMX_TILE_DIAGONAL_FLAG) >>> 0 ? (t.anchorX = .5,
        t.anchorY = .5,
        t.x = this.getPositionAt(e).x + t.width / 2,
        t.y = this.getPositionAt(e).y + t.height / 2,
        e = (i & (cc.TMX_TILE_HORIZONTAL_FLAG | cc.TMX_TILE_VERTICAL_FLAG) >>> 0) >>> 0,
        e === cc.TMX_TILE_HORIZONTAL_FLAG ? t.rotation = 90 : e === cc.TMX_TILE_VERTICAL_FLAG ? t.rotation = 270 : (t.rotation = e === (cc.TMX_TILE_VERTICAL_FLAG | cc.TMX_TILE_HORIZONTAL_FLAG) >>> 0 ? 90 : 270,
        t.setFlippedX(!0))) : ((i & cc.TMX_TILE_HORIZONTAL_FLAG) >>> 0 && t.setFlippedX(!0),
        (i & cc.TMX_TILE_VERTICAL_FLAG) >>> 0 && t.setFlippedY(!0))
    },
    _vertexZForPos: function(t) {
        var e = 0
          , i = 0;
        if (this._useAutomaticVertexZ)
            switch (this.layerOrientation) {
            case cc.TMX_ORIENTATION_ISO:
                i = this._layerSize.width + this._layerSize.height,
                e = -(i - (t.x + t.y));
                break;
            case cc.TMX_ORIENTATION_ORTHO:
                e = -(this._layerSize.height - t.y);
                break;
            case cc.TMX_ORIENTATION_HEX:
                cc.log("TMX Hexa zOrder not supported");
                break;
            default:
                cc.log("TMX invalid value")
            }
        else
            e = this._vertexZvalue;
        return e
    },
    _atlasIndexForExistantZ: function(t) {
        var e;
        if (this._atlasIndexArray)
            for (var i = this._atlasIndexArray, n = 0, r = i.length; n < r && (e = i[n],
            e !== t); n++)
                ;
        return cc.isNumber(e) || cc.log("cc.TMXLayer._atlasIndexForExistantZ(): TMX atlas index not found. Shall not happen"),
        n
    },
    _atlasIndexForNewZ: function(t) {
        for (var e = this._atlasIndexArray, i = 0, n = e.length; i < n && !(t < e[i]); i++)
            ;
        return i
    }
}),
_p = cc.TMXLayer.prototype,
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture),
cc.defineGetterSetter(_p, "layerWidth", _p._getLayerWidth, _p._setLayerWidth),
cc.defineGetterSetter(_p, "layerHeight", _p._getLayerHeight, _p._setLayerHeight),
cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth),
cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight),
cc.TMXLayer.create = function(t, e, i) {
    return new cc.TMXLayer(t,e,i)
}
,
function() {
    cc.TMXLayer.CanvasRenderCmd = function(t) {
        cc.SpriteBatchNode.CanvasRenderCmd.call(this, t),
        this._needDraw = !0,
        this._realWorldTransform = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            tx: 0,
            ty: 0
        };
        var e = cc._canvas;
        t = document.createElement("canvas"),
        t.width = e.width,
        t.height = e.height,
        this._cacheCanvas = t,
        this._cacheContext = new cc.CanvasContextWrapper(this._cacheCanvas.getContext("2d")),
        e = new cc.Texture2D,
        e.initWithElement(t),
        e.handleLoadedTexture(),
        this._cacheTexture = e,
        this._cacheDirty = !1
    }
    ;
    var t = cc.TMXLayer.CanvasRenderCmd.prototype = Object.create(cc.SpriteBatchNode.CanvasRenderCmd.prototype);
    t.constructor = cc.TMXLayer.CanvasRenderCmd,
    t._setNodeDirtyForCache = function() {
        this._cacheDirty = !0
    }
    ,
    t._renderingChildToCache = function() {
        if (this._cacheDirty) {
            var t = this._cacheContext
              , e = t.getContext()
              , i = this._cacheCanvas;
            e.setTransform(1, 0, 0, 1, 0, 0),
            e.clearRect(0, 0, i.width, i.height);
            for (var e = this._node._children, i = 0, n = e.length; i < n; i++)
                if (e[i]) {
                    var r = e[i]._renderCmd;
                    r && (r.rendering(t, 1, 1),
                    r._cacheDirty = !1)
                }
            this._cacheDirty = !1
        }
    }
    ,
    t.rendering = function(t, e, i) {
        var n = this._displayedOpacity / 255;
        if (!(0 >= n)) {
            var r = this._node;
            this._renderingChildToCache();
            var c = t || cc._renderContext;
            t = c.getContext(),
            c.setGlobalAlpha(n),
            (n = this._cacheCanvas) && 0 !== n.width && 0 !== n.height && (c.setTransform(this._realWorldTransform, e, i),
            c = n.height * i,
            r.layerOrientation === cc.TMX_ORIENTATION_HEX ? t.drawImage(n, 0, 0, n.width, n.height, 0, -c + .5 * r._mapTileSize.height * i, n.width * e, c) : t.drawImage(n, 0, 0, n.width, n.height, 0, -c, n.width * e, c)),
            cc.g_NumberOfDraws++
        }
    }
    ,
    t._updateCacheContext = function(t, e) {
        var i = this._node
          , n = i._contentSize
          , r = this._cacheCanvas
          , c = cc.contentScaleFactor();
        r.width = 0 | 1.5 * n.width * c,
        r.height = 0 | 1.5 * n.height * c,
        i.layerOrientation === cc.TMX_ORIENTATION_HEX ? this._cacheContext.setOffset(0, .5 * -i._mapTileSize.height) : this._cacheContext.setOffset(0, 0),
        i = this._cacheTexture._contentSize,
        i.width = r.width,
        i.height = r.height
    }
    ,
    t.getTexture = function() {
        return this._cacheTexture
    }
    ,
    t.visit = function(t) {
        var e, i = this._node, n = i._children;
        if (i._visible && n && 0 !== n.length) {
            if ((t = t || this.getParentRenderCmd()) && (this._curLevel = t._curLevel + 1),
            this._syncStatus(t),
            this._cacheDirty) {
                t = this._cacheContext;
                var r = this._cacheCanvas
                  , c = t.getContext()
                  , s = i.__instanceId
                  , o = cc.renderer;
                for (o._turnToCacheMode(s),
                i.sortAllChildren(),
                i = 0,
                e = n.length; i < e; i++)
                    if (n[i]) {
                        var a = n[i]._renderCmd;
                        a && (a.visit(this),
                        a._cacheDirty = !1)
                    }
                c.setTransform(1, 0, 0, 1, 0, 0),
                c.clearRect(0, 0, r.width, r.height),
                o._renderingToCacheCanvas(t, s),
                this._cacheDirty = !1
            }
            cc.renderer.pushRenderCommand(this),
            this._dirtyFlag = 0
        }
    }
    ,
    t.transform = function(t, e) {
        var i = this.getNodeToParentTransform()
          , n = this._realWorldTransform;
        if (t) {
            var r = t._worldTransform;
            n.a = i.a * r.a + i.b * r.c,
            n.b = i.a * r.b + i.b * r.d,
            n.c = i.c * r.a + i.d * r.c,
            n.d = i.c * r.b + i.d * r.d,
            n.tx = r.a * i.tx + r.c * i.ty + r.tx,
            n.ty = r.d * i.ty + r.ty + r.b * i.tx
        } else
            n.a = i.a,
            n.b = i.b,
            n.c = i.c,
            n.d = i.d,
            n.tx = i.tx,
            n.ty = i.ty;
        if (e && (i = this._node._children) && 0 !== i.length)
            for (n = 0,
            r = i.length; n < r; n++)
                i[n]._renderCmd.transform(this, e)
    }
    ,
    t.initImageSize = function() {
        this._node.tileset.imageSize = this._texture.getContentSizeInPixels()
    }
    ,
    t._reusedTileWithRect = function(t) {
        var e = this._node;
        return e._reusedTile = new cc.Sprite,
        e._reusedTile.initWithTexture(this._texture, t, !1),
        e._reusedTile.batchNode = e,
        e._reusedTile.parent = e,
        e._reusedTile._renderCmd._cachedParent = e._renderCmd,
        e._reusedTile
    }
}(),
function() {
    cc.TMXLayer.WebGLRenderCmd = function(t) {
        cc.SpriteBatchNode.WebGLRenderCmd.call(this, t),
        this._needDraw = !0
    }
    ;
    var t = cc.TMXLayer.WebGLRenderCmd.prototype = Object.create(cc.SpriteBatchNode.WebGLRenderCmd.prototype);
    t.constructor = cc.TMXLayer.WebGLRenderCmd,
    t._updateCacheContext = function() {}
    ,
    t.initImageSize = function() {
        this._node.tileset.imageSize = this._textureAtlas.texture.getContentSizeInPixels(),
        this._textureAtlas.texture.setAliasTexParameters()
    }
    ,
    t._reusedTileWithRect = function(t) {
        var e = this._node;
        return e._reusedTile ? (e._reusedTile.batchNode = null,
        e._reusedTile.setTextureRect(t, !1)) : (e._reusedTile = new cc.Sprite,
        e._reusedTile.initWithTexture(e.texture, t, !1)),
        e._reusedTile.batchNode = e,
        e._reusedTile
    }
}(),
cc.PointObject = cc.Class.extend({
    _ratio: null,
    _offset: null,
    _child: null,
    ctor: function(t, e) {
        this.initWithCCPoint(t, e)
    },
    getRatio: function() {
        return this._ratio
    },
    setRatio: function(t) {
        this._ratio = t
    },
    getOffset: function() {
        return this._offset
    },
    setOffset: function(t) {
        this._offset = t
    },
    getChild: function() {
        return this._child
    },
    setChild: function(t) {
        this._child = t
    },
    initWithCCPoint: function(t, e) {
        return this._ratio = t,
        this._offset = e,
        this._child = null,
        !0
    }
}),
cc.PointObject.create = function(t, e) {
    return new cc.PointObject(t,e)
}
,
cc.ParallaxNode = cc.Node.extend({
    parallaxArray: null,
    _lastPosition: null,
    _className: "ParallaxNode",
    getParallaxArray: function() {
        return this.parallaxArray
    },
    setParallaxArray: function(t) {
        this.parallaxArray = t
    },
    ctor: function() {
        cc.Node.prototype.ctor.call(this),
        this.parallaxArray = [],
        this._lastPosition = cc.p(-100, -100)
    },
    addChild: function(t, e, i, n) {
        if (3 === arguments.length)
            cc.log("ParallaxNode: use addChild(child, z, ratio, offset) instead");
        else {
            if (!t)
                throw Error("cc.ParallaxNode.addChild(): child should be non-null");
            var r = new cc.PointObject(i,n);
            r.setChild(t),
            this.parallaxArray.push(r),
            t.setPosition(this._position.x * i.x + n.x, this._position.y * i.y + n.y),
            cc.Node.prototype.addChild.call(this, t, e, t.tag)
        }
    },
    removeChild: function(t, e) {
        for (var i = this.parallaxArray, n = 0; n < i.length; n++)
            if (i[n].getChild() === t) {
                i.splice(n, 1);
                break
            }
        cc.Node.prototype.removeChild.call(this, t, e)
    },
    removeAllChildren: function(t) {
        this.parallaxArray.length = 0,
        cc.Node.prototype.removeAllChildren.call(this, t)
    },
    _updateParallaxPosition: function() {
        var t = this._absolutePosition();
        if (!cc.pointEqualToPoint(t, this._lastPosition)) {
            for (var e = this.parallaxArray, i = 0, n = e.length; i < n; i++) {
                var r = e[i];
                r.getChild().setPosition(-t.x + t.x * r.getRatio().x + r.getOffset().x, -t.y + t.y * r.getRatio().y + r.getOffset().y)
            }
            this._lastPosition = t
        }
    },
    _absolutePosition: function() {
        for (var t = this._position, e = this; null !== e.parent; )
            e = e.parent,
            t = cc.pAdd(t, e.getPosition());
        return t
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.ParallaxNode.CanvasRenderCmd(this) : new cc.ParallaxNode.WebGLRenderCmd(this)
    }
}),
cc.ParallaxNode.create = function() {
    return new cc.ParallaxNode
}
,
function() {
    cc.ParallaxNode.CanvasRenderCmd = function(t) {
        cc.Node.CanvasRenderCmd.call(this, t),
        this._needDraw = !1
    }
    ;
    var t = cc.ParallaxNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    t.constructor = cc.ParallaxNode.CanvasRenderCmd,
    t.updateStatus = function() {
        this._node._updateParallaxPosition(),
        cc.Node.CanvasRenderCmd.prototype.updateStatus.call(this)
    }
    ,
    t._syncStatus = function(t) {
        this._node._updateParallaxPosition(),
        cc.Node.CanvasRenderCmd.prototype._syncStatus.call(this, t)
    }
}(),
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function() {
    if (cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
        cc.ParallaxNode.WebGLRenderCmd = function(t) {
            cc.Node.WebGLRenderCmd.call(this, t),
            this._needDraw = !1
        }
        ;
        var t = cc.ParallaxNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
        t.constructor = cc.ParallaxNode.WebGLRenderCmd,
        t.updateStatus = function() {
            this._node._updateParallaxPosition(),
            cc.Node.WebGLRenderCmd.prototype.updateStatus.call(this)
        }
        ,
        t._syncStatus = function(t) {
            this._node._updateParallaxPosition(),
            cc.Node.WebGLRenderCmd.prototype._syncStatus.call(this, t)
        }
    }
}),
function() {
    var t = cc.sys
      , e = t.browserVersion
      , i = !!(window.AudioContext || window.webkitAudioContext || window.mozAudioContext)
      , n = {
        common: {
            MULTI_CHANNEL: !0,
            WEB_AUDIO: i,
            AUTOPLAY: !0
        }
    };
    if (n[t.BROWSER_TYPE_IE] = {
        MULTI_CHANNEL: !0,
        WEB_AUDIO: i,
        AUTOPLAY: !0,
        USE_EMPTIED_EVENT: !0
    },
    n[t.BROWSER_TYPE_ANDROID] = {
        MULTI_CHANNEL: !1,
        WEB_AUDIO: !1,
        AUTOPLAY: !1
    },
    n[t.BROWSER_TYPE_CHROME] = {
        MULTI_CHANNEL: !0,
        WEB_AUDIO: !0,
        AUTOPLAY: !1
    },
    n[t.BROWSER_TYPE_FIREFOX] = {
        MULTI_CHANNEL: !0,
        WEB_AUDIO: !0,
        AUTOPLAY: !0,
        DELAY_CREATE_CTX: !0
    },
    n[t.BROWSER_TYPE_UC] = {
        MULTI_CHANNEL: !0,
        WEB_AUDIO: !1,
        AUTOPLAY: !1
    },
    n[t.BROWSER_TYPE_QQ] = {
        MULTI_CHANNEL: !1,
        WEB_AUDIO: !1,
        AUTOPLAY: !0
    },
    n[t.BROWSER_TYPE_OUPENG] = {
        MULTI_CHANNEL: !1,
        WEB_AUDIO: !1,
        AUTOPLAY: !1,
        REPLAY_AFTER_TOUCH: !0,
        USE_EMPTIED_EVENT: !0
    },
    n[t.BROWSER_TYPE_WECHAT] = {
        MULTI_CHANNEL: !1,
        WEB_AUDIO: !1,
        AUTOPLAY: !1,
        REPLAY_AFTER_TOUCH: !0,
        USE_EMPTIED_EVENT: !0
    },
    n[t.BROWSER_TYPE_360] = {
        MULTI_CHANNEL: !1,
        WEB_AUDIO: !1,
        AUTOPLAY: !0
    },
    n[t.BROWSER_TYPE_MIUI] = {
        MULTI_CHANNEL: !1,
        WEB_AUDIO: !1,
        AUTOPLAY: !0
    },
    n[t.BROWSER_TYPE_LIEBAO] = {
        MULTI_CHANNEL: !1,
        WEB_AUDIO: !1,
        AUTOPLAY: !1,
        REPLAY_AFTER_TOUCH: !0,
        USE_EMPTIED_EVENT: !0
    },
    n[t.BROWSER_TYPE_SOUGOU] = {
        MULTI_CHANNEL: !1,
        WEB_AUDIO: !1,
        AUTOPLAY: !1,
        REPLAY_AFTER_TOUCH: !0,
        USE_EMPTIED_EVENT: !0
    },
    n[t.BROWSER_TYPE_BAIDU] = {
        MULTI_CHANNEL: !1,
        WEB_AUDIO: !1,
        AUTOPLAY: !1,
        REPLAY_AFTER_TOUCH: !0,
        USE_EMPTIED_EVENT: !0
    },
    n[t.BROWSER_TYPE_BAIDU_APP] = {
        MULTI_CHANNEL: !1,
        WEB_AUDIO: !1,
        AUTOPLAY: !1,
        REPLAY_AFTER_TOUCH: !0,
        USE_EMPTIED_EVENT: !0
    },
    n[t.BROWSER_TYPE_SAFARI] = {
        MULTI_CHANNEL: !0,
        WEB_AUDIO: !0,
        AUTOPLAY: !1,
        webAudioCallback: function(t) {
            document.createElement("audio").src = t
        }
    },
    cc.sys.isMobile)
        window.__audioSupport = cc.sys.os !== cc.sys.OS_IOS ? n[t.browserType] || n.common : n[t.BROWSER_TYPE_SAFARI];
    else
        switch (t.browserType) {
        case t.BROWSER_TYPE_IE:
            window.__audioSupport = n[t.BROWSER_TYPE_IE];
            break;
        case t.BROWSER_TYPE_FIREFOX:
            window.__audioSupport = n[t.BROWSER_TYPE_FIREFOX];
            break;
        default:
            window.__audioSupport = n.common
        }
    if (e)
        switch (t.browserType) {
        case t.BROWSER_TYPE_CHROME:
            e = parseInt(e),
            30 > e ? window.__audioSupport = {
                MULTI_CHANNEL: !1,
                WEB_AUDIO: !0,
                AUTOPLAY: !1
            } : 42 === e && (window.__audioSupport.NEED_MANUAL_LOOP = !0);
            break;
        case t.BROWSER_TYPE_MIUI:
            cc.sys.isMobile && (e = e.match(/\d+/g),
            2 > e[0] || 2 === e[0] && 0 === e[1] && 1 >= e[2]) && (window.__audioSupport.AUTOPLAY = !1)
        }
}(),
cc.Audio = cc.Class.extend({
    volume: 1,
    loop: !1,
    src: null,
    _touch: !1,
    _playing: !1,
    _AUDIO_TYPE: "AUDIO",
    _pause: !1,
    _buffer: null,
    _currentSource: null,
    _startTime: null,
    _currentTime: null,
    _context: null,
    _volume: null,
    _ignoreEnded: !1,
    _manualLoop: !1,
    _element: null,
    ctor: function(t, e, i) {
        t && (this._context = t),
        e && (this._volume = e),
        t && e && (this._AUDIO_TYPE = "WEBAUDIO"),
        this.src = i
    },
    _setBufferCallback: null,
    setBuffer: function(t) {
        if (t) {
            var e = this._playing;
            this._AUDIO_TYPE = "WEBAUDIO",
            this._buffer && this._buffer !== t && this.getPlaying() && this.stop(),
            this._buffer = t,
            e && this.play(),
            this._volume.gain.value = this.volume,
            this._setBufferCallback && this._setBufferCallback(t)
        }
    },
    _setElementCallback: null,
    setElement: function(t) {
        if (t) {
            var e = this._playing;
            this._AUDIO_TYPE = "AUDIO",
            this._element && this._element !== t && this.getPlaying() && this.stop(),
            this._element = t,
            e && this.play(),
            t.volume = this.volume,
            t.loop = this.loop,
            this._setElementCallback && this._setElementCallback(t)
        }
    },
    play: function(t, e) {
        this._playing = !0,
        this.loop = void 0 === e ? this.loop : e,
        "AUDIO" === this._AUDIO_TYPE ? this._playOfAudio(t) : this._playOfWebAudio(t)
    },
    getPlaying: function() {
        if (!this._playing)
            return !1;
        if ("AUDIO" === this._AUDIO_TYPE) {
            var t = this._element;
            return !(!t || this._pause || t.ended) || (this._playing = !1)
        }
        return t = this._currentSource,
        !t || !t.playbackState || this._currentTime + this._context.currentTime - this._startTime < t.buffer.duration || 2 == t.playbackState
    },
    _playOfWebAudio: function(t) {
        var e = this._currentSource;
        if (this._buffer) {
            if (!this._pause && e) {
                if (!(0 === this._context.currentTime || this._currentTime + this._context.currentTime - this._startTime > e.buffer.duration))
                    return;
                this._stopOfWebAudio()
            }
            if (e = this._context.createBufferSource(),
            e.buffer = this._buffer,
            e.connect(this._volume),
            e.loop = !this._manualLoop && this.loop,
            this._startTime = this._context.currentTime,
            this._currentTime = t || 0,
            this._ignoreEnded = !1,
            e.start)
                e.start(0, t || 0);
            else if (e.noteGrainOn) {
                var i = e.buffer.duration;
                this.loop ? e.noteGrainOn(0, t, i) : e.noteGrainOn(0, t, i - t)
            } else
                e.noteOn(0);
            this._currentSource = e;
            var n = this;
            e.onended = function() {
                n._manualLoop && n._playing && n.loop ? (n.stop(),
                n.play()) : n._ignoreEnded ? n._ignoreEnded = !1 : n._pause ? n._playing = !1 : n.stop()
            }
        }
    },
    _playOfAudio: function() {
        var t = this._element;
        t && (t.loop = this.loop,
        t.play())
    },
    stop: function() {
        this._playing = !1,
        "AUDIO" === this._AUDIO_TYPE ? this._stopOfAudio() : this._stopOfWebAudio()
    },
    _stopOfWebAudio: function() {
        var t = this._currentSource;
        this._ignoreEnded = !0,
        t && (t.stop(0),
        this._currentSource = null)
    },
    _stopOfAudio: function() {
        var t = this._element;
        t && (t.pause(),
        t.duration && 1 / 0 !== t.duration && (t.currentTime = 0))
    },
    pause: function() {
        !1 !== this.getPlaying() && (this._playing = !1,
        this._pause = !0,
        "AUDIO" === this._AUDIO_TYPE ? this._pauseOfAudio() : this._pauseOfWebAudio())
    },
    _pauseOfWebAudio: function() {
        this._currentTime += this._context.currentTime - this._startTime;
        var t = this._currentSource;
        t && t.stop(0)
    },
    _pauseOfAudio: function() {
        var t = this._element;
        t && t.pause()
    },
    resume: function() {
        this._pause && ("AUDIO" === this._AUDIO_TYPE ? this._resumeOfAudio() : this._resumeOfWebAudio(),
        this._pause = !1,
        this._playing = !0)
    },
    _resumeOfWebAudio: function() {
        var t = this._currentSource;
        t && (this._startTime = this._context.currentTime,
        this._playOfWebAudio(this._currentTime % t.buffer.duration))
    },
    _resumeOfAudio: function() {
        var t = this._element;
        t && t.play()
    },
    setVolume: function(t) {
        1 < t && (t = 1),
        0 > t && (t = 0),
        this.volume = t,
        "AUDIO" === this._AUDIO_TYPE ? this._element && (this._element.volume = t) : this._volume && (this._volume.gain.value = t)
    },
    getVolume: function() {
        return this.volume
    },
    cloneNode: function() {
        var t, e;
        if ("AUDIO" === this._AUDIO_TYPE) {
            t = new cc.Audio;
            var i = document.createElement("audio");
            i.src = this.src,
            t.setElement(i)
        } else
            i = this._context.createGain(),
            i.gain.value = 1,
            i.connect(this._context.destination),
            t = new cc.Audio(this._context,i,this.src),
            this._buffer ? t.setBuffer(this._buffer) : (e = this,
            this._setBufferCallback = function(i) {
                t.setBuffer(i),
                e._setBufferCallback = null
            }
            ),
            t._manualLoop = this._manualLoop;
        return t._AUDIO_TYPE = this._AUDIO_TYPE,
        t
    }
}),
function(t) {
    var e = t.WEB_AUDIO
      , i = t.MULTI_CHANNEL
      , n = t.AUTOPLAY
      , r = [];
    !function() {
        var t = document.createElement("audio");
        if (t.canPlayType) {
            var e = t.canPlayType('audio/ogg; codecs="vorbis"');
            e && "" !== e && r.push(".ogg"),
            (e = t.canPlayType("audio/mpeg")) && "" !== e && r.push(".mp3"),
            (e = t.canPlayType('audio/wav; codecs="1"')) && "" !== e && r.push(".wav"),
            (e = t.canPlayType("audio/mp4")) && "" !== e && r.push(".mp4"),
            (t = t.canPlayType("audio/x-m4a")) && "" !== t && r.push(".m4a")
        }
    }();
    try {
        if (e) {
            var c = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext);
            t.DELAY_CREATE_CTX && setTimeout(function() {
                c = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext)
            }, 0)
        }
    } catch (s) {
        e = !1,
        cc.log("browser don't support web audio")
    }
    var o = {
        cache: {},
        load: function(i, n, s, a) {
            if (0 === r.length)
                return a("can not support audio!");
            cc.loader.audioPath && (i = cc.path.join(cc.loader.audioPath, i));
            var h = cc.path.extname(i)
              , l = [h];
            for (s = 0; s < r.length; s++)
                h !== r[s] && l.push(r[s]);
            var u;
            if (o.cache[n])
                return a(null, o.cache[n]);
            if (e)
                try {
                    var d = c.createGain();
                    d.gain.value = 1,
                    d.connect(c.destination),
                    u = new cc.Audio(c,d,i),
                    t.NEED_MANUAL_LOOP && (u._manualLoop = !0)
                } catch (_) {
                    e = !1,
                    cc.log("browser don't support web audio"),
                    u = new cc.Audio(null,null,i)
                }
            else
                u = new cc.Audio(null,null,i);
            this.loadAudioFromExtList(i, l, u, a),
            o.cache[n] = u
        },
        loadAudioFromExtList: function(i, n, s, a) {
            if (0 === n.length) {
                var h = "can not found the resource of audio! Last match url is : "
                  , h = h + i.replace(/\.(.*)?$/, "(");
                return r.forEach(function(t) {
                    h += t + "|"
                }),
                h = h.replace(/\|$/, ")"),
                a({
                    status: 520,
                    errorMessage: h
                }, null)
            }
            if (i = cc.path.changeExtname(i, n.splice(0, 1)),
            e) {
                t.webAudioCallback && t.webAudioCallback(i);
                var l = new XMLHttpRequest;
                l.open("GET", i, !0),
                l.responseType = "arraybuffer",
                l.onload = function() {
                    c.decodeAudioData(l.response, function(t) {
                        s.setBuffer(t),
                        a(null, s)
                    }, function() {
                        o.loadAudioFromExtList(i, n, s, a)
                    })
                }
                ,
                l.onerror = function() {
                    a({
                        status: 520,
                        errorMessage: h
                    }, null)
                }
                ,
                l.send()
            } else {
                var u = document.createElement("audio")
                  , d = !1
                  , _ = !1
                  , p = setTimeout(function() {
                    0 === u.readyState ? m() : (_ = !0,
                    u.pause(),
                    document.body.removeChild(u),
                    a("audio load timeout : " + i, s))
                }, 1e4)
                  , f = function() {
                    if (!d) {
                        try {
                            u.currentTime = 0,
                            u.volume = 1
                        } catch (t) {}
                        document.body.removeChild(u),
                        s.setElement(u),
                        u.removeEventListener("canplaythrough", f, !1),
                        u.removeEventListener("error", g, !1),
                        u.removeEventListener("emptied", m, !1),
                        !_ && a(null, s),
                        d = !0,
                        clearTimeout(p)
                    }
                }
                  , g = function() {
                    d && (document.body.removeChild(u),
                    u.removeEventListener("canplaythrough", f, !1),
                    u.removeEventListener("error", g, !1),
                    u.removeEventListener("emptied", m, !1),
                    !_ && o.loadAudioFromExtList(i, n, s, a),
                    d = !0,
                    clearTimeout(p))
                }
                  , m = function() {
                    _ = !0,
                    f(),
                    a(null, s)
                };
                u.addEventListener("canplaythrough", f, !1),
                u.addEventListener("error", g, !1),
                t.USE_EMPTIED_EVENT && u.addEventListener("emptied", m, !1),
                u.src = i,
                document.body.appendChild(u),
                u.volume = 0
            }
        }
    };
    if (cc.loader.register(["mp3", "ogg", "wav", "mp4", "m4a"], o),
    cc.audioEngine = {
        _currMusic: null,
        _musicVolume: 1,
        features: t,
        willPlayMusic: function() {
            return !1
        },
        playMusic: function(t, e) {
            var i = this._currMusic;
            i && i.src !== t && i.getPlaying() && i.stop(),
            i = o.cache[t],
            i || (cc.loader.load(t),
            i = o.cache[t]),
            i.play(0, e),
            i.setVolume(this._musicVolume),
            this._currMusic = i
        },
        stopMusic: function(t) {
            var e = this._currMusic;
            e && (e.stop(),
            t && cc.loader.release(e.src))
        },
        pauseMusic: function() {
            var t = this._currMusic;
            t && t.pause()
        },
        resumeMusic: function() {
            var t = this._currMusic;
            t && t.resume()
        },
        rewindMusic: function() {
            var t = this._currMusic;
            t && (t.stop(),
            t.play())
        },
        getMusicVolume: function() {
            return this._musicVolume
        },
        setMusicVolume: function(t) {
            t -= 0,
            isNaN(t) && (t = 1),
            1 < t && (t = 1),
            0 > t && (t = 0),
            this._musicVolume = t;
            var e = this._currMusic;
            e && e.setVolume(t)
        },
        isMusicPlaying: function() {
            var t = this._currMusic;
            return !!t && t.getPlaying()
        },
        _audioPool: {},
        _maxAudioInstance: 5,
        _effectVolume: 1,
        playEffect: function(t, n) {
            if (!i)
                return null;
            var r = this._audioPool[t];
            r || (r = this._audioPool[t] = []);
            var c;
            for (c = 0; c < r.length && r[c].getPlaying(); c++)
                ;
            if (r[c])
                s = r[c],
                s.setVolume(this._effectVolume),
                s.play(0, n);
            else if (!e && c > this._maxAudioInstance)
                cc.log("Error: %s greater than %d", t, this._maxAudioInstance);
            else {
                var s = o.cache[t];
                s || (cc.loader.load(t),
                s = o.cache[t]),
                s = s.cloneNode(),
                s.setVolume(this._effectVolume),
                s.loop = n || !1,
                s.play(),
                r.push(s)
            }
            return s
        },
        setEffectsVolume: function(t) {
            t -= 0,
            isNaN(t) && (t = 1),
            1 < t && (t = 1),
            0 > t && (t = 0),
            this._effectVolume = t;
            var e, i = this._audioPool;
            for (e in i) {
                var n = i[e];
                if (Array.isArray(n))
                    for (var r = 0; r < n.length; r++)
                        n[r].setVolume(t)
            }
        },
        getEffectsVolume: function() {
            return this._effectVolume
        },
        pauseEffect: function(t) {
            t && t.pause()
        },
        pauseAllEffects: function() {
            var t, e = this._audioPool;
            for (t in e)
                for (var i = e[t], n = 0; n < e[t].length; n++)
                    i[n].getPlaying() && i[n].pause()
        },
        resumeEffect: function(t) {
            t && t.resume()
        },
        resumeAllEffects: function() {
            var t, e = this._audioPool;
            for (t in e)
                for (var i = e[t], n = 0; n < e[t].length; n++)
                    i[n].resume()
        },
        stopEffect: function(t) {
            t && t.stop()
        },
        stopAllEffects: function() {
            var t, e = this._audioPool;
            for (t in e)
                for (var i = e[t], n = 0; n < e[t].length; n++)
                    i[n].stop()
        },
        unloadEffect: function(t) {
            if (t) {
                cc.loader.release(t);
                var e = this._audioPool[t];
                e && (e.length = 0),
                delete this._audioPool[t],
                delete o.cache[t]
            }
        },
        end: function() {
            this.stopMusic(),
            this.stopAllEffects()
        },
        _pauseCache: [],
        _pausePlaying: function() {
            var t = this._currMusic;
            t && t.getPlaying() && (t.pause(),
            this._pauseCache.push(t));
            var e, t = this._audioPool;
            for (e in t)
                for (var i = t[e], n = 0; n < t[e].length; n++)
                    i[n].getPlaying() && (i[n].pause(),
                    this._pauseCache.push(i[n]))
        },
        _resumePlaying: function() {
            for (var t = this._pauseCache, e = 0; e < t.length; e++)
                t[e].resume();
            t.length = 0
        }
    },
    !n) {
        var a = function() {
            var e = cc.audioEngine._currMusic;
            e && !1 === e._touch && e._playing && e.getPlaying() && (e._touch = !0,
            e.play(0, e.loop),
            !t.REPLAY_AFTER_TOUCH && cc._canvas.removeEventListener("touchstart", a))
        };
        setTimeout(function() {
            cc._canvas && cc._canvas.addEventListener("touchstart", a, !1)
        }, 150)
    }
}(window.__audioSupport),
cc.pool = {
    _pool: {},
    _releaseCB: function() {
        this.release()
    },
    _autoRelease: function(t) {
        var e = void 0 !== t._running && !t._running;
        cc.director.getScheduler().schedule(this._releaseCB, t, 0, 0, 0, e)
    },
    putInPool: function(t) {
        var e = t.constructor.prototype.__pid;
        if (!e) {
            var i = {
                writable: !0,
                enumerable: !1,
                configurable: !0
            };
            i.value = ClassManager.getNewID(),
            Object.defineProperty(t.constructor.prototype, "__pid", i)
        }
        this._pool[e] || (this._pool[e] = []),
        t.retain && t.retain(),
        t.unuse && t.unuse(),
        this._pool[e].push(t)
    },
    hasObject: function(t) {
        return !(!(t = this._pool[t.prototype.__pid]) || 0 === t.length)
    },
    removeObject: function(t) {
        var e = t.constructor.prototype.__pid;
        if (e && (e = this._pool[e]))
            for (var i = 0; i < e.length; i++)
                t === e[i] && (t.release && t.release(),
                e.splice(i, 1))
    },
    getFromPool: function(t) {
        if (this.hasObject(t)) {
            var e = this._pool[t.prototype.__pid]
              , i = Array.prototype.slice.call(arguments);
            return i.shift(),
            e = e.pop(),
            e.reuse && e.reuse.apply(e, i),
            cc.sys.isNative && e.release && this._autoRelease(e),
            e
        }
    },
    drainAllPools: function() {
        for (var t in this._pool)
            for (var e = 0; e < this._pool[t].length; e++) {
                var i = this._pool[t][e];
                i.release && i.release()
            }
        this._pool = {}
    }
};
var res2 = {
    UI_Plist: "assets/res/UI.plist",
    UI_png: "assets/res/UI.png",
    pop_effect: "assets/res/music/pop2.mp3",
    pop_effect1: "assets/res/music/pop.mp3",
    click: "assets/res/music/music_click.mp3",
    effect_cannotuse: "assets/res/music/cannotuse.mp3",
    effect_use: "assets/res/music/use.mp3",
    popup_anim_png: "assets/res/popup_anim.png",
    effect_coin1: "assets/res/music/coin1.mp3",
    effect_coin2: "assets/res/music/coin2.mp3",
    effect_coin3: "assets/res/music/coin3.mp3",
    effect_coin4: "assets/res/music/coin4.mp3",
    effect_coin5: "assets/res/music/coin5.mp3",
    effect_hit: "assets/res/music/hit.mp3",
    effect_lose: "assets/res/music/music_fail.mp3",
    effect_win: "assets/res/music/gamewin2.mp3",
    effect_lottery: "assets/res/music/music_win.mp3",
    particle: "assets/res/particle/particle_texture.plist",
    particle_texture: "assets/res/particle/particle_texture.png",
    logo_png: window.famobi.__("preload_image"),
    bubble_logo: "assets/res/logo.png",
    orientation_jpg: "assets/res/orientation.jpg",
    lvlScene2: "assets/res/LevelScene2.png",
    lvlScene1: "assets/res/LevelScene1.png",
    lvlScene3: "assets/res/LevelScene3.png",
    lvlScene4: "assets/res/LevelScene4.png",
    lvlScene5: "assets/res/LevelScene5.png",
    border: "assets/res/border.png",
    map_backgr_png: "assets/res/map_backgr2.png",
    small_bg: "assets/res/popup_backgr.png",
    moreGamePng: window.famobi.getMoreGamesButtonImage(),
    trFont: {
        type: "font",
        name: "Foo",
        srcs: ["assets/res/font.ttf"]
    },
    playButtonPng: "assets/res/play_button.png"
}
  , res = {
    ball0: "#ball_0.png",
    ball1: "#ball_1.png",
    ball2: "#ball_2.png",
    ball3: "#ball_3.png",
    ball4: "#ball_4.png",
    ball5: "#ball_5.png",
    ball6: "#ball_6.png",
    centerWall_png: "#centerWall4.png",
    centerWall_tc_png: "#inner_whell_tc.png",
    centerWall_tl_png: "#inner_whell_tl.png",
    centerWall_tr_png: "#inner_whell_tr.png",
    centerWall_bc_png: "#inner_whell_bc.png",
    centerWall_bl_png: "#inner_whell_bl.png",
    centerWall_br_png: "#inner_whell_br.png",
    star_png: "#star.png",
    starGrey_png: "#starGrey.png",
    btn_play_big: "#btn_play_big.png",
    btn_sound_on: "#btn_sound_on.png",
    btn_sound_off: "#btn_sound_off.png",
    btn_more_games: "#btn_more_games.png",
    coin_png: "#money.png",
    lives_png: "#lives.png",
    btn_pause_png: "#btn_pause.png",
    btn_play_png: "#btn_play.png",
    btn_replay_png: "#btn_replay.png",
    btn_home_png: "#btn_home.png",
    btn_back_png: "#btn_back.png",
    btn_back2_png: "#btn_back2.png",
    btn_shop_png: "#btn_shop.png",
    btn_shop2_png: "#btn_shop2.png",
    gift_icon_png: "#gift_icon.png",
    lvl_lock_png: "#lvl_lock.png",
    planet_star_png: "#planet_star.png",
    pop_circle_png: "#pop_circle5.png",
    bg_exit: "#popup_backgr_exit.png",
    lose_png: "#popup_lose.png",
    star_1_png: "#star_1.png",
    star_2_png: "#star_2.png",
    plus_png: "#plus.png",
    plus2_png: "#plus2.png",
    booster_aim: "#booster_1.png",
    booster_aim_big: "#booster_1_big.png",
    booster_redo: "#booster_2.png",
    booster_redo_big: "#booster_2_big.png",
    booster_explosion: "#booster_3.png",
    booster_explosion_big: "#booster_3_big.png",
    booster_elimination: "#booster_4.png",
    booster_elimination_big: "#booster_4_big.png",
    check_mark_png: "#check_mark.png",
    booster_cnt: "#booster_cnt.png",
    btn_watchAD_png: "#btn_play.png",
    btn_claim_png: "#btn_yes.png",
    boosterBar_png: "#booster_bar.png",
    boosterIcon_png: "#booster_icon.png",
    tutorial_hand_png: "#tutorial_hand.png",
    pop_effect: "assets/res/music/pop2.mp3",
    pop_effect1: "assets/res/music/pop.mp3",
    click: "assets/res/music/music_click.mp3",
    effect_cannotuse: "assets/res/music/cannotuse.mp3",
    effect_use: "assets/res/music/use.mp3",
    popup_anim_png: "assets/res/popup_anim.png",
    effect_coin1: "assets/res/music/coin1.mp3",
    effect_coin2: "assets/res/music/coin2.mp3",
    effect_coin3: "assets/res/music/coin3.mp3",
    effect_coin4: "assets/res/music/coin4.mp3",
    effect_coin5: "assets/res/music/coin5.mp3",
    effect_hit: "assets/res/music/hit.mp3",
    effect_lose: "assets/res/music/music_fail.mp3",
    effect_win: "assets/res/music/gamewin2.mp3",
    effect_lottery: "assets/res/music/music_win.mp3",
    particle: "assets/res/particle/particle_texture.plist",
    particle_texture: "assets/res/particle/particle_texture.png",
    logo_png: window.famobi.__("preload_image"),
    bubble_logo: "assets/res/logo.png",
    orientation_jpg: "assets/res/orientation.jpg",
    lvlScene2: "assets/res/LevelScene2.png",
    lvlScene1: "assets/res/LevelScene1.png",
    lvlScene3: "assets/res/LevelScene3.png",
    lvlScene4: "assets/res/LevelScene4.png",
    lvlScene5: "assets/res/LevelScene5.png",
    border: "assets/res/border.png",
    map_backgr_png: "assets/res/map_backgr2.png",
    small_bg: "assets/res/popup_backgr.png",
    lemonFont: {
        type: "font",
        name: "Lemon",
        srcs: ["assets/res/lemonMore.ttf"]
    },
    trFont: {
        type: "font",
        name: "Foo",
        srcs: ["assets/res/font.ttf"]
    }
};
getFont = function(t) {
    return "tr" === window.famobi.getCurrentLanguage() || "ru" === window.famobi.getCurrentLanguage() || "pl" === window.famobi.getCurrentLanguage() ? cc.sys.isNative ? res2.trFont.srcs[0] : res2.trFont.name : cc.sys.isNative ? t.srcs[0] : t.name
}
;
var g_resources = [], i;
for (i in res2)
    g_resources.push(res2[i]);
g_resources.push(res.lemonFont),
g_resources.push(res.trFont);
var Sound = {
    silence: !1,
    _effortNum: 0,
    playEffect: function() {
        Sound.silence || (Sound._effortNum && cc.audioEngine.stopEffect(Sound._effortNum),
        Sound._effortNum = cc.audioEngine.playEffect("", !1))
    },
    playCoin1: function() {
        Sound.silence || cc.audioEngine.playEffect(res.effect_coin1, !1)
    },
    playCoin2: function() {
        Sound.silence || cc.audioEngine.playEffect(res.effect_coin2, !1)
    },
    playCoin3: function() {
        Sound.silence || cc.audioEngine.playEffect(res.effect_coin3, !1)
    },
    playCoin4: function() {
        Sound.silence || cc.audioEngine.playEffect(res.effect_coin4, !1)
    },
    playCoin5: function() {
        Sound.silence || cc.audioEngine.playEffect(res.effect_coin5, !1)
    },
    playHit: function() {
        Sound.silence || cc.audioEngine.playEffect(res.effect_hit, !1)
    },
    playClearEffect1: function() {
        Sound.silence || cc.audioEngine.playEffect(res.pop_effect1, !1)
    },
    playClearEffect: function() {
        Sound.silence || cc.audioEngine.playEffect(res.pop_effect, !1)
    },
    playClick: function() {
        Sound.silence || cc.audioEngine.playEffect(res.click, !1)
    },
    playWin: function() {
        Sound.silence || cc.audioEngine.playEffect(res.effect_win, !1)
    },
    playLottery: function() {
        Sound.silence || cc.audioEngine.playEffect(res.effect_lottery, !1)
    },
    playLose: function() {
        Sound.silence || cc.audioEngine.playEffect(res.effect_lose, !1)
    },
    playCannotUse: function() {
        Sound.silence || cc.audioEngine.playEffect(res.effect_cannotuse, !1)
    },
    playUse: function() {
        Sound.silence || cc.audioEngine.playEffect(res.effect_use, !1)
    },
    stop: function() {
        cc.audioEngine.stopAllEffects(),
        cc.audioEngine.stopMusic()
    },
    pause: function() {
        cc.audioEngine.pauseMusic()
    },
    resume: function() {
        cc.audioEngine.resumeMusic()
    },
    toggleOnoff: function() {
        Sound.silence ? (Sound.silence = !1,
        this.playClick(),
        cc.audioEngine.setEffectsVolume(1),
        cc.audioEngine.setMusicVolume(1)) : (Sound.silence = !0,
        cc.audioEngine.setEffectsVolume(0),
        cc.audioEngine.setMusicVolume(0)),
        window.famobi_analytics.trackEvent("EVENT_VOLUMECHANGE", {
            bgmVolume: cc.audioEngine.getMusicVolume(),
            sfxVolume: cc.audioEngine.getEffectsVolume()
        })
    }
}
  , HelloWorldLayer = cc.Layer.extend({
    sprite: null,
    ctor: function() {
        this._super(),
        Sound.playCoin2();
        var t = new cc.Sprite(res.btn_home_png);
        t.x = 0,
        t.y = cc.winSize.height / 2,
        this.addChild(t, 1, 1);
        var e = cc.jumpBy(3, cc.p(400, 0), 200, 3);
        return t.runAction(cc.sequence(e, e.reverse()).repeatForever()),
        !0
    }
})
  , HelloWorldScene = cc.Scene.extend({
    onEnter: function() {
        this._super();
        var t = new HelloWorldLayer;
        this.addChild(t)
    }
});
groupArray = [],
BALLCOUNT = 6,
LEFT = -1,
RIGHT = 1,
COLORTYPE = {
    1: "blue",
    2: "yellow",
    3: "green",
    4: "red",
    5: "purple",
    6: "coffee"
};
var GameScene = cc.Scene.extend({
    BALLWIDTH: 40,
    BALLHEIGHT: 40,
    STARTX: 20,
    STARTY: 140,
    leftWall: 0,
    rightWall: 0,
    gameWindowWidth: 640,
    gameWindowHeight: 960,
    angle: 0,
    level: 0,
    lastLevel: -1,
    centerX: 7,
    centerY: 7,
    rowMax: 16,
    colMax: 16,
    currentBullet: null,
    speed: 15,
    vx: 5,
    vy: 5,
    topHeight: 980,
    hitWallCount: 0,
    bulletPlaying: !1,
    isGameOver: !1,
    hasConfigUI: !1,
    adjustPoint: null,
    rotateCountMax: 0,
    rotateCount: 0,
    hasWin: !1,
    bulletProject: [],
    bulletNum: 0,
    isCheckingOrPlaying: !1,
    projectAngle: 0,
    rotateAngle: 0,
    rotateDirection: 0,
    rotateDirectionReal: 0,
    rotateB: 0,
    rotateK: 0,
    bulletMaxCnt: 9,
    hasClearBall: !1,
    bulletProjectIsUpdating: !1,
    idleBulletStartPosArray: [],
    needRotateArray: [],
    continueClearCnt: 0,
    goodLabel: "",
    curColTypes: {
        1: !1,
        2: !1,
        3: !1,
        4: !1,
        5: !1,
        6: !1
    },
    radarPaint: null,
    dangerList: [],
    starCntLabel: "",
    starCnt: 3,
    ballCount: 999,
    aimSelected: 0,
    redoSelected: 0,
    explosionSelected: 0,
    eliminationSelected: 0,
    aimCnt: 0,
    redoCnt: 0,
    explosionCnt: 0,
    eliminationCnt: 0,
    initArray: function() {
        groupArray = [],
        this.bulletProject = [],
        this.dangerList = [],
        this.needRotateArray = [],
        this.idleBulletStartPosArray = [],
        this.curColTypes = {
            1: !1,
            2: !1,
            3: !1,
            4: !1,
            5: !1,
            6: !1
        }
    },
    ctor: function(t) {
        this._super(),
        this.initArray(),
        cc.log("ctor again"),
        LEVEL[t] || (t = 1),
        t || (t = 1),
        this.level = t,
        window.famobi_analytics.trackEvent(this.level === LASTLEVEL ? "EVENT_LEVELRESTART" : "EVENT_LEVELSTART", {
            levelName: "" + this.level
        }),
        window.famobi_analytics.trackScreen("SCREEN_LEVEL", "" + this.level),
        LASTLEVEL = this.level,
        this.leftWall = cc.winSize.width / 2 - this.gameWindowWidth / 2,
        this.rightWall = cc.winSize.width / 2 + this.gameWindowWidth / 2,
        this.STARTX = this.leftWall + this.BALLHEIGHT / 2,
        this.STARTY = this.topHeight - this.BALLHEIGHT / 2 - 12,
        this.bottomHeight = this.topHeight - this.rowMax * this.BALLHEIGHT,
        this.centerx = cc.winSize.width / 2,
        this.centery = cc.winSize.height / 2,
        this.layer = t = new cc.Layer,
        this.nodeGroup = new cc.Node,
        this.addChild(t, 0, 0),
        this.drawBg(),
        this.drawBorder(),
        this.drawTopTools(),
        this.initCurColorList(),
        this.initBall(),
        this.getDangerBall(),
        this.drawCenterWall(),
        this.drawNewBulletProject(),
        this.calFourBouncePoint(),
        this.drawPauseMenu(),
        t = new cc.DrawNode;
        var e = cc.color(244, 145, 162);
        if (t.drawSegment(cc.p(this.leftWall, this.topHeight), cc.p(this.rightWall, this.topHeight), 3, e),
        this.layer.addChild(t, 132, 132),
        t.drawSegment(cc.p(this.leftWall, this.bottomHeight), cc.p(this.rightWall, this.bottomHeight), 3, e),
        this.radarPaint = new cc.DrawNode,
        this.layer.addChild(this.radarPaint, 40, 40),
        this.configIdleBallPara(),
        this.goodLabel = new cc.LabelTTF("",getFont(res.lemonFont),60),
        this.layer.addChild(this.goodLabel, 25, 25),
        this.drawBoosterMenu(),
        ISDEBUG) {
            this.drawPos(),
            e = new cc.LabelTTF("<-LEFT","",50),
            e = new cc.MenuItemLabel(e,function() {
                this.rotateDirection = 10,
                this.rotateAllBall(1)
            }
            ,this),
            e.x = this.STARTX + 100,
            e.y = 100;
            var i = new cc.LabelTTF("RIGHT->","",50)
              , i = new cc.MenuItemLabel(i,function() {
                this.rotateDirection = -10,
                this.rotateAllBall(-10)
            }
            ,this);
            i.x = this.STARTX + 500,
            i.y = 100;
            var n = new cc.LabelTTF("gameOver","",50)
              , n = new cc.MenuItemLabel(n,function() {
                this.playCenterWallCartoon()
            }
            ,this);
            n.x = this.STARTX + 300,
            n.y = 100,
            e = new cc.Menu(e,i,n),
            e.x = e.y = 0,
            this.addChild(e, 31, 31),
            t && t.drawDot(cc.p(groupArray[this.centerX][this.centerY].x, groupArray[this.centerX][this.centerY].y), this.gameWindowWidth / 2, cc.color(0, 0, 0, 120)),
            this.tempBall = []
        }
        1 === this.level && this.tutorialCartoon(),
        cc.eventManager.addCustomListener("stopSchedule", this.stopSchedule.bind(this))
    },
    stopSchedule: function() {
        this.unscheduleUpdate()
    },
    onEnterTransitionDidFinish: function() {
        this._super(),
        cc.log("start update,,,,,,,,,,,"),
        this.scheduleUpdate()
    },
    drawBrokenCenterWall: function() {
        var t = groupArray[this.centerX][this.centerY].x
          , e = groupArray[this.centerX][this.centerY].y
          , i = new cc.Sprite(res.centerWall_bc_png);
        this.layer.addChild(i, 11, 11);
        var n = new cc.Sprite(res.centerWall_bl_png);
        this.layer.addChild(n, 11, 11);
        var r = new cc.Sprite(res.centerWall_br_png);
        this.layer.addChild(r, 11, 11);
        var c = new cc.Sprite(res.centerWall_tc_png);
        this.layer.addChild(c, 11, 11);
        var s = new cc.Sprite(res.centerWall_tl_png);
        this.layer.addChild(s, 11, 11);
        var o = new cc.Sprite(res.centerWall_tr_png);
        for (this.layer.addChild(o, 11, 11),
        i.setAnchorPoint(cc.p(.5, 1)),
        n.setAnchorPoint(cc.p(1, 1)),
        r.setAnchorPoint(cc.p(0, 1)),
        c.setAnchorPoint(cc.p(.5, 0)),
        s.setAnchorPoint(cc.p(1, 0)),
        o.setAnchorPoint(cc.p(0, 0)),
        c.x = s.x = o.x = n.x = r.x = i.x = t,
        c.y = s.y = o.y = r.y = n.y = i.y = e,
        this.cw = [i, n, r, c, s, o],
        t = 0; t != this.cw.length; t++)
            this.cw[t].setRotation(this.centerWall.rotation);
        t = this.layer.getChildByName("centerStar"),
        e = this.layer.getChildByName("centerStarCnt"),
        t.removeFromParent(),
        e.removeFromParent()
    },
    playCenterWallCartoon: function() {
        this.centerWall.setVisible(!1),
        this.drawBrokenCenterWall();
        for (var t = 0; t != this.cw.length; t++) {
            var e = cc.fadeOut(1)
              , i = cc.rotateBy(2, 180)
              , n = cc.random0To1() * cc.winSize.width;
            cc.random0To1(),
            n = cc.jumpTo(1, cc.p(n, -cc.winSize.height), 700, 1),
            e = cc.spawn(e, i, n),
            e = cc.sequence(cc.delayTime(0), e),
            this.cw[t].runAction(e)
        }
    },
    drawPauseMenu: function() {
        var t = new cc.MenuItemImage(res.btn_pause_png,res.btn_pause_png,this.optionClick,this);
        t.x = this.rightWall - t.width / 2 - 20,
        t.y = cc.winSize.height - t.height,
        t.setScale(.5),
        t = new cc.Menu(t),
        t.x = t.y = 0,
        this.layer.addChild(t, 60, 60)
    },
    configUIClose: function() {
        this.hasConfigUI = !1
    },
    optionClick: function() {
        if (!this.hasWin && !this.isGameOver && !0 !== this.hasConfigUI && 1 !== this.level) {
            Sound.playClick(),
            cc.director.isPaused() ? cc.director.resume() : cc.director.pause(),
            this.hasConfigUI = !this.hasConfigUI;
            var t = new OptionUI(this.level);
            this.layer.addChild(t, 549, 549)
        }
    },
    drawBoosterMenu: function() {
        this.aimCnt = Storage.getAimBoosterNum(),
        this.redoCnt = Storage.getRedoBoosterNum(),
        this.eliminationCnt = Storage.getEliminationBoosterNum(),
        this.explosionCnt = Storage.getExplosionBoosterNum();
        var t = new cc.MenuItemImage(res.booster_elimination,res.booster_elimination_big,function() {
            this.isGameOver || this.hasWin || (0 >= this.eliminationCnt ? Sound.playCannotUse() : (cc.log("use elimination booster"),
            this.useEliminationBooster(),
            this.eliminationCnt--,
            Storage.setEliminationBoosterNum(this.eliminationCnt),
            this.updateBoosterLabel()))
        }
        ,this);
        t.x = this.rightWall - 100,
        t.y = t.height / 2 + 10,
        t.setScale(.8),
        this.eliminationCntLabel = new cc.LabelTTF(this.eliminationCnt + "",getFont(res.lemonFont),30),
        this.eliminationCntLabel.anchorX = 0,
        this.eliminationCntLabel.x = t.x + 50,
        this.eliminationCntLabel.y = t.y,
        this.layer.addChild(this.eliminationCntLabel, 51, 51);
        var e = new cc.MenuItemImage(res.booster_explosion,res.booster_explosion_big,function() {
            if (!this.isGameOver && !this.hasWin)
                if (cc.log("use explosion "),
                0 >= this.explosionCnt)
                    Sound.playCannotUse();
                else {
                    if (Sound.playUse(),
                    this.bulletProject[0]) {
                        var t = cc.textureCache.addImage("assets/res/explosionBall.png");
                        this.bulletProject[0].setTexture(t)
                    }
                    this.explosionSelected = 1,
                    this.explosionCnt--,
                    Storage.setExplosionBoosterNum(this.explosionCnt),
                    this.updateBoosterLabel()
                }
        }
        ,this);
        e.x = t.x,
        e.y = t.y + e.height / 2 + 30,
        e.setScale(.8),
        this.explosionCntLabel = new cc.LabelTTF(this.explosionCnt + "",getFont(res.lemonFont),30),
        this.explosionCntLabel.anchorX = 0,
        this.explosionCntLabel.x = e.x + 50,
        this.explosionCntLabel.y = e.y,
        this.layer.addChild(this.explosionCntLabel, 51, 51);
        var i = new cc.MenuItemImage(res.booster_redo,res.booster_redo_big,function() {
            this.isGameOver || this.hasWin || (cc.log("use redo booster"),
            0 >= this.redoCnt ? Sound.playCannotUse() : (Sound.playUse(),
            this.redoCnt--,
            Storage.setRedoBoosterNum(this.redoCnt),
            this.useRedoBooster2(),
            this.updateBoosterLabel()))
        }
        ,this);
        i.x = t.x,
        i.y = e.y + e.height / 2 * e.scale + 30,
        i.setScale(.8),
        this.redoCntLabel = new cc.LabelTTF(this.redoCnt + "",getFont(res.lemonFont),30),
        this.redoCntLabel.anchorX = 0,
        this.redoCntLabel.x = i.x + 50,
        this.redoCntLabel.y = i.y,
        this.layer.addChild(this.redoCntLabel, 51, 51);
        var n = new cc.MenuItemImage(res.booster_aim,res.booster_aim_big,function() {
            this.isGameOver || this.hasWin || (cc.log("use aim item"),
            0 >= this.aimCnt ? Sound.playCannotUse() : 0 === this.aimSelected && (Sound.playUse(),
            this.aimCnt--,
            Storage.setAimBoosterNum(this.aimCnt),
            this.updateBoosterLabel(),
            this.aimSelected = 1))
        }
        ,this);
        n.x = t.x,
        n.y = i.y + i.height / 2 + 30,
        n.setScale(.8),
        this.aimCntLabel = new cc.LabelTTF(this.aimCnt + "",getFont(res.lemonFont),30),
        this.aimCntLabel.anchorX = 0,
        this.aimCntLabel.x = n.x + 50,
        this.aimCntLabel.y = n.y,
        this.layer.addChild(this.aimCntLabel, 51, 51),
        t = new cc.Menu(t,i,e,n),
        t.x = t.y = 0,
        this.layer.addChild(t, 50, 50)
    },
    updateBoosterLabel: function() {
        this.eliminationCntLabel.setString(this.eliminationCnt),
        this.explosionCntLabel.setString(this.explosionCnt),
        this.redoCntLabel.setString(this.redoCnt),
        this.aimCntLabel.setString(this.aimCnt)
    },
    useRedoBooster: function() {
        this.rotateCount = 0,
        this.rotateB = 90,
        this.rotateCountMax = 1,
        this.rotateK = -1 * this.rotateB / this.rotateCountMax,
        this.rotateDirection = 1
    },
    useRedoBooster2: function() {
        var t = new cc.Sprite(res.booster_redo)
          , e = groupArray[this.centerX][this.centerY].y;
        t.x = groupArray[this.centerX][this.centerY].x,
        t.y = e,
        this.layer.addChild(t, 31, 31),
        t.setVisible(!1),
        t.setScale(8);
        var e = cc.show()
          , i = cc.rotateBy(1, 180)
          , n = cc.callFunc(function(t, e) {
            e.removeFromParent()
        }, this, t)
          , r = cc.callFunc(function() {
            for (var t = 0; t != groupArray.length; t++)
                for (var e = 0; e != groupArray[t].length; e++)
                    groupArray[t][e].type !== CENTERBALL_TYPE && groupArray[t][e].status === NOTBLANK && groupArray[t][e].changeType(this.getRightColorType(9))
        }, this)
          , e = cc.sequence(e, i, n, r);
        t.runAction(e)
    },
    calFourBouncePoint: function() {
        var t = groupArray[this.centerX][this.centerY].x
          , e = groupArray[this.centerX][this.centerY].y
          , i = this.BALLHEIGHT / 2 + 10;
        this.leftWall,
        this.rightWall,
        this.rightWallBouncePoint = cc.p(this.rightWall - this.BALLHEIGHT / 2, (e - i) / 2),
        this.leftWallBouncePoint = cc.p(this.leftWall + this.BALLHEIGHT / 2, (e - i) / 2),
        this.topRightBouncePoint = cc.p(t + (this.rightWall - t) / 2, this.topHeight - this.BALLHEIGHT / 2),
        this.topLeftBouncePoint = cc.p(this.leftWall + (t - this.leftWall) / 2, this.topHeight - this.BALLHEIGHT / 2)
    },
    initCurColorList: function() {
        for (var t = 0; t != LEVEL[this.level].colorRange.length; t++)
            this.curColTypes[LEVEL[this.level].colorRange[t] + ""] = !0
    },
    drawBg: function() {
        var t = new cc.Sprite(getBg(this.level));
        t.x = cc.winSize.width / 2,
        t.y = cc.winSize.height / 2,
        this.layer.addChild(t, 1, 1)
    },
    drawBorder: function() {
        if (!(cc.winSize.width <= this.gameWindowWidth)) {
            var t = new cc.Sprite(res.border);
            t.x = this.leftWall - 5,
            t.y = this.centery,
            this.layer.addChild(t, 1, 1),
            t = new cc.Sprite(res.border),
            t.x = this.rightWall + 5,
            t.y = this.centery,
            this.layer.addChild(t, 1, 1)
        }
    },
    configIdleBallPara: function() {
        this.idleBulletStartPosArray = [cc.p(-this.BALLWIDTH / 2, this.topHeight), cc.p(this.centerx + this.gameWindowWidth / 2 + this.BALLWIDTH / 2, this.topHeight), cc.p(-this.BALLWIDTH / 2, cc.winSize.height / 2 - 100), cc.p(this.centerx + this.gameWindowWidth / 2 + this.BALLWIDTH / 2, cc.winSize.height / 2 - 100)],
        this.maxIdleBulletCnt = LEVEL[this.level].projectIdleBullet[1],
        this.everyIdleBulletTime = LEVEL[this.level].projectIdleBullet[0],
        this.hasUpdateBulletProjectCnt = 0
    },
    drawTopTools: function() {
        var t = new cc.Sprite(res.coin_png);
        t.x = this.leftWall + 50,
        t.x += 20,
        t.y = cc.winSize.height - 50,
        t.y -= 70,
        this.layer.addChild(t, 1, 1),
        t.setScale(.6);
        var e = new cc.Sprite(res.lives_png);
        e.x = t.x,
        e.y = t.y - t.height / 2 - 30,
        e.setScale(.6);
        var i = new cc.LabelTTF("" + Storage.getCoin(),getFont(res.lemonFont),36);
        i.anchorX = 0,
        i.x = t.x + 40,
        i.y = t.y,
        this.layer.addChild(i, 1, 1),
        t = new cc.LabelTTF(Storage.getLives(),getFont(res.lemonFont),36),
        t.anchorX = 0,
        t.x = e.x + 40,
        t.y = e.y
    },
    drawCenterWall: function() {
        var t = groupArray[this.centerX][this.centerY].x
          , e = groupArray[this.centerX][this.centerY].y
          , i = new cc.Sprite(res.centerWall_png);
        this.centerWall = i,
        i.x = t,
        i.y = e,
        this.layer.addChild(i, 11, 11);
        var n = new cc.Sprite(res.star_png);
        n.x = i.x,
        n.y = i.y,
        this.layer.addChild(n, 11, 11),
        n.setScale(.5),
        n.setName("centerStar"),
        t = cc.callFunc(function(t, e) {
            var i = 360 * cc.random0To1()
              , r = .5 > cc.random0To1() ? -1 : 1
              , i = cc.rotateBy(3, i * r).easing(cc.easeInOut(2))
              , r = cc.delayTime(3);
            n.runAction(cc.sequence(i, r).repeatForever())
        }, this, n),
        ISDEBUG || n.runAction(t),
        t = new cc.LabelTTF("1",getFont(res.lemonFont),36),
        t.x = n.x,
        t.y = n.y,
        this.layer.addChild(t, 12, 12),
        this.starCntLabel = t,
        t.setName("centerStarCnt")
    },
    getRandomAngle: function() {
        var t = 360 * cc.random0To1()
          , e = .5 > cc.random0To1() ? -1 : 1;
        return t * e
    },
    getDangerBall: function() {
        for (var t = 0; t != groupArray.length; t++)
            for (var e = 0; e != groupArray[t].length; e++)
                if (cc.pDistance(cc.p(groupArray[this.centerX][this.centerY].x, groupArray[this.centerX][this.centerY].y), cc.p(groupArray[t][e].x, groupArray[t][e].y)) + this.BALLWIDTH / 2 > this.gameWindowWidth / 2) {
                    var i = new BubbleSprite(2);
                    i.x = groupArray[t][e].x,
                    i.y = groupArray[t][e].y,
                    this.layer.addChild(i, 9, 9),
                    this.dangerList.push(i),
                    i.px = groupArray[t][e].px,
                    i.py = groupArray[t][e].py,
                    groupArray[t][e].status === NOTBLANK ? i.setVisible(!0) : i.setVisible(!1);
                    var n = cc.spriteFrameCache.getSpriteFrame("glow0007.png");
                    i.setSpriteFrame(n);
                    var n = cc.scaleBy(1, 1.5)
                      , r = cc.fadeOut(1)
                      , c = cc.fadeIn(1);
                    cc.callFunc(function(t, e) {
                        e.setScale(2),
                        e.setOpacity(255)
                    }, this, i),
                    n = cc.sequence(cc.spawn(n, c), cc.spawn(r, cc.scaleBy(1, 10 / 15))).repeatForever(),
                    i.runAction(n),
                    groupArray[t][e].isDangerBall = !0
                }
        cc.log("danger list:", this.dangerList)
    },
    drawNewBulletProject: function() {
        this.bulletNum = LEVEL[this.level].bulletNum;
        for (var t = 0, e = 0; e != this.bulletNum; e++) {
            Math.random();
            var i = new BubbleSprite(this.getRightColorType(9))
              , n = 1
              , n = 0 === e ? 1 : 8 >= e ? 1 - .1 * e : .1;
            i.setScale(n),
            i.x = 0 === e ? this.centerx : t - 7 - i.scale * this.BALLHEIGHT / 2,
            i.y = this.BALLHEIGHT / 2 + 10 - (1 - i.scale) * this.BALLHEIGHT / 2;
            var t = i.x - i.scale * this.BALLHEIGHT / 2
              , n = i.x
              , r = i.y;
            i.y = -this.BALLHEIGHT / 2,
            n = cc.moveTo(.3 + .1 * e, n, r).easing(cc.easeBackInOut()),
            r = cc.callFunc(function(t) {
                this.bulletProjectIsUpdating = !1
            }, this),
            n = cc.sequence(n, r),
            i.runAction(n),
            this.layer.addChild(i, 20, 20),
            this.bulletProject.push(i)
        }
    },
    updateBulletProjectPos: function(t) {
        t || (t = 0);
        var e = this.bulletProject.length;
        if (0 === e)
            this.scheduleOnce(this.drawNewBulletProject, .5);
        else
            for (e -= 1; -1 != e; e--) {
                var i = 0
                  , n = 0;
                0 !== e ? (i = this.bulletProject[e - 1].x,
                n = this.bulletProject[e - 1].y) : (i = cc.winSize.width / 2,
                n = this.BALLHEIGHT / 2 + 10);
                var r = cc.delayTime(t)
                  , i = cc.moveTo(.3, i, n)
                  , n = cc.scaleTo(.1, this.bulletProject[e].scale + .1)
                  , i = cc.spawn(n, i)
                  , n = cc.callFunc(function(t, e) {
                    this.bulletProjectIsUpdating = !1
                }, this)
                  , r = cc.sequence(r, i, n);
                this.bulletProject[e].runAction(r)
            }
    },
    removeNoColorBullet: function() {
        var t = this.bulletProject.length;
        if (0 == t)
            return 0;
        var e = [];
        Math.floor(this.bulletProject[0].x) !== Math.floor(this.centerx) && e.push(cc.p(this.centerx, this.BALLHEIGHT / 2 + 10));
        for (var i = 0; i != t; i++)
            e.push(cc.p(this.bulletProject[i].x, this.bulletProject[i].y));
        var n, t = [];
        for (n in this.curColTypes)
            if (n != CENTERBALL_TYPE && !1 === this.curColTypes[n])
                for (i = 0; i != this.bulletProject.length; i++)
                    parseInt(n) === this.bulletProject[i].type && (t.push(this.bulletProject[i]),
                    this.bulletProject.splice(i, 1),
                    i--);
        for (n = 0,
        cc.log("remove bullet project list:", t),
        i = 0; i != t.length; i++)
            n = cc.moveTo(.3 + .1 * i, t[i].x, -this.BALLHEIGHT / 2).easing(cc.easeBackInOut()),
            t[i].runAction(n),
            n = .3 + .1 * i;
        for (t = n,
        i = 0; i != this.bulletProject.length; i++) {
            n = cc.scaleTo(.3, 1 - .1 * i);
            var r = cc.moveTo(.3, e[i]).easing(cc.easeIn(2));
            n = cc.spawn(n, r),
            n = cc.sequence(cc.delayTime(t), n),
            this.bulletProject[i].runAction(n)
        }
        return 0 == this.bulletProject.length ? t : .3 + t
    },
    addANewBullet: function(t) {
        var e = this.bulletProject.length
          , i = new BubbleSprite(this.getRightColorType(9));
        this.bulletProject.push(i),
        this.layer.addChild(i, 20, 20);
        var n = 0;
        if (0 === e)
            n = cc.winSize.width / 2;
        else
            for (var r = 0, c = 0; c != e; c++)
                r = 0 == c ? cc.winSize.width / 2 : n - 7 - (1 - .1 * c) * this.BALLHEIGHT / 2,
                n = r - (1 - .1 * c) * this.BALLHEIGHT / 2;
        return .1 > 1 - .1 * (e + 1) ? i.setScale(.1) : i.setScale(1 - .1 * e),
        i.x = 0 == e ? this.centerx : n - 7 - i.scale * this.BALLHEIGHT / 2,
        e = i.height / 2 + 10 - (1 - i.scale) * i.height / 2,
        i.y = -i.height / 2,
        e = cc.moveBy(.5, 0, e - i.y).easing(cc.easeBackInOut()),
        t = cc.delayTime(t),
        t = cc.sequence(t, e),
        i.runAction(t),
        .5
    },
    fireBullet: function(t, e) {
        if (cc.log("fire bullet func start"),
        cc.log(this.bulletProject),
        !this.currentBullet)
            if (this.bulletProject[0]) {
                this.currentBullet = this.bulletProject[0];
                var i = Math.atan2(e - this.currentBullet.y, t - this.currentBullet.x);
                this.projectAngle = i,
                cc.log("angle:" + this.projectAngle / Math.PI * 180),
                this.rotateDirection = this.projectAngle < Math.PI / 2 ? LEFT : RIGHT,
                this.vy = Math.sin(i) * this.speed,
                this.vx = Math.cos(i) * this.speed,
                this.bulletProject.splice(0, 1)
            } else
                cc.warn("no bullet now!")
    },
    onEnter: function() {
        this._super(),
        cc.eventManager.addCustomListener("configUIClose", this.configUIClose.bind(this)),
        cc.eventManager.addListener({
            event: cc.EventListener.TOUCH_ONE_BY_ONE,
            onTouchBegan: this.onTouchBegan,
            onTouchMoved: this.onTouchMoved,
            onTouchEnded: this.onTouchEnded
        }, this)
    },
    onExit: function() {
        this._super(),
        cc.eventManager.removeCustomListeners("configUIClose"),
        this.unscheduleUpdate(),
        cc.pool.drainAllPools()
    },
    drawNormalHelpDot: function(t) {
        t.x < this.leftWall && (t.x = this.leftWall),
        t.x > this.rightWall && (t.x = this.rightWall);
        var e = cc.p(this.centerx, this.BALLHEIGHT / 2 + 10);
        this.currentBullet && (e = cc.p(this.currentBullet.x, this.currentBullet.y)),
        this.radarPaint.drawSegment(e, t, 3, cc.color(232, 232, 232))
    },
    clearNormalHelpDot: function(t) {
        this.radarPaint.clear()
    },
    drawTrajectory: function(t) {
        var e = cc.p(this.centerx, this.BALLHEIGHT / 2 + 10);
        this.currentBullet && (e = cc.p(this.currentBullet.x, this.currentBullet.y));
        var i = e.x
          , n = e.y
          , r = Math.atan2(t.y - n, t.x - i);
        t = Math.sin(r) * this.speed;
        for (var r = Math.cos(r) * this.speed, e = [e], c = 0, s = !1; 3 > c && 0 == s; )
            i += r,
            n += t,
            this.collisionCheckPoint(cc.p(i, n)) ? (s = !0,
            e.push(cc.p(i + r, n + t))) : (n > this.topHeight - this.BALLHEIGHT / 2 && (n = this.topHeight - this.BALLHEIGHT / 2,
            t *= -1,
            c++,
            e.push(cc.p(i, n))),
            n < this.BALLHEIGHT / 2 && (n = this.BALLHEIGHT / 2,
            t *= -1,
            c++,
            e.push(cc.p(i, n))),
            i > this.rightWall - this.BALLHEIGHT / 2 && (i = this.rightWall - this.BALLHEIGHT / 2,
            r *= -1,
            c++,
            e.push(cc.p(i, n))),
            i < this.leftWall + this.BALLHEIGHT / 2 && (i = this.leftWall + this.BALLHEIGHT / 2,
            r *= -1,
            c++,
            e.push(cc.p(i, n))));
        for (i = 1; i != e.length; i++)
            this.radarPaint.drawSegment(e[i - 1], e[i], 3, cc.color(21, 202, 128))
    },
    clearTrajectory: function() {
        this.radarPaint.clear()
    },
    tutorialCartoon: function() {
        window.famobi_analytics.trackScreen("SCREEN_TUTORIAL", "tut1");
        var t = new cc.LabelTTF(Texts[lang][23],getFont(res.lemonFont),45);
        this.layer.addChild(t, 510, 510),
        t.setName("tutorialLabel"),
        t.x = cc.winSize.width / 2,
        t.y = groupArray[this.centerX][this.centerY].y + 140,
        t.setOpacity(0),
        t.runAction(cc.fadeIn(1)),
        t = new cc.Sprite(res.tutorial_hand_png),
        t.x = groupArray[this.centerX][this.centerY].x + 120,
        t.y = groupArray[this.centerX][this.centerY].y - 140,
        this.layer.addChild(t, 96, 96);
        var e = cc.scaleBy(1, 1.2)
          , i = e.clone().reverse()
          , e = cc.sequence(e, i)
          , e = cc.repeatForever(e);
        t.runAction(e),
        t.setName("finger")
    },
    stopTutorialCartoon: function() {
        var t = this.layer.getChildByName("finger")
          , e = this.layer.getChildByName("tutorialLabel");
        t && (e.removeFromParent(),
        t.removeFromParent())
    },
    secondTutorialCartoon: function() {
        window.famobi_analytics.trackScreen("SCREEN_TUTORIAL", "tut2");
        var t = this.layer.getChildByName("finger");
        this.layer.getChildByName("tutorialLabel");
        var e = cc.moveTo(1, groupArray[this.centerX][this.centerY].x + 60, groupArray[this.centerX][this.centerY].y - t.height / 2);
        t.runAction(e)
    },
    onTouchBegan: function(t, e) {
        var i = e.getCurrentTarget();
        return !(i.isCheckingOrPlaying || i.bulletProjectIsUpdating || i.hasConfigUI || i.isGameOver || i.hasWin) && (i.isCheckingOrPlaying = !0,
        i.bulletProjectIsUpdating = !0,
        cc.log("ontouch"),
        this.dragOffsetStartX = t.getLocationX(),
        this.dragOffsetStartY = t.getLocationY(),
        i.aimSelected ? i.drawTrajectory(cc.p(this.dragOffsetStartX, this.dragOffsetStartY)) : i.drawNormalHelpDot(cc.p(this.dragOffsetStartX, this.dragOffsetStartY)),
        !0)
    },
    onTouchMoved: function(t, e) {
        var i = e.getCurrentTarget();
        return this.dragOffsetEndX = t.getLocationX(),
        this.dragOffsetEndY = t.getLocationY(),
        cc.log("on moved"),
        i.aimSelected ? (i.clearTrajectory(),
        i.drawTrajectory(cc.p(this.dragOffsetEndX, this.dragOffsetEndY))) : (i.clearNormalHelpDot(),
        i.drawNormalHelpDot(cc.p(this.dragOffsetEndX, this.dragOffsetEndY))),
        !0
    },
    onTouchEnded: function(t, e) {
        var i = e.getCurrentTarget();
        this.endX = t.getLocationX(),
        this.endY = t.getLocationY(),
        i.aimSelected ? i.clearTrajectory() : i.clearNormalHelpDot(),
        cc.log("on touch end"),
        i.fireBullet(this.endX, this.endY)
    },
    getRightColorType: function(t) {
        var e = -1;
        if (0 === t)
            e = 0;
        else if (9 === t) {
            var i, e = [];
            for (i in this.curColTypes)
                i != CENTERBALL_TYPE + "" && this.curColTypes[i] && e.push(parseInt(i));
            i = e.length,
            t = Math.floor(Math.random() * i),
            e = e[t],
            0 === i && (e = 5)
        } else
            e = t;
        return e
    },
    initBall: function() {
        this.ballCount = 0;
        for (var t = LEVEL[this.level].maps, e = 0; e != this.rowMax; e++) {
            var i = []
              , n = t[e];
            if (0 === e % 2) {
                if (1 === n.length && 0 === n[0])
                    for (var r = 0; r != this.colMax; r++)
                        n[r] = 0;
                for (r = 0; r != this.colMax; r++) {
                    var c = this.getRightColorType(n[r]);
                    i[r] = new BubbleSprite(c),
                    i[r].x = this.STARTX + r * this.BALLWIDTH,
                    i[r].y = this.STARTY - this.BALLHEIGHT * e,
                    i[r].px = e,
                    i[r].py = r,
                    this.layer.addChild(i[r], 10, 10),
                    c && this.ballCount++
                }
            } else {
                if (1 === n.length && 0 === n[0])
                    for (r = 0; r != this.colMax - 1; r++)
                        n[r] = 0;
                for (r = 0; r != this.colMax - 1; r++) {
                    var c = this.getRightColorType(n[r])
                      , s = new BubbleSprite(c);
                    s.x = this.STARTX + this.BALLWIDTH / 2 + r * this.BALLWIDTH,
                    s.y = this.STARTY - this.BALLHEIGHT * e,
                    this.layer.addChild(s, 10, 10),
                    i[r] = s,
                    i[r].px = e,
                    i[r].py = r,
                    c && this.ballCount++
                }
            }
            groupArray[e] = i
        }
        for (cc.log("groupArray[2][7]", groupArray[2][7].y),
        cc.log("groupArray[2][8]", groupArray[2][8].y),
        cc.log("groupArray[2][9]", groupArray[2][9].y),
        groupArray[this.centerX][this.centerY].status = CENTERBALL_TYPE,
        groupArray[this.centerX][this.centerY].setVisible(!1),
        t = this.getSurroundBall(groupArray[this.centerX][this.centerY]),
        e = 0; e != t.length; e++)
            t[e].type = CENTERBALL_TYPE,
            t[e].setVisible(!1)
    },
    getSurroundBall2: function(t) {
        var e = []
          , i = t.px
          , n = t.py;
        return 0 === t.px % 2 ? (0 <= n - 1 && i + 1 <= this.rowMax - 1 && e.push(groupArray[i + 1][n - 1]),
        n <= this.colMax - 2 && i + 1 <= this.rowMax - 1 && e.push(groupArray[i + 1][n]),
        0 <= n - 1 && e.push(groupArray[i][n - 1]),
        n + 1 <= this.colMax - 1 && e.push(groupArray[i][n + 1]),
        0 <= i - 1 && 0 <= n - 1 && e.push(groupArray[i - 1][n - 1]),
        0 <= i - 1 && n <= this.colMax - 2 && e.push(groupArray[i - 1][n])) : (i + 1 <= this.rowMax - 1 && e.push(groupArray[i + 1][n]),
        n + 1 <= this.colMax && i + 1 <= this.rowMax - 1 && e.push(groupArray[i + 1][n + 1]),
        0 <= n - 1 && e.push(groupArray[i][n - 1]),
        n != this.colMax - 2 && e.push(groupArray[i][n + 1]),
        0 <= i - 1 && e.push(groupArray[i - 1][n]),
        0 <= i - 1 && n + 1 <= this.colMax && e.push(groupArray[i - 1][n + 1])),
        e
    },
    getSurroundBlankBall: function(t) {
        t = this.getSurroundBall(t);
        var e = [];
        if (!t)
            return null;
        for (var i = 0; i != t.length; i++)
            t[i].isFake && e.push(t[i]);
        return e
    },
    getSurround_N_B_R_Ball: function(t) {
        t = this.getSurroundBall(t);
        var e = [];
        if (!t)
            return null;
        for (var i = 0; i != t.length; i++)
            t[i].isNotFake() && t[i].status !== REMOVABLE && t[i].status !== CENTERBALL_TYPE && e.push(t[i]);
        return e
    },
    getSurroundSameType: function(t) {
        var e = this.getSurroundBall(t)
          , i = [];
        if (!e)
            return null;
        for (var n = 0; n != e.length; n++)
            e[n].type === t.type && e[n].status !== CENTERBALL_TYPE && i.push(e[n]);
        return i
    },
    getSurroundBall: function(t) {
        if (!t.isFake) {
            var e = []
              , i = t.px
              , n = t.py;
            return 0 === t.px % 2 ? (groupArray[i + 1] && groupArray[i + 1][n - 1] && e.push(groupArray[i + 1][n - 1]),
            groupArray[i + 1] && groupArray[i + 1][n] && e.push(groupArray[i + 1][n]),
            groupArray[i] && groupArray[i][n - 1] && e.push(groupArray[i][n - 1]),
            groupArray[i] && groupArray[i][n + 1] && e.push(groupArray[i][n + 1]),
            groupArray[i - 1] && groupArray[i - 1][n - 1] && e.push(groupArray[i - 1][n - 1]),
            groupArray[i - 1] && groupArray[i - 1][n] && e.push(groupArray[i - 1][n])) : (i + 1 <= this.rowMax - 1 && e.push(groupArray[i + 1][n]),
            n + 1 <= this.colMax && i + 1 <= this.rowMax - 1 && e.push(groupArray[i + 1][n + 1]),
            0 <= n - 1 && e.push(groupArray[i][n - 1]),
            n != this.colMax - 2 && e.push(groupArray[i][n + 1]),
            0 <= i - 1 && e.push(groupArray[i - 1][n]),
            0 <= i - 1 && n + 1 <= this.colMax && e.push(groupArray[i - 1][n + 1])),
            e
        }
    },
    drawPos: function() {
        for (var t = groupArray.length, e = 0; e != t; e++)
            for (var i = groupArray[e].length, n = 0; n != i; n++) {
                var r = new cc.LabelTTF(e + "," + n);
                groupArray[e][n].addChild(r, 1, 1),
                r.anchorX = r.anchorY = 0,
                r.fillStyle = cc.color(0, 0, 0)
            }
    },
    resetBulletParameter: function() {
        this.hitWallCount = 0,
        this.bulletPlaying = !1,
        this.currentBullet = null
    },
    adjustPos: function(t, e) {
        var i = this.getSurroundBlankBall(t)
          , n = this.getFittest(i, this.currentBullet);
        -1 !== n ? (this.currentBullet.x = i[n].x,
        this.currentBullet.y = i[n].y,
        this.currentBullet.px = i[n].px,
        this.currentBullet.py = i[n].py,
        groupArray[i[n].px][i[n].py] = this.currentBullet,
        i[n].removeFromParent()) : (this.resetBulletParameter(),
        this.isGameOver = !0)
    },
    getFittest: function(t, e) {
        if (!t || 0 == t.length)
            return -1;
        for (var i = 9999, n = -1, r = 0; r != t.length; r++) {
            var c = cc.pDistance(cc.p(t[r].x, t[r].y), cc.p(e.x, e.y));
            c < i && c < 1.414 * this.BALLHEIGHT && (i = c,
            n = r)
        }
        return n
    },
    collisionCheckPoint: function(t) {
        for (var e = 0; e != groupArray.length; e++)
            for (var i = 0; i != groupArray[e].length; i++)
                if (groupArray[e][i] && groupArray[e][i].isNotFake() && cc.pDistance(t, cc.p(groupArray[e][i].x, groupArray[e][i].y)) < 2 * this.BALLWIDTH) {
                    var n = cc.p(t.x + 1 * this.vx, t.y + 1 * this.vy);
                    if (cc.pDistance(n, cc.p(groupArray[e][i].x, groupArray[e][i].y)) < .8 * this.BALLWIDTH)
                        return this.checkPoint = groupArray[e][i],
                        !0
                }
        return !1
    },
    collisionCheck: function() {
        if (this.currentBullet) {
            for (var t = 0; t != groupArray.length; t++)
                for (var e = 0; e != groupArray[t].length; e++)
                    if (groupArray[t][e] && groupArray[t][e].isNotFake() && cc.pDistance(cc.p(this.currentBullet.x, this.currentBullet.y), cc.p(groupArray[t][e].x, groupArray[t][e].y)) < 2 * this.currentBullet.width) {
                        var i = cc.p(this.currentBullet.x + 1 * this.vx, this.currentBullet.y + 1 * this.vy);
                        if (cc.pDistance(i, cc.p(groupArray[t][e].x, groupArray[t][e].y)) < .8 * this.currentBullet.width)
                            return this.adjustPoint = groupArray[t][e],
                            t = cc.pDistance(cc.p(this.currentBullet.x, this.currentBullet.y), cc.p(groupArray[this.centerX][this.centerY].x, groupArray[this.centerX][this.centerY].y)),
                            t < 2 * this.BALLWIDTH + 10 ? this.hasWin = !0 : cc.log("win distance:", t, "delta:", 2 * this.BALLWIDTH + 3 - t),
                            !0
                    }
            return !1
        }
        cc.log("current bullet is null")
    },
    removeAllLeftBalls: function() {
        if (!this.bulletPlaying) {
            this.bulletPlaying = !0;
            for (var t = 0; t != groupArray.length; t++)
                for (var e = 0; e != groupArray[t].length; e++)
                    groupArray[t][e].status === NOTBLANK && groupArray[t][e].type !== CENTERBALL_TYPE && (groupArray[t][e].status = DROPABLE);
            this.resetBulletParameter(),
            this.playRemoveEffect(),
            this.playGoodLabelCartoon()
        }
    },
    useEliminationBooster: function() {
        if (!this.bulletPlaying) {
            this.bulletPlaying = !0;
            for (var t = this.getRightColorType(9), e = [], i = 0; i != groupArray.length; i++)
                for (var n = 0; n != groupArray[i].length; n++)
                    groupArray[i][n] && groupArray[i][n].isNotFake() && groupArray[i][n].type == t && (e.push(groupArray[i][n]),
                    groupArray[i][n].status = REMOVABLE);
            for (this.checkDropBall(),
            this.resetBulletParameter(),
            this.playRemoveEffect(),
            this.playGoodLabelCartoon(),
            i = this.removeNoColorBullet(),
            n = this.addANewBullet(i - .1),
            this.scheduleOnce(function() {
                this.bulletProjectIsUpdating = !1
            }
            .bind(this), i + n),
            i = t = 0; i != groupArray.length; i++)
                for (n = 0; n != groupArray[i].length; n++)
                    groupArray[i][n].status !== NOTBLANK && groupArray[i][n].status != CENTERBALL_TYPE || t++;
            this.ballCount = t
        }
    },
    useExplosionBooster: function(t) {
        var e = [t];
        t = this.getSurround_N_B_R_Ball(t);
        for (var i = 0; i != t.length; i++)
            e.push(t[i]);
        for (i = 0; i != e.length; i++)
            e[i].status = REMOVABLE;
        this.continueClearCnt++,
        this.checkDropBall()
    },
    checkRemovable: function(t) {
        for (var e = [t], i = 0; i < e.length; ) {
            var n = this.getSurroundSameType(e[i]);
            if (n && 0 != n.length) {
                for (var r = e.length, c = 0; c != n.length; c++)
                    if (n[c].type === t.type) {
                        for (var s = !1, o = 0; o != r; o++)
                            if (e[o] === n[c]) {
                                s = !0;
                                break
                            }
                        !1 === s && e.push(n[c])
                    }
            } else
                cc.log("checkRemovable function: cannot find same type array");
            i++
        }
        if (cc.log("surround same colors:"),
        cc.log(e),
        3 > e.length)
            this.clearBallCnt = this.continueClearCnt = 0;
        else {
            for (this.continueClearCnt++,
            c = 0; c != e.length; c++)
                e[c].status = REMOVABLE;
            this.checkDropBall()
        }
    },
    checkDropBall: function() {
        for (var t = 0, e = [groupArray[this.centerX][this.centerY]]; t < e.length; ) {
            var i = this.getSurround_N_B_R_Ball(e[t]);
            if (i && 0 != i.length)
                for (var n = e.length, r = 0; r != i.length; r++) {
                    for (var c = !1, s = 0; s != n; s++)
                        if (e[s] === i[r]) {
                            c = !0;
                            break
                        }
                    !1 === c && (e.push(i[r]),
                    i[r].isLinkedCenter = !0)
                }
            else
                cc.error("checkDropBall function: same type array is null,it should not happen,check the startSprite");
            t++
        }
        for (e.splice(0, 1),
        cc.log(e),
        t = [],
        r = 0; r != groupArray.length; r++)
            for (s = 0; s != groupArray[r].length; s++)
                groupArray[r][s].status === BLANK || r === this.centerX && s === this.centerY || (groupArray[r][s].isLinkedCenter || groupArray[r][s].status == REMOVABLE ? groupArray[r][s].isLinkedCenter = !1 : (groupArray[r][s].status = DROPABLE,
                t.push(groupArray[r][s])));
        for (var o in this.curColTypes)
            this.curColTypes[o] = !1;
        for (r = 0; r != e.length; r++)
            for (o in e[r].isLinkedCenter = !1,
            s = e[r].type,
            this.curColTypes)
                this.curColTypes[s] = !0;
        if (cc.log("colors:", this.curColTypes),
        ISDEBUG)
            for (r = 0; r != t.length; r++)
                t[r].children[0] && t[r].children[0].setString("DDD")
    },
    getAccordingTypeBooble: function(t) {
        return BoobleMap[t]
    },
    playRemoveEffect: function() {
        for (var t = [], e = [], i = 0; i != groupArray.length; i++)
            for (var n = 0; n != groupArray[i].length; n++)
                groupArray[i][n].status === REMOVABLE && t.push(groupArray[i][n]),
                groupArray[i][n].status === DROPABLE && e.push(groupArray[i][n]);
        if (this.clearBallCnt = t.length + e.length,
        0 == t.length && !1 === this.hasWin)
            this.hasClearBall = this.isCheckingOrPlaying = !1;
        else {
            for (this.hasClearBall = !0,
            n = [],
            i = 0; i != t.length; i++) {
                var r = t[i].type
                  , c = cc.spriteFrameCache.getSpriteFrame(res.ball0.replace("#", ""));
                t[i].setSpriteFrame(c),
                t[i].initPara(BLANK),
                r = this.getOneBubbleSprite(r),
                r.x = t[i].x,
                r.y = t[i].y,
                n.push(r),
                r.needRoated = !0,
                this.needRotateArray.push(r)
            }
            for (t = n.length,
            n.reverse(),
            i = 0; i != t; i++) {
                var s = 0
                  , s = 6 > i ? .02 * i : .02 * i + .01 * (i - 6)
                  , o = cc.callFunc(function(t, e) {
                    e.needRoated = !1
                }, this, n[i])
                  , r = cc.callFunc(function(t, e) {
                    var i = cc.spriteFrameCache.getSpriteFrame("booble_" + e.type + ".png");
                    e.setSpriteFrame(i)
                }, this, n[i])
                  , a = cc.scaleBy(.3, 1.5, 1.5)
                  , h = cc.fadeOut(1)
                  , c = cc.random0To1() * cc.winSize.width;
                cc.random0To1(),
                c = cc.jumpTo(1, cc.p(c, -cc.winSize.height), 700, 1),
                c = cc.spawn(a, c, h),
                r = cc.sequence(cc.delayTime(s), o, r, c),
                c = cc.callFunc(function(t, e) {
                    6 > e && Sound.playClearEffect1()
                }, this, i),
                c = cc.sequence(cc.delayTime(.08 * i), c),
                cc.callFunc(function(t, e) {
                    cc.pool.putInPool(e)
                }, this, n[i]),
                s = cc.callFunc(function() {
                    this.isCheckingOrPlaying = !1
                }, this),
                s = cc.spawn(c, r),
                i === t - 1 && 0 === e.length ? (s = cc.callFunc(function() {
                    this.isCheckingOrPlaying = !1
                }, this),
                r = cc.spawn(s, c, r),
                n[i].runAction(r)) : n[i].runAction(s)
            }
            if (t = e.length,
            0 !== t) {
                for (n = [],
                i = 0; i != t; i++)
                    r = e[i].type,
                    c = cc.spriteFrameCache.getSpriteFrame(res.ball0.replace("#", "")),
                    e[i].setSpriteFrame(c),
                    e[i].initPara(BLANK),
                    r = this.getOneBubbleSprite(r),
                    r.x = e[i].x,
                    r.y = e[i].y,
                    n.push(r),
                    r.needRoated = !0,
                    this.needRotateArray.push(r);
                for (i = 0; i != n.length; i++)
                    h = cc.fadeOut(1),
                    r = cc.callFunc(function(t, e) {
                        var i = cc.spriteFrameCache.getSpriteFrame(res.pop_circle_png.replace("#", ""));
                        e.setSpriteFrame(i)
                    }, this, n[i]),
                    c = cc.random0To1() * cc.winSize.width,
                    c = cc.jumpTo(1, cc.p(c, -cc.winSize.height), 500, 1),
                    a = cc.scaleBy(.5, 1.5, 1.5),
                    e = cc.spawn(h, a),
                    e = cc.spawn(cc.sequence(cc.delayTime(.5), e)),
                    t = cc.spawn(c, e),
                    e = cc.callFunc(function(t, e) {
                        cc.pool.putInPool(e),
                        this.isCheckingOrPlaying = !1
                    }, this, n[i]),
                    t = cc.sequence(cc.delayTime(.1), t),
                    e = cc.sequence(t, e),
                    n[i].runAction(e)
            }
        }
    },
    setGameisCheckingOrPlaying: function() {
        this.isCheckingOrPlaying = !1
    },
    playGoodLabelCartoon: function(t) {
        if (3 <= this.continueClearCnt && 10 < this.clearBallCnt)
            t = Texts[lang][0];
        else if (3 <= this.continueClearCnt)
            t = Texts[lang][1];
        else if (1 <= this.continueClearCnt && 15 < this.clearBallCnt)
            t = Texts[lang][2];
        else if (1 <= this.continueClearCnt && 10 < this.clearBallCnt)
            t = Texts[lang][3];
        else {
            if (!(1 <= this.continueClearCnt && 5 < this.clearBallCnt))
                return;
            t = Texts[lang][4]
        }
        this.goodLabel.setString(t),
        this.goodLabel.setOpacity(255),
        this.goodLabel.x = this.centerx,
        this.goodLabel.y = cc.winSize.height / 2,
        t = cc.moveBy(1, 0, this.topHeight - this.goodLabel.y);
        var e = cc.fadeOut(1);
        t = cc.spawn(t, e),
        this.goodLabel.runAction(t)
    },
    getOneBubbleSprite: function(t) {
        return cc.pool.hasObject(BubbleSprite) ? (cc.log("get reuse one"),
        cc.pool.getFromPool(BubbleSprite, t)) : (cc.log("create new one"),
        t = new BubbleSprite(t),
        this.layer.addChild(t, 11, 11),
        t)
    },
    projectIdleBullet: function(t, e) {
        var i, n = 0;
        i = Math.atan2(groupArray[this.centerX][this.centerY].y - t.y, groupArray[this.centerX][this.centerY].x - t.x),
        n = 20 * Math.sin(i),
        i = 20 * Math.cos(i);
        for (var r = !1, c = t.x + i, s = t.y + n; 0 == r; )
            this.collisionCheckPoint(cc.p(c, s)) ? r = !0 : (c += i,
            s += n);
        i = this.getSurroundBlankBall(this.checkPoint),
        0 === i.length ? this.isProjectIdleBulleting = !1 : (n = this.getOneBubbleSprite(this.getRightColorType(9)),
        n.needRoated = !1,
        n.x = i[0].x,
        n.y = i[0].y,
        r = i[0].x,
        c = i[0].y,
        n.px = i[0].px,
        n.py = i[0].py,
        groupArray[i[0].px][i[0].py] = n,
        i[0].removeFromParent(),
        cc.moveTo(.8, r, c).easing(cc.easeBackIn()),
        n.setScale(.3),
        i = cc.scaleTo(.8, 1),
        r = cc.callFunc(function(t, e) {
            e && (this.isProjectIdleBulleting = !1)
        }, this, e),
        i = cc.sequence(i, r),
        n.runAction(i))
    },
    updateBullet: function() {
        if (!this.bulletPlaying)
            if (3 <= this.hitWallCount) {
                this.bulletPlaying = !0;
                var t = cc.moveTo(1, cc.p(this.currentBullet.x, -100))
                  , e = cc.callFunc(this.resetBulletParameter, this)
                  , i = cc.callFunc(function() {
                    this.isCheckingOrPlaying = !1
                }, this)
                  , t = cc.sequence(t, e, i);
                this.currentBullet.runAction(t),
                t = this.removeNoColorBullet(),
                e = this.addANewBullet(t),
                this.scheduleOnce(function() {
                    this.bulletProjectIsUpdating = !1
                }
                .bind(this), t + e)
            } else if (!0 === this.collisionCheck())
                if (1 === this.level && this.secondTutorialCartoon(),
                Sound.playHit(),
                cc.log("collision check over"),
                this.adjustPos(this.adjustPoint, this.currentBullet),
                cc.log("adjust position over"),
                this.hasWin)
                    this.isCheckingOrPlaying = !1,
                    Sound.playWin(),
                    this.playCenterWallCartoon(),
                    this.removeAllLeftBalls(),
                    e = new GameWinLayer(this.level,2 * this.starCnt,this.starCnt,this.starCnt,1.3),
                    Storage.addCoin(2 * this.starCnt),
                    this.layer.addChild(e, 190, 190),
                    APIStatistics.levelUp(this.level),
                    APIStatistics.submitHighScore(this.level, this.starCnt),
                    e.setScale(.2),
                    t = cc.scaleTo(1, 1).easing(cc.easeBackInOut()),
                    e.runAction(t),
                    Storage.getLevel() < this.level + 1 && Storage.setLevel(this.level + 1),
                    Storage.getLevelStarCnt(this.level) < this.starCnt && Storage.setLevelStarCnt(this.level, this.starCnt);
                else if (this.isGameOver)
                    this.isCheckingOrPlaying = !1,
                    Sound.playLose(),
                    e = new GameOverLayer(this.level,groupArray),
                    this.layer.addChild(e, 190, 190),
                    e.setScale(.2),
                    t = cc.scaleTo(1, 1).easing(cc.easeBackInOut()),
                    e.runAction(t),
                    APIStatistics.gameOver(this.level, 0);
                else {
                    if (this.calRotateThing(),
                    cc.log("calRotateThing over"),
                    this.explosionSelected ? (this.useExplosionBooster(this.currentBullet),
                    this.explosionSelected = 0) : this.checkRemovable(this.currentBullet),
                    cc.log("check removable over"),
                    this.resetBulletParameter(),
                    cc.log("resetBulletParameter over"),
                    this.playRemoveEffect(),
                    cc.log("play remove effect over"),
                    this.playGoodLabelCartoon(),
                    cc.log("play good label cartoon over"),
                    this.hasClearBall)
                        t = this.removeNoColorBullet(),
                        e = this.addANewBullet(t - .1),
                        this.scheduleOnce(function() {
                            this.bulletProjectIsUpdating = !1
                        }
                        .bind(this), t + e);
                    else if (0 === this.bulletProject.length && this.hasUpdateBulletProjectCnt++,
                    0 === this.bulletProject.length && 0 == this.hasUpdateBulletProjectCnt % this.everyIdleBulletTime) {
                        for (t = 0; t != this.maxIdleBulletCnt; t++)
                            t === this.maxIdleBulletCnt - 1 ? this.projectIdleBullet(this.idleBulletStartPosArray[t], !0) : this.projectIdleBullet(this.idleBulletStartPosArray[t]);
                        this.updateBulletProjectPos(1.3)
                    } else
                        this.updateBulletProjectPos(.5);
                    cc.log("bullet update over")
                }
            else
                this.currentBullet.x <= this.rightWall - this.currentBullet.width / 2 && this.currentBullet.x >= this.leftWall + this.currentBullet.width / 2 && this.currentBullet.y <= this.topHeight - this.currentBullet.height / 2 && this.currentBullet.y >= this.currentBullet.height / 2 ? (this.currentBullet.x += this.vx,
                this.currentBullet.y += this.vy) : (this.currentBullet.y > this.topHeight - this.currentBullet.height / 2 && (this.currentBullet.y = this.topHeight - this.currentBullet.height / 2,
                this.vy *= -1,
                this.hitWallCount++,
                this.currentBullet.x < this.topLeftBouncePoint.x && (this.rotateDirection *= -1),
                this.currentBullet.x > this.topRightBouncePoint.x && (this.rotateDirection *= -1)),
                this.currentBullet.y < this.currentBullet.height / 2 && (this.currentBullet.y = this.currentBullet.height / 2,
                this.vy *= -1,
                this.hitWallCount++),
                this.currentBullet.x > this.rightWall - this.currentBullet.width / 2 && (this.currentBullet.x = this.rightWall - this.currentBullet.width / 2,
                this.vx *= -1,
                this.hitWallCount++,
                this.currentBullet.y < this.rightWallBouncePoint.y && (this.rotateDirection *= -1)),
                this.currentBullet.x < this.leftWall + this.currentBullet.width / 2 && (this.currentBullet.x = this.leftWall + this.currentBullet.width / 2,
                this.vx *= -1,
                this.hitWallCount++,
                this.currentBullet.y < this.leftWallBouncePoint.y && (this.rotateDirection *= -1)))
    },
    getRotateB: function(t) {
        return 10 > t ? 4 : 20 > t ? 3 : 1 - t / (this.colMax * this.rowMax)
    },
    calRotateThing: function() {
        for (var t = 0, e = 0; e != groupArray.length; e++)
            for (var i = 0; i != groupArray[e].length; i++)
                groupArray[e][i].status !== REMOVABLE && groupArray[e][i].status !== DROPABLE || cc.error("Error it has removable or dropable ball "),
                groupArray[e][i].status !== BLANK && t++;
        e = Math.PI / 4,
        e = (360 - 360 / (this.colMax * this.rowMax) * t) * (1 - Math.sin(this.projectAngle < 2 * e && this.projectAngle > e ? this.projectAngle - Math.PI / 6 : this.projectAngle >= e && this.projectAngle < 3 * e ? this.projectAngle + Math.PI / 6 : this.projectAngle)),
        this.rotateB = this.getRotateB(t),
        this.rotateCountMax = Math.round(e),
        this.rotateK = -1 * this.rotateB / this.rotateCountMax,
        this.rotateCount = 0,
        this.rotateDirectionReal = this.rotateDirection
    },
    getRotateAngleSpeed: function(t) {
        return this.rotateK * t + this.rotateB
    },
    checkDangerBall: function() {
        if (!this.isCheckingOrPlaying)
            for (var t = this.dangerList.length, e = 0; e != t; e++)
                if (groupArray[this.dangerList[e].px][this.dangerList[e].py].status === NOTBLANK) {
                    var i = !1;
                    if (this.dangerList[e].y > this.topHeight - this.BALLWIDTH / 2 && (i = !0),
                    this.dangerList[e].y < this.bottomHeight + this.BALLHEIGHT / 2 + 1 && (i = !0),
                    this.dangerList[e].x > this.rightWall - this.BALLWIDTH / 2 && (i = !0),
                    this.dangerList[e].x < this.leftWall + this.BALLWIDTH / 2 && (i = !0),
                    !0 === i) {
                        cc.log("has hit wall!!game over"),
                        this.isGameOver = !0,
                        Sound.playLose(),
                        i = new GameOverLayer(this.level,groupArray),
                        this.layer.addChild(i, 190, 190),
                        i.setScale(.2);
                        var n = cc.scaleTo(1, 1).easing(cc.easeBackInOut());
                        i.runAction(n),
                        APIStatistics.gameOver(this.level, 0)
                    }
                }
    },
    syncDangerBall: function() {
        for (var t = this.dangerList.length, e = 0; e != t; e++) {
            var i = this.dangerList[e].px
              , n = this.dangerList[e].py;
            groupArray[i][n].status === NOTBLANK ? this.dangerList[e].setVisible(!0) : this.dangerList[e].setVisible(!1),
            this.dangerList[e].x = groupArray[i][n].x,
            this.dangerList[e].y = groupArray[i][n].y
        }
    },
    updateStarCntLabel: function() {
        this.starCnt = 0 >= this.ballCount - 7 ? 3 : 40 >= this.ballCount - 7 ? 2 : 1,
        this.starCntLabel.setString("" + this.starCnt)
    },
    update: function() {
        if (this.updateStarCntLabel(),
        !this.isGameOver && !this.hasWin && !this.isProjectIdleBulleting) {
            if (this.currentBullet && this.updateBullet(),
            this.rotateCount !== this.rotateCountMax) {
                cc.log("rotate count:", this.rotateCount);
                var t = this.getRotateAngleSpeed(this.rotateCount);
                this.rotateAllBall(this.rotateDirectionReal * t),
                this.rotateCount++
            }
            this.syncDangerBall(),
            this.checkDangerBall()
        }
    },
    rotateAllBall: function(t) {
        for (var e = this.centerX, i = this.centerY, n = groupArray[e][i].x, r = groupArray[e][i].y, c = 0, s = 0; s != groupArray.length; s++)
            for (var o = 0; o != groupArray[s].length; o++) {
                var a = cc.pDistance(cc.p(groupArray[e][i].x, groupArray[e][i].y), cc.p(groupArray[s][o].x, groupArray[s][o].y))
                  , h = Math.atan2(groupArray[s][o].y - r, groupArray[s][o].x - n) / Math.PI * 180
                  , h = 360 - (h - 90)
                  , h = h + t
                  , l = Math.sin(h / 180 * Math.PI) * a + n
                  , a = Math.cos(h / 180 * Math.PI) * a + r;
                groupArray[s][o].x = l,
                groupArray[s][o].y = a,
                groupArray[s][o].status !== NOTBLANK && groupArray[s][o].status != CENTERBALL_TYPE || c++
            }
        for (this.ballCount = c,
        this.centerWall.setRotation(this.centerWall.rotation + t),
        o = 0; o != this.needRotateArray.length; o++)
            void 0 !== this.needRotateArray[o].needRoated && !0 === this.needRotateArray[o].needRoated ? (a = cc.pDistance(cc.p(groupArray[e][i].x, groupArray[e][i].y), cc.p(this.needRotateArray[o].x, this.needRotateArray[o].y)),
            h = Math.atan2(this.needRotateArray[o].y - r, this.needRotateArray[o].x - n) / Math.PI * 180,
            h = 360 - (h - 90),
            h += t,
            l = Math.sin(h / 180 * Math.PI) * a + n,
            a = Math.cos(h / 180 * Math.PI) * a + r,
            this.needRotateArray[o].x = l,
            this.needRotateArray[o].y = a) : (this.needRotateArray.splice(o, 1),
            o--)
    }
})
  , LASTLEVEL = -1
  , LEVEL = {
    1: {
        maps: [[0], [0], [0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],
        bulletNum: 5,
        projectIdleBullet: [10, 2],
        colorRange: [1]
    },
    11: {
        maps: [[0], [0], [0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],
        bulletNum: 2,
        projectIdleBullet: [2, 2],
        colorRange: [1, 2, 3, 4]
    },
    21: {
        maps: [[0], [0], [0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],
        bulletNum: 1,
        projectIdleBullet: [2, 2],
        colorRange: [1, 2, 3, 4, 5]
    },
    31: {
        maps: [[0], [0], [0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],
        bulletNum: 1,
        projectIdleBullet: [2, 2],
        colorRange: [1, 2, 3, 4, 5, 6]
    },
    2: {
        maps: [[0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 2, 2, 2, 2, 2, 1, 1, 0, 0, 0], [0, 0, 0, 0, 1, 2, 2, 6, 6, 2, 2, 1, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 6, 6, 6, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 1, 2, 2, 6, 6, 2, 2, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 2, 2, 2, 2, 2, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 4,
        projectIdleBullet: [3, 2],
        colorRange: [1, 2]
    },
    12: {
        maps: [[0], [0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 9, 9, 9, 9, 5, 5, 5, 0, 0, 0], [0, 0, 0, 1, 1, 9, 9, 9, 9, 9, 5, 5, 0, 0, 0], [0, 0, 0, 0, 1, 9, 9, 6, 6, 9, 9, 5, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 6, 6, 6, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 3, 9, 9, 6, 6, 9, 9, 2, 0, 0, 0, 0], [0, 0, 0, 3, 3, 9, 9, 9, 9, 9, 2, 2, 0, 0, 0], [0, 0, 0, 3, 3, 3, 9, 9, 9, 9, 2, 2, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 7,
        projectIdleBullet: [2, 1],
        colorRange: [1, 2, 3, 4, 5]
    },
    22: {
        maps: [[0], [0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 1, 3, 9, 1, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 2, 3, 2, 3, 2, 9, 9, 0, 0, 0], [0, 0, 0, 0, 9, 3, 2, 6, 6, 9, 2, 9, 0, 0, 0, 0], [0, 0, 0, 0, 1, 9, 6, 6, 6, 2, 1, 0, 0, 0, 0], [0, 0, 0, 0, 9, 2, 9, 6, 6, 2, 2, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 2, 9, 2, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 1, 2, 9, 1, 9, 9, 9, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 4,
        projectIdleBullet: [1, 2],
        colorRange: [1, 2, 3]
    },
    32: {
        maps: [[0], [0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 6, 6, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 6, 6, 6, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 6, 6, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 2,
        projectIdleBullet: [1, 3],
        colorRange: [1, 2, 3, 4]
    },
    13: {
        maps: [[0], [0], [0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0], [0, 0, 0, 2, 1, 1, 1, 6, 1, 1, 1, 2, 0, 0, 0], [0, 0, 0, 0, 2, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 6,
        projectIdleBullet: [2, 1],
        colorRange: [1, 2]
    },
    3: {
        maps: [[0], [0], [0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 9, 9, 9, 9, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 9, 9, 9, 9, 9, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 9, 9, 9, 9, 9, 9, 2, 0, 0, 0, 0], [0, 0, 0, 2, 9, 9, 9, 6, 9, 9, 9, 2, 0, 0, 0], [0, 0, 0, 0, 2, 9, 9, 9, 9, 9, 9, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 9, 9, 9, 9, 9, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 9, 9, 9, 9, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 2,
        projectIdleBullet: [1, 1],
        colorRange: [1, 2, 3, 4, 5]
    },
    73: {
        maps: [[0], [0], [0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 9, 9, 9, 9, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 9, 9, 9, 9, 9, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 9, 9, 9, 9, 9, 9, 2, 0, 0, 0, 0], [0, 0, 0, 2, 9, 9, 9, 6, 9, 9, 9, 2, 0, 0, 0], [0, 0, 0, 0, 2, 9, 9, 9, 9, 9, 9, 2, 0, 0, 0, 0], [0, 0, 0, 1, 2, 9, 9, 9, 9, 9, 2, 1, 0, 0, 0], [0, 0, 0, 0, 1, 2, 9, 9, 9, 9, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 2,
        projectIdleBullet: [1, 1],
        colorRange: [2]
    },
    33: {
        maps: [[0], [0], [0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 1, 9, 1, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 1, 9, 4, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 4, 1, 1, 3, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 3, 1, 6, 1, 1, 2, 9, 0, 0, 0], [0, 0, 0, 0, 9, 4, 1, 1, 1, 1, 2, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 2, 1, 1, 1, 2, 9, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 2, 4, 2, 4, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 3,
        projectIdleBullet: [3, 2],
        colorRange: [1, 2, 3, 4]
    },
    23: {
        maps: [[0], [0], [0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 6, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 2,
        projectIdleBullet: [2, 3],
        colorRange: [1, 2, 3, 4, 5]
    },
    4: {
        maps: [[0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 1, 2, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 2, 6, 6, 2, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 6, 6, 6, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 6, 6, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 2, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 5,
        projectIdleBullet: [10, 1],
        colorRange: [1, 2]
    },
    14: {
        maps: [[0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 6, 6, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 6, 6, 6, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 6, 6, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 3,
        projectIdleBullet: [1, 4],
        colorRange: [1, 2, 3, 4]
    },
    24: {
        maps: [[0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 6, 6, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 6, 6, 6, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 6, 6, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 2,
        projectIdleBullet: [1, 3],
        colorRange: [1, 2, 3, 4, 5]
    },
    34: {
        maps: [[0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 6, 6, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 6, 6, 6, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 6, 6, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 1,
        projectIdleBullet: [1, 4],
        colorRange: [1, 2, 3, 4, 5, 6]
    },
    5: {
        maps: [[0], [0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 2, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 2, 2, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 2, 2, 2, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 2, 6, 6, 2, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 2, 6, 6, 6, 2, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 1, 6, 6, 1, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 1, 1, 1, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 1, 1, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 1, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 5,
        projectIdleBullet: [10, 1],
        colorRange: [1, 2, 3]
    },
    15: {
        maps: [[0], [0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 9, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 9, 9, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 9, 9, 9, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 9, 6, 6, 9, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 9, 6, 6, 6, 9, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 9, 6, 6, 9, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 9, 9, 9, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 9, 9, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 9, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 2,
        projectIdleBullet: [2, 1],
        colorRange: [1, 2, 3, 4, 5]
    },
    25: {
        maps: [[0], [0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 2, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 2, 2, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 2, 2, 2, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 2, 6, 6, 2, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 9, 2, 6, 6, 6, 2, 9, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 6, 6, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 2,
        projectIdleBullet: [2, 2],
        colorRange: [1, 2, 3, 4]
    },
    35: {
        maps: [[0], [0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 6, 6, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 6, 6, 6, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 6, 6, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 2,
        projectIdleBullet: [1, 1],
        colorRange: [1, 2, 3, 4, 5]
    },
    16: {
        maps: [[0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 6, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 5,
        projectIdleBullet: [2, 4],
        colorRange: [1, 2]
    },
    6: {
        maps: [[0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 0, 0, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 0, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 1, 1, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 1, 9, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 6, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 2,
        projectIdleBullet: [1, 3],
        colorRange: [1, 2, 3]
    },
    26: {
        maps: [[0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 0, 0, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 0, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 1, 1, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 1, 9, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 6, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 3,
        projectIdleBullet: [1, 2],
        colorRange: [1, 2, 3, 4, 5]
    },
    36: {
        maps: [[0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 0, 0, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 0, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 1, 1, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 1, 9, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 6, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 1,
        projectIdleBullet: [1, 4],
        colorRange: [1, 2, 3, 4, 5, 6]
    },
    7: {
        maps: [[0], [0], [0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 6, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 4,
        projectIdleBullet: [2, 2],
        colorRange: [1, 2, 3]
    },
    17: {
        maps: [[0], [0], [0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 6, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 6,
        projectIdleBullet: [3, 4],
        colorRange: [1, 2, 3, 4, 5, 6]
    },
    27: {
        maps: [[0], [0], [0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 6, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 2,
        projectIdleBullet: [1, 4],
        colorRange: [1, 2, 3, 4]
    },
    37: {
        maps: [[0], [0], [0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 6, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 1,
        projectIdleBullet: [1, 4],
        colorRange: [1, 2, 3, 4, 5, 6]
    },
    8: {
        maps: [[0], [0], [0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 6, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 1,
        projectIdleBullet: [1, 2],
        colorRange: [1, 2, 3]
    },
    18: {
        maps: [[0], [0], [0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 6, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 3,
        projectIdleBullet: [1, 2],
        colorRange: [1, 2, 3, 4]
    },
    28: {
        maps: [[0], [0], [0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 6, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 2,
        projectIdleBullet: [2, 2],
        colorRange: [1, 2, 3, 4, 5]
    },
    38: {
        maps: [[0], [0], [0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 6, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 1,
        projectIdleBullet: [1, 4],
        colorRange: [1, 2, 3, 4, 5, 6]
    },
    9: {
        maps: [[0], [0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 2, 2, 2, 2, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 2, 2, 2, 2, 2, 9, 9, 0, 0, 0], [0, 0, 0, 0, 9, 2, 2, 6, 6, 2, 2, 9, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 6, 6, 6, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 9, 2, 2, 6, 6, 2, 2, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 2, 2, 2, 2, 2, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 2, 2, 2, 2, 9, 9, 9, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 9,
        projectIdleBullet: [2, 1],
        colorRange: [1, 2, 3, 4]
    },
    19: {
        maps: [[0], [0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 6, 6, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 6, 6, 6, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 6, 6, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 9,
        projectIdleBullet: [2, 2],
        colorRange: [1, 2, 3, 4, 5, 6]
    },
    29: {
        maps: [[0], [0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 6, 6, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 6, 6, 6, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 6, 6, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 2,
        projectIdleBullet: [1, 3],
        colorRange: [1, 2, 3, 4, 5]
    },
    39: {
        maps: [[0], [0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 6, 6, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 6, 6, 6, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 6, 6, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 1,
        projectIdleBullet: [1, 4],
        colorRange: [1, 2, 3, 4, 5, 6]
    },
    10: {
        maps: [[0], [0], [0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 9, 9, 9, 9, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 9, 9, 9, 9, 9, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 9, 9, 9, 9, 9, 9, 2, 0, 0, 0, 0], [0, 0, 0, 2, 9, 9, 9, 6, 9, 9, 9, 2, 0, 0, 0], [0, 0, 0, 0, 2, 9, 9, 9, 9, 9, 9, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 9, 9, 9, 9, 9, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 9, 9, 9, 9, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 5,
        projectIdleBullet: [1, 3],
        colorRange: [1, 2, 3, 4]
    },
    20: {
        maps: [[0], [0], [0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 6, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 8,
        projectIdleBullet: [1, 4],
        colorRange: [1, 2, 3, 4, 5, 6]
    },
    30: {
        maps: [[0], [0], [0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 6, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 4,
        projectIdleBullet: [1, 4],
        colorRange: [1, 2, 3, 4, 5]
    },
    40: {
        maps: [[0], [0], [0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 6, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 1,
        projectIdleBullet: [1, 4],
        colorRange: [1, 2, 3, 4, 5, 6]
    },
    42: {
        maps: [[0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 6, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 1,
        projectIdleBullet: [1, 4],
        colorRange: [1, 2, 3, 4, 5, 6]
    },
    41: {
        maps: [[0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 6, 6, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 6, 6, 6, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0], [0], [0]],
        bulletNum: 5,
        projectIdleBullet: [10, 1],
        colorRange: [1]
    }
};
BLANK = 0,
NOTBLANK = 1,
REMOVABLE = 2,
DROPABLE = 3,
CENTERBALL_TYPE = 100;
var typePopImage = res.pop_circle_png
  , type0image = res.ball0
  , type1image = res.ball1
  , type2image = res.ball2
  , type3image = res.ball3
  , type4image = res.ball4
  , type5image = res.ball5
  , type6image = res.ball6
  , textureMap = {
    7: typePopImage,
    0: type0image,
    2: type2image,
    1: type1image,
    3: type3image,
    4: type4image,
    5: type5image,
    6: type6image
}
  , BoobleMap = {
    1: "assets/res/p/booble_1.png",
    2: "assets/res/p/booble_2.png",
    3: "assets/res/p/booble_3.png",
    4: "assets/res/p/booble_4.png",
    5: "assets/res/p/booble_5.png",
    6: "assets/res/p/booble_6.png"
}
  , BubbleSprite = cc.Sprite.extend({
    px: 0,
    py: 0,
    isFake: !1,
    status: -1,
    type: -1,
    ctor: function(t) {
        var e = "#ball_" + t + ".png";
        99 === t && (e = "#pop_circle5.png"),
        this._super(e),
        this.initPara(t)
    },
    initPara: function(t) {
        this.type = t,
        this.status = 0 === t ? BLANK : NOTBLANK,
        this.isFake = 0 === t,
        ISDEBUG || 0 === t && this.setVisible(!1)
    },
    isNotFake: function() {
        return !this.isFake
    },
    unuse: function() {
        console.log("unuse one sprite"),
        this.children[0] && this.children[0].setString(""),
        this.setOpacity(0),
        this.setScale(1),
        this.retain()
    },
    reuse: function(t) {
        console.log("reuse one sprite"),
        this.setOpacity(255),
        this.setScale(1),
        this.setVisible(!0);
        var e = cc.spriteFrameCache.getSpriteFrame(textureMap[t].replace("#", ""));
        this.setSpriteFrame(e),
        this.initPara(t)
    },
    changeType: function(t) {
        var e = cc.spriteFrameCache.getSpriteFrame(textureMap[t].replace("#", ""));
        this.setSpriteFrame(e),
        this.initPara(t)
    }
})
  , GameOverLayer = cc.Layer.extend({
    _gameScene: null,
    ctor: function(t) {
        window.famobi_analytics.trackEvent("SCREEN_LEVELRESULT"),
        this._super(),
        this.level = t,
        SG_Hooks && !1 === SG_Hooks.isEnabledIncentiviseButton() || (t = Storage.getLives(),
        Storage.setLives(t - 1)),
        this.popupBg = new cc.Sprite(res.small_bg),
        this.popupBg.x = cc.winSize.width / 2,
        this.popupBg.y = cc.winSize.height / 2,
        this.addChild(this.popupBg, 1, 1),
        t = new cc.MenuItemImage(res.btn_shop_png,res.btn_shop2_png,this.gotoShop,this),
        t.x = this.popupBg.x - 100,
        t.y = this.popupBg.y - this.popupBg.height / 2;
        var e = new cc.MenuItemImage(res.btn_replay_png,res.btn_replay_png,this._replay,this);
        e.x = this.popupBg.x + 100,
        e.y = this.popupBg.y - this.popupBg.height / 2 + 20,
        t = new cc.Menu(e,t),
        t.x = 0,
        t.y = 0,
        this.addChild(t, 2, 2),
        t = new cc.Sprite(res.lose_png),
        this.addChild(t, 3, 3),
        t.x = cc.visibleRect.center.x,
        t.y = cc.visibleRect.center.y - 50,
        t.setScale(.6),
        e = new cc.LabelTTF(Texts[lang][18],getFont(res.lemonFont),55),
        300 < e.width && e.setScale(300 / e.width),
        this.addChild(e, 4, 4),
        e.fillStyle = cc.color(0, 0, 0),
        e.x = t.x,
        e.y = t.y + 150
    },
    _replay: function(t) {
        window.famobi_analytics.trackEvent("EVENT_LEVELRESTART", {
            levelName: ""
        }),
        Sound.playClick(),
        trace("replay "),
        cc.eventManager.dispatchCustomEvent("stopSchedule", ""),
        cc.director.runScene(new GameScene(this.level))
    },
    _return: function() {
        Sound.playClick(),
        cc.director.runScene(new cc.TransitionFade(1,new MapScene)),
        trace("go to menu")
    },
    gotoShop: function(t) {
        Sound.playClick(),
        cc.director.runScene(new cc.TransitionFade(1,new GameShopScene(this.level)))
    }
})
  , GameWinLayer = cc.Layer.extend({
    _gameScene: null,
    coin: null,
    ctor: function(t, e, i, n, r) {
        window.famobi_analytics.trackEvent("SCREEN_LEVELRESULT"),
        this._super(),
        this.coin = e || 1,
        this.extraCoin = i || 1,
        this.delay = r || 0,
        this.level = t,
        this.playing = !1,
        this.popupAnim = new cc.Sprite(res.popup_anim_png),
        this.popupAnim.x = cc.winSize.width / 2,
        this.popupAnim.y = cc.winSize.height / 2,
        this.addChild(this.popupAnim, 0, 0),
        this.popupAnim.runAction(cc.rotateBy(2, 30).repeatForever()),
        this.popupBg = new cc.Sprite(res.small_bg),
        this.popupBg.x = cc.winSize.width / 2,
        this.popupBg.y = cc.winSize.height / 2,
        this.addChild(this.popupBg, 1, 1),
        e = new cc.LabelTTF("",getFont(res.lemonFont),60),
        300 < e.width && e.setScale(300 / e.width),
        e.x = cc.winSize.width / 2,
        e.y = this.popupBg.y + this.popupBg.height / 2 - 20,
        this.addChild(e, 3, 3),
        i = new cc.Sprite(res.star_png),
        t = new cc.Sprite(res.star_png);
        var c = new cc.Sprite(res.star_png);
        i.x = cc.winSize.width / 2,
        i.y = e.y - 80,
        t.x = i.x - i.width / 2,
        t.y = i.y - 40,
        c.x = i.x + i.width / 2,
        c.y = i.y - 40,
        this.addChild(i, 6, 6),
        this.addChild(t, 5, 5),
        this.addChild(c, 4, 4),
        2 === n ? i.setVisible(!1) : 3 !== n && (t.setVisible(!1),
        c.setVisible(!1)),
        n = new cc.Sprite(res.coin_png),
        n.x = cc.winSize.width / 2 - 60,
        n.y = t.y - 100,
        this.addChild(n, 7, 7),
        i = new cc.LabelTTF("+" + this.coin.toString(),getFont(res.lemonFont),55),
        i.x = cc.winSize.width / 2 + 30,
        i.y = n.y,
        i.anchorX = 0,
        this.addChild(i, 8, 8),
        i.fillStyle = cc.color(255, 215, 0),
        n.setVisible(!1),
        t = new cc.Sprite(res.coin_png),
        t.x = n.x,
        t.y = n.y - n.height / 2 - 35,
        this.addChild(t, 17, 17),
        e = new cc.Sprite(res.coin_png),
        e.x = t.x - e.width / 2,
        e.y = n.y - n.height / 2 - 40,
        e.setScale(.9),
        this.addChild(e, 9, 9),
        e = new cc.Sprite(res.coin_png),
        e.x = t.x + e.width / 2,
        e.y = n.y - n.height / 2 - 35 - 5,
        this.addChild(e, 9, 9),
        e.setScale(.9),
        e = new cc.LabelTTF("",getFont(res.lemonFont),55),
        e.setString(Storage.getCoin()),
        e.x = cc.winSize.width / 2 + 40,
        e.y = t.y,
        e.anchorX = 0,
        e.fillStyle = cc.color(255, 215, 0),
        this.addChild(e, 8, 8),
        e.setName("coinLabel2"),
        e.setScale(2),
        e.setVisible(!1),
        n = new cc.LabelTTF("+" + this.extraCoin.toString(),getFont(res.lemonFont),58),
        n.x = i.x + i.width,
        n.y = i.y + 10,
        this.addChild(n, 8, 8),
        n.fillStyle = cc.color(255, 215, 0),
        n.anchorX = 0;
        var s = cc.callFunc(function() {
            Sound.playCoin1()
        }, this)
          , o = cc.callFunc(function() {
            Sound.playCoin2()
        }, this)
          , c = cc.callFunc(function() {
            Sound.playCoin3()
        }, this);
        t = cc.callFunc(function() {
            Sound.playCoin4()
        }, this);
        var a = cc.callFunc(function() {
            this.playing = !0
        }, this);
        r = cc.delayTime(this.delay);
        var h = cc.show()
          , l = cc.scaleTo(.2, 1);
        r = cc.sequence(a, r, cc.spawn(h, l, s)),
        e.runAction(r),
        r = cc.delayTime(r.getDuration() + .3),
        i.setVisible(!1),
        i.setScale(2),
        l = cc.scaleTo(.5, 1),
        h = cc.show(),
        l = cc.fadeOut(1),
        s = cc.moveBy(.5, 0, 50),
        l = cc.spawn(l, s),
        i.x = e.x + e.width,
        i.y = e.y,
        o = cc.sequence(r, o, h, l),
        i.runAction(o),
        i = cc.delayTime(o.getDuration() - .5),
        o = cc.show(),
        r = cc.scaleTo(.5, 1),
        h = cc.callFunc(function() {
            var t = this.getChildByName("coinLabel2");
            t && t.setString(Storage.getCoin())
        }, this),
        i = cc.sequence(i, c, h, o, r.easing(cc.easeElasticOut())),
        e.runAction(i),
        i = cc.delayTime(i.getDuration()),
        n.x = e.x + e.width,
        n.y = e.y + 10,
        cc.show(),
        e = cc.show(),
        c = cc.fadeOut(.5),
        o = cc.moveBy(.5, 0, 50),
        e = cc.sequence(e, cc.spawn(c, o)),
        n.setVisible(!1),
        n.setScale(2),
        c = cc.scaleTo(.3, 1),
        o = cc.delayTime(.1),
        r = cc.callFunc(function(t, e) {
            var i = this.getChildByName("coinLabel2");
            i && (Sound.playCoin5(),
            i.setString(parseInt(Storage.getCoin()) + e),
            Storage.addCoin(e),
            this.playing = !1)
        }, this, this.extraCoin),
        n.runAction(cc.sequence(i, t, e, o, cc.spawn(c, r))),
        n = new cc.MenuItemImage(res.btn_play_png,res.btn_play_png,this.playNext,this),
        n.x = this.popupBg.x + 100,
        n.y = this.popupBg.y - this.popupBg.height / 2,
        t = new cc.MenuItemImage(res.btn_replay_png,res.btn_replay_png,this.replay,this),
        t.x = this.popupBg.x - 100,
        t.y = this.popupBg.y - this.popupBg.height / 2 + 20,
        n = new cc.Menu(n,t),
        n.x = 0,
        n.y = 0,
        this.addChild(n, 2, 2)
    },
    replay: function(t) {
        trace("replay "),
        !0 !== this.playing && (Sound.playClick(),
        cc.eventManager.dispatchCustomEvent("stopSchedule", ""),
        cc.director.runScene(new GameScene(this.level)))
    },
    playNext: function(t) {
        if (!0 !== this.playing) {
            Sound.playClick(),
            41 <= this.level + 1 && cc.director.runScene(new cc.TransitionFade(1,new MapScene((!1),e)));
            var e = Math.floor((this.level + 1 - 1) / LEVEL_NUM_OF_EVERY_MAP);
            1 === Storage.getPlanetState(e) ? cc.director.runScene(new cc.TransitionFade(1,new GameShopScene(this.level + 1))) : cc.director.runScene(new cc.TransitionFade(1,new MapScene((!1),e)))
        }
    }
})
  , BoosterMap = {
    1: {
        file: res.booster_aim,
        name: "aim booster",
        price: 40
    },
    2: {
        file: res.booster_redo,
        name: "redo booster",
        price: 80
    },
    3: {
        file: res.booster_explosion,
        name: "explosion booster",
        price: 20
    },
    4: {
        file: res.booster_elimination,
        name: "elimination booster",
        price: 60
    }
}
  , GameShopScene = cc.Scene.extend({
    level: null,
    ctor: function(t) {
        window.famobi_analytics.trackScreen("SCREEN_SHOP"),
        this._super(),
        this.level = t,
        t = new ShopShowUI(this.level),
        this.addChild(t, 1, 1)
    }
})
  , ShopShowUI = cc.Layer.extend({
    selectedBuster: null,
    _level: null,
    isTutorial: !1,
    finishTutorial: !1,
    hasShowWatchAds: !1,
    gameWindowWidth: 640,
    gameWindowHeight: 960,
    boosterArray: [],
    hasClickPlayBtn: !1,
    ctor: function(t) {
        this._super(),
        cc.spriteFrameCache.addSpriteFrames(res2.UI_Plist, res2.UI_png),
        this.leftWall = cc.winSize.width / 2 - this.gameWindowWidth / 2,
        this.rightWall = cc.winSize.width / 2 + this.gameWindowWidth / 2,
        this.selectedBuster = [],
        trace("daoju:" + this.selectedBuster),
        this._level = t,
        "tutorial" === t && (this.isTutorial = !0),
        t || (this._level = 0);
        var e = cc.winSize;
        t = e.width / 2;
        var e = e.height / 2
          , i = new cc.Sprite(getBg(this._level));
        i.x = cc.winSize.width / 2,
        i.y = cc.winSize.height / 2,
        this.addChild(i, 1, 1),
        this.popupBg = new cc.Sprite(res.small_bg),
        this.popupBg.x = t,
        this.popupBg.y = e,
        this.addChild(this.popupBg, 1, 1);
        var n = this.leftWall
          , r = this.popupBg.y - this.popupBg.height / 2;
        this.closeMenuItem = new cc.MenuItemImage(res.bg_exit,res.bg_exit,this.returnToMap,this),
        this.closeMenuItem.x = this.popupBg.x + this.popupBg.getContentSize().width / 2 - this.closeMenuItem.getContentSize().width / 2 - 30,
        this.closeMenuItem.y = this.popupBg.y + this.popupBg.getContentSize().height / 2 - this.closeMenuItem.getContentSize().height / 2 - 30,
        e = new cc.Sprite(res.coin_png),
        e.x = this.leftWall + 50,
        e.x += 20,
        e.y = cc.winSize.height - e.height / 2 - 20,
        e.y -= 70,
        this.addChild(e, 19, 19),
        t = Storage.getCoin(),
        this.coinLabel = new cc.LabelTTF("" + t,getFont(res.lemonFont),40),
        this.coinLabel.x = e.x + 50,
        this.coinLabel.y = e.y,
        this.coinLabel.anchorX = 0,
        this.addChild(this.coinLabel, 21, 21),
        this.coinLabel.setName("coinLabel"),
        t = new cc.MenuItemImage(res.plus_png,res.plus2_png,this.showMoreCoin,this),
        t.x = this.coinLabel.x + this.coinLabel.width + 30,
        t.y = this.coinLabel.y,
        t.setScale(.7),
        t.setName("moreCoinItem"),
        t.setVisible(!1),
        i = new cc.Sprite(res.lives_png),
        i.x = e.x,
        i.y = e.y - e.height / 2 - i.height / 2 - 10,
        i.setScale(.9),
        e = Storage.getLives(),
        this.livesLabel = new cc.LabelTTF("" + e,getFont(res.lemonFont),40),
        this.livesLabel.x = i.x + 50,
        this.livesLabel.y = i.y,
        this.livesLabel.anchorX = 0,
        this.livesLabel.setName("livesLabel"),
        e = new cc.MenuItemImage(res.plus_png,res.plus2_png,this.showMoreLives,this),
        e.x = this.livesLabel.x + this.livesLabel.width + 30,
        e.y = this.livesLabel.y,
        e.setScale(.7),
        e.setName("moreLivesItem"),
        e.setVisible(!1),
        i = new cc.MenuItemImage(res.booster_aim,res.booster_aim,this.clickCallBack,this),
        i.x = n + 1 * this.popupBg.width / 4,
        i.y = r + 2 * this.popupBg.height / 3.5 + 60;
        var c = new cc.MenuItemImage(res.plus_png,res.plus2_png,this.clickCallBack,this);
        c.x = i.x + i.width / 2 - 10,
        c.y = i.y - i.height / 2 + 10;
        var s = Storage.getAimBoosterNum();
        i.busterNum = s,
        s = new cc.MenuItemImage(res.booster_redo,res.booster_redo,this.clickCallBack,this),
        s.x = n + 1 * this.popupBg.width / 4,
        s.y = r + 2 * this.popupBg.height / 5 - 50,
        n = new cc.MenuItemImage(res.plus_png,res.plus2_png,this.clickCallBack,this),
        n.x = s.x + s.width / 2 - 10,
        n.y = s.y - s.height / 2 + 10,
        r = Storage.getRedoBoosterNum(),
        s.busterNum = r,
        r = new cc.MenuItemImage(res.booster_explosion,res.booster_explosion,this.clickCallBack,this),
        r.x = this.popupBg.x + 120,
        r.y = i.y;
        var o = new cc.MenuItemImage(res.plus_png,res.plus2_png,this.clickCallBack,this);
        o.x = r.x + r.width / 2 - 10,
        o.y = r.y - r.height / 2 + 10;
        var a = Storage.getExplosionBoosterNum();
        r.busterNum = a,
        a = new cc.MenuItemImage(res.booster_elimination,res.booster_elimination,this.clickCallBack,this),
        a.x = r.x,
        a.y = s.y;
        var h = new cc.MenuItemImage(res.plus_png,res.plus2_png,this.clickCallBack,this);
        h.x = a.x + a.width / 2 - 10,
        h.y = a.y - a.height / 2 + 10;
        var l = Storage.getEliminationBoosterNum();
        a.busterNum = l;
        var l = new cc.MenuItemImage(res.btn_sound_on)
          , u = new cc.MenuItemImage(res.btn_sound_off)
          , l = new cc.MenuItemToggle(l,u,function() {
            trace("sound toggle"),
            Sound.toggleOnoff()
        }
        ,this);
        if (!0 === Sound.silence && l.setSelectedIndex(1),
        l.x = this.rightWall - l.width / 2,
        l.y = cc.winSize.height - l.height / 2,
        l.setScale(.6),
        u = new cc.MenuItemImage(res.btn_play_png,res.btn_play_png,this.play,this),
        u.x = this.popupBg.x,
        u.y = this.popupBg.y - this.popupBg.height,
        this.playBtn = u,
        !ISDEBUG) {
            var d = cc.sequence(cc.scaleBy(.5, 1.2), cc.scaleBy(.5, 10 / 12), cc.delayTime(1.5));
            u.runAction(d.repeatForever())
        }
        i.setScale(1.2),
        s.setScale(1.2),
        r.setScale(1.2),
        a.setScale(1.2),
        c.setScale(1 / 1.2),
        n.setScale(1 / 1.2),
        o.setScale(1 / 1.2),
        h.setScale(1 / 1.2),
        this.menu = new cc.Menu(i,c,s,n,r,o,a,h,u,this.closeMenuItem,l,t,e),
        i.tag = 1,
        c.tag = 5,
        s.tag = 2,
        n.tag = 6,
        r.tag = 3,
        o.tag = 7,
        a.tag = 4,
        h.tag = 8,
        this.menu.x = 0,
        this.menu.y = 0,
        this.addChild(this.menu, 2, 2),
        this.boosterArray = [i, s, r, a],
        this.drawBoosterNum(),
        this.drawBoosterPrice(),
        this.isTutorial && (e = this.menu.getChildByTag(4),
        t = new cc.Sprite(res.hand_png),
        t.x = e.x + 40,
        t.y = e.y - 96,
        this.addChild(t, 500, 500),
        e = cc.scaleBy(1, 1.2),
        i = e.clone().reverse(),
        e = cc.sequence(e, i),
        e = cc.repeatForever(e),
        t.runAction(e),
        t.setName("hand")),
        cc.eventManager.addCustomListener("coinChange", this.coinChange.bind(this)),
        cc.eventManager.addCustomListener("livesChange", this.lifeChange.bind(this)),
        cc.eventManager.addCustomListener("updateBoosterNum", this.updateBoosterNum.bind(this)),
        cc.eventManager.addCustomListener("moveToCloseButton", this.moveToCloseButton.bind(this)),
        cc.eventManager.addCustomListener("chooseLargeBuster", this.chooseLargeBuster.bind(this)),
        cc.eventManager.addCustomListener("play", this.tutorialPart4.bind(this)),
        cc.eventManager.addCustomListener("updateMoreCoinPos", this.updateMoreCoinPosition.bind(this)),
        cc.eventManager.addCustomListener("updateMoreLivesPos", this.updateMoreLifePosition.bind(this)),
        cc.eventManager.addCustomListener("hasShowWatchAds", this.updateShowWatchAds.bind(this)),
        this.scheduleUpdate()
    },
    checkLivesPrize: function() {
        var t = new Date
          , e = Storage.getLastLivesPrizeTime()
          , i = -1;
        e ? (i = Math.floor((t - new Date(e)) / 1e3 / 60),
        60 <= i && this.showLivesPrizeLayer()) : Storage.setLastLivesPrizeTime(t)
    },
    showLivesPrizeLayer: function() {
        var t = new cc.Layer;
        this.addChild(t, 110, 110),
        t.setName("livesPrizeLayer");
        var e = new cc.Sprite(res.small_bg);
        e.x = cc.winSize.width / 2,
        e.y = cc.winSize.height / 2,
        t.addChild(e, 1, 1);
        var i = new cc.LabelTTF(Texts[lang][22],getFont(res.lemonFont),40);
        500 < i.width && i.setScale(450 / i.width),
        t.addChild(i, 2, 2),
        i.x = e.x,
        i.y = e.y + 40,
        i = new cc.MenuItemImage(res.btn_claim_png,res.btn_claim_png,this.livesClaimClick,this),
        i.x = e.x,
        i.y = e.y - 230 + 20,
        e = new cc.Menu(i),
        e.x = 0,
        e.y = 0,
        t.addChild(e, 1, 1),
        t.setScale(.5),
        e = cc.scaleTo(1, 1).easing(cc.easeBackInOut()),
        i = cc.callFunc(function() {
            Sound.playLottery()
        }),
        e = cc.sequence(e, i),
        t.runAction(e)
    },
    livesClaimClick: function(t) {
        trace("claim 1 lives"),
        Sound.playClick(),
        t = Storage.getLives(),
        Storage.setLives(t + 1),
        t = new cc.LabelTTF("+1",getFont(res.lemonFont),30),
        this.addChild(t, 120, 120),
        t.x = this.leftWall + 200,
        t.y = cc.winSize.height - 100;
        var e = cc.moveBy(1, cc.p(0, 20))
          , i = cc.fadeOut(1)
          , e = cc.spawn(e, i);
        t.runAction(e),
        cc.eventManager.dispatchCustomEvent("livesChange", Storage.getLives()),
        cc.eventManager.dispatchCustomEvent("updateMoreLivesPos", []),
        Storage.setLastLivesPrizeTime(new Date),
        (t = this.getChildByName("livesPrizeLayer")) && t.removeFromParent()
    },
    update: function() {
        this.hasShowWatchAds ? this.playBtn.setVisible(!1) : this.playBtn.setVisible(!0)
    },
    moveToCloseButton: function() {
        this.isTutorial && this.getChildByName("hand").runAction(cc.moveTo(1, cc.p(this.closeMenuItem.x + 90, this.closeMenuItem.y - 10)))
    },
    showMoreCoin: function(t) {
        if (trace("show more coin item"),
        !0 !== this.hasShowWatchAds && !1 === this.isTutorial && !cc.sys.isNative) {
            Sound.playClick();
            var e = cc.callFunc(function() {
                var t = new WatchADUI((!0));
                this.addChild(t, 100, 100),
                this.hasShowWatchAds = !this.hasShowWatchAds
            }, this);
            t.runAction(e)
        }
    },
    showMoreLives: function(t) {
        if (trace("show more lives item"),
        !0 !== this.hasShowWatchAds && !1 === this.isTutorial && !cc.sys.isNative) {
            Sound.playClick();
            var e = cc.callFunc(function() {
                var t = new WatchADUI((!0),"",Texts[lang][19],null,THANKS_PRIZE_LIVES);
                this.addChild(t, 100, 100),
                this.hasShowWatchAds = !this.hasShowWatchAds
            }, this);
            t.runAction(e)
        }
    },
    updateShowWatchAds: function() {
        this.hasShowWatchAds = !1
    },
    chooseLargeBuster: function(t) {
        if (t.getUserData(),
        this.isTutorial) {
            t = this.getChildByName("hand");
            var e = this.menu.getChildByTag(4);
            t.runAction(cc.moveTo(1, cc.p(e.x + 40, e.y - 96)))
        }
    },
    tutorialPart4: function() {
        this.finishTutorial = !0,
        GameConstants.firstTutorialFinished = !0,
        this.isTutorial && this.getChildByName("hand").runAction(cc.moveTo(1, cc.p(this.popupBg.x + 40, this.popupBg.y - this.popupBg.height / 2 - 80)))
    },
    drawBoosterNum: function() {
        for (var t = 0; 4 != t; t++) {
            var e = new cc.Sprite(res.booster_cnt);
            this.boosterArray[t].addChild(e, 1, 1),
            e.x = -e.width / 2,
            e.y = this.boosterArray[t].height,
            e.setName("itemSB");
            var i = new cc.LabelTTF(this.boosterArray[t].busterNum + "",getFont(res.lemonFont),35);
            i.x = e.x,
            i.y = e.y,
            i.setName("label"),
            this.boosterArray[t].addChild(i, 2, 2),
            i.width > e.width && i.setScale(e.width / (i.width + 5))
        }
    },
    drawBoosterPrice: function() {
        for (var t = 0; 4 != t; t++) {
            var e = this.boosterArray[t]
              , i = new cc.LabelTTF("$" + BoosterMap[e.tag].price,getFont(res.lemonFont),25);
            i.setColor(cc.color(0, 0, 0)),
            i.x = e.width / 2,
            i.y = -30,
            e.addChild(i, 3, 3)
        }
    },
    updateBoosterNum: function() {
        for (var t = 0; 4 != t; t++) {
            var e = this.boosterArray[t].busterNum
              , i = this.boosterArray[t].getChildByName("label");
            i.setString(e + ""),
            e = this.boosterArray[t].getChildByName("itemSB"),
            i.width > e.width && i.setScale(e.width / (i.width + 5))
        }
    },
    coinChange: function(t) {
        t = t.getUserData();
        var e = this.getChildByName("coinLabel");
        e && e.setString(t)
    },
    lifeChange: function(t) {
        t = t.getUserData();
        var e = this.getChildByName("livesLabel");
        e && e.setString(t)
    },
    setLabelPosition: function(t, e, i, n) {
        i = new cc.LabelTTF("x" + i,getFont(res.lemonFont),40),
        this.addChild(i, 10 + n, 10 + n),
        4 === n ? (i.anchorX = .2,
        i.x = t + 10) : (i.anchorX = .8,
        i.x = t - 10),
        i.y = e + 30
    },
    clickCallBack: function(t) {
        if (trace("touch begin" + t.tag),
        !this.isTutorial || 4 === t.tag || 8 === t.tag) {
            var e;
            e = 4 < t.tag ? this.menu.getChildByTag(t.tag - 4) : this.menu.getChildByTag(t.tag);
            var i = BoosterMap[e.tag].price
              , n = Storage.getCoin();
            n >= i ? (Sound.playClick(),
            t = Storage.getBoosterCnt(parseInt(e.tag)),
            e.busterNum = t + 1,
            this.updateBoosterNum(),
            Storage.setBoosterCnt(parseInt(e.tag), t + 1),
            cc.eventManager.dispatchCustomEvent("coinChange", n - i),
            cc.eventManager.dispatchCustomEvent("updateMoreCoinPos", ""),
            Storage.addCoin(-i)) : (cc.log("not enough coin!"),
            !0 === this.hasShowWatchAds || !1 !== this.isTutorial || cc.sys.isNative || (Sound.playClick(),
            e = cc.callFunc(function() {
                var t = new WatchADUI((!1));
                this.addChild(t, 100, 100),
                this.hasShowWatchAds = !this.hasShowWatchAds
            }, this),
            t.runAction(e)))
        }
    },
    showNoEnoughLabel: function(t) {
        var e = new cc.LabelTTF(Texts[lang][13],getFont(res.lemonFont),20,cc.size(120, 0));
        e.x = t.x + t.width + e.width / 2,
        e.y = t.y,
        this.addChild(e, 20, 20),
        e.opacity = 255,
        t = cc.fadeIn(.5);
        var i = cc.fadeOut(.5)
          , n = cc.callFunc(function(t, e) {
            e.removeFromParent()
        }, this, e);
        t = cc.sequence(t, i, n),
        e.runAction(t)
    },
    showBuyBusterLayer: function(t, e) {
        var i = new BuyBusterLayer(e,this.isTutorial);
        this.isTutorial && this.getChildByName("hand").runAction(cc.moveTo(1, cc.p(this.popupBg.x + 40, this.popupBg.y - this.popupBg.height / 2 - 80))),
        this.addChild(i, 40, 40)
    },
    returnToMap: function(t) {
        Sound.playClick(),
        this.isTutorial || cc.director.runScene(new cc.TransitionFade(1,new MapScene))
    },
    play: function(t) {
        if (Sound.playClick(),
        !this.hasClickPlayBtn && (this.hasClickPlayBtn = !0,
        !this.isTutorial || !1 !== this.finishTutorial) && (this.isTutorial && (this._level = 2),
        !0 !== this.hasShowWatchAds))
            if (0 >= Storage.getLives())
                t = new WatchADUI((!1),Texts[lang][21],Texts[lang][19],null,THANKS_PRIZE_LIVES,THANKS_PRIZE_LIVES),
                this.addChild(t, 100, 100),
                this.hasShowWatchAds = !this.hasShowWatchAds;
            else {
                var e = cc.callFunc(function() {
                    cc.director.runScene(new cc.TransitionFade(1,new GameScene(this._level)))
                }, this)
                  , i = cc.scaleBy(.2, 1.2)
                  , n = i.reverse()
                  , e = cc.sequence(i, n, e);
                t.runAction(e)
            }
    },
    onExitTransitionDidStart: function() {
        this._super(),
        this.adjustBusterNum()
    },
    adjustBusterNum: function() {
        for (var t = this.selectedBuster.length, e = 0; e < t; e++) {
            var i = this.selectedBuster[e]
              , n = parseInt(Storage.getBoosterCnt(i));
            0 < n && Storage.setBoosterCnt(i, n - 1)
        }
    },
    updateMoreCoinPosition: function() {
        var t = this.menu.getChildByName("moreCoinItem");
        t && (t.x = this.coinLabel.x + this.coinLabel.width + 30)
    },
    updateMoreLifePosition: function() {
        var t = this.menu.getChildByName("moreLivesItem");
        t && (t.x = this.livesLabel.x + this.livesLabel.width + 30)
    }
})
  , THANKS_PRIZE_LIVES = "lives"
  , THANKS_PRIZE_COINS = "coins"
  , WatchADUI = cc.Layer.extend({
    gameWindowWidth: 640,
    gameWindowHeight: 960,
    ctor: function(t, e, i, n, r, c) {
        this._super(),
        this.leftWall = cc.winSize.width / 2 - this.gameWindowWidth / 2,
        this.rightWall = cc.winSize.width / 2 + this.gameWindowWidth / 2,
        this.hideReasonLabel = t,
        this.exitCalf = n,
        this.isFromMapScene = c,
        this.thanksPrize = r ? r : THANKS_PRIZE_COINS,
        this.popupBg = new cc.Sprite(res.small_bg),
        this.popupBg.x = cc.winSize.width / 2,
        this.popupBg.y = cc.winSize.height / 2,
        this.addChild(this.popupBg, 1, 1),
        this.buttonWatch = new cc.MenuItemImage(res.btn_watchAD_png,res.btn_watchAD_png,this.watchAds,this),
        this.buttonWatch.x = cc.winSize.width / 2,
        this.buttonWatch.y = this.popupBg.y - this.popupBg.height / 2,
        this.buttonWatch.tag = 1,
        this.buttonWatch.setVisible(!1),
        this.reasonLabel = new cc.LabelTTF(Texts[lang][13],getFont(res.lemonFont),40),
        500 < this.reasonLabel.width && this.reasonLabel.setScale(350 / this.reasonLabel.width),
        this.addChild(this.reasonLabel, 4, 4),
        this.reasonLabel.x = this.popupBg.x,
        this.reasonLabel.y = this.popupBg.y + 100,
        e && this.reasonLabel.setString(e),
        this.actionLabel = new cc.LabelTTF(Texts[lang][5],getFont(res.lemonFont),40),
        this.actionLabel.x = this.popupBg.x,
        this.actionLabel.y = this.popupBg.y + 40,
        this.actionLabel.setScale(350 / this.actionLabel.width),
        i && this.actionLabel.setString(i),
        t = new cc.MenuItemImage(res.btn_watchAD_png,res.btn_watchAD_png,this.watchAds,this),
        t.x = cc.winSize.width / 2,
        t.y = this.actionLabel.y - 150,
        this.hideReasonLabel && (this.reasonLabel.setVisible(!1),
        this.actionLabel.y = this.popupBg.y + 70,
        t.y = this.actionLabel.y - 160),
        this.closeMenuItem = new cc.MenuItemImage(res.bg_exit,res.bg_exit,this.closeUI,this),
        this.closeMenuItem.x = this.popupBg.x + this.popupBg.getContentSize().width / 2 - this.closeMenuItem.getContentSize().width / 2 - 30,
        this.closeMenuItem.y = this.popupBg.y + this.popupBg.getContentSize().height / 2 - this.closeMenuItem.getContentSize().height / 2 - 30,
        this.menu = new cc.Menu(this.closeMenuItem,this.buttonWatch),
        this.menu.x = 0,
        this.menu.y = 0,
        this.addChild(this.menu, 2, 2)
    },
    closeUI: function() {
        Sound.playClick(),
        cc.eventManager.dispatchCustomEvent("hasShowWatchAds", []),
        this.exitCalf && this.exitCalf("exit"),
        this.removeFromParent()
    },
    triggerIncentivise: function(t) {
        t(!0)
    },
    checkAndSetAdsPrizePara: function() {
        var t = new Date
          , e = Storage.getLastAdsTime()
          , i = -1;
        return e ? (i = Math.floor((t - new Date(e)) / 1e3 / 60),
        720 <= i ? (Storage.setWatchAdsCnt(1),
        !0) : 4 >= Storage.getWatchAdsCnt() && (t = Storage.getWatchAdsCnt(),
        Storage.setWatchAdsCnt(t + 1),
        !0)) : (Storage.setLastAdsPrizeTime(t),
        Storage.setWatchAdsCnt(1),
        !0)
    },
    watchAds: function(t) {
        trace("watch"),
        Sound.playClick(),
        t = this.checkAndSetAdsPrizePara(),
        this.isFromMapScene ? window.famobi.showAd(this.incentiviseFinished.bind(this)) : window.famobi && t ? window.famobi.showAd(this.incentiviseFinished.bind(this)) : this.showNoVideo()
    },
    incentiviseFinished: function(t) {
        this.exitCalf ? (this.removeFromParent(),
        this.exitCalf()) : this.showThanksForWatching()
    },
    showThanksForWatching: function() {
        var t = new cc.Layer;
        this.addChild(t, 11, 11),
        t.setName("thanksLayer");
        var e = new cc.Sprite(res.small_bg);
        e.x = cc.winSize.width / 2,
        e.y = cc.winSize.height / 2,
        t.addChild(e, 1, 1);
        var i = new cc.LabelTTF(Texts[lang][6],getFont(res.lemonFont),40);
        if (500 < i.width && i.setScale(450 / i.width),
        t.addChild(i, 2, 2),
        i.x = e.x,
        i.y = e.y + 120,
        i = new cc.LabelTTF(Texts[lang][7],getFont(res.lemonFont),40),
        500 < i.width && i.setScale(450 / i.width),
        t.addChild(i, 2, 2),
        i.x = e.x,
        i.y = e.y + 40,
        this.thanksPrize === THANKS_PRIZE_LIVES) {
            i = new cc.LabelTTF(Texts[lang][20],getFont(res.lemonFont),50),
            t.addChild(i, 3, 3),
            250 < i.width && i.setScale(250 / i.width),
            i.x = e.x,
            i.y = e.y - 90,
            i.fillStyle = cc.color(0, 128, 153);
            var n = new cc.Sprite(res.lives_png);
            n.x = i.x + i.width / 2 * i.scale + 50,
            n.y = i.y,
            t.addChild(n, 4, 4)
        } else
            i = new cc.LabelTTF(Texts[lang][8],getFont(res.lemonFont),50),
            t.addChild(i, 3, 3),
            250 < i.width && i.setScale(250 / i.width),
            i.x = e.x,
            i.y = e.y - 90,
            i.fillStyle = cc.color(0, 128, 153),
            this.playCoinEffect(t, i.x + 200, i.y + 30);
        i = new cc.MenuItemImage(res.btn_claim_png,res.btn_claim_png,this.claimClick,this),
        i.x = e.x,
        i.y = e.y - 230 + 30,
        e = new cc.Menu(i),
        e.x = 0,
        e.y = 0,
        t.addChild(e, 1, 1)
    },
    playCoinEffect: function(t, e, i) {
        var n = new cc.Sprite("assets/res/coin_anim/free_coin_glow0001.png");
        for (n.x = e,
        n.y = i,
        t.addChild(n, 15, 15),
        t = new cc.Animation,
        e = 1; 20 > e; e++)
            e = 10 > e ? "0" + e : "" + e,
            t.addSpriteFrameWithFile("assets/res/coin_anim/free_coin_glow00" + e + ".png"),
            t.setDelayPerUnit(1 / 18);
        t = cc.animate(t),
        n.runAction(cc.repeatForever(t))
    },
    coinClaimClick: function(t) {
        trace("claim 5 coins"),
        t = new cc.LabelTTF("+5",getFont(res.lemonFont),30),
        this.addChild(t, 120, 120),
        t.x = this.leftWall + 200,
        t.y = cc.winSize.height - 50;
        var e = cc.moveBy(1, cc.p(0, 20))
          , i = cc.fadeOut(1)
          , e = cc.spawn(e, i);
        t.runAction(e),
        Storage.addCoin(5),
        cc.eventManager.dispatchCustomEvent("coinChange", Storage.getCoin()),
        cc.eventManager.dispatchCustomEvent("updateMoreCoinPos", []),
        (t = this.getChildByName("thanksLayer")) && t.removeFromParent(),
        this.closeUI()
    },
    livesClaimClick: function(t) {
        trace("claim 2 lives"),
        Sound.playClick(),
        t = Storage.getLives(),
        Storage.setLives(t + 2),
        t = new cc.LabelTTF("+2",getFont(res.lemonFont),30),
        this.addChild(t, 120, 120),
        t.x = this.leftWall + 200,
        t.y = cc.winSize.height - 100;
        var e = cc.moveBy(1, cc.p(0, 20))
          , i = cc.fadeOut(1)
          , e = cc.spawn(e, i);
        t.runAction(e),
        cc.eventManager.dispatchCustomEvent("livesChange", Storage.getLives()),
        cc.eventManager.dispatchCustomEvent("updateMoreLivesPos", []),
        (t = this.getChildByName("thanksLayer")) && t.removeFromParent(),
        this.closeUI()
    },
    claimClick: function(t) {
        this.thanksPrize === THANKS_PRIZE_LIVES ? this.livesClaimClick(t) : this.coinClaimClick(t);
    },
    showNoVideo: function() {
        var t = new cc.Layer;
        this.addChild(t, 12, 12),
        t.setName("noVideoLayer");
        var e = new cc.Sprite(res.small_bg);
        e.x = cc.winSize.width / 2,
        e.y = cc.winSize.height / 2,
        t.addChild(e, 1, 1);
        var i = new cc.LabelTTF(Texts[lang][9],getFont(res.lemonFont),60);
        t.addChild(i, 2, 2),
        i.x = e.x,
        i.y = e.y + 100,
        i = new cc.LabelTTF(Texts[lang][10],getFont(res.lemonFont),40),
        500 < i.width && i.setScale(450 / i.width),
        i.anchorX = 0,
        t.addChild(i, 2, 2),
        i.x = e.x - 1 * e.width / 2 + 50,
        i.y = e.y + 20,
        i = new cc.LabelTTF(Texts[lang][11],getFont(res.lemonFont),40),
        500 < i.width && i.setScale(450 / i.width),
        i.anchorX = 0,
        t.addChild(i, 2, 2),
        i.x = e.x - 1 * e.width / 2 + 50,
        i.y = e.y - 25,
        i = new cc.LabelTTF(Texts[lang][12],getFont(res.lemonFont),40),
        500 < i.width && i.setScale(450 / i.width),
        i.anchorX = 0,
        t.addChild(i, 2, 2),
        i.x = e.x - 1 * e.width / 2 + 50,
        i.y = e.y - 80,
        i = new cc.MenuItemImage(res.popup_exit_png,res.popup_exit_png,this.comeBackToMain,this),
        i.x = e.x + e.getContentSize().width / 2 - i.width / 2,
        i.y = e.y + e.getContentSize().height / 2 - i.height / 2 - 63,
        i = new cc.MenuItemImage(res.btn_restart_png,res.btn_restart_png,this.comeBackToMain,this),
        i.x = cc.winSize.width / 2,
        i.y = e.y - 270,
        this.closeMenuItem = new cc.MenuItemImage(res.bg_exit,res.bg_exit,this.comeBackToMain,this),
        this.closeMenuItem.x = this.popupBg.x + this.popupBg.getContentSize().width / 2 - this.closeMenuItem.getContentSize().width / 2 - 30,
        this.closeMenuItem.y = this.popupBg.y + this.popupBg.getContentSize().height / 2 - this.closeMenuItem.getContentSize().height / 2 - 30,
        e = new cc.Menu(this.closeMenuItem),
        e.x = 0,
        e.y = 0,
        t.addChild(e, 1, 1)
    },
    comeBackToMain: function() {
        Sound.playClick();
        var t = this.getChildByName("noVideoLayer");
        t && t.removeFromParent()
    }
})
  , HomeScene = cc.Scene.extend({
    ctor: function() {
        window.famobi_analytics.trackScreen("SCREEN_HOME"),
        this._super(),
        Storage.getFirstGame() || (Storage.setLives(5),
        Storage.setFirstGame(),
        Storage.setLevel(1),
        Storage.setCoin(0));
        var t = new cc.Sprite("assets/res/PlayScene1.jpg")
          , e = cc.winSize.width / 2
          , i = cc.winSize.height / 2;
        t.x = e,
        t.y = i,
        this.bg1 = t,
        this.addChild(t, 0, 0),
        t = new cc.Sprite(res.bubble_logo),
        t.x = e,
        t.y = i + 300,
        this.addChild(t, 1, 1),
        t.setScale(-.5, .5);
        var n = cc.scaleTo(.8, .5, .5)
          , r = cc.scaleTo(2, 1, 1).easing(cc.easeElasticOut())
          , n = cc.sequence(n, r);
        t.runAction(n),
        t = new cc.MenuItemImage(res.btn_play_big,res.btn_play_big,this.play,this),
        t.x = e,
        t.y = 0,
        this.playBtn = t,
        this.schedule(this.smallAndBig, 6, cc.REPEAT_FOREVER, 3),
        r = i - 100,
        n = new cc.MenuItemImage(res2.moreGamePng,res2.moreGamePng,function() {
            famobi.moreGamesLink()
        }
        ,this),
        n.x = cc.winSize.width,
        n.y = r - t.height / 2 - 150,
        n.setScale(.6);
        var c = new cc.MenuItemImage(res2.playButtonPng,res2.playButtonPng,this.play,this);
        c.x = cc.winSize.width + 10,
        c.y = r - this.playBtn.y;
        var r = new cc.MenuItemImage(res.btn_sound_on)
          , s = new cc.MenuItemImage(res.btn_sound_off)
          , r = new cc.MenuItemToggle(r,s,function() {
            Sound.toggleOnoff()
        }
        ,this);
        r.x = 0,
        r.y = n.y,
        !0 === Sound.silence && r.setSelectedIndex(1),
        s = new cc.Menu(t,n,c,r),
        s.x = s.y = 0,
        this.addChild(s, 3, 3),
        r.setVisible(!1),
        t.setScale(.5);
        var s = cc.rotateBy(1, 360)
          , o = cc.scaleTo(3, 1).easing(cc.easeElasticOut())
          , i = cc.moveBy(1, 0, i - 100).easing(cc.easeBackOut());
        t.runAction(cc.spawn(s, o, i)),
        n.runAction(cc.moveBy(1, -(cc.winSize.width - e), 0).easing(cc.easeBackOut())),
        c.runAction(cc.moveBy(1, -(cc.winSize.width - e), 0).easing(cc.easeBackOut())),
        r.runAction(cc.moveBy(1, cc.winSize.width - (e + 200), 0).easing(cc.easeBackOut()))
    },
    update: function() {
        this.bg1.x -= .1
    },
    play: function() {
        cc.log("play click"),
        this.smallAndBig(),
        Sound.playClick(),
        1 >= parseInt(Storage.getLevel()) ? cc.director.runScene(new cc.TransitionFade(1,new GameScene(1))) : cc.director.runScene(new cc.TransitionFade(1,new MapScene))
    },
    smallAndBig: function() {
        var t = cc.scaleBy(.2, 1.1, 1.1)
          , e = cc.scaleBy(1, 10 / 11, 10 / 11).easing(cc.easeElasticOut())
          , t = cc.sequence(t, e)
          , e = cc.rotateBy(1, 60)
          , t = cc.spawn(t, e);
        this.playBtn.runAction(t)
    }
});
PLANETLOCKSTAR = {
    1: 23,
    2: 46,
    3: 69,
    4: 91
},
LEVEL_NUM_OF_EVERY_MAP = 8;
var MapScene = cc.Scene.extend({
    gameWindowWidth: 640,
    gameWindowHeight: 960,
    lvlSprites: null,
    ctor: function(t, e) {
        LASTLEVEL = -1,
        window.famobi_analytics.trackScreen("SCREEN_LEVELSELECT"),
        this._super(),
        this.lvlSprites = [],
        this.curLevel = parseInt(Storage.getLevel());
        var i = cc.winSize.width / 2;
        this.centerx = i;
        var n = cc.winSize.height / 2;
        this.centery = n,
        this.leftWall = cc.winSize.width / 2 - this.gameWindowWidth / 2,
        this.rightWall = cc.winSize.width / 2 + this.gameWindowWidth / 2;
        var r = new cc.Layer;
        for (this.layer = r,
        this.addChild(r, 1, 1),
        r = new cc.Sprite(res.map_backgr_png),
        r.x = i,
        r.y = n,
        this.layer.addChild(r, 1, 1),
        this.createLvlSprite(),
        n = new cc.Layer,
        this.layer.addChild(n, 2, 2),
        n = cc.winSize.height,
        r = 0; 40 != r; r++) {
            var c = new cc.Sprite(res.star_1_png);
            c.x = Math.random() * cc.winSize.width,
            c.y = Math.random() * n,
            this.layer.addChild(c, 3, 3)
        }
        for (r = 0; 10 != r; r++) {
            c = new cc.Sprite(res.star_1_png),
            c.x = Math.random() * cc.winSize.width,
            c.y = Math.random() * n,
            this.layer.addChild(c, 3, 3),
            cc.blink(3 + .2 * r, 1);
            var s = cc.fadeOut(1)
              , o = cc.fadeIn(1)
              , a = cc.callFunc(function(t, e) {}, this, c)
              , s = cc.sequence(cc.delayTime(.1 * r), s, o, a);
            c.runAction(s.repeatForever())
        }
        for (r = 0; 40 != r; r++)
            c = new cc.Sprite(res.star_2_png),
            c.x = Math.random() * cc.winSize.width,
            c.y = Math.random() * n,
            this.layer.addChild(c, 3, 3);
        for (r = 0; 10 != r; r++)
            c = new cc.Sprite(res.star_2_png),
            c.x = Math.random() * (this.rightWall - this.leftWall) + this.leftWall,
            c.y = Math.random() * n,
            this.layer.addChild(c, 3, 3),
            c.runAction(cc.blink(2 + .2 * r, 1).repeatForever());
        for (this.planetGroup = n = [],
        r = 0; 5 != r; r++)
            n[r] = new cc.MenuItemImage(res.ball1,res.ball2,this.level,this),
            n[r].tag = r,
            n[r].x = i - (0 === r % 2 ? -100 : 100),
            n[r].setScale(200 / n[r].width),
            n[r].y = 0 === r ? n[r].width / 2 * n[r].scale + 10 : n[r - 1].y + n[r - 1].height / 2 * n[r - 1].scale + n[r].width / 2 * n[r].scale + 20,
            n[r].runAction(cc.rotateBy(30, 360).repeatForever()),
            n[r].setVisible(!1);
        for (parseInt(Storage.getLevel()),
        r = 0; 5 != r; r++)
            (i = Storage.getPlanetState(r)) ? (n[r].stopAllActions(),
            this.showHasLockedPlanet(n[r])) : (n[r].setColor(cc.color(255, 0, 0)),
            this.showUnlockedPlanet(n[r], n[r].x, n[r].y));
        this.lottery = i = new cc.MenuItemImage(res.gift_icon_png,res.gift_icon_png,this.lotterClick,this),
        i.x = this.leftWall + 116,
        i.y = 116,
        i.setScale(.4),
        s = cc.scaleTo(2, .3),
        r = cc.scaleTo(2, .4),
        r = cc.sequence(s, r).repeatForever(),
        i.runAction(r),
        r = new cc.MenuItemImage(res.btn_back_png,res.btn_back2_png,function() {
            Sound.playClick(),
            cc.director.runScene(new cc.TransitionFade(1,new HomeScene))
        }
        ,this),
        r.x = cc.winSize.width / 2,
        r.y = cc.winSize.height - r.height / 2 - 10,
        c = new cc.MenuItemImage(res.btn_sound_on),
        s = new cc.MenuItemImage(res.btn_sound_off),
        c = new cc.MenuItemToggle(c,s,function() {
            trace("sound toggle"),
            Sound.toggleOnoff()
        }
        ,this),
        !0 === Sound.silence && c.setSelectedIndex(1),
        c.x = r.x + 100 + this.leftWall + c.width / 2,
        c.y = r.y,
        c.setVisible(!1),
        i = new cc.Menu(r,c,n[0],n[1],n[2],n[3],n[4],this.lvlSprites[0],this.lvlSprites[1],this.lvlSprites[2],this.lvlSprites[3],this.lvlSprites[4],i),
        i.x = i.y = 0,
        this.layer.addChild(i, 5, 5),
        cc.eventManager.addCustomListener("MapChoiceLayerRemoved", this.mapChoiceLayerRemoved.bind(this)),
        t && (i = Storage.getPlanetState(e)) && this.showMapChoiceLayer(e)
    },
    createLvlSprite: function() {
        for (var t = cc.winSize.width / 2, e = [res.lvlScene1, res.lvlScene2, res.lvlScene3, res.lvlScene4, res.lvlScene5], i = 0; 5 != i; i++) {
            var n = new cc.MenuItemImage(e[i],e[i],this.level,this);
            n.tag = i,
            n.x = t,
            n.y = cc.winSize.height - 200 - n.height * i - 5 * i,
            this.lvlSprites.push(n)
        }
        for (parseInt(Storage.getLevel()),
        i = 0; 5 != i; i++)
            Storage.getPlanetState(i) ? this.showHasLockedPlanet(this.lvlSprites[i]) : this.showUnlockedPlanet(this.lvlSprites[i], this.lvlSprites[i].x, this.lvlSprites[i].y)
    },
    showHasLockedPlanet: function(t) {
        var e = new cc.Sprite(res.planet_star_png);
        e.x = t.width / 2,
        e.y = t.height / 2,
        t.addChild(e, 1, 1),
        e.setScale(t.height / 300),
        e.setName("star"),
        t = t.tag;
        for (var i = 0, n = t * LEVEL_NUM_OF_EVERY_MAP + 1; n != (t + 1) * LEVEL_NUM_OF_EVERY_MAP + 1; n++)
            i += Storage.getLevelStarCnt(n);
        t = new cc.LabelTTF(i + "/24",getFont(res.lemonFont),50),
        t.x = e.width / 2,
        t.y = e.height / 2 - 20,
        e.addChild(t, 1, 1),
        t.setName("label")
    },
    showUnlockedMessage: function(t) {
        var e = new cc.LabelTTF(Texts[lang][24],getFont(res.lemonFont),30);
        e.x = t.x,
        e.y = t.y,
        this.layer.addChild(e, 12, 2),
        e.fillStyle = cc.color(255, 255, 255),
        e.setName("label1");
        var i = new cc.LabelTTF(Texts[lang][25],getFont(res.lemonFont),30);
        i.x = t.x,
        i.y = e.y - e.height,
        this.layer.addChild(i, 13, 3),
        i.setString(Texts[lang][25] + " " + PLANETLOCKSTAR[t.tag]),
        i.setName("label2"),
        t = new cc.Sprite(res.planet_star_png),
        t.setScale(i.height / t.height),
        t.x = i.x + i.width / 2 + t.width / 2 * t.scale + 1,
        t.y = i.y,
        this.layer.addChild(t, 12, 12);
        var n = cc.fadeOut(1);
        e.runAction(n),
        i.runAction(n.clone()),
        t.runAction(n.clone())
    },
    showUnlockedPlanet: function(t, e, i) {
        e = new cc.Sprite(res.lvl_lock_png),
        t.addChild(e, 1, 1),
        e.x = t.width / 2,
        e.y = t.height / 2,
        e.setScale(2),
        e.setName("lock"),
        t.setColor(cc.color(100, 100, 100))
    },
    lotterClick: function() {
        var t = new Date
          , e = -1;
        if (Storage.getLastLotteryTime() ? (e = new Date(Storage.getLastLotteryTime()),
        e = Math.floor((t - e) / 1e3 / 3600)) : e = 2,
        2 <= e)
            this.showLotteryLayer();
        else {
            t = new cc.LabelTTF(2 - e + Texts[lang][16],getFont(res.lemonFont),20),
            t.anchorX = 0,
            t.x = this.lottery.x - this.lottery.width * this.lottery.scale,
            t.y = this.lottery.y + t.height + this.lottery.height / 2 * this.lottery.scale,
            this.layer.addChild(t, 8, 8);
            var e = cc.fadeOut(2)
              , i = cc.callFunc(function(t, e) {
                e.removeFromParent()
            }, this, t)
              , e = cc.sequence(e, i);
            t.runAction(e)
        }
    },
    showLotteryLayer: function() {
        var t = new LotteryLayer;
        this.layer.addChild(t, 6, 6)
    },
    mapChoiceLayerRemoved: function(t) {
        t.getUserData(),
        this.hasChoiceLayer = !1
    },
    showMapChoiceLayer: function(t) {
        this.hasChoiceLayer = !0,
        t = new MapChoiceLayer(t),
        this.layer.addChild(t, 6, 6)
    },
    level: function(t) {
        if (!this.hasChoiceLayer) {
            this.hasChoiceLayer = !0,
            cc.log("planet", t.tag, " clicked"),
            Sound.playClick();
            var e = t.tag;
            if (this.curLevel >= e * LEVEL_NUM_OF_EVERY_MAP + 1) {
                for (var i = Storage.getPlanetState(e), n = 0, r = 1; r != e * LEVEL_NUM_OF_EVERY_MAP + 1; r++)
                    n += Storage.getLevelStarCnt(r);
                cc.log("star cnt ", n, "before:", e * LEVEL_NUM_OF_EVERY_MAP + 1),
                i ? (i = new MapChoiceLayer(e),
                this.layer.addChild(i, 6, 6)) : !i && n < PLANETLOCKSTAR[e] ? (i = new WatchADUI((!1),Texts[lang][14] + "\n(" + Texts[lang][24] + " " + Texts[lang][25] + " " + PLANETLOCKSTAR[t.tag] + ")",Texts[lang][15],function(i) {
                    if (this.hasChoiceLayer = !1,
                    "exit" !== i) {
                        var n = cc.blink(2, 10)
                          , r = cc.tintTo(2, 255, 255, 255);
                        i = cc.callFunc(function(t, e) {
                            var i = e.getChildByName("lock");
                            i && i.removeFromParent()
                        }, this, t),
                        n = cc.spawn(n, r),
                        r = cc.callFunc(function(t, e) {
                            this.showHasLockedPlanet(e),
                            e.setRotation(0),
                            e.stopAllActions()
                        }, this, t),
                        i = cc.sequence(n, i, r),
                        t.runAction(i),
                        Storage.setPlanetState(e, 1)
                    }
                }
                .bind(this),null,(!0)),
                this.layer.addChild(i, 7, 7)) : (cc.log("direct unlock planet"),
                n = cc.blink(2, 10),
                r = cc.tintTo(2, 255, 255, 255),
                i = cc.callFunc(function(t, e) {
                    var i = e.getChildByName("lock");
                    i && i.removeFromParent()
                }, this, t),
                n = cc.spawn(n, r),
                r = cc.callFunc(function(t, e) {
                    this.showHasLockedPlanet(e),
                    e.setRotation(0),
                    e.stopAllActions()
                }, this, t),
                i = cc.sequence(n, i, r),
                t.runAction(i),
                Storage.setPlanetState(e, 1),
                this.hasChoiceLayer = !1)
            } else
                this.hasChoiceLayer = !1,
                this.showUnlockedMessage(t)
        }
    }
})
  , MapChoiceLayer = cc.Layer.extend({
    curLevel: 0,
    gameWindowWidth: 640,
    gameWindowHeight: 960,
    ctor: function(t) {
        this._super(),
        this.curLevel = parseInt(Storage.getLevel()),
        this.leftWall = cc.winSize.width / 2 - this.gameWindowWidth / 2,
        this.rightWall = cc.winSize.width / 2 + this.gameWindowWidth / 2;
        var e = new cc.Layer;
        this.addChild(e, 1, 1),
        this.layer = e;
        var i = new cc.Sprite(res.small_bg);
        i.x = cc.winSize.width / 2,
        i.y = cc.winSize.height / 2,
        this.layer.addChild(i, 2, 2),
        e = new cc.MenuItemImage(res.bg_exit,res.bg_exit,this.exit,this),
        e.x = i.x + i.width / 2 - e.width,
        e.y = i.y + i.height / 2 - e.height;
        var n = [];
        t *= LEVEL_NUM_OF_EVERY_MAP;
        for (var r = this.leftWall + i.width / 4 - 20, i = i.y + i.height / 2 - 160, c = 0; c != LEVEL_NUM_OF_EVERY_MAP; c++) {
            var s = Math.floor(c / 4)
              , o = c % 4
              , a = new cc.MenuItemImage("#door_0000_Layer.png","#door_0000_Layer.png",this.Choice,this);
            a.x = r + 126 * o,
            a.y = i - 146 * s,
            a.level = t + c + 1,
            n[c] = a,
            a.tag = c,
            s = new cc.LabelTTF(t + c + 1,getFont(res.lemonFont),40),
            s.x = 58,
            s.y = 58,
            a.addChild(s, 9, 9),
            parseInt(Storage.getLevel()) < t + c + 1 ? (a.setOpacity(100),
            s.setOpacity(100)) : (s = Storage.getLevelStarCnt(a.level)) && this.showThreeStars(a.x, a.y, s)
        }
        e = new cc.Menu(e,n[0],n[1],n[2],n[3],n[4],n[5],n[6],n[7]),
        e.x = e.y = 0,
        this.layer.addChild(e, 5, 5)
    },
    Choice: function(t) {
        if (cc.log(t.tag),
        !this.isPlaying) {
            Sound.playClick(),
            this.isPlaying = !0;
            var e = cc.callFunc(function() {
                this.isPlaying = !1
            }, this)
              , i = cc.scaleBy(.2, 1.3)
              , n = cc.callFunc(function(t, e) {
                this.curLevel >= e && cc.director.runScene(new cc.TransitionFade(1,new GameShopScene(e)))
            }, this, t.level);
            t.runAction(cc.sequence(i, i.reverse(), e, n))
        }
    },
    showThreeStars: function(t, e, i) {
        var n = e - 42
          , r = new cc.Sprite(res.star_png);
        e = new cc.Sprite(res.star_png);
        var c = new cc.Sprite(res.star_png);
        r.x = t,
        r.y = n,
        e.x = r.x - .4 * r.width / 2,
        e.y = r.y - 16,
        c.x = r.x + .4 * r.width / 2,
        c.y = r.y - 16,
        this.layer.addChild(r, 8, 8),
        this.layer.addChild(e, 7, 7),
        this.layer.addChild(c, 7, 7),
        r.setScale(.4),
        e.setScale(.4),
        c.setScale(.4),
        t = cc.spriteFrameCache.getSpriteFrame(res.starGrey_png.replace("#", "")),
        1 === i ? (e.setSpriteFrame(t),
        c.setSpriteFrame(t)) : 2 === i && c.setSpriteFrame(t)
    },
    exit: function() {
        cc.eventManager.dispatchCustomEvent("MapChoiceLayerRemoved", ""),
        this.removeFromParent()
    }
})
  , LotteryLayer = cc.Layer.extend({
    hasClicked: !1,
    ctor: function() {
        this._super();
        var t = new cc.Layer;
        this.layer = t,
        this.addChild(t, 1, 1),
        t = new cc.Sprite(res.small_bg),
        t.x = cc.winSize.width / 2,
        t.y = cc.winSize.height / 2,
        this.layer.addChild(t, 1, 1),
        t.setScaleY(1.3),
        this.circleArray = [],
        this.circleArray[4] = new cc.Sprite("#door_0005_Layer.png"),
        this.circleArray[4].x = t.x,
        this.circleArray[4].y = t.y,
        this.layer.addChild(this.circleArray[4], 2, 2);
        for (var e = 0; 9 != e; e++) {
            var i = e % 3
              , n = Math.floor(e / 3);
            4 != e && (this.circleArray[e] = new cc.Sprite("#door_0005_Layer.png"),
            this.circleArray[e].x = this.circleArray[4].x - 146 * (1 - i),
            this.circleArray[e].y = this.circleArray[4].y + 146 * (1 - n),
            this.layer.addChild(this.circleArray[e], 2, 2))
        }
        e = new cc.MenuItemImage(res.bg_exit,res.bg_exit,function() {
            this.removeFromParent()
        }
        ,this),
        e.x = t.x + t.width / 2 - e.width - 10,
        e.y = t.y + t.height / 2 * 1.3 - e.height,
        t = new cc.Menu(e),
        t.x = t.y = 0,
        this.layer.addChild(t, 8, 8)
    },
    onEnter: function() {
        this._super(),
        cc.log("onEnter layer"),
        cc.eventManager.addListener({
            event: cc.EventListener.TOUCH_ONE_BY_ONE,
            onTouchBegan: this.onTouchBegan,
            onTouchMoved: this.onTouchMoved,
            onTouchEnded: this.onTouchEnded
        }, this)
    },
    onTouchBegan: function(t, e) {
        e.stopPropagation();
        var i = e.getCurrentTarget();
        if (!i.hasClicked) {
            i.hasClicked = !0;
            for (var i = e.getCurrentTarget(), n = i.convertToNodeSpace(t.getLocation()), r = 0; 9 != r; r++)
                if (cc.rectContainsPoint(i.circleArray[r].getBoundingBox(), n))
                    return cc.log(r, "clicked"),
                    i.dealLotteryResult(r),
                    !1;
            return this.dragOffsetStartX = t.getLocationX(),
            this.dragOffsetStartY = t.getLocationY(),
            !0
        }
    },
    onTouchMoved: function(t, e) {
        return e.getCurrentTarget(),
        this.dragOffsetEndX = t.getLocationX(),
        this.dragOffsetEndY = t.getLocationY(),
        !0
    },
    onTouchEnded: function(t, e) {
        e.getCurrentTarget(),
        this.endX = t.getLocationX(),
        this.endY = t.getLocationY()
    },
    dealLotteryResult: function(t) {
        var e = Math.floor(4 * Math.random()) + 1
          , i = Storage.getBoosterCnt(e)
          , n = new cc.Sprite("#booster_" + e + ".png");
        for (n.x = this.circleArray[t].x,
        n.y = this.circleArray[t].y,
        this.layer.addChild(n, 7, 7),
        n.setVisible(!1),
        Storage.setBoosterCnt(e, i + 1),
        Storage.setLastLotteryTime(new Date),
        e = new cc.Animation,
        i = 5; -1 != i; i--)
            e.addSpriteFrame("door_000" + i + "_Layer.png");
        e.setDelayPerUnit(.25),
        e = new cc.animate(e),
        n = cc.callFunc(function(t, e) {
            e.setVisible(!0),
            Sound.playLottery();
            var i = new cc.ParticleSystem(res.particle);
            this.layer.addChild(i, 6, 6),
            this.particle = i,
            this.particle.x = e.x,
            this.particle.y = e.y
        }, this, n),
        n = cc.sequence(e, n),
        this.circleArray[t].runAction(n)
    }
});
Loader = cc.Scene.extend({
    _interval: null,
    _label: null,
    _className: "Loader",
    init: function() {
        window.famobi_analytics.trackScreen("SCREEN_SPLASH");
        var t = this
          , e = 200
          , i = t._bgLayer = new cc.LayerColor(cc.color(32, 32, 32, 255));
        t.addChild(i, 0);
        var n = 48
          , r = -e / 2 + 100;
        return res.logo_png && (cc.loader.loadImg(res.logo_png, {
            isCrossOrigin: !1
        }, function(i, n) {
            e = n.height,
            t._initStage(n, cc.visibleRect.center)
        }),
        n = 14,
        r = -e / 2 - 60),
        n = 30,
        n = t._label = new cc.LabelTTF(window.famobi.__("Loading... ") + "0%","Arial",n),
        n.setPosition(cc.pAdd(cc.visibleRect.center, cc.p(0, r))),
        n.setColor(cc.color(180, 180, 180)),
        i.addChild(this._label, 10),
        !0
    },
    _initStage: function(t, e) {
        var i = this._texture2d = new cc.Texture2D;
        i.initWithElement(t),
        i.handleLoadedTexture(),
        i = this._logo = new cc.Sprite(i),
        i.setScale(.8),
        i.x = e.x,
        i.y = e.y,
        this._bgLayer.addChild(i, 10)
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this),
        this.schedule(this._startLoading, .3)
    },
    onExit: function() {
        cc.Node.prototype.onExit.call(this),
        this._label.setString(window.famobi.__("Loading... ") + "0%")
    },
    initWithResources: function(t, e) {
        cc.isString(t) && (t = [t]),
        this.resources = t || [],
        this.cb = e
    },
    _startLoading: function() {
        var t = this;
        t.unschedule(t._startLoading),
        cc.loader.load(t.resources, function(e, i, n) {
            e = Math.min(n / i * 100 | 0, 100),
            t._label.setString(window.famobi.__("Loading... ") + e + "%")
        }, function() {
            t.cb && t.cb()
        })
    }
}),
Loader.preload = function(t, e) {
    var i = cc;
    return i.loaderScene || (i.loaderScene = new Loader,
    i.loaderScene.init()),
    i.loaderScene.initWithResources(t, e),
    cc.director.runScene(i.loaderScene),
    i.loaderScene
}
;
for (var Texts = {
    en: "Awesome!;Cool!;Perfect!;Great Shot!;Good!;Watch video to add;We hope you enjoyed!;Thanks for watching.;You get 5;Thank you;You watch all available;video for today.;Come back tomorrow.;No Enough Coin!;No Enough Star;Watch video to lock;hours for next lottery;You Win!;You Lose!;Watch video to add life;You get 2;No Life!;Get one life prize!;Touch to Aim;Unlock;for".split(";"),
    de: "Super!;Cool!;Perfekt!;Guter Schuss!;Gut!;Sieh ein Video an und erhalte;Wir hoffen es hat Dir gefallen!;Danke für's Ansehen!;Du erhältst;Danke;Du hast heute alle;verfügbaren Videos gesehen,;versuche es morgen noch einmal.;Nicht genug Münzen!;Nicht genug Sterne!;Sieh ein Video an und sperre;Stunden bis zur nächsten Lotterie;Gewonnen!;Verloren!;Video ansehen und ein Leben erhalten;Du erhältst 2;Kein Leben!;Du erhältst ein Leben!;Antippen um zu zielen;Freischalten;für".split(";"),
    es: "¡Asombroso!;¡Genial!;¡Perfecto!;¡Gran disparo!;¡Bien!;Ve un vídeo para añadir;¡Esperamos que hayas disfrutado!;Gracias por verlo.;Consigues 5;Gracias;Has visto todos los vídeos;disponibles para hoy.;Vuelve mañana.;¡No hay monedas suficientes!;¡No hay estrellas suficientes!;Ve el vídeo para bloquear;horas hasta la próxima lotería;¡Tú ganas!;¡Tú pierdes!;Ve el vídeo para añadir una vida;Consigues 2;¡Sin vidas!;Consigue el premio de una vida!;Toca para apuntar;Desbloquear;para".split(";"),
    fr: "Super !;Cool !;Parfait !;Beau tir !;Bien !;Regardez une vidéo pour ajouter;Nous espérons que cela vous a plu !;Merci d'avoir regardé cette vidéo.;Vous en obtenez 5;Merci;Vous avez regardé toutes;les vidéos disponibles pour aujourd'hui.;Revenez demain.;Vous n'avez pas assez de pièces !;Vous n'avez pas assez d'étoiles !;Regardez une vidéo pour verrouiller;les heures jusqu'à la prochaine loterie;Vous avez gagné !;Vous avez perdu !;Regardez une vidéo pour ajouter une vie;Vous en obtenez 2;Plus de vies !;Obtenez une vie en cadeau !;Touchez pour viser;Déverrouillez;pour".split(";"),
    it: "Eccezionale!;Bello!;Perfetto!;Bel colpo!;Ottimo!;Guarda un video per aggiungere;Speriamo che ti sia piaciuto!;Grazie per aver guardato.;Ne ottieni 5;Grazie;Hai guardato tutti i video disponibili;per oggi.;Ritorna domani.;Non hai abbastanza monete!;Non hai abbastanza stelle!;Guarda il video per bloccare;l'orario fino alla prossima lotteria;Hai vinto!;Hai perso!;Guarda il video per aggiungere una vita;Ne ottieni 2;Nessuna vita!;Ottieni una vita in premio!;Tocca per mirare;Sblocca;per".split(";"),
    pt: "Fantástico!;Fixe!;Perfeito!;Grande Tiro!;Bem!;Veja um vídeo para adicionar;Esperamos que tenha gostado!;Obrigado por ter visto.;Recebe 5;Obrigado;Viu todos os vídeos;disponíveis hoje.;Volte amanhã.;Sem moedas suficientes!;Sem estrelas suficientes!;Veja o vídeo para bloquear;horas até ao próximo sorteio;Ganhou!;Perdeu!;Veja o vídeo para ganhar uma vida;Recebe 2;Sem vidas!;Ganhe 1 vida de prémio!;Toque para apontar;Desbloquear;para".split(";"),
    ru: "Потрясающе!;Круто!;Идеально!;Отличный выстрел!;Хорошо! ;Смотреть видео для добавления;Надеемся, вам понравилось!;Спасибо за просмотр.;Вы получите 5;Спасибо;Вы смотрели все имеющиеся;видео за сегодня.;Возвращайтесь завтра.;Не хватает монет!;Не достаточно звезд!;Смотреть видео для разблокировки;часов до очередного розыгрыша лотереи;Вы выиграли!;Вы проиграли!;Смотрите видео для добавления жизни ;Вы получите 2;Нет жизни! ;Получите жизнь в качестве приза!;Нажмите для прицеливания  ;Разблокировать;за".split(";"),
    tr: "Muhteşem!;Süper!;Harika!;İyi Vuruş!;İyi!;Eklemek için bir video izle;Keyif aldığını umuyoruz!;İzlediğin için teşekkürler.;5 tane aldın;Teşekkür ederiz;Bugünkü tüm;videoları izledin.;Yarın yine gel;Yeterli jeton yok!;Yeterli yıldız yok!;Bir sonraki çekilişe kadar saatleri;kapamak için videoyu izle;Kazandın!;Kaybettin!;Can eklemek için bir video izle;2 tane aldın;Can Yok!;Bir can ödül al!;Hedefe Ulaş;Kilidi Aç;:".split(";"),
    nl: "Geweldig!;Cool!;Perfect!;Mooie schot!;Goed!;Bekijk een video om toe te voegen;We hopen dat je hebt genoten!;Bedankt voor het kijken.;Je krijgt 5;Bedankt;Je bekeek alle beschikbare;video's voor vandaag.;Kom morgen terug.;Niet genoeg munten!;Niet genoeg sterren!;Bekijk een video om te vergrendelen;Aantal uur tot de volgende loterij;Je wint!;Je verliest!;Bekijk een video om een leven toe te voegen;Je krijgt 2;Geen leven!;Ontvang één levenprijs!;Raak aan om te richten;Ontgrendelen;voor".split(";"),
    pl: "Świetnie!;Nieźle!;Idealnie!;Świetny strzał!;Dobrze!;Obejrzyj wideo, by dodać;Mamy nadzieję, że Ci się podobało!;Dzięki za obejrzenie.;Otrzymujesz 5;Dziękujemy;Obejrzałeś wszystkie dostępne;filmy na dziś.;Wróć jutro.;Za mało monet!;Za mało gwiazdek!;Obejrzyj wideo, by zablokować;godziny do następnej loterii;Wygrałeś!;Przegrałeś!;Obejrzyj wideo, by dodać życie;Otrzymujesz 2;Brak życia!;Otrzymaj jedno życie w nagrodę!;Dotknij, by celować;Odblokuj;za".split(";")
}, help = null, i = 0; i < Texts.en.length; i++)
    help = window.famobi.__(Texts.en[i]),
    help && (Texts.en[i] = help);
var MaxLevel = 40;
isLocalStorageNameSupported() ? Saver = cc.sys.localStorage : (cc.log("using Saver now"),
Saver = {
    proxy: {
        version: 0
    },
    setItem: function(t, e) {
        Saver.proxy[t] = e
    },
    getItem: function(t) {
        return Saver.proxy[t]
    }
});
var Storage = {
    leverStarArray: [],
    getLevel: function() {
        return parseInt(Saver.getItem("level") || 0)
    },
    setLevel: function(t) {
        Saver.setItem("level", t)
    },
    getPlanetState: function(t) {
        if (0 === t)
            return 1;
        var e = Saver.getItem("planetState");
        return e ? (e = e.split(":"),
        parseInt(e[t])) : 0
    },
    setPlanetState: function(t, e) {
        var i = Saver.getItem("planetState");
        if (i) {
            for (i = i.split(":"),
            i[t] = e,
            r = 0; r != i.length; r++)
                n = 0 == r ? i[r] : n + ":" + i[r];
            Saver.setItem("planetState", n)
        } else {
            for (var n, r = 0; 5 != r; r++)
                n = 0 == r ? 1 : n + ":0";
            Saver.setItem("planetState", n),
            this.setPlanetState(t, 1)
        }
    },
    getLevelStarCnt: function(t) {
        var e = Saver.getItem("levelStartCnt");
        return e ? (e = e.split(":"),
        parseInt(e[t - 1])) : 0
    },
    setLevelStarCnt: function(t, e) {
        var i = Saver.getItem("levelStartCnt");
        if (i) {
            i = i.split(":"),
            i[t - 1] = e + "";
            for (var n = "", r = 0; r != i.length; r++)
                n = 0 == r ? i[r] : n + ":" + i[r];
            Saver.setItem("levelStartCnt", n)
        } else {
            for (var r = 0; r != MaxLevel; r++)
                n = 0 == r ? 0 : n + ":0";
            Saver.setItem("levelStartCnt", n),
            this.setLevelStarCnt(t, e)
        }
    },
    getScore: function() {
        return Saver.getItem("score") || 0
    },
    setScore: function(t) {
        Saver.setItem("score", t)
    },
    addScore: function(t) {
        var e = this.getScore();
        this.setScore(parseInt(e) + t)
    },
    getCoin: function() {
        return parseInt(Saver.getItem("coin") || 0)
    },
    setCoin: function(t) {
        Saver.setItem("coin", t)
    },
    addCoin: function(t) {
        var e = this.getCoin();
        this.setCoin(parseInt(e) + t)
    },
    getAimBoosterNum: function() {
        return parseInt(Saver.getItem("AimBooster")) || 0
    },
    setAimBoosterNum: function(t) {
        return Saver.setItem("AimBooster", t)
    },
    getRedoBoosterNum: function() {
        return parseInt(Saver.getItem("RedoBooster")) || 0
    },
    setRedoBoosterNum: function(t) {
        return Saver.setItem("RedoBooster", t)
    },
    getExplosionBoosterNum: function() {
        return parseInt(Saver.getItem("ExplosionBooster")) || 0
    },
    setExplosionBoosterNum: function(t) {
        return Saver.setItem("ExplosionBooster", t)
    },
    getEliminationBoosterNum: function() {
        return parseInt(Saver.getItem("EliminationBooster")) || 0
    },
    setEliminationBoosterNum: function(t) {
        return Saver.setItem("EliminationBooster", t)
    },
    setBoosterCnt: function(t, e) {
        switch (t) {
        case 2:
            this.setRedoBoosterNum(e);
            break;
        case 1:
            this.setAimBoosterNum(e);
            break;
        case 4:
            this.setEliminationBoosterNum(e);
            break;
        case 3:
            this.setExplosionBoosterNum(e);
            break;
        default:
            trace("No this type")
        }
    },
    getBoosterCnt: function(t) {
        var e = -1;
        switch (t) {
        case 2:
            e = this.getRedoBoosterNum();
            break;
        case 1:
            e = this.getAimBoosterNum();
            break;
        case 4:
            e = this.getEliminationBoosterNum();
            break;
        case 3:
            e = this.getExplosionBoosterNum();
            break;
        default:
            trace("No this type")
        }
        return parseInt(e)
    },
    getLastLivesPrizeTime: function() {
        return Saver.getItem("lastLivesPrizeTime")
    },
    setLastLivesPrizeTime: function(t) {
        return Saver.setItem("lastLivesPrizeTime", t + "")
    },
    getLastLotteryTime: function() {
        return Saver.getItem("lastLotteryTime")
    },
    setLastLotteryTime: function(t) {
        return Saver.setItem("lastLotteryTime", t)
    },
    setLastAdsPrizeTime: function(t) {
        return Saver.setItem("lastAdsPrizeTime", t + "")
    },
    getLastAdsTime: function() {
        return Saver.getItem("lastAdsPrizeTime")
    },
    getWatchAdsCnt: function() {
        return parseInt(Saver.getItem("WatchAdsCnt") || 0)
    },
    setWatchAdsCnt: function(t) {
        Saver.setItem("WatchAdsCnt", t)
    },
    getLives: function() {
        return 99
    },
    setLives: function(t) {
        return Saver.setItem("lives", 99)
    },
    getLivesLotteryTime: function() {
        return Saver.getItem("livesLotteryTime")
    },
    setLivesLotteryTime: function(t) {
        return Saver.setItem("livesLotteryTime", t)
    },
    getFirstGame: function() {
        return Saver.getItem("firstGame")
    },
    setFirstGame: function() {
        return Saver.setItem("firstGame", "true")
    }
};
BOOSTERLAYER_WIDTH = 121,
BOOSTERLAYER_HEIGHT = 570;
var GameBoosterLayer = cc.Layer.extend({
    ctor: function(t, e) {
        this._super();
        var i = new cc.LayerColor(cc.color(255, 255, 255, 0),121,570);
        i.x = t,
        i.y = e,
        this.addChild(i, 1, 1),
        this.layer = i;
        var n = new cc.Sprite(res.boosterBar_png);
        n.x = i.width / 2,
        n.y = i.height / 2,
        this.layer.addChild(n, 1, 1),
        i = new cc.Sprite(res.boosterIcon_png),
        i.x = n.x,
        i.y = n.y + n.height / 2 - 50 - i.height / 2,
        this.layer.addChild(i, 2, 2)
    }
})
  , APIStatistics = {
    levelUp: function(t) {
        1 === t && window.famobi_analytics.trackEvent("EVENT_TUTORIALCOMPLETED"),
        window.famobi_analytics.trackEvent("EVENT_LEVELSUCCESS", {
            levelName: "" + t
        })
    },
    gameOver: function(t) {
        window.famobi_analytics.trackEvent("EVENT_LEVELFAIL", {
            levelName: "" + t,
            reason: "dead"
        })
    },
    submitHighScore: function(t, e) {}
}
  , OptionUI = cc.Layer.extend({
    ctor: function(t) {
        this._super(),
        this.level = t,
        this.showPopupMenu()
    },
    showPopupMenu: function() {
        window.famobi_analytics.trackScreen("SCREEN_PAUSE", "" + this.level);
        var t = new cc.Sprite(res.small_bg);
        t.x = cc.winSize.width / 2,
        t.y = cc.winSize.height / 2,
        this.addChild(t, 2, 2);
        var e = new cc.MenuItemImage(res.btn_play_png,res.btn_play_png,this.resumePlay,this);
        e.x = t.x,
        e.y = cc.winSize.height / 2 + 80;
        var i = new cc.MenuItemImage(res.btn_replay_png,res.btn_replay_png,this._replay,this);
        i.x = t.x - 200,
        i.y = e.y - e.height;
        var n = new cc.MenuItemImage(res.btn_back_png,res.btn_back_png,this.gotoMap,this);
        n.x = t.x,
        n.y = e.y - e.height;
        var t = new cc.MenuItemImage(res.btn_sound_on)
          , r = new cc.MenuItemImage(res.btn_sound_off)
          , t = new cc.MenuItemToggle(t,r,function() {
            trace("sound toggle"),
            Sound.toggleOnoff()
        }
        ,this);
        !0 === Sound.silence && t.setSelectedIndex(1),
        t.x = n.x + 200,
        t.y = e.y - e.height,
        e = new cc.Menu(e,i,t,n),
        this.addChild(e, 3, 3),
        e.x = 0,
        e.y = 0
    },
    gotoShop: function() {
        Sound.playClick(),
        cc.director.resume(),
        this.minusOneLives(),
        cc.director.runScene(new cc.TransitionFade(1,new GameShopScene(this.level)))
    },
    minusOneLives: function() {
        var t = Storage.getLives();
        0 !== t && Storage.setLives(t - 1)
    },
    _replay: function(t) {
        Sound.playClick(),
        cc.director.resume(),
        this.minusOneLives(),
        cc.eventManager.dispatchCustomEvent("stopSchedule", ""),
        cc.director.runScene(new GameScene(this.level))
    },
    resumePlay: function() {
        Sound.playClick(),
        cc.director.resume(),
        cc.eventManager.dispatchCustomEvent("configUIClose", []),
        this.hidePopupMenu(),
        window.famobi_analytics.trackScreen("SCREEN_LEVEL", "" + this.level)
    },
    gotoMap: function() {
        window.famobi_analytics.trackEvent("EVENT_LEVELFAIL", {
            levelName: "" + this.level,
            reason: "quit"
        }),
        Sound.playClick(),
        cc.director.resume();
        var t = Math.floor((this.level - 1) / LEVEL_NUM_OF_EVERY_MAP);
        this.minusOneLives(),
        cc.director.runScene(new cc.TransitionFade(1,new MapScene((!0),t)))
    },
    hidePopupMenu: function() {
        var t = this.getChildByTag(2)
          , e = this.getChildByTag(3);
        e && t && (e.removeFromParent(),
        t.removeFromParent())
    }
});
ISDEBUG = !1;
var SG_Hooks = void 0;
if (!cc.sys.isNative)
    var resizeMyOwn = function() {
        console.log("resize now");
        var t = cc.view.getFrameSize()
          , t = cc.view.getFrameSize();
        1 < t.height / t.width ? (document.getElementById("Cocos2dGameContainer").style.display = "block",
        document.getElementById("orientation").style.display = "none") : (document.getElementById("orientation").style = document.getElementById("Cocos2dGameContainer").style,
        document.getElementById("orientation").style.display = "block",
        document.getElementById("Cocos2dGameContainer").style.display = "none")
    };
var trace = function() {
    cc.log(Array.prototype.join.call(arguments, ", "))
};
cc.game.onStart = function() {
    if (cc.sys.isNative) {
        var t = jsb.fileUtils.getSearchPaths()
          , e = cc.view.getFrameSize().width / 640;
        cc.view.setDesignResolutionSize(640, Math.floor(cc.view.getFrameSize().height / e), cc.ResolutionPolicy.SHOW_ALL),
        t.push("res"),
        t.push("src"),
        jsb.fileUtils.setSearchPaths(t)
    }
    cc.sys.browserType === cc.sys.BROWSER_TYPE_SAFARI ? (cc.view.enableRetina(!0),
    cc.log("safari then disable retina")) : (cc.log("other brower, enable retina"),
    cc.view.enableRetina(!0)),
    cc.view.adjustViewPort(!0),
    cc.sys.isMobile ? cc.view.setDesignResolutionSize(640, 1136, cc.ResolutionPolicy.FIXED_HEIGHT) : cc.view.setDesignResolutionSize(640, 1136, cc.ResolutionPolicy.SHOW_ALL),
    cc.view.resizeWithBrowserSize(!0),
    !cc.sys.isNative && cc.sys.isMobile && (cc.view.setResizeCallback(resizeMyOwn),
    resizeMyOwn()),
    window.famobi_onPauseRequested = function() {
        cc.audioEngine._pausePlaying(),
        cc.director.pause()
    }
    ,
    window.famobi_onResumeRequested = function() {
        cc.audioEngine._resumePlaying(),
        cc.director.resume()
    }
    ,
    Loader.preload(g_resources, function() {
        cc.spriteFrameCache.addSpriteFrames(res2.UI_Plist, res2.UI_png),
        cc.director.runScene(new HomeScene)
    }, this)
}
;
var lang = "en";
cc.game.run();
